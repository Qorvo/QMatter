# The QMatter build flow

## Makefiles

The applications in the QMatter SDK are built using GNU MAKE, a well known
build system.  The applications are built on top of component libraries like
protocol stacks and glue layers that form a set of .o library files (.a).

To link in the component libraries and protocol stacks, the top level application makefiles will
include a make rule (for each library) to call the specific component library makefile.
These 'PHONY' rules will trigger each time the build is triggered, so the component library makefile can
check if the .a file needs to be updated.


### Makefile dependency tree
For a given application, its makefiles can call makefiles, forming a dependency tree, for example:

* Applications/Matter/light/Makefile.light\_qpg6105\_development
  * Libraries/Qorvo/QorvoStack/Makefile.QorvoStack\_qpg6105
  * Libraries/Qorvo/MatterQorvoGlue/Makefile.MatterQorvoGlue\_qpg6105\_libbuild
  * Libraries/Qorvo/Bootloader/Makefile.Bootloader\_qpg6105\_compr\_secure
    * Applications/Bootloader/Makefile.UMB\_QPG6105DK\_K01\_compr\_secure\_armgccemb
  * Libraries/Qorvo/mbedtls\_alt/Makefile.mbedtls\_alt\_qpg6105
  * Libraries/Qorvo/OpenThreadQorvoGlue/Makefile.OpenThreadQorvoGlue\_qpg6105\_mtd
  * Libraries/Qorvo/FactoryData/Makefile.FactoryData\_light

## Configuration files

Each QMatter application build configuration consists of several files.

### Makefile.light_qpg6105_development

The Makefile contains a list of the files and libraries used to build the application.
Lines of particular interest are those that list the source files included in the compilation, e.g.:

```
SRC_APP+=$(BASEDIR)/../../../Applications/Matter/light/src/AppTask.cpp
```
Or lines that define paths, like this one specifying the name of a configuration file:
```
ZAP_FILE=$(BASEDIR)/../../../Applications/Matter/light/light.zap
```

### light_qpg6105_development_postbuild.sh

The post-build shell script contains calls to Qorvo tools that are run after make finishes. The tools called in the
shell script typically modify the `.hex` files, generate OTA payloads or generate a Qorvo Programmer Utility
configuration XML file.

### light.zap

This file contains the cluster configuration. It can be edited using the zap GUI tool by running `Components/ThirdParty/Matter/repo/scripts/tools/zap/run_zaptool.sha`
or via AppCreator.

### light.matter

This file is generated by the ZAP tool and used as input file for code generation.

### light.matter_args

The contents of the `.matter_args` file are passed to GN using `gn --args`.

## Code generation

The Makefile will run `scripts/tools/zap/generate.py`, this will generate a `.matter` file at the location of the `.zap`
file. The `.matter` file is a human and machine readable representation of the `.zap` file, and it is used for code
generation in the next step.

Next `scripts/codegen.py` will perform some more source code generation.
The generated files are located in the Work/(applicationname)/zap-generated/zap-output folder.
An intermediate rsync copy step is done so the generated files only have updated timestamps if their content changes.
This is done to optimize the build process since make uses these timestamps to determine if it needs to trigger a
rebuild.

Here are some of the generated files:

* Work/(applicationname)/zap-generated/zap-generated/IMClusterCommandHandler.cpp
* Work/(applicationname)/zap-generated/zap-generated/CHIPClientCallbacks.h
* Work/(applicationname)/zap-generated/zap-generated/endpoint_config.h
* Work/(applicationname)/zap-generated/zap-generated/af-gen-event.h
* Work/(applicationname)/zap-generated/zap-generated/app/PluginApplicationCallbacks.h
* Work/(applicationname)/zap-generated/zap-generated/app/callback-stub.cpp
* Work/(applicationname)/zap-generated/zap-generated/access.h
* Work/(applicationname)/zap-generated/zap-generated/gen_config.h
* Work/(applicationname)/zap-generated/zap-generated/CHIPClusters.h

To include the source code of all chosen clusters, the Makefile will run
`Components/ThirdParty/Matter/repo/src/app/zap_cluster_list.py` and for each cluster
add `Components/ThirdParty/Matter/repo/src/app/clusters/$(CLUSTER_NAME)/*.cpp))` to the build.

## GN/Ninja build of the matter stack

Building the matter stack is done by the application Makefile by running `gn` and `ninja` to build a specific
`libMatterStack.a` which contains the compiler output for the [Matter
codebase](../../Components/ThirdParty/Matter/repo).

The matter codebase has [a Qorvo specific GN configuration at qpg/chip-gn](../../Components/ThirdParty/Matter/repo/config/qpg/chip-gn)
that defines what code is included in this library.

## The QPG6105 bootloader

The QPG6105 bootloader needs to be included in the main factory firmware image to enable the OTA firmware upgrade process.
The bootloader is linked into the main firmware image as binary blobs that are placed at the correct flash addresses.

The bootloader is compiled into a `.hex` file using [the specific bootloader application makefile in Applications/Bootloader](../../Applications/Bootloader).
To easily embed the bootloader in the firmware image, it is converted to a libBootloader.a objectcode library by
the [bootloader library makefile in Libraries/Qorvo/Bootloader](../../Libraries/Qorvo/Bootloader) and included in the
linking step.

## Compiler invocation and compiler flags

The calling of the compiler and the compiler flags used is split to the following files under make/:

* [make/gpcommon.mk](../../make/gpcommon.mk): make compilation rules (.o/.elf/.map/.lss)
* [make/compilers/armgccemb/compiler\_rules.mk](../../make/compilers/armgccemb/compiler_rules.mk) make compilation rules (.hex)
* [make/compilers/armgccemb/compiler\_defines.mk](../../make/compilers/armgccemb/compiler_defines.mk): compiler flags

## Firmware flashing

Additionally, the programmer\_rules.mk file implements programming related rules that can be used to flash the `.hex` file using
the JLink programming tool:

* [make/programmers/jlink/programmer\_rules.mk](../../make/programmers/jlink/programmer_rules.mk)
  * 'program': erase and flash the hex file
  * 'gdbserver': start a gdbserver to debug the target device
  * 'erase': erase the device
  * 'reset': reset the device

This requires J-Link Software and Documentation pack to be installed at /opt/JLink (either directly or via a symlink).
You can download this at the [J-Link Software and Documentation pack download page](https://www.segger.com/downloads/jlink/).
