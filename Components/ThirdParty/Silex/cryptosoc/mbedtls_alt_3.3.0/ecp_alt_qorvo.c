/*
 * Copyright (c) 2021, Qorvo Inc
 *
 * This software is owned by Qorvo Inc
 * and protected under applicable copyright laws.
 * It is delivered under the terms of the license
 * and is intended and supplied for use solely and
 * exclusively with products manufactured by
 * Qorvo Inc.
 *
 *
 * THIS SOFTWARE IS PROVIDED IN AN "AS IS"
 * CONDITION. NO WARRANTIES, WHETHER EXPRESS,
 * IMPLIED OR STATUTORY, INCLUDING, BUT NOT
 * LIMITED TO, IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
 * QORVO INC. SHALL NOT, IN ANY
 * CIRCUMSTANCES, BE LIABLE FOR SPECIAL,
 * INCIDENTAL OR CONSEQUENTIAL DAMAGES,
 * FOR ANY REASON WHATSOEVER.
 *
 */

/** @file "ecp_qorvo.c"
 *
 *  Implementation of mbedtls_ecp_gen_privkey using ecp_alt
*/


#if !defined(MBEDTLS_CONFIG_FILE)
#include <mbedtls/build_info.h>
#else
#include MBEDTLS_CONFIG_FILE
#endif

#if defined(MBEDTLS_ECP_C)

#include "mbedtls/ecp.h"
#include "mbedtls/threading.h"

#include <string.h>

#if defined(MBEDTLS_ECP_ALT)

#if defined(MBEDTLS_PLATFORM_C)
#include "mbedtls/platform.h"
#else
#include <stdlib.h>
#include <stdio.h>
#define mbedtls_printf printf
#define mbedtls_calloc calloc
#define mbedtls_free   free
#endif

#if(defined(__ARMCC_VERSION) || defined(_MSC_VER)) && \
    !defined(inline) && !defined(__cplusplus)
#define inline __inline
#endif

#include <stdbool.h>
#include <ba414e_config.h>
#include <sx_dh_alg.h>
#include <sx_ecc_curves.h>
#include <sx_ecc_keygen_alg.h>
#include <sx_primitives.h>
#include <sx_generic.h>

#if defined(MBEDTLS_ECP_DP_SECP192R1_ENABLED) || \
    defined(MBEDTLS_ECP_DP_SECP224R1_ENABLED) || \
    defined(MBEDTLS_ECP_DP_SECP256R1_ENABLED) || \
    defined(MBEDTLS_ECP_DP_SECP384R1_ENABLED) || \
    defined(MBEDTLS_ECP_DP_SECP521R1_ENABLED) || \
    defined(MBEDTLS_ECP_DP_BP256R1_ENABLED) ||   \
    defined(MBEDTLS_ECP_DP_BP384R1_ENABLED) ||   \
    defined(MBEDTLS_ECP_DP_BP512R1_ENABLED) ||   \
    defined(MBEDTLS_ECP_DP_SECP192K1_ENABLED) || \
    defined(MBEDTLS_ECP_DP_SECP224K1_ENABLED) || \
    defined(MBEDTLS_ECP_DP_SECP256K1_ENABLED)
#define ECP_SHORTWEIERSTRASS
#endif

#if defined(MBEDTLS_ECP_DP_CURVE25519_ENABLED)
#define ECP_MONTGOMERY
#endif

#if defined(MBEDTLS_CHECK_PARAMS)

#if defined(MBEDTLS_PARAM_FAILED)
/** An alternative definition of MBEDTLS_PARAM_FAILED has been set in config.h.
 *
 * This flag can be used to check whether it is safe to assume that
 * MBEDTLS_PARAM_FAILED() will expand to a call to mbedtls_param_failed().
 */
#define MBEDTLS_PARAM_FAILED_ALT
#else /* MBEDTLS_PARAM_FAILED */
#define MBEDTLS_PARAM_FAILED(cond) \
    mbedtls_param_failed(#cond, __FILE__, __LINE__)

/**
 * \brief       User supplied callback function for parameter validation failure.
 *              See #MBEDTLS_CHECK_PARAMS for context.
 *
 *              This function will be called unless an alternative treatement
 *              is defined through the #MBEDTLS_PARAM_FAILED macro.
 *
 *              This function can return, and the operation will be aborted, or
 *              alternatively, through use of setjmp()/longjmp() can resume
 *              execution in the application code.
 *
 * \param failure_condition The assertion that didn't hold.
 * \param file  The file where the assertion failed.
 * \param line  The line in the file where the assertion failed.
 */
void mbedtls_param_failed(const char* failure_condition,
                          const char* file,
                          int line);
#endif /* MBEDTLS_PARAM_FAILED */

/* Internal macro meant to be called only from within the library. */
#define MBEDTLS_INTERNAL_VALIDATE_RET(cond, ret) \
    do                                           \
    {                                            \
        if(!(cond))                              \
        {                                        \
            MBEDTLS_PARAM_FAILED(cond);          \
            return (ret);                        \
        }                                        \
    } while(0)

/* Internal macro meant to be called only from within the library. */
#define MBEDTLS_INTERNAL_VALIDATE(cond) \
    do                                  \
    {                                   \
        if(!(cond))                     \
        {                               \
            MBEDTLS_PARAM_FAILED(cond); \
            return;                     \
        }                               \
    } while(0)

#else /* MBEDTLS_CHECK_PARAMS */

/* Internal macros meant to be called only from within the library. */
#define MBEDTLS_INTERNAL_VALIDATE_RET(cond, ret) \
    do                                           \
    {                                            \
    } while(0)
#define MBEDTLS_INTERNAL_VALIDATE(cond) \
    do                                  \
    {                                   \
    } while(0)

#endif /* MBEDTLS_CHECK_PARAMS */

/* Parameter validation macros based on platform_util.h */
#define ECP_VALIDATE_RET(cond) \
    MBEDTLS_INTERNAL_VALIDATE_RET(cond, MBEDTLS_ERR_ECP_BAD_INPUT_DATA)
#define ECP_VALIDATE(cond) \
    MBEDTLS_INTERNAL_VALIDATE(cond)

/*
 * Get the type of a curve
 */
mbedtls_ecp_curve_type mbedtls_ecp_get_type(const mbedtls_ecp_group* grp)
{
    if(grp->G.MBEDTLS_PRIVATE(X).MBEDTLS_PRIVATE(p) == NULL)
        return (MBEDTLS_ECP_TYPE_NONE);

    if(grp->G.MBEDTLS_PRIVATE(Y).MBEDTLS_PRIVATE(p) == NULL)
        return (MBEDTLS_ECP_TYPE_MONTGOMERY);
    else
        return (MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS);
}

/*
 * Generate a private key
 */
int mbedtls_ecp_gen_privkey(const mbedtls_ecp_group* grp,
                            mbedtls_mpi* d,
                            int (*f_rng)(void*, unsigned char*, size_t),
                            void* p_rng)
{
    int ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
    size_t n_size;

    ECP_VALIDATE_RET(grp != NULL);
    ECP_VALIDATE_RET(d != NULL);
    ECP_VALIDATE_RET(f_rng != NULL);

    n_size = (grp->nbits + 7) / 8;

#if defined(ECP_MONTGOMERY)
    if(mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_MONTGOMERY)
    {
        /* [M225] page 5 */
        size_t b;

        do
        {
            MBEDTLS_MPI_CHK(mbedtls_mpi_fill_random(d, n_size, f_rng, p_rng));
        } while(mbedtls_mpi_bitlen(d) == 0);

        /* Make sure the most significant bit is nbits */
        b = mbedtls_mpi_bitlen(d) - 1; /* mbedtls_mpi_bitlen is one-based */
        if(b > grp->nbits)
            MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(d, b - grp->nbits));
        else
            MBEDTLS_MPI_CHK(mbedtls_mpi_set_bit(d, grp->nbits, 1));

        /* Make sure the last two bits are unset for Curve448, three bits for
           Curve25519 */
        MBEDTLS_MPI_CHK(mbedtls_mpi_set_bit(d, 0, 0));
        MBEDTLS_MPI_CHK(mbedtls_mpi_set_bit(d, 1, 0));
        if(grp->nbits == 254)
        {
            MBEDTLS_MPI_CHK(mbedtls_mpi_set_bit(d, 2, 0));
        }
    }
#endif /* ECP_MONTGOMERY */

#if defined(ECP_SHORTWEIERSTRASS)
    if(mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS)
    {
        /* SEC1 3.2.1: Generate d such that 1 <= n < N */
        int count = 0;

        /*
         * Match the procedure given in RFC 6979 (deterministic ECDSA):
         * - use the same byte ordering;
         * - keep the leftmost nbits bits of the generated octet string;
         * - try until result is in the desired range.
         * This also avoids any biais, which is especially important for ECDSA.
         */
        do
        {
            MBEDTLS_MPI_CHK(mbedtls_mpi_fill_random(d, n_size, f_rng, p_rng));
            MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(d, 8 * n_size - grp->nbits));

            /*
             * Each try has at worst a probability 1/2 of failing (the msb has
             * a probability 1/2 of being 0, and then the result will be < N),
             * so after 30 tries failure probability is a most 2**(-30).
             *
             * For most curves, 1 try is enough with overwhelming probability,
             * since N starts with a lot of 1s in binary, but some curves
             * such as secp224k1 are actually very close to the worst case.
             */
            if(++count > 30)
                return (MBEDTLS_ERR_ECP_RANDOM_FAILED);
        } while(mbedtls_mpi_cmp_int(d, 1) < 0 ||
                mbedtls_mpi_cmp_mpi(d, &grp->N) >= 0);
    }
#endif /* ECP_SHORTWEIERSTRASS */

cleanup:
    return (ret);
}

#define MBEDTLS_INTERNAL_VALIDATE_RET(cond, ret) \
    do                                           \
    {                                            \
    } while(0)
#define ECP_VALIDATE_RET(cond) \
    MBEDTLS_INTERNAL_VALIDATE_RET(cond, MBEDTLS_ERR_ECP_BAD_INPUT_DATA)
/*
 * Write a private key.
 */
int mbedtls_ecp_write_key(mbedtls_ecp_keypair* key,
                          unsigned char* buf, size_t buflen)
{
    int ret = MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;

    ECP_VALIDATE_RET(key != NULL);
    ECP_VALIDATE_RET(buf != NULL);

#if defined(ECP_MONTGOMERY)
    if(mbedtls_ecp_get_type(&key->grp) == MBEDTLS_ECP_TYPE_MONTGOMERY)
    {
        if(key->grp.id == MBEDTLS_ECP_DP_CURVE25519)
        {
            if(buflen < ECP_CURVE25519_KEY_SIZE)
                return MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL;

            MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary_le(&key->d, buf, buflen));
        }
        else
            ret = MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
    }
#endif /* ECP_MONTGOMERY */

#if defined(ECP_SHORTWEIERSTRASS)
    if(mbedtls_ecp_get_type(&key->MBEDTLS_PRIVATE(grp)) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS)
    {
        MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&key->MBEDTLS_PRIVATE(d), buf, buflen));
    }
#endif /* ECP_SHORTWEIERSTRASS */

cleanup:
    return (ret);
}

#endif /* MBEDTLS_ECP_ALT */

#endif /* MBEDTLS_ECP_C */
