#ifndef GP_WB_PROP_H
#define GP_WB_PROP_H

/***************************
 * layout: plme
 ***************************/

/* dont use this address */
#define GP_WB_READ_PLME_ILLEGAL_ADDRESS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x000))


/* tranceiver state, 0=trx_off/1=rx_on/2=tx_on/3=cal, status from design */
#define GP_WB_READ_PLME_TRX_STATE_STATUS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x001))


/* CCA energy detect threshold */
#define GP_WB_READ_PLME_CCA_ED_THRESH() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x002))

#define GP_WB_WRITE_PLME_CCA_ED_THRESH(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x002), (val)); \
        } while (0)


/* Sets the cca mode to either energy only or energy combined with carrier sense (carrier sense only can be obtained by choosing the combined mode and lowering the cca_ed_threshold) */
#define GP_WB_READ_PLME_CCA_MODE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x003), 0)

#define GP_WB_WRITE_PLME_CCA_MODE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x003), 0, (val)); \
        } while (0)

/* sets the duration of the cca measurement in symbols (time=(cca_measurement_time+1)* 16 us). This is also used for ED measurements */
#define GP_WB_READ_PLME_CCA_MEASUREMENT_TIME() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x003)) >> 1) & 0x07)

#define GP_WB_WRITE_PLME_CCA_MEASUREMENT_TIME(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x003), 0x0E, (val) << 1); \
        } while (0)

/* Sets the divide factor for the prescaler. The prescaled frequency is 16MHz/(2**prescale_div) */
#define GP_WB_READ_PLME_SIG_GEN_PRESCALE_DIV() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x003)) >> 4) & 0x03)

#define GP_WB_WRITE_PLME_SIG_GEN_PRESCALE_DIV(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x003), 0x30, (val) << 4); \
        } while (0)


/* Sets the start pointer for the pattern descriptors (32 bit word address - using memory map address) */
#define GP_WB_READ_PLME_SIG_GEN_PATTERN_DESCRIPTOR_PTR() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x004))

#define GP_WB_WRITE_PLME_SIG_GEN_PATTERN_DESCRIPTOR_PTR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFFFF); \
          GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x004), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PLME_SIG_GEN_TRANSITION_CONTROL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x007))

#define GP_WB_WRITE_PLME_SIG_GEN_TRANSITION_CONTROL(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x007), (val))

/* Determines what transition will be done e.g. off 2 tx or tx to rx, ... (should actually be set by the design ... is here for test purposes) */
#define GP_WB_READ_PLME_SIG_GEN_TRANSITION() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x007)) & 0x0F)

#define GP_WB_GET_PLME_SIG_GEN_TRANSITION_FROM_SIG_GEN_TRANSITION_CONTROL(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_PLME_SIG_GEN_TRANSITION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x007), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_PLME_SIG_GEN_TRANSITION_TO_SIG_GEN_TRANSITION_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x10; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Set to true when you want to trigger patterns fromn the regmap (when set to FALSE, the design controls the triggering of the sequences) */
#define GP_WB_READ_PLME_SIG_GEN_TRIGGER_FROM_REGMAP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x007), 4)

#define GP_WB_GET_PLME_SIG_GEN_TRIGGER_FROM_REGMAP_FROM_SIG_GEN_TRANSITION_CONTROL(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_PLME_SIG_GEN_TRIGGER_FROM_REGMAP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x007), 4, (val)); \
        } while (0)

#define GP_WB_SET_PLME_SIG_GEN_TRIGGER_FROM_REGMAP_TO_SIG_GEN_TRANSITION_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


#define GP_WB_WRITE_PLME_SIG_GEN_SEQUENCE_TRIGGERS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x008), (val))

/* Fire of a ram sequence */
#define GP_WB_PLME_SIG_GEN_START_SEQUENCE() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x008), 0x01)

#define GP_WB_SET_PLME_SIG_GEN_START_SEQUENCE_TO_SIG_GEN_SEQUENCE_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Aborts the ongoing sequence entirely */
#define GP_WB_PLME_SIG_GEN_ABORT_SEQUENCE() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x008), 0x02)

#define GP_WB_SET_PLME_SIG_GEN_ABORT_SEQUENCE_TO_SIG_GEN_SEQUENCE_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* interrupt clear */
#define GP_WB_PLME_CLR_SEQUENCE_DONE_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x008), 0x04)

#define GP_WB_SET_PLME_CLR_SEQUENCE_DONE_INTERRUPT_TO_SIG_GEN_SEQUENCE_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* This triggers a repeating pattern to stop repeating */
#define GP_WB_PLME_SIG_GEN_STOP_REPEAT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x008), 0x08)

#define GP_WB_SET_PLME_SIG_GEN_STOP_REPEAT_TO_SIG_GEN_SEQUENCE_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PLME_SIG_GEN_SEQUENCE_STATUS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x009))

/* ram sequence is ongoing */
#define GP_WB_READ_PLME_SIG_GEN_BUSY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x009), 0)

#define GP_WB_GET_PLME_SIG_GEN_BUSY_FROM_SIG_GEN_SEQUENCE_STATUS(tmp) \
        ((tmp) & 0x01)

/* indicates that the ram sequence was aborted because of a memory access err-or */
#define GP_WB_READ_PLME_SIG_GEN_MEM_ERR() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x009), 1)

#define GP_WB_GET_PLME_SIG_GEN_MEM_ERR_FROM_SIG_GEN_SEQUENCE_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* unmasked interrupt status of the interrupt triggered by finishing a ram sequence */
#define GP_WB_READ_PLME_UNMASKED_SEQUENCE_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x009), 2)

#define GP_WB_GET_PLME_UNMASKED_SEQUENCE_DONE_INTERRUPT_FROM_SIG_GEN_SEQUENCE_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)

/* Indicates what state transition is currently being executed - only really meaningful when busy is true */
#define GP_WB_READ_PLME_SIG_GEN_TRANSITION_OBSERVE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x009)) >> 3) & 0x0F)

#define GP_WB_GET_PLME_SIG_GEN_TRANSITION_OBSERVE_FROM_SIG_GEN_SEQUENCE_STATUS(tmp) \
        (((tmp) >> 3) & 0x0F)


/* shows the what index in the ram sequence is currently being executed */
#define GP_WB_READ_PLME_SIG_GEN_SEQUENCE_IDX() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x00a))


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PLME_DUTY_CYCLE_TRANSITION_CONTROL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x00b))

#define GP_WB_WRITE_PLME_DUTY_CYCLE_TRANSITION_CONTROL(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x00b), (val))

/* Selects the transition that will be played out when the phy starts/restarts the duty cycling mode (so a low power listening mode) */
#define GP_WB_READ_PLME_DUTY_CYCLING_START_TRANSITION() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x00b)) & 0x0F)

#define GP_WB_GET_PLME_DUTY_CYCLING_START_TRANSITION_FROM_DUTY_CYCLE_TRANSITION_CONTROL(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_PLME_DUTY_CYCLING_START_TRANSITION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x00b), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_PLME_DUTY_CYCLING_START_TRANSITION_TO_DUTY_CYCLE_TRANSITION_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0xF0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Selects the transition that will be played out when the phy stops/aborts the duty cycling mode (so e.g when going from preamble to data phase) */
#define GP_WB_READ_PLME_DUTY_CYCLING_STOP_TRANSITION() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x00b)) >> 4) & 0x0F)

#define GP_WB_GET_PLME_DUTY_CYCLING_STOP_TRANSITION_FROM_DUTY_CYCLE_TRANSITION_CONTROL(tmp) \
        (((tmp) >> 4) & 0x0F)

#define GP_WB_WRITE_PLME_DUTY_CYCLING_STOP_TRANSITION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x00b), 0xF0, (val) << 4); \
        } while (0)

#define GP_WB_SET_PLME_DUTY_CYCLING_STOP_TRANSITION_TO_DUTY_CYCLE_TRANSITION_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* The channel that is used in overrule mode (so when overrule_ena is 1) - This channel is really the channel used by the FLL and the rest of the design. So the overrule happens at the very last point */
#define GP_WB_READ_PLME_CHANNEL_OVERRULE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x00c)) & 0x3F)

#define GP_WB_WRITE_PLME_CHANNEL_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x00c), 0x3F, (val)); \
        } while (0)

/* Enables overruling the channel used */
#define GP_WB_READ_PLME_CHANNEL_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x00c), 6)

#define GP_WB_WRITE_PLME_CHANNEL_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x00c), 6, (val)); \
        } while (0)

/* In normal operation, channel updates will be triggered by the mac. This option disables mac channel updates */
#define GP_WB_READ_PLME_DISABLE_MAC_CHANNEL_UPDATE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x00c), 7)

#define GP_WB_WRITE_PLME_DISABLE_MAC_CHANNEL_UPDATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x00c), 7, (val)); \
        } while (0)

/* In normal operation, the mac can force the phy to be in single channel mode (e.g for TX). This option disables mac channel forcing */
#define GP_WB_READ_PLME_DISABLE_MAC_CHANNEL_FORCE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x00d), 0)

#define GP_WB_WRITE_PLME_DISABLE_MAC_CHANNEL_FORCE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x00d), 0, (val)); \
        } while (0)

/* When enabled, this setting will force a virtual channel transition on each receiver channel slot when using multichannel mode, even if the channel in consecutive slots is the same channel */
#define GP_WB_READ_PLME_FORCE_CHANNEL_TRANSITION_ON_EACH_SLOT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x00d), 1)

#define GP_WB_WRITE_PLME_FORCE_CHANNEL_TRANSITION_ON_EACH_SLOT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x00d), 1, (val)); \
        } while (0)

/* When enabled, the option is presented to disable listening on the channel we just dropped a packet on, for the remaining length of the packet. */
#define GP_WB_READ_PLME_ENABLE_CHANNEL_DISABLE_FEATURE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x00d), 2)

#define GP_WB_WRITE_PLME_ENABLE_CHANNEL_DISABLE_FEATURE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x00d), 2, (val)); \
        } while (0)

/* When 1, the channel_disable feature will also work when there is only 1 active channel. */
#define GP_WB_READ_PLME_ENABLE_CHANNEL_DISABLE_SINGLE_CH() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x00d), 3)

#define GP_WB_WRITE_PLME_ENABLE_CHANNEL_DISABLE_SINGLE_CH(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x00d), 3, (val)); \
        } while (0)


/* direct channel configuration interface for a channel - the value set will take effect when apply_channel_* is triggered. The channel will then be applied to the appropriate index */
#define GP_WB_READ_PLME_CHANNEL_SET() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x00e))

#define GP_WB_WRITE_PLME_CHANNEL_SET(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x00e), (val)); \
        } while (0)


#define GP_WB_WRITE_PLME_APPLY_CHANNEL(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x00f), (val))

/* when triggered channel 0 will be set to the value defined in channel_0 */
#define GP_WB_PLME_APPLY_CHANNEL_0() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x00f), 0x01)

#define GP_WB_SET_PLME_APPLY_CHANNEL_0_TO_APPLY_CHANNEL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* when triggered channel 1 will be set to the value defined in channel_0 */
#define GP_WB_PLME_APPLY_CHANNEL_1() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x00f), 0x02)

#define GP_WB_SET_PLME_APPLY_CHANNEL_1_TO_APPLY_CHANNEL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* when triggered channel 2 will be set to the value defined in channel_2 */
#define GP_WB_PLME_APPLY_CHANNEL_2() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x00f), 0x04)

#define GP_WB_SET_PLME_APPLY_CHANNEL_2_TO_APPLY_CHANNEL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* when triggered channel 3 will be set to the value defined in channel_3 */
#define GP_WB_PLME_APPLY_CHANNEL_3() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x00f), 0x08)

#define GP_WB_SET_PLME_APPLY_CHANNEL_3_TO_APPLY_CHANNEL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x77; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* when triggered channel 4 will be set to the value defined in channel_4 */
#define GP_WB_PLME_APPLY_CHANNEL_4() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x00f), 0x10)

#define GP_WB_SET_PLME_APPLY_CHANNEL_4_TO_APPLY_CHANNEL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x6F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* when triggered channel 5 will be set to the value defined in channel_5 */
#define GP_WB_PLME_APPLY_CHANNEL_5() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x00f), 0x20)

#define GP_WB_SET_PLME_APPLY_CHANNEL_5_TO_APPLY_CHANNEL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x5F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* when triggered, the channel the current packet was being received on will be disabled for the remaining length of the packet. Only works when enable_channel_disable_feature is set */
#define GP_WB_PLME_DISABLE_CHANNEL_FOR_REMAINING_PART_OF_PACKET() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x00f), 0x40)

#define GP_WB_SET_PLME_DISABLE_CHANNEL_FOR_REMAINING_PART_OF_PACKET_TO_APPLY_CHANNEL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PLME_CHANNEL_PREAMBLE_DETECT_DISABLE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x010))

#define GP_WB_WRITE_PLME_CHANNEL_PREAMBLE_DETECT_DISABLE(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x010), (val))

/* Will prevent the receiver to go to the data phase when a preamble is detected on the channel indicated by idx 0 */
#define GP_WB_READ_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_0() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x010), 0)

#define GP_WB_GET_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_0_FROM_CHANNEL_PREAMBLE_DETECT_DISABLE(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x010), 0, (val)); \
        } while (0)

#define GP_WB_SET_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_0_TO_CHANNEL_PREAMBLE_DETECT_DISABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Will prevent the receiver to go to the data phase when a preamble is detected on the channel indicated by idx 1 */
#define GP_WB_READ_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_1() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x010), 1)

#define GP_WB_GET_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_1_FROM_CHANNEL_PREAMBLE_DETECT_DISABLE(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x010), 1, (val)); \
        } while (0)

#define GP_WB_SET_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_1_TO_CHANNEL_PREAMBLE_DETECT_DISABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Will prevent the receiver to go to the data phase when a preamble is detected on the channel indicated by idx 2 */
#define GP_WB_READ_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_2() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x010), 2)

#define GP_WB_GET_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_2_FROM_CHANNEL_PREAMBLE_DETECT_DISABLE(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x010), 2, (val)); \
        } while (0)

#define GP_WB_SET_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_2_TO_CHANNEL_PREAMBLE_DETECT_DISABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Will prevent the receiver to go to the data phase when a preamble is detected on the channel indicated by idx 3 */
#define GP_WB_READ_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_3() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x010), 3)

#define GP_WB_GET_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_3_FROM_CHANNEL_PREAMBLE_DETECT_DISABLE(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x010), 3, (val)); \
        } while (0)

#define GP_WB_SET_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_3_TO_CHANNEL_PREAMBLE_DETECT_DISABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Will prevent the receiver to go to the data phase when a preamble is detected on the channel indicated by idx 4 */
#define GP_WB_READ_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_4() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x010), 4)

#define GP_WB_GET_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_4_FROM_CHANNEL_PREAMBLE_DETECT_DISABLE(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x010), 4, (val)); \
        } while (0)

#define GP_WB_SET_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_4_TO_CHANNEL_PREAMBLE_DETECT_DISABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Will prevent the receiver to go to the data phase when a preamble is detected on the channel indicated by idx 5 */
#define GP_WB_READ_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_5() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x010), 5)

#define GP_WB_GET_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_5_FROM_CHANNEL_PREAMBLE_DETECT_DISABLE(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x010), 5, (val)); \
        } while (0)

#define GP_WB_SET_PLME_DISABLE_PREAMBLE_DET_ON_CH_IDX_5_TO_CHANNEL_PREAMBLE_DETECT_DISABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PLME_CHANNEL_CONFIG_UPDATE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x011))

#define GP_WB_WRITE_PLME_CHANNEL_CONFIG_UPDATE(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x011), (val))

/* Will prevent the lf preload to be updated from the FLL */
#define GP_WB_READ_PLME_DISABLE_LF_PRELOAD_UPDATE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x011), 0)

#define GP_WB_GET_PLME_DISABLE_LF_PRELOAD_UPDATE_FROM_CHANNEL_CONFIG_UPDATE(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_PLME_DISABLE_LF_PRELOAD_UPDATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x011), 0, (val)); \
        } while (0)

#define GP_WB_SET_PLME_DISABLE_LF_PRELOAD_UPDATE_TO_CHANNEL_CONFIG_UPDATE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* will prevent any updates to be written to memory */
#define GP_WB_READ_PLME_DISABLE_WRITE_BACK_TO_MEM() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x011), 1)

#define GP_WB_GET_PLME_DISABLE_WRITE_BACK_TO_MEM_FROM_CHANNEL_CONFIG_UPDATE(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_PLME_DISABLE_WRITE_BACK_TO_MEM(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x011), 1, (val)); \
        } while (0)

#define GP_WB_SET_PLME_DISABLE_WRITE_BACK_TO_MEM_TO_CHANNEL_CONFIG_UPDATE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


#define GP_WB_WRITE_PLME_FLL_ACTIONS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x012), (val))

/* manual trigger for fetching the channel index info from ram */
#define GP_WB_PLME_TRIGGER_FLL_CONFIG_LOAD_FROM_RAM() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x012), 0x01)

#define GP_WB_SET_PLME_TRIGGER_FLL_CONFIG_LOAD_FROM_RAM_TO_FLL_ACTIONS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* manual trigger for starting a calibration in the fll */
#define GP_WB_PLME_TRIGGER_FLL_START_CAL() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x012), 0x02)

#define GP_WB_SET_PLME_TRIGGER_FLL_START_CAL_TO_FLL_ACTIONS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PLME_FLL_OVERRULES() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x013))

#define GP_WB_WRITE_PLME_FLL_OVERRULES(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x013), (val))

/* overrule for the closed loop enable signal to the FLL */
#define GP_WB_READ_PLME_FLL_CLOSED_LOOP_ENABLE_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x013), 0)

#define GP_WB_GET_PLME_FLL_CLOSED_LOOP_ENABLE_OVERRULE_FROM_FLL_OVERRULES(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_PLME_FLL_CLOSED_LOOP_ENABLE_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x013), 0, (val)); \
        } while (0)

#define GP_WB_SET_PLME_FLL_CLOSED_LOOP_ENABLE_OVERRULE_TO_FLL_OVERRULES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_PLME_FLL_CLOSED_LOOP_ENABLE_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x013), 1)

#define GP_WB_GET_PLME_FLL_CLOSED_LOOP_ENABLE_OVERRULE_ENA_FROM_FLL_OVERRULES(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_PLME_FLL_CLOSED_LOOP_ENABLE_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x013), 1, (val)); \
        } while (0)

#define GP_WB_SET_PLME_FLL_CLOSED_LOOP_ENABLE_OVERRULE_ENA_TO_FLL_OVERRULES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* overrule */
#define GP_WB_READ_PLME_FLL_TX_NOT_RX_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x013), 2)

#define GP_WB_GET_PLME_FLL_TX_NOT_RX_OVERRULE_FROM_FLL_OVERRULES(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_PLME_FLL_TX_NOT_RX_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x013), 2, (val)); \
        } while (0)

#define GP_WB_SET_PLME_FLL_TX_NOT_RX_OVERRULE_TO_FLL_OVERRULES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_PLME_FLL_TX_NOT_RX_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x013), 3)

#define GP_WB_GET_PLME_FLL_TX_NOT_RX_OVERRULE_ENA_FROM_FLL_OVERRULES(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_PLME_FLL_TX_NOT_RX_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x013), 3, (val)); \
        } while (0)

#define GP_WB_SET_PLME_FLL_TX_NOT_RX_OVERRULE_ENA_TO_FLL_OVERRULES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* channel 0 effectively being used by the design */
#define GP_WB_READ_PLME_ACTIVE_CHANNEL_0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x014))

/* channel 1 effectively being used by the design */
#define GP_WB_READ_PLME_ACTIVE_CHANNEL_1() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x015))

/* channel 2 effectively being used by the design */
#define GP_WB_READ_PLME_ACTIVE_CHANNEL_2() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x016))

/* channel 3 effectively being used by the design */
#define GP_WB_READ_PLME_ACTIVE_CHANNEL_3() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x017))

/* channel 4 effectively being used by the design */
#define GP_WB_READ_PLME_ACTIVE_CHANNEL_4() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x018))

/* channel 5 effectively being used by the design */
#define GP_WB_READ_PLME_ACTIVE_CHANNEL_5() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x019))


/* Indicates what channel indexes use the currently active channel as a mask */
#define GP_WB_READ_PLME_MATCHING_CH_IDX_MASK() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x01a))


#define GP_WB_WRITE_PLME_CLR_RSSI_FOR_CHANNEL(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x01b), (val))

/* when triggered the max hold rssi for channel idx 0 shall be cleared */
#define GP_WB_PLME_CLR_RSSI_CHANNEL_0() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x01b), 0x01)

#define GP_WB_SET_PLME_CLR_RSSI_CHANNEL_0_TO_CLR_RSSI_FOR_CHANNEL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* when triggered the max hold rssi for channel idx 0 shall be cleared */
#define GP_WB_PLME_CLR_RSSI_CHANNEL_1() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x01b), 0x02)

#define GP_WB_SET_PLME_CLR_RSSI_CHANNEL_1_TO_CLR_RSSI_FOR_CHANNEL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* when triggered the max hold rssi for channel idx 2 shall be cleared */
#define GP_WB_PLME_CLR_RSSI_CHANNEL_2() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x01b), 0x04)

#define GP_WB_SET_PLME_CLR_RSSI_CHANNEL_2_TO_CLR_RSSI_FOR_CHANNEL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* when triggered the max hold rssi for channel idx 3 shall be cleared */
#define GP_WB_PLME_CLR_RSSI_CHANNEL_3() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x01b), 0x08)

#define GP_WB_SET_PLME_CLR_RSSI_CHANNEL_3_TO_CLR_RSSI_FOR_CHANNEL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* when triggered the max hold rssi for channel idx 4 shall be cleared */
#define GP_WB_PLME_CLR_RSSI_CHANNEL_4() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x01b), 0x10)

#define GP_WB_SET_PLME_CLR_RSSI_CHANNEL_4_TO_CLR_RSSI_FOR_CHANNEL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* when triggered the max hold rssi for channel idx 5 shall be cleared */
#define GP_WB_PLME_CLR_RSSI_CHANNEL_5() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x01b), 0x20)

#define GP_WB_SET_PLME_CLR_RSSI_CHANNEL_5_TO_CLR_RSSI_FOR_CHANNEL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* Max hold rssi value for channel idx 0. Cleared by incoming packet or by explicit software clear */
#define GP_WB_READ_PLME_RSSI_CHANNEL_0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x01c))


/* Max hold rssi value for channel idx 1. Cleared by incoming packet or by explicit software clear */
#define GP_WB_READ_PLME_RSSI_CHANNEL_1() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x01d))


/* Max hold rssi value for channel idx 2. Cleared by incoming packet or by explicit software clear */
#define GP_WB_READ_PLME_RSSI_CHANNEL_2() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x01e))


/* Max hold rssi value for channel idx 3. Cleared by incoming packet or by explicit software clear */
#define GP_WB_READ_PLME_RSSI_CHANNEL_3() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x01f))


/* Max hold rssi value for channel idx 4. Cleared by incoming packet or by explicit software clear */
#define GP_WB_READ_PLME_RSSI_CHANNEL_4() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x020))


/* Max hold rssi value for channel idx 5. Cleared by incoming packet or by explicit software clear */
#define GP_WB_READ_PLME_RSSI_CHANNEL_5() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x021))


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PLME_RSSI_VALID() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x022))

/* Indicates that an rssi value has been latched into the rssi value register for channel idx 0 */
#define GP_WB_READ_PLME_RSSI_VALID_CHANNEL_0() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x022), 0)

#define GP_WB_GET_PLME_RSSI_VALID_CHANNEL_0_FROM_RSSI_VALID(tmp) \
        ((tmp) & 0x01)

/* Indicates that an rssi value has been latched into the rssi value register for channel idx 1 */
#define GP_WB_READ_PLME_RSSI_VALID_CHANNEL_1() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x022), 1)

#define GP_WB_GET_PLME_RSSI_VALID_CHANNEL_1_FROM_RSSI_VALID(tmp) \
        (((tmp) >> 1) & 0x01)

/* Indicates that an rssi value has been latched into the rssi value register for channel idx 2 */
#define GP_WB_READ_PLME_RSSI_VALID_CHANNEL_2() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x022), 2)

#define GP_WB_GET_PLME_RSSI_VALID_CHANNEL_2_FROM_RSSI_VALID(tmp) \
        (((tmp) >> 2) & 0x01)

/* Indicates that an rssi value has been latched into the rssi value register for channel idx 3 */
#define GP_WB_READ_PLME_RSSI_VALID_CHANNEL_3() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x022), 3)

#define GP_WB_GET_PLME_RSSI_VALID_CHANNEL_3_FROM_RSSI_VALID(tmp) \
        (((tmp) >> 3) & 0x01)

/* Indicates that an rssi value has been latched into the rssi value register for channel idx 4 */
#define GP_WB_READ_PLME_RSSI_VALID_CHANNEL_4() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x022), 4)

#define GP_WB_GET_PLME_RSSI_VALID_CHANNEL_4_FROM_RSSI_VALID(tmp) \
        (((tmp) >> 4) & 0x01)

/* Indicates that an rssi value has been latched into the rssi value register for channel idx 5 */
#define GP_WB_READ_PLME_RSSI_VALID_CHANNEL_5() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x022), 5)

#define GP_WB_GET_PLME_RSSI_VALID_CHANNEL_5_FROM_RSSI_VALID(tmp) \
        (((tmp) >> 5) & 0x01)


/* Value of the lf preload. Watch out : no precautions taken to have an atomic readout !! */
#define GP_WB_READ_PLME_LF_PRELOAD() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x024))


/* fine capbank value */
#define GP_WB_READ_PLME_CAPBANK_FINE_TX() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x027))


/* fine capbank value tx */
#define GP_WB_READ_PLME_CAPBANK_FINE_RX() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x028))


/* loop gain value. Watch out : no precautions taken to have atomiuc readout ! */
#define GP_WB_READ_PLME_LOOP_GAIN() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x02a))


/* current channel */
#define GP_WB_READ_PLME_ACTIVE_CHANNEL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x02c))

/* current channel_idx */
#define GP_WB_READ_PLME_ACTIVE_CHANNEL_IDX() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x02d)) & 0x07)

/* current channel is ble */
#define GP_WB_READ_PLME_ACTIVE_CHANNEL_IS_BLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x02d), 3)


/* Determines the behaviour when rx is requested by zb/ble */
#define GP_WB_READ_PLME_RX_MULTI_STD_MODE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x02e)) & 0x07)

#define GP_WB_WRITE_PLME_RX_MULTI_STD_MODE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x02e), 0x07, (val)); \
        } while (0)

/* Selects the receiver mode when zb mode is active (Normal / lpl / multichannel with or without antenna diversity) */
#define GP_WB_READ_PLME_RX_MODE_ZB() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x02e)) >> 3) & 0x03)

#define GP_WB_WRITE_PLME_RX_MODE_ZB(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x02e), 0x18, (val) << 3); \
        } while (0)

/* Selectes the receiver mode when ble mode is active (ble, ble high data rate or ble long range) */
#define GP_WB_READ_PLME_RX_MODE_BLE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x02e)) >> 5) & 0x03)

#define GP_WB_WRITE_PLME_RX_MODE_BLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x02e), 0x60, (val) << 5); \
        } while (0)


/* Overrules the rx mode generated by the phy_channel_mode_ctrl (multi_std modes no longer taken into account) */
#define GP_WB_READ_PLME_RX_MODE_OVERRULE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x02f)) & 0x07)

#define GP_WB_WRITE_PLME_RX_MODE_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x02f), 0x07, (val)); \
        } while (0)

#define GP_WB_READ_PLME_RX_MODE_OVERRULE_EN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x02f), 3)

#define GP_WB_WRITE_PLME_RX_MODE_OVERRULE_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x02f), 3, (val)); \
        } while (0)

/***************************
 * layout: trx
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_EXTERNAL_MODE_CONTROL() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x080))

#define GP_WB_WRITE_TRX_EXTERNAL_MODE_CONTROL(val) \
      GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x080), (val))

/* Gives a set of 4 signals that can be configured to a value to be set when the radio is in trx off state. These control signals can be put on pins using the mode_ctrl_(0..3)_pinmap registers */
#define GP_WB_READ_TRX_EXT_MODE_CTRL_FOR_TRX_OFF() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x080)) & 0x0F)

#define GP_WB_GET_TRX_EXT_MODE_CTRL_FOR_TRX_OFF_FROM_EXTERNAL_MODE_CONTROL(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_TRX_EXT_MODE_CTRL_FOR_TRX_OFF(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x080), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_TRX_EXT_MODE_CTRL_FOR_TRX_OFF_TO_EXTERNAL_MODE_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x01FFF0; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Gives a set of 4 signals that can be configured to a value to be set when the radio is in rx on state and att_ctrl is low. These control signals can be put on pins using the mode_ctrl_(0..3)_pinmap registers */
#define GP_WB_READ_TRX_EXT_MODE_CTRL_FOR_RX_ON_ATT_CTRL_LOW() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x080)) >> 4) & 0x0F)

#define GP_WB_GET_TRX_EXT_MODE_CTRL_FOR_RX_ON_ATT_CTRL_LOW_FROM_EXTERNAL_MODE_CONTROL(tmp) \
        (((tmp) >> 4) & 0x0F)

#define GP_WB_WRITE_TRX_EXT_MODE_CTRL_FOR_RX_ON_ATT_CTRL_LOW(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x080), 0xF0, (val) << 4); \
        } while (0)

#define GP_WB_SET_TRX_EXT_MODE_CTRL_FOR_RX_ON_ATT_CTRL_LOW_TO_EXTERNAL_MODE_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x01FF0F; \
          (tmp) |= (((UInt32)(val)) << 4); \
        } while (0)

/* Gives a set of 4 signals that can be configured to a value to be set when the radio is in rx on state and att_ctrl is high. These control signals can be put on pins using the mode_ctrl_(0..3)_pinmap registers */
#define GP_WB_READ_TRX_EXT_MODE_CTRL_FOR_RX_ON_ATT_CTRL_HIGH() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x081)) & 0x0F)

#define GP_WB_GET_TRX_EXT_MODE_CTRL_FOR_RX_ON_ATT_CTRL_HIGH_FROM_EXTERNAL_MODE_CONTROL(tmp) \
        (((tmp) >> 8) & 0x0F)

#define GP_WB_WRITE_TRX_EXT_MODE_CTRL_FOR_RX_ON_ATT_CTRL_HIGH(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x081), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_TRX_EXT_MODE_CTRL_FOR_RX_ON_ATT_CTRL_HIGH_TO_EXTERNAL_MODE_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x01F0FF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* Gives a set of 4 signals that can be configured to a value to be set when the radio is in rx on state. These are fo rthe chanenl_ctrl bits. */
#define GP_WB_READ_TRX_EXT_CHANNEL_CTRL_FOR_TRX_OFF() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x081)) >> 4) & 0x0F)

#define GP_WB_GET_TRX_EXT_CHANNEL_CTRL_FOR_TRX_OFF_FROM_EXTERNAL_MODE_CONTROL(tmp) \
        (((tmp) >> 12) & 0x0F)

#define GP_WB_WRITE_TRX_EXT_CHANNEL_CTRL_FOR_TRX_OFF(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x081), 0xF0, (val) << 4); \
        } while (0)

#define GP_WB_SET_TRX_EXT_CHANNEL_CTRL_FOR_TRX_OFF_TO_EXTERNAL_MODE_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x010FFF; \
          (tmp) |= (((UInt32)(val)) << 12); \
        } while (0)

/* Mask the channel dependant cahnnel_ctrl bits off (use ext_channel_ctrl_for_trx_off) when the radio is in trx_off. */
#define GP_WB_READ_TRX_MASK_CHANNEL_CTRL_FOR_TRX_OFF() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x082), 0)

#define GP_WB_GET_TRX_MASK_CHANNEL_CTRL_FOR_TRX_OFF_FROM_EXTERNAL_MODE_CONTROL(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_TRX_MASK_CHANNEL_CTRL_FOR_TRX_OFF(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x082), (val)); \
        } while (0)

#define GP_WB_SET_TRX_MASK_CHANNEL_CTRL_FOR_TRX_OFF_TO_EXTERNAL_MODE_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x00FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_RX_ANTENNA_0_CFG_0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x083))

#define GP_WB_WRITE_TRX_RX_ANTENNA_0_CFG_0(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x083), (val))

/* tune capacitance at tx-side */
#define GP_WB_READ_TRX_RX_ANT0_MATCH_TX_TUNE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x083)) & 0x07)

#define GP_WB_GET_TRX_RX_ANT0_MATCH_TX_TUNE_FROM_RX_ANTENNA_0_CFG_0(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_TRX_RX_ANT0_MATCH_TX_TUNE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x083), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TRX_RX_ANT0_MATCH_TX_TUNE_TO_RX_ANTENNA_0_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x18; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* select antenna 1 to connect to tx or rx */
#define GP_WB_READ_TRX_RX_ANT0_MATCH_ANT1_SELECT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x083), 3)

#define GP_WB_GET_TRX_RX_ANT0_MATCH_ANT1_SELECT_FROM_RX_ANTENNA_0_CFG_0(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_TRX_RX_ANT0_MATCH_ANT1_SELECT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x083), 3, (val)); \
        } while (0)

#define GP_WB_SET_TRX_RX_ANT0_MATCH_ANT1_SELECT_TO_RX_ANTENNA_0_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* select antenna 2 to connect to tx or rx */
#define GP_WB_READ_TRX_RX_ANT0_MATCH_ANT2_SELECT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x083), 4)

#define GP_WB_GET_TRX_RX_ANT0_MATCH_ANT2_SELECT_FROM_RX_ANTENNA_0_CFG_0(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_TRX_RX_ANT0_MATCH_ANT2_SELECT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x083), 4, (val)); \
        } while (0)

#define GP_WB_SET_TRX_RX_ANT0_MATCH_ANT2_SELECT_TO_RX_ANTENNA_0_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_RX_ANTENNA_0_CFG_1() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x084))

#define GP_WB_WRITE_TRX_RX_ANTENNA_0_CFG_1(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x084), (val))

/* tune capacitance at ant1-side */
#define GP_WB_READ_TRX_RX_ANT0_MATCH_ANT1_TUNE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x084)) & 0x07)

#define GP_WB_GET_TRX_RX_ANT0_MATCH_ANT1_TUNE_FROM_RX_ANTENNA_0_CFG_1(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_TRX_RX_ANT0_MATCH_ANT1_TUNE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x084), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TRX_RX_ANT0_MATCH_ANT1_TUNE_TO_RX_ANTENNA_0_CFG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x38; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* tune capacitance at ant2-side */
#define GP_WB_READ_TRX_RX_ANT0_MATCH_ANT2_TUNE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x084)) >> 3) & 0x07)

#define GP_WB_GET_TRX_RX_ANT0_MATCH_ANT2_TUNE_FROM_RX_ANTENNA_0_CFG_1(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_TRX_RX_ANT0_MATCH_ANT2_TUNE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x084), 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_TRX_RX_ANT0_MATCH_ANT2_TUNE_TO_RX_ANTENNA_0_CFG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_RX_ANTENNA_0_CFG_2() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x085))

#define GP_WB_WRITE_TRX_RX_ANTENNA_0_CFG_2(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x085), (val))

/* resistive termination of unused antenna 1 when receiving at antenna 2 */
#define GP_WB_READ_TRX_RX_ANT0_MATCH_ANT1_RLOAD() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x085)) & 0x07)

#define GP_WB_GET_TRX_RX_ANT0_MATCH_ANT1_RLOAD_FROM_RX_ANTENNA_0_CFG_2(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_TRX_RX_ANT0_MATCH_ANT1_RLOAD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x085), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TRX_RX_ANT0_MATCH_ANT1_RLOAD_TO_RX_ANTENNA_0_CFG_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x38; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* resistive termination of unused antenna 2 when receiving at antenna 1 */
#define GP_WB_READ_TRX_RX_ANT0_MATCH_ANT2_RLOAD() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x085)) >> 3) & 0x07)

#define GP_WB_GET_TRX_RX_ANT0_MATCH_ANT2_RLOAD_FROM_RX_ANTENNA_0_CFG_2(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_TRX_RX_ANT0_MATCH_ANT2_RLOAD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x085), 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_TRX_RX_ANT0_MATCH_ANT2_RLOAD_TO_RX_ANTENNA_0_CFG_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_RX_ANTENNA_1_CFG_0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x086))

#define GP_WB_WRITE_TRX_RX_ANTENNA_1_CFG_0(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x086), (val))

/* tune capacitance at tx-side */
#define GP_WB_READ_TRX_RX_ANT1_MATCH_TX_TUNE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x086)) & 0x07)

#define GP_WB_GET_TRX_RX_ANT1_MATCH_TX_TUNE_FROM_RX_ANTENNA_1_CFG_0(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_TRX_RX_ANT1_MATCH_TX_TUNE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x086), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TRX_RX_ANT1_MATCH_TX_TUNE_TO_RX_ANTENNA_1_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x18; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* select antenna 1 to connect to tx or rx */
#define GP_WB_READ_TRX_RX_ANT1_MATCH_ANT1_SELECT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x086), 3)

#define GP_WB_GET_TRX_RX_ANT1_MATCH_ANT1_SELECT_FROM_RX_ANTENNA_1_CFG_0(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_TRX_RX_ANT1_MATCH_ANT1_SELECT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x086), 3, (val)); \
        } while (0)

#define GP_WB_SET_TRX_RX_ANT1_MATCH_ANT1_SELECT_TO_RX_ANTENNA_1_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* select antenna 2 to connect to tx or rx */
#define GP_WB_READ_TRX_RX_ANT1_MATCH_ANT2_SELECT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x086), 4)

#define GP_WB_GET_TRX_RX_ANT1_MATCH_ANT2_SELECT_FROM_RX_ANTENNA_1_CFG_0(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_TRX_RX_ANT1_MATCH_ANT2_SELECT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x086), 4, (val)); \
        } while (0)

#define GP_WB_SET_TRX_RX_ANT1_MATCH_ANT2_SELECT_TO_RX_ANTENNA_1_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_RX_ANTENNA_1_CFG_1() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x087))

#define GP_WB_WRITE_TRX_RX_ANTENNA_1_CFG_1(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x087), (val))

/* tune capacitance at ant1-side */
#define GP_WB_READ_TRX_RX_ANT1_MATCH_ANT1_TUNE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x087)) & 0x07)

#define GP_WB_GET_TRX_RX_ANT1_MATCH_ANT1_TUNE_FROM_RX_ANTENNA_1_CFG_1(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_TRX_RX_ANT1_MATCH_ANT1_TUNE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x087), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TRX_RX_ANT1_MATCH_ANT1_TUNE_TO_RX_ANTENNA_1_CFG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x38; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* tune capacitance at ant2-side */
#define GP_WB_READ_TRX_RX_ANT1_MATCH_ANT2_TUNE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x087)) >> 3) & 0x07)

#define GP_WB_GET_TRX_RX_ANT1_MATCH_ANT2_TUNE_FROM_RX_ANTENNA_1_CFG_1(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_TRX_RX_ANT1_MATCH_ANT2_TUNE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x087), 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_TRX_RX_ANT1_MATCH_ANT2_TUNE_TO_RX_ANTENNA_1_CFG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_RX_ANTENNA_1_CFG_2() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x088))

#define GP_WB_WRITE_TRX_RX_ANTENNA_1_CFG_2(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x088), (val))

/* resistive termination of unused antenna 1 when receiving at antenna 2 */
#define GP_WB_READ_TRX_RX_ANT1_MATCH_ANT1_RLOAD() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x088)) & 0x07)

#define GP_WB_GET_TRX_RX_ANT1_MATCH_ANT1_RLOAD_FROM_RX_ANTENNA_1_CFG_2(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_TRX_RX_ANT1_MATCH_ANT1_RLOAD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x088), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TRX_RX_ANT1_MATCH_ANT1_RLOAD_TO_RX_ANTENNA_1_CFG_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x38; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* resistive termination of unused antenna 2 when receiving at antenna 1 */
#define GP_WB_READ_TRX_RX_ANT1_MATCH_ANT2_RLOAD() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x088)) >> 3) & 0x07)

#define GP_WB_GET_TRX_RX_ANT1_MATCH_ANT2_RLOAD_FROM_RX_ANTENNA_1_CFG_2(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_TRX_RX_ANT1_MATCH_ANT2_RLOAD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x088), 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_TRX_RX_ANT1_MATCH_ANT2_RLOAD_TO_RX_ANTENNA_1_CFG_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_RX_LNA_CFG_0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x089))

#define GP_WB_WRITE_TRX_RX_LNA_CFG_0(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x089), (val))

/* sets gain of filter for receiving */
#define GP_WB_READ_TRX_RX_RX_BPF_GAIN() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x089)) & 0x0F)

#define GP_WB_GET_TRX_RX_RX_BPF_GAIN_FROM_RX_LNA_CFG_0(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_TRX_RX_RX_BPF_GAIN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x089), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_TRX_RX_RX_BPF_GAIN_TO_RX_LNA_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x30; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* low bias option for lna for receiving */
#define GP_WB_READ_TRX_RX_RX_LNA_LOWBIAS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x089), 4)

#define GP_WB_GET_TRX_RX_RX_LNA_LOWBIAS_FROM_RX_LNA_CFG_0(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_TRX_RX_RX_LNA_LOWBIAS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x089), 4, (val)); \
        } while (0)

#define GP_WB_SET_TRX_RX_RX_LNA_LOWBIAS_TO_RX_LNA_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* set lna in low-gain mode for receiving */
#define GP_WB_READ_TRX_RX_RX_LNA_LOWGAIN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x089), 5)

#define GP_WB_GET_TRX_RX_RX_LNA_LOWGAIN_FROM_RX_LNA_CFG_0(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_TRX_RX_RX_LNA_LOWGAIN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x089), 5, (val)); \
        } while (0)

#define GP_WB_SET_TRX_RX_RX_LNA_LOWGAIN_TO_RX_LNA_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_TX_ANTENNA_0_CFG_0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08a))

#define GP_WB_WRITE_TRX_TX_ANTENNA_0_CFG_0(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08a), (val))

/* tune capacitance at tx-side */
#define GP_WB_READ_TRX_TX_ANT0_MATCH_TX_TUNE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08a)) & 0x07)

#define GP_WB_GET_TRX_TX_ANT0_MATCH_TX_TUNE_FROM_TX_ANTENNA_0_CFG_0(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_TRX_TX_ANT0_MATCH_TX_TUNE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08a), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TRX_TX_ANT0_MATCH_TX_TUNE_TO_TX_ANTENNA_0_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x18; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* select antenna 1 to connect to tx or rx */
#define GP_WB_READ_TRX_TX_ANT0_MATCH_ANT1_SELECT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08a), 3)

#define GP_WB_GET_TRX_TX_ANT0_MATCH_ANT1_SELECT_FROM_TX_ANTENNA_0_CFG_0(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_TRX_TX_ANT0_MATCH_ANT1_SELECT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08a), 3, (val)); \
        } while (0)

#define GP_WB_SET_TRX_TX_ANT0_MATCH_ANT1_SELECT_TO_TX_ANTENNA_0_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* select antenna 2 to connect to tx or rx */
#define GP_WB_READ_TRX_TX_ANT0_MATCH_ANT2_SELECT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08a), 4)

#define GP_WB_GET_TRX_TX_ANT0_MATCH_ANT2_SELECT_FROM_TX_ANTENNA_0_CFG_0(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_TRX_TX_ANT0_MATCH_ANT2_SELECT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08a), 4, (val)); \
        } while (0)

#define GP_WB_SET_TRX_TX_ANT0_MATCH_ANT2_SELECT_TO_TX_ANTENNA_0_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_TX_ANTENNA_0_CFG_1() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08b))

#define GP_WB_WRITE_TRX_TX_ANTENNA_0_CFG_1(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08b), (val))

/* tune capacitance at ant1-side */
#define GP_WB_READ_TRX_TX_ANT0_MATCH_ANT1_TUNE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08b)) & 0x07)

#define GP_WB_GET_TRX_TX_ANT0_MATCH_ANT1_TUNE_FROM_TX_ANTENNA_0_CFG_1(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_TRX_TX_ANT0_MATCH_ANT1_TUNE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08b), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TRX_TX_ANT0_MATCH_ANT1_TUNE_TO_TX_ANTENNA_0_CFG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x38; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* tune capacitance at ant2-side */
#define GP_WB_READ_TRX_TX_ANT0_MATCH_ANT2_TUNE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08b)) >> 3) & 0x07)

#define GP_WB_GET_TRX_TX_ANT0_MATCH_ANT2_TUNE_FROM_TX_ANTENNA_0_CFG_1(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_TRX_TX_ANT0_MATCH_ANT2_TUNE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08b), 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_TRX_TX_ANT0_MATCH_ANT2_TUNE_TO_TX_ANTENNA_0_CFG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_TX_ANTENNA_0_CFG_2() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08c))

#define GP_WB_WRITE_TRX_TX_ANTENNA_0_CFG_2(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08c), (val))

/* resistive termination of unused antenna 1 when transmitting at antenna 2 */
#define GP_WB_READ_TRX_TX_ANT0_MATCH_ANT1_RLOAD() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08c)) & 0x07)

#define GP_WB_GET_TRX_TX_ANT0_MATCH_ANT1_RLOAD_FROM_TX_ANTENNA_0_CFG_2(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_TRX_TX_ANT0_MATCH_ANT1_RLOAD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08c), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TRX_TX_ANT0_MATCH_ANT1_RLOAD_TO_TX_ANTENNA_0_CFG_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x38; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* resistive termination of unused antenna 2 when transmitting at antenna 1 */
#define GP_WB_READ_TRX_TX_ANT0_MATCH_ANT2_RLOAD() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08c)) >> 3) & 0x07)

#define GP_WB_GET_TRX_TX_ANT0_MATCH_ANT2_RLOAD_FROM_TX_ANTENNA_0_CFG_2(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_TRX_TX_ANT0_MATCH_ANT2_RLOAD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08c), 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_TRX_TX_ANT0_MATCH_ANT2_RLOAD_TO_TX_ANTENNA_0_CFG_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_TX_ANTENNA_1_CFG_0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08d))

#define GP_WB_WRITE_TRX_TX_ANTENNA_1_CFG_0(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08d), (val))

/* tune capacitance at tx-side */
#define GP_WB_READ_TRX_TX_ANT1_MATCH_TX_TUNE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08d)) & 0x07)

#define GP_WB_GET_TRX_TX_ANT1_MATCH_TX_TUNE_FROM_TX_ANTENNA_1_CFG_0(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_TRX_TX_ANT1_MATCH_TX_TUNE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08d), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TRX_TX_ANT1_MATCH_TX_TUNE_TO_TX_ANTENNA_1_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x18; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* select antenna 1 to connect to tx or rx */
#define GP_WB_READ_TRX_TX_ANT1_MATCH_ANT1_SELECT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08d), 3)

#define GP_WB_GET_TRX_TX_ANT1_MATCH_ANT1_SELECT_FROM_TX_ANTENNA_1_CFG_0(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_TRX_TX_ANT1_MATCH_ANT1_SELECT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08d), 3, (val)); \
        } while (0)

#define GP_WB_SET_TRX_TX_ANT1_MATCH_ANT1_SELECT_TO_TX_ANTENNA_1_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* select antenna 2 to connect to tx or rx */
#define GP_WB_READ_TRX_TX_ANT1_MATCH_ANT2_SELECT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08d), 4)

#define GP_WB_GET_TRX_TX_ANT1_MATCH_ANT2_SELECT_FROM_TX_ANTENNA_1_CFG_0(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_TRX_TX_ANT1_MATCH_ANT2_SELECT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08d), 4, (val)); \
        } while (0)

#define GP_WB_SET_TRX_TX_ANT1_MATCH_ANT2_SELECT_TO_TX_ANTENNA_1_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_TX_ANTENNA_1_CFG_1() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08e))

#define GP_WB_WRITE_TRX_TX_ANTENNA_1_CFG_1(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08e), (val))

/* tune capacitance at ant1-side */
#define GP_WB_READ_TRX_TX_ANT1_MATCH_ANT1_TUNE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08e)) & 0x07)

#define GP_WB_GET_TRX_TX_ANT1_MATCH_ANT1_TUNE_FROM_TX_ANTENNA_1_CFG_1(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_TRX_TX_ANT1_MATCH_ANT1_TUNE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08e), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TRX_TX_ANT1_MATCH_ANT1_TUNE_TO_TX_ANTENNA_1_CFG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x38; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* tune capacitance at ant2-side */
#define GP_WB_READ_TRX_TX_ANT1_MATCH_ANT2_TUNE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08e)) >> 3) & 0x07)

#define GP_WB_GET_TRX_TX_ANT1_MATCH_ANT2_TUNE_FROM_TX_ANTENNA_1_CFG_1(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_TRX_TX_ANT1_MATCH_ANT2_TUNE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08e), 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_TRX_TX_ANT1_MATCH_ANT2_TUNE_TO_TX_ANTENNA_1_CFG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_TX_ANTENNA_1_CFG_2() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08f))

#define GP_WB_WRITE_TRX_TX_ANTENNA_1_CFG_2(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08f), (val))

/* resistive termination of unused antenna 1 when transmitting at antenna 2 */
#define GP_WB_READ_TRX_TX_ANT1_MATCH_ANT1_RLOAD() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08f)) & 0x07)

#define GP_WB_GET_TRX_TX_ANT1_MATCH_ANT1_RLOAD_FROM_TX_ANTENNA_1_CFG_2(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_TRX_TX_ANT1_MATCH_ANT1_RLOAD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08f), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TRX_TX_ANT1_MATCH_ANT1_RLOAD_TO_TX_ANTENNA_1_CFG_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x38; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* resistive termination of unused antenna 2 when transmitting at antenna 1 */
#define GP_WB_READ_TRX_TX_ANT1_MATCH_ANT2_RLOAD() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08f)) >> 3) & 0x07)

#define GP_WB_GET_TRX_TX_ANT1_MATCH_ANT2_RLOAD_FROM_TX_ANTENNA_1_CFG_2(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_TRX_TX_ANT1_MATCH_ANT2_RLOAD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x08f), 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_TRX_TX_ANT1_MATCH_ANT2_RLOAD_TO_TX_ANTENNA_1_CFG_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_TX_LNA_CFG_0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x090))

#define GP_WB_WRITE_TRX_TX_LNA_CFG_0(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x090), (val))

/* sets gain of filter for transmitting */
#define GP_WB_READ_TRX_TX_RX_BPF_GAIN() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x090)) & 0x0F)

#define GP_WB_GET_TRX_TX_RX_BPF_GAIN_FROM_TX_LNA_CFG_0(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_TRX_TX_RX_BPF_GAIN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x090), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_TRX_TX_RX_BPF_GAIN_TO_TX_LNA_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x30; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* low bias option for lna for transmitting */
#define GP_WB_READ_TRX_TX_RX_LNA_LOWBIAS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x090), 4)

#define GP_WB_GET_TRX_TX_RX_LNA_LOWBIAS_FROM_TX_LNA_CFG_0(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_TRX_TX_RX_LNA_LOWBIAS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x090), 4, (val)); \
        } while (0)

#define GP_WB_SET_TRX_TX_RX_LNA_LOWBIAS_TO_TX_LNA_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* set lna in low-gain mode for transmitting */
#define GP_WB_READ_TRX_TX_RX_LNA_LOWGAIN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x090), 5)

#define GP_WB_GET_TRX_TX_RX_LNA_LOWGAIN_FROM_TX_LNA_CFG_0(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_TRX_TX_RX_LNA_LOWGAIN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x090), 5, (val)); \
        } while (0)

#define GP_WB_SET_TRX_TX_RX_LNA_LOWGAIN_TO_TX_LNA_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_ATT_ANTENNA_0_CFG_0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x091))

#define GP_WB_WRITE_TRX_ATT_ANTENNA_0_CFG_0(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x091), (val))

/* tune capacitance at tx-side */
#define GP_WB_READ_TRX_ATT_ANT0_MATCH_TX_TUNE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x091)) & 0x07)

#define GP_WB_GET_TRX_ATT_ANT0_MATCH_TX_TUNE_FROM_ATT_ANTENNA_0_CFG_0(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_TRX_ATT_ANT0_MATCH_TX_TUNE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x091), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TRX_ATT_ANT0_MATCH_TX_TUNE_TO_ATT_ANTENNA_0_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x18; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* select antenna 1 to connect to tx or rx */
#define GP_WB_READ_TRX_ATT_ANT0_MATCH_ANT1_SELECT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x091), 3)

#define GP_WB_GET_TRX_ATT_ANT0_MATCH_ANT1_SELECT_FROM_ATT_ANTENNA_0_CFG_0(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_TRX_ATT_ANT0_MATCH_ANT1_SELECT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x091), 3, (val)); \
        } while (0)

#define GP_WB_SET_TRX_ATT_ANT0_MATCH_ANT1_SELECT_TO_ATT_ANTENNA_0_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* select antenna 2 to connect to tx or rx */
#define GP_WB_READ_TRX_ATT_ANT0_MATCH_ANT2_SELECT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x091), 4)

#define GP_WB_GET_TRX_ATT_ANT0_MATCH_ANT2_SELECT_FROM_ATT_ANTENNA_0_CFG_0(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_TRX_ATT_ANT0_MATCH_ANT2_SELECT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x091), 4, (val)); \
        } while (0)

#define GP_WB_SET_TRX_ATT_ANT0_MATCH_ANT2_SELECT_TO_ATT_ANTENNA_0_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_ATT_ANTENNA_0_CFG_1() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x092))

#define GP_WB_WRITE_TRX_ATT_ANTENNA_0_CFG_1(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x092), (val))

/* tune capacitance at ant1-side */
#define GP_WB_READ_TRX_ATT_ANT0_MATCH_ANT1_TUNE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x092)) & 0x07)

#define GP_WB_GET_TRX_ATT_ANT0_MATCH_ANT1_TUNE_FROM_ATT_ANTENNA_0_CFG_1(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_TRX_ATT_ANT0_MATCH_ANT1_TUNE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x092), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TRX_ATT_ANT0_MATCH_ANT1_TUNE_TO_ATT_ANTENNA_0_CFG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x38; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* tune capacitance at ant2-side */
#define GP_WB_READ_TRX_ATT_ANT0_MATCH_ANT2_TUNE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x092)) >> 3) & 0x07)

#define GP_WB_GET_TRX_ATT_ANT0_MATCH_ANT2_TUNE_FROM_ATT_ANTENNA_0_CFG_1(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_TRX_ATT_ANT0_MATCH_ANT2_TUNE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x092), 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_TRX_ATT_ANT0_MATCH_ANT2_TUNE_TO_ATT_ANTENNA_0_CFG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_ATT_ANTENNA_0_CFG_2() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x093))

#define GP_WB_WRITE_TRX_ATT_ANTENNA_0_CFG_2(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x093), (val))

/* resistive termination of unused antenna 1 when attenuated receiving at antenna 2 */
#define GP_WB_READ_TRX_ATT_ANT0_MATCH_ANT1_RLOAD() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x093)) & 0x07)

#define GP_WB_GET_TRX_ATT_ANT0_MATCH_ANT1_RLOAD_FROM_ATT_ANTENNA_0_CFG_2(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_TRX_ATT_ANT0_MATCH_ANT1_RLOAD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x093), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TRX_ATT_ANT0_MATCH_ANT1_RLOAD_TO_ATT_ANTENNA_0_CFG_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x38; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* resistive termination of unused antenna 2 when attenuated receiving at antenna 1 */
#define GP_WB_READ_TRX_ATT_ANT0_MATCH_ANT2_RLOAD() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x093)) >> 3) & 0x07)

#define GP_WB_GET_TRX_ATT_ANT0_MATCH_ANT2_RLOAD_FROM_ATT_ANTENNA_0_CFG_2(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_TRX_ATT_ANT0_MATCH_ANT2_RLOAD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x093), 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_TRX_ATT_ANT0_MATCH_ANT2_RLOAD_TO_ATT_ANTENNA_0_CFG_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_ATT_ANTENNA_1_CFG_0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x094))

#define GP_WB_WRITE_TRX_ATT_ANTENNA_1_CFG_0(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x094), (val))

/* tune capacitance at tx-side */
#define GP_WB_READ_TRX_ATT_ANT1_MATCH_TX_TUNE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x094)) & 0x07)

#define GP_WB_GET_TRX_ATT_ANT1_MATCH_TX_TUNE_FROM_ATT_ANTENNA_1_CFG_0(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_TRX_ATT_ANT1_MATCH_TX_TUNE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x094), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TRX_ATT_ANT1_MATCH_TX_TUNE_TO_ATT_ANTENNA_1_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x18; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* select antenna 1 to connect to tx or rx */
#define GP_WB_READ_TRX_ATT_ANT1_MATCH_ANT1_SELECT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x094), 3)

#define GP_WB_GET_TRX_ATT_ANT1_MATCH_ANT1_SELECT_FROM_ATT_ANTENNA_1_CFG_0(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_TRX_ATT_ANT1_MATCH_ANT1_SELECT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x094), 3, (val)); \
        } while (0)

#define GP_WB_SET_TRX_ATT_ANT1_MATCH_ANT1_SELECT_TO_ATT_ANTENNA_1_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* select antenna 2 to connect to tx or rx */
#define GP_WB_READ_TRX_ATT_ANT1_MATCH_ANT2_SELECT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x094), 4)

#define GP_WB_GET_TRX_ATT_ANT1_MATCH_ANT2_SELECT_FROM_ATT_ANTENNA_1_CFG_0(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_TRX_ATT_ANT1_MATCH_ANT2_SELECT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x094), 4, (val)); \
        } while (0)

#define GP_WB_SET_TRX_ATT_ANT1_MATCH_ANT2_SELECT_TO_ATT_ANTENNA_1_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_ATT_ANTENNA_1_CFG_1() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x095))

#define GP_WB_WRITE_TRX_ATT_ANTENNA_1_CFG_1(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x095), (val))

/* tune capacitance at ant1-side */
#define GP_WB_READ_TRX_ATT_ANT1_MATCH_ANT1_TUNE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x095)) & 0x07)

#define GP_WB_GET_TRX_ATT_ANT1_MATCH_ANT1_TUNE_FROM_ATT_ANTENNA_1_CFG_1(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_TRX_ATT_ANT1_MATCH_ANT1_TUNE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x095), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TRX_ATT_ANT1_MATCH_ANT1_TUNE_TO_ATT_ANTENNA_1_CFG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x38; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* tune capacitance at ant2-side */
#define GP_WB_READ_TRX_ATT_ANT1_MATCH_ANT2_TUNE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x095)) >> 3) & 0x07)

#define GP_WB_GET_TRX_ATT_ANT1_MATCH_ANT2_TUNE_FROM_ATT_ANTENNA_1_CFG_1(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_TRX_ATT_ANT1_MATCH_ANT2_TUNE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x095), 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_TRX_ATT_ANT1_MATCH_ANT2_TUNE_TO_ATT_ANTENNA_1_CFG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_ATT_ANTENNA_1_CFG_2() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x096))

#define GP_WB_WRITE_TRX_ATT_ANTENNA_1_CFG_2(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x096), (val))

/* resistive termination of unused antenna 1 when attenuated receiving at antenna 2 */
#define GP_WB_READ_TRX_ATT_ANT1_MATCH_ANT1_RLOAD() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x096)) & 0x07)

#define GP_WB_GET_TRX_ATT_ANT1_MATCH_ANT1_RLOAD_FROM_ATT_ANTENNA_1_CFG_2(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_TRX_ATT_ANT1_MATCH_ANT1_RLOAD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x096), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TRX_ATT_ANT1_MATCH_ANT1_RLOAD_TO_ATT_ANTENNA_1_CFG_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x38; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* resistive termination of unused antenna 2 when attenuated receiving at antenna 1 */
#define GP_WB_READ_TRX_ATT_ANT1_MATCH_ANT2_RLOAD() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x096)) >> 3) & 0x07)

#define GP_WB_GET_TRX_ATT_ANT1_MATCH_ANT2_RLOAD_FROM_ATT_ANTENNA_1_CFG_2(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_TRX_ATT_ANT1_MATCH_ANT2_RLOAD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x096), 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_TRX_ATT_ANT1_MATCH_ANT2_RLOAD_TO_ATT_ANTENNA_1_CFG_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_ATT_LNA_CFG_0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x097))

#define GP_WB_WRITE_TRX_ATT_LNA_CFG_0(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x097), (val))

/* sets gain of filter for attenuated receiving */
#define GP_WB_READ_TRX_ATT_RX_BPF_GAIN() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x097)) & 0x0F)

#define GP_WB_GET_TRX_ATT_RX_BPF_GAIN_FROM_ATT_LNA_CFG_0(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_TRX_ATT_RX_BPF_GAIN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x097), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_TRX_ATT_RX_BPF_GAIN_TO_ATT_LNA_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x30; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* low bias option for lna for attenuated receiving */
#define GP_WB_READ_TRX_ATT_RX_LNA_LOWBIAS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x097), 4)

#define GP_WB_GET_TRX_ATT_RX_LNA_LOWBIAS_FROM_ATT_LNA_CFG_0(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_TRX_ATT_RX_LNA_LOWBIAS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x097), 4, (val)); \
        } while (0)

#define GP_WB_SET_TRX_ATT_RX_LNA_LOWBIAS_TO_ATT_LNA_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* set lna in low-gain mode for attenuated receiving */
#define GP_WB_READ_TRX_ATT_RX_LNA_LOWGAIN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x097), 5)

#define GP_WB_GET_TRX_ATT_RX_LNA_LOWGAIN_FROM_ATT_LNA_CFG_0(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_TRX_ATT_RX_LNA_LOWGAIN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x097), 5, (val)); \
        } while (0)

#define GP_WB_SET_TRX_ATT_RX_LNA_LOWGAIN_TO_ATT_LNA_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_LOW_ATT_ANTENNA_0_CFG_0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x098))

#define GP_WB_WRITE_TRX_LOW_ATT_ANTENNA_0_CFG_0(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x098), (val))

/* tune capacitance at tx-side */
#define GP_WB_READ_TRX_LOW_ATT_ANT0_MATCH_TX_TUNE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x098)) & 0x07)

#define GP_WB_GET_TRX_LOW_ATT_ANT0_MATCH_TX_TUNE_FROM_LOW_ATT_ANTENNA_0_CFG_0(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_TRX_LOW_ATT_ANT0_MATCH_TX_TUNE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x098), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TRX_LOW_ATT_ANT0_MATCH_TX_TUNE_TO_LOW_ATT_ANTENNA_0_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x18; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* select antenna 1 to connect to tx or rx */
#define GP_WB_READ_TRX_LOW_ATT_ANT0_MATCH_ANT1_SELECT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x098), 3)

#define GP_WB_GET_TRX_LOW_ATT_ANT0_MATCH_ANT1_SELECT_FROM_LOW_ATT_ANTENNA_0_CFG_0(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_TRX_LOW_ATT_ANT0_MATCH_ANT1_SELECT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x098), 3, (val)); \
        } while (0)

#define GP_WB_SET_TRX_LOW_ATT_ANT0_MATCH_ANT1_SELECT_TO_LOW_ATT_ANTENNA_0_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* select antenna 2 to connect to tx or rx */
#define GP_WB_READ_TRX_LOW_ATT_ANT0_MATCH_ANT2_SELECT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x098), 4)

#define GP_WB_GET_TRX_LOW_ATT_ANT0_MATCH_ANT2_SELECT_FROM_LOW_ATT_ANTENNA_0_CFG_0(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_TRX_LOW_ATT_ANT0_MATCH_ANT2_SELECT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x098), 4, (val)); \
        } while (0)

#define GP_WB_SET_TRX_LOW_ATT_ANT0_MATCH_ANT2_SELECT_TO_LOW_ATT_ANTENNA_0_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_LOW_ATT_ANTENNA_0_CFG_1() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x099))

#define GP_WB_WRITE_TRX_LOW_ATT_ANTENNA_0_CFG_1(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x099), (val))

/* tune capacitance at ant1-side */
#define GP_WB_READ_TRX_LOW_ATT_ANT0_MATCH_ANT1_TUNE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x099)) & 0x07)

#define GP_WB_GET_TRX_LOW_ATT_ANT0_MATCH_ANT1_TUNE_FROM_LOW_ATT_ANTENNA_0_CFG_1(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_TRX_LOW_ATT_ANT0_MATCH_ANT1_TUNE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x099), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TRX_LOW_ATT_ANT0_MATCH_ANT1_TUNE_TO_LOW_ATT_ANTENNA_0_CFG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x38; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* tune capacitance at ant2-side */
#define GP_WB_READ_TRX_LOW_ATT_ANT0_MATCH_ANT2_TUNE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x099)) >> 3) & 0x07)

#define GP_WB_GET_TRX_LOW_ATT_ANT0_MATCH_ANT2_TUNE_FROM_LOW_ATT_ANTENNA_0_CFG_1(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_TRX_LOW_ATT_ANT0_MATCH_ANT2_TUNE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x099), 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_TRX_LOW_ATT_ANT0_MATCH_ANT2_TUNE_TO_LOW_ATT_ANTENNA_0_CFG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_LOW_ATT_ANTENNA_0_CFG_2() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09a))

#define GP_WB_WRITE_TRX_LOW_ATT_ANTENNA_0_CFG_2(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09a), (val))

/* resistive termination of unused antenna 1 when low-attenuated receiving at antenna 2 */
#define GP_WB_READ_TRX_LOW_ATT_ANT0_MATCH_ANT1_RLOAD() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09a)) & 0x07)

#define GP_WB_GET_TRX_LOW_ATT_ANT0_MATCH_ANT1_RLOAD_FROM_LOW_ATT_ANTENNA_0_CFG_2(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_TRX_LOW_ATT_ANT0_MATCH_ANT1_RLOAD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09a), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TRX_LOW_ATT_ANT0_MATCH_ANT1_RLOAD_TO_LOW_ATT_ANTENNA_0_CFG_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x38; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* resistive termination of unused antenna 2 when low-attenuated receiving at antenna 1 */
#define GP_WB_READ_TRX_LOW_ATT_ANT0_MATCH_ANT2_RLOAD() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09a)) >> 3) & 0x07)

#define GP_WB_GET_TRX_LOW_ATT_ANT0_MATCH_ANT2_RLOAD_FROM_LOW_ATT_ANTENNA_0_CFG_2(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_TRX_LOW_ATT_ANT0_MATCH_ANT2_RLOAD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09a), 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_TRX_LOW_ATT_ANT0_MATCH_ANT2_RLOAD_TO_LOW_ATT_ANTENNA_0_CFG_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_LOW_ATT_ANTENNA_1_CFG_0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09b))

#define GP_WB_WRITE_TRX_LOW_ATT_ANTENNA_1_CFG_0(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09b), (val))

/* tune capacitance at tx-side */
#define GP_WB_READ_TRX_LOW_ATT_ANT1_MATCH_TX_TUNE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09b)) & 0x07)

#define GP_WB_GET_TRX_LOW_ATT_ANT1_MATCH_TX_TUNE_FROM_LOW_ATT_ANTENNA_1_CFG_0(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_TRX_LOW_ATT_ANT1_MATCH_TX_TUNE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09b), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TRX_LOW_ATT_ANT1_MATCH_TX_TUNE_TO_LOW_ATT_ANTENNA_1_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x18; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* select antenna 1 to connect to tx or rx */
#define GP_WB_READ_TRX_LOW_ATT_ANT1_MATCH_ANT1_SELECT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09b), 3)

#define GP_WB_GET_TRX_LOW_ATT_ANT1_MATCH_ANT1_SELECT_FROM_LOW_ATT_ANTENNA_1_CFG_0(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_TRX_LOW_ATT_ANT1_MATCH_ANT1_SELECT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09b), 3, (val)); \
        } while (0)

#define GP_WB_SET_TRX_LOW_ATT_ANT1_MATCH_ANT1_SELECT_TO_LOW_ATT_ANTENNA_1_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* select antenna 2 to connect to tx or rx */
#define GP_WB_READ_TRX_LOW_ATT_ANT1_MATCH_ANT2_SELECT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09b), 4)

#define GP_WB_GET_TRX_LOW_ATT_ANT1_MATCH_ANT2_SELECT_FROM_LOW_ATT_ANTENNA_1_CFG_0(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_TRX_LOW_ATT_ANT1_MATCH_ANT2_SELECT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09b), 4, (val)); \
        } while (0)

#define GP_WB_SET_TRX_LOW_ATT_ANT1_MATCH_ANT2_SELECT_TO_LOW_ATT_ANTENNA_1_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_LOW_ATT_ANTENNA_1_CFG_1() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09c))

#define GP_WB_WRITE_TRX_LOW_ATT_ANTENNA_1_CFG_1(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09c), (val))

/* tune capacitance at ant1-side */
#define GP_WB_READ_TRX_LOW_ATT_ANT1_MATCH_ANT1_TUNE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09c)) & 0x07)

#define GP_WB_GET_TRX_LOW_ATT_ANT1_MATCH_ANT1_TUNE_FROM_LOW_ATT_ANTENNA_1_CFG_1(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_TRX_LOW_ATT_ANT1_MATCH_ANT1_TUNE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09c), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TRX_LOW_ATT_ANT1_MATCH_ANT1_TUNE_TO_LOW_ATT_ANTENNA_1_CFG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x38; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* tune capacitance at ant2-side */
#define GP_WB_READ_TRX_LOW_ATT_ANT1_MATCH_ANT2_TUNE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09c)) >> 3) & 0x07)

#define GP_WB_GET_TRX_LOW_ATT_ANT1_MATCH_ANT2_TUNE_FROM_LOW_ATT_ANTENNA_1_CFG_1(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_TRX_LOW_ATT_ANT1_MATCH_ANT2_TUNE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09c), 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_TRX_LOW_ATT_ANT1_MATCH_ANT2_TUNE_TO_LOW_ATT_ANTENNA_1_CFG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_LOW_ATT_ANTENNA_1_CFG_2() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09d))

#define GP_WB_WRITE_TRX_LOW_ATT_ANTENNA_1_CFG_2(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09d), (val))

/* resistive termination of unused antenna 1 when low-attenuated receiving at antenna 2 */
#define GP_WB_READ_TRX_LOW_ATT_ANT1_MATCH_ANT1_RLOAD() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09d)) & 0x07)

#define GP_WB_GET_TRX_LOW_ATT_ANT1_MATCH_ANT1_RLOAD_FROM_LOW_ATT_ANTENNA_1_CFG_2(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_TRX_LOW_ATT_ANT1_MATCH_ANT1_RLOAD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09d), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TRX_LOW_ATT_ANT1_MATCH_ANT1_RLOAD_TO_LOW_ATT_ANTENNA_1_CFG_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x38; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* resistive termination of unused antenna 2 when low-attenuated receiving at antenna 1 */
#define GP_WB_READ_TRX_LOW_ATT_ANT1_MATCH_ANT2_RLOAD() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09d)) >> 3) & 0x07)

#define GP_WB_GET_TRX_LOW_ATT_ANT1_MATCH_ANT2_RLOAD_FROM_LOW_ATT_ANTENNA_1_CFG_2(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_TRX_LOW_ATT_ANT1_MATCH_ANT2_RLOAD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09d), 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_TRX_LOW_ATT_ANT1_MATCH_ANT2_RLOAD_TO_LOW_ATT_ANTENNA_1_CFG_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TRX_LOW_ATT_LNA_CFG_0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09e))

#define GP_WB_WRITE_TRX_LOW_ATT_LNA_CFG_0(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09e), (val))

/* sets gain of filter for low-attenuated receiving */
#define GP_WB_READ_TRX_LOW_ATT_RX_BPF_GAIN() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09e)) & 0x0F)

#define GP_WB_GET_TRX_LOW_ATT_RX_BPF_GAIN_FROM_LOW_ATT_LNA_CFG_0(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_TRX_LOW_ATT_RX_BPF_GAIN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09e), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_TRX_LOW_ATT_RX_BPF_GAIN_TO_LOW_ATT_LNA_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x30; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* low bias option for lna for low-attenuated receiving */
#define GP_WB_READ_TRX_LOW_ATT_RX_LNA_LOWBIAS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09e), 4)

#define GP_WB_GET_TRX_LOW_ATT_RX_LNA_LOWBIAS_FROM_LOW_ATT_LNA_CFG_0(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_TRX_LOW_ATT_RX_LNA_LOWBIAS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09e), 4, (val)); \
        } while (0)

#define GP_WB_SET_TRX_LOW_ATT_RX_LNA_LOWBIAS_TO_LOW_ATT_LNA_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* set lna in low-gain mode for low-attenuated receiving */
#define GP_WB_READ_TRX_LOW_ATT_RX_LNA_LOWGAIN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09e), 5)

#define GP_WB_GET_TRX_LOW_ATT_RX_LNA_LOWGAIN_FROM_LOW_ATT_LNA_CFG_0(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_TRX_LOW_ATT_RX_LNA_LOWGAIN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09e), 5, (val)); \
        } while (0)

#define GP_WB_SET_TRX_LOW_ATT_RX_LNA_LOWGAIN_TO_LOW_ATT_LNA_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* each regmap needs at least one RO prop */
#define GP_WB_READ_TRX_DUMMY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x09f), 0)

/***************************
 * layout: fll
 ***************************/

#define GP_WB_READ_FLL_STATE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100))


/* scaling between the two FLL injection points for ZB */
#define GP_WB_READ_FLL_MSK_MI_ADJUST() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x101))

#define GP_WB_WRITE_FLL_MSK_MI_ADJUST(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x101), (val)); \
        } while (0)


/* scaling between the two FLL injection points for BLE */
#define GP_WB_READ_FLL_GFSK_MI_ADJUST() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x102))

#define GP_WB_WRITE_FLL_GFSK_MI_ADJUST(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x102), (val)); \
        } while (0)


/* delay compensation between the two FLL injection points for ZB */
#define GP_WB_READ_FLL_MSK_DELAY() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x103)) & 0x0F)

#define GP_WB_WRITE_FLL_MSK_DELAY(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x103), 0x0F, (val)); \
        } while (0)

/* delay compensation between the two FLL injection points for BLE */
#define GP_WB_READ_FLL_GFSK_DELAY() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x103)) >> 4) & 0x0F)

#define GP_WB_WRITE_FLL_GFSK_DELAY(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x103), 0xF0, (val) << 4); \
        } while (0)


/* When 1 the clock to the FLL is permantly enable, dynamically switched otherwise */
#define GP_WB_READ_FLL_DISABLE_CLK_GATING() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104), 0)

#define GP_WB_WRITE_FLL_DISABLE_CLK_GATING(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104), 0, (val)); \
        } while (0)

/* The error correction module is switched off when 1 */
#define GP_WB_READ_FLL_ERR_CORR_DIS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104), 1)

#define GP_WB_WRITE_FLL_ERR_CORR_DIS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104), 1, (val)); \
        } while (0)

/* When TRUE, soft start is bypassed */
#define GP_WB_READ_FLL_SOFT_START_BYPASS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104), 2)

#define GP_WB_WRITE_FLL_SOFT_START_BYPASS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104), 2, (val)); \
        } while (0)

/* When TRUE, delta sigma modulator is enabled, reducing DCO quantization noise */
#define GP_WB_READ_FLL_DSM_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104), 3)

#define GP_WB_WRITE_FLL_DSM_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104), 3, (val)); \
        } while (0)

/* LFF coupling factor: 0 = 64, 1 = 128, 2 = 256, 3 = 512 */
#define GP_WB_READ_FLL_LFF_INT_COUPLING_FACTOR() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104)) >> 4) & 0x03)

#define GP_WB_WRITE_FLL_LFF_INT_COUPLING_FACTOR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104), 0x30, (val) << 4); \
        } while (0)

/* When 1, the LFF register will be bypassed when the loop is closed */
#define GP_WB_READ_FLL_LFF_BYPASS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104), 6)

#define GP_WB_WRITE_FLL_LFF_BYPASS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104), 6, (val)); \
        } while (0)


/* Length of the prepare states (resolution is 31.25ns) */
#define GP_WB_READ_FLL_CHANNEL_INVALID_DURATION() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x105))

#define GP_WB_WRITE_FLL_CHANNEL_INVALID_DURATION(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x105), (val)); \
        } while (0)


/* Upper threshold for RX out of range detect */
#define GP_WB_READ_FLL_RX_OUT_OF_RANGE_HI_THRES() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106))

#define GP_WB_WRITE_FLL_RX_OUT_OF_RANGE_HI_THRES(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106), (val)); \
        } while (0)


/* Upper threshold for RX out of range detect */
#define GP_WB_READ_FLL_RX_OUT_OF_RANGE_LO_THRES() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x108))

#define GP_WB_WRITE_FLL_RX_OUT_OF_RANGE_LO_THRES(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x108), (val)); \
        } while (0)


/* Upper threshold for RX out of range detect */
#define GP_WB_READ_FLL_TX_OUT_OF_RANGE_HI_THRES() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a))

#define GP_WB_WRITE_FLL_TX_OUT_OF_RANGE_HI_THRES(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a), (val)); \
        } while (0)


/* Upper threshold for RX out of range detect */
#define GP_WB_READ_FLL_TX_OUT_OF_RANGE_LO_THRES() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10c))

#define GP_WB_WRITE_FLL_TX_OUT_OF_RANGE_LO_THRES(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10c), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_FLL_UNMASKED_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e))

/* Unmasked value of the rx_out_of_range interrupt */
#define GP_WB_READ_FLL_UNMASKED_RX_OUT_OF_RANGE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e), 0)

#define GP_WB_GET_FLL_UNMASKED_RX_OUT_OF_RANGE_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* Unmasked value of the tx_out_of_range interrupt */
#define GP_WB_READ_FLL_UNMASKED_TX_OUT_OF_RANGE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e), 1)

#define GP_WB_GET_FLL_UNMASKED_TX_OUT_OF_RANGE_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* Unmasked value of the tx_out_of_lock interrupt */
#define GP_WB_READ_FLL_UNMASKED_TX_OUT_OF_LOCK_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e), 2)

#define GP_WB_GET_FLL_UNMASKED_TX_OUT_OF_LOCK_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* unmasked status of the Frequency estimation done interrupt */
#define GP_WB_READ_FLL_UNMASKED_FE_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e), 3)

#define GP_WB_GET_FLL_UNMASKED_FE_DONE_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

/* unmasked status of the calibration start interrupt */
#define GP_WB_READ_FLL_UNMASKED_CAL_START_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e), 4)

#define GP_WB_GET_FLL_UNMASKED_CAL_START_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)


#define GP_WB_WRITE_FLL_CLR_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10f), (val))

/* Clear FLL RX out of range interrupt */
#define GP_WB_FLL_CLR_RX_OUT_OF_RANGE_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10f), 0x01)

#define GP_WB_SET_FLL_CLR_RX_OUT_OF_RANGE_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Clear FLL RX out of range interrupt */
#define GP_WB_FLL_CLR_TX_OUT_OF_RANGE_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10f), 0x02)

#define GP_WB_SET_FLL_CLR_TX_OUT_OF_RANGE_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Clear FLL TX out of lock interrupt */
#define GP_WB_FLL_CLR_TX_OUT_OF_LOCK_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10f), 0x04)

#define GP_WB_SET_FLL_CLR_TX_OUT_OF_LOCK_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Clear for the Frequncy estimation done interrupt */
#define GP_WB_FLL_CLR_FE_DONE_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10f), 0x08)

#define GP_WB_SET_FLL_CLR_FE_DONE_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Clear for the calibration start interrupt */
#define GP_WB_FLL_CLR_CAL_START_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10f), 0x10)

#define GP_WB_SET_FLL_CLR_CAL_START_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* Coefficient used for tap 0 and 26 for BLE */
#define GP_WB_READ_FLL_GFSK_FILTER_COEFF0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x110))

#define GP_WB_WRITE_FLL_GFSK_FILTER_COEFF0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x110), (val)); \
        } while (0)


/* Coefficient used for tap 1 and 25 for BLE */
#define GP_WB_READ_FLL_GFSK_FILTER_COEFF1() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x111))

#define GP_WB_WRITE_FLL_GFSK_FILTER_COEFF1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x111), (val)); \
        } while (0)


/* Coefficient used for tap 2 and 24 for BLE */
#define GP_WB_READ_FLL_GFSK_FILTER_COEFF2() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x112))

#define GP_WB_WRITE_FLL_GFSK_FILTER_COEFF2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x112), (val)); \
        } while (0)


/* Coefficient used for tap 3 and 23 for BLE */
#define GP_WB_READ_FLL_GFSK_FILTER_COEFF3() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x113))

#define GP_WB_WRITE_FLL_GFSK_FILTER_COEFF3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x113), (val)); \
        } while (0)


/* Coefficient used for tap 4 and 22 for BLE */
#define GP_WB_READ_FLL_GFSK_FILTER_COEFF4() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x114))

#define GP_WB_WRITE_FLL_GFSK_FILTER_COEFF4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x114), (val)); \
        } while (0)


/* Coefficient used for tap 5 and 21 for BLE */
#define GP_WB_READ_FLL_GFSK_FILTER_COEFF5() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x115))

#define GP_WB_WRITE_FLL_GFSK_FILTER_COEFF5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x115), (val)); \
        } while (0)


/* Coefficient used for tap 6 and 20 for BLE */
#define GP_WB_READ_FLL_GFSK_FILTER_COEFF6() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x116))

#define GP_WB_WRITE_FLL_GFSK_FILTER_COEFF6(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x116), (val)); \
        } while (0)


/* Coefficient used for tap 7 and 19 for BLE */
#define GP_WB_READ_FLL_GFSK_FILTER_COEFF7() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x117))

#define GP_WB_WRITE_FLL_GFSK_FILTER_COEFF7(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x117), (val)); \
        } while (0)


/* Coefficient used for tap 8 and 18 for BLE */
#define GP_WB_READ_FLL_GFSK_FILTER_COEFF8() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x118))

#define GP_WB_WRITE_FLL_GFSK_FILTER_COEFF8(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x118), (val)); \
        } while (0)


/* Coefficient used for tap 9 and 17 for BLE */
#define GP_WB_READ_FLL_GFSK_FILTER_COEFF9() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x119))

#define GP_WB_WRITE_FLL_GFSK_FILTER_COEFF9(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x119), (val)); \
        } while (0)


/* Coefficient used for tap 10 and 16 for BLE */
#define GP_WB_READ_FLL_GFSK_FILTER_COEFF10() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a))

#define GP_WB_WRITE_FLL_GFSK_FILTER_COEFF10(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a), (val)); \
        } while (0)


/* Coefficient used for tap 11 and 15 for BLE */
#define GP_WB_READ_FLL_GFSK_FILTER_COEFF11() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11b))

#define GP_WB_WRITE_FLL_GFSK_FILTER_COEFF11(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11b), (val)); \
        } while (0)


/* Coefficient used for tap 12 and 14 for BLE */
#define GP_WB_READ_FLL_GFSK_FILTER_COEFF12() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11c))

#define GP_WB_WRITE_FLL_GFSK_FILTER_COEFF12(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11c), (val)); \
        } while (0)


/* Coefficient used for tap 13 for BLE */
#define GP_WB_READ_FLL_GFSK_FILTER_COEFF13() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11e))

#define GP_WB_WRITE_FLL_GFSK_FILTER_COEFF13(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11e), (val)); \
        } while (0)


/* Coefficient used for tap 0 and 26 for ZB */
#define GP_WB_READ_FLL_MSK_FILTER_COEFF0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x120))

#define GP_WB_WRITE_FLL_MSK_FILTER_COEFF0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x120), (val)); \
        } while (0)


/* Coefficient used for tap 1 and 25 for ZB */
#define GP_WB_READ_FLL_MSK_FILTER_COEFF1() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x121))

#define GP_WB_WRITE_FLL_MSK_FILTER_COEFF1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x121), (val)); \
        } while (0)


/* Coefficient used for tap 2 and 24 for ZB */
#define GP_WB_READ_FLL_MSK_FILTER_COEFF2() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x122))

#define GP_WB_WRITE_FLL_MSK_FILTER_COEFF2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x122), (val)); \
        } while (0)


/* Coefficient used for tap 3 and 23 for ZB */
#define GP_WB_READ_FLL_MSK_FILTER_COEFF3() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x123))

#define GP_WB_WRITE_FLL_MSK_FILTER_COEFF3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x123), (val)); \
        } while (0)


/* Coefficient used for tap 4 and 22 for ZB */
#define GP_WB_READ_FLL_MSK_FILTER_COEFF4() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x124))

#define GP_WB_WRITE_FLL_MSK_FILTER_COEFF4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x124), (val)); \
        } while (0)


/* Coefficient used for tap 5 and 21 for ZB */
#define GP_WB_READ_FLL_MSK_FILTER_COEFF5() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x125))

#define GP_WB_WRITE_FLL_MSK_FILTER_COEFF5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x125), (val)); \
        } while (0)


/* Coefficient used for tap 6 and 20 for ZB */
#define GP_WB_READ_FLL_MSK_FILTER_COEFF6() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x126))

#define GP_WB_WRITE_FLL_MSK_FILTER_COEFF6(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x126), (val)); \
        } while (0)


/* Coefficient used for tap 7 and 19 for ZB */
#define GP_WB_READ_FLL_MSK_FILTER_COEFF7() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x127))

#define GP_WB_WRITE_FLL_MSK_FILTER_COEFF7(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x127), (val)); \
        } while (0)


/* Coefficient used for tap 8 and 18 for ZB */
#define GP_WB_READ_FLL_MSK_FILTER_COEFF8() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x128))

#define GP_WB_WRITE_FLL_MSK_FILTER_COEFF8(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x128), (val)); \
        } while (0)


/* Coefficient used for tap 9 and 17 for ZB */
#define GP_WB_READ_FLL_MSK_FILTER_COEFF9() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x129))

#define GP_WB_WRITE_FLL_MSK_FILTER_COEFF9(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x129), (val)); \
        } while (0)


/* Coefficient used for tap 10 and 16 for ZB */
#define GP_WB_READ_FLL_MSK_FILTER_COEFF10() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12a))

#define GP_WB_WRITE_FLL_MSK_FILTER_COEFF10(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12a), (val)); \
        } while (0)


/* Coefficient used for tap 11 and 15 for ZB */
#define GP_WB_READ_FLL_MSK_FILTER_COEFF11() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12b))

#define GP_WB_WRITE_FLL_MSK_FILTER_COEFF11(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12b), (val)); \
        } while (0)


/* Coefficient used for tap 12 and 14 for ZB */
#define GP_WB_READ_FLL_MSK_FILTER_COEFF12() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12c))

#define GP_WB_WRITE_FLL_MSK_FILTER_COEFF12(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12c), (val)); \
        } while (0)


/* Coefficient used for tap 13 for ZB */
#define GP_WB_READ_FLL_MSK_FILTER_COEFF13() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12e))

#define GP_WB_WRITE_FLL_MSK_FILTER_COEFF13(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12e), (val)); \
        } while (0)


/* Mainly for the traffic generator, additional frequency offset on FLL for tx */
#define GP_WB_READ_FLL_TX_FREQUENCY_OFFSET() \
        (GP_WB_S16(GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x130)), 11))

#define GP_WB_WRITE_FLL_TX_FREQUENCY_OFFSET(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -1024, 1023); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x130), (UInt16)((val))); \
        } while (0)


/* Mainly for the traffic generator, additional frequency offset on FLL for rx */
#define GP_WB_READ_FLL_RX_FREQUENCY_OFFSET() \
        (GP_WB_S16(GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x132)), 11))

#define GP_WB_WRITE_FLL_RX_FREQUENCY_OFFSET(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -1024, 1023); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x132), (UInt16)((val))); \
        } while (0)


/* tuning bank for closed loop mode */
#define GP_WB_READ_FLL_CB_TUNE_CORE() \
        GP_WB_READ_SER_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x134))


/* Output of the loop filter. So, before the 2nd data modulation injection point. */
#define GP_WB_READ_FLL_LF_CORE() \
        (GP_WB_S16(GP_WB_READ_SER_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x136)), 12))


/* Trigger to stop the fll Calibration state */
#define GP_WB_FLL_CAL_STOP() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x138), 0x01)

/* Trigger to start a frequency estimation */
#define GP_WB_FLL_FE_START() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x138), 0x02)


/* result of a frequency estimation */
#define GP_WB_READ_FLL_FE_RESULT() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13a))


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_FLL_CAL_CFG() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13c))

#define GP_WB_WRITE_FLL_CAL_CFG(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13c), (val))

/* Selects the FE measurement period */
#define GP_WB_READ_FLL_FE_PERIOD() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13c)) & 0x03)

#define GP_WB_GET_FLL_FE_PERIOD_FROM_CAL_CFG(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_FLL_FE_PERIOD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13c), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_FLL_FE_PERIOD_TO_CAL_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0xFFFC; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Selects the FE sampler input */
#define GP_WB_READ_FLL_FE_SAMPLER() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13c)) >> 2) & 0x03)

#define GP_WB_GET_FLL_FE_SAMPLER_FROM_CAL_CFG(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_FLL_FE_SAMPLER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13c), 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_FLL_FE_SAMPLER_TO_CAL_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0xFFF3; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* Use cb_fine from regmap instead of from channel controller */
#define GP_WB_READ_FLL_CB_FINE_RM() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13c), 4)

#define GP_WB_GET_FLL_CB_FINE_RM_FROM_CAL_CFG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_FLL_CB_FINE_RM(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13c), 4, (val)); \
        } while (0)

#define GP_WB_SET_FLL_CB_FINE_RM_TO_CAL_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFEF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* Sweep the cb_fine around the center (cb_fine) when doing the FE */
#define GP_WB_READ_FLL_CB_FINE_SWEEP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13c), 5)

#define GP_WB_GET_FLL_CB_FINE_SWEEP_FROM_CAL_CFG(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_FLL_CB_FINE_SWEEP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13c), 5, (val)); \
        } while (0)

#define GP_WB_SET_FLL_CB_FINE_SWEEP_TO_CAL_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFDF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

/* Use cb_tune from regmap instead of from FLL */
#define GP_WB_READ_FLL_CB_TUNE_RM() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13c), 6)

#define GP_WB_GET_FLL_CB_TUNE_RM_FROM_CAL_CFG(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_FLL_CB_TUNE_RM(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13c), 6, (val)); \
        } while (0)

#define GP_WB_SET_FLL_CB_TUNE_RM_TO_CAL_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFBF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

/* Sweep the cb_tune around the center (cb_tune) when doing the FE */
#define GP_WB_READ_FLL_CB_TUNE_SWEEP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13c), 7)

#define GP_WB_GET_FLL_CB_TUNE_SWEEP_FROM_CAL_CFG(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_FLL_CB_TUNE_SWEEP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13c), 7, (val)); \
        } while (0)

#define GP_WB_SET_FLL_CB_TUNE_SWEEP_TO_CAL_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* Put the DTC in calibration state */
#define GP_WB_READ_FLL_CLK_DELAY_CAL() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13d), 0)

#define GP_WB_GET_FLL_CLK_DELAY_CAL_FROM_CAL_CFG(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_FLL_CLK_DELAY_CAL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13d), 0, (val)); \
        } while (0)

#define GP_WB_SET_FLL_CLK_DELAY_CAL_TO_CAL_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFEFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* Use clk_delay from regmap instead of from FLL */
#define GP_WB_READ_FLL_CLK_DELAY_RM() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13d), 1)

#define GP_WB_GET_FLL_CLK_DELAY_RM_FROM_CAL_CFG(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_FLL_CLK_DELAY_RM(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13d), 1, (val)); \
        } while (0)

#define GP_WB_SET_FLL_CLK_DELAY_RM_TO_CAL_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFDFF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)

/* Select the cal_sampler divider */
#define GP_WB_READ_FLL_DTC_CAL_DIV() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13d)) >> 2) & 0x07)

#define GP_WB_GET_FLL_DTC_CAL_DIV_FROM_CAL_CFG(tmp) \
        (((tmp) >> 10) & 0x07)

#define GP_WB_WRITE_FLL_DTC_CAL_DIV(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13d), 0x1C, (val) << 2); \
        } while (0)

#define GP_WB_SET_FLL_DTC_CAL_DIV_TO_CAL_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0xE3FF; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)

/* MSB bits are put to SLOW mode,to enable succesfull calibration */
#define GP_WB_READ_FLL_DTC_CAL_SLOW() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13d), 5)

#define GP_WB_GET_FLL_DTC_CAL_SLOW_FROM_CAL_CFG(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_FLL_DTC_CAL_SLOW(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13d), 5, (val)); \
        } while (0)

#define GP_WB_SET_FLL_DTC_CAL_SLOW_TO_CAL_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDFFF; \
          (tmp) |= (((UInt16)(val)) << 13); \
        } while (0)

/* put DCO in HP mode for during DTC calibration */
#define GP_WB_READ_FLL_DTC_LDO_HP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13d), 6)

#define GP_WB_GET_FLL_DTC_LDO_HP_FROM_CAL_CFG(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_FLL_DTC_LDO_HP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13d), 6, (val)); \
        } while (0)

#define GP_WB_SET_FLL_DTC_LDO_HP_TO_CAL_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBFFF; \
          (tmp) |= (((UInt16)(val)) << 14); \
        } while (0)

/* Use dtc_step from regmap instead of from channel controller */
#define GP_WB_READ_FLL_DTC_STEP_RM() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13d), 7)

#define GP_WB_GET_FLL_DTC_STEP_RM_FROM_CAL_CFG(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_FLL_DTC_STEP_RM(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13d), 7, (val)); \
        } while (0)

#define GP_WB_SET_FLL_DTC_STEP_RM_TO_CAL_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7FFF; \
          (tmp) |= (((UInt16)(val)) << 15); \
        } while (0)


/* Use the divide by 64 for the divsampler instead of divide by 16 */
#define GP_WB_READ_FLL_DIV64() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13e), 0)

#define GP_WB_WRITE_FLL_DIV64(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13e), (val)); \
        } while (0)


#define GP_WB_READ_FLL_CB_TUNE() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x140))

#define GP_WB_WRITE_FLL_CB_TUNE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x140), (val)); \
        } while (0)


#define GP_WB_READ_FLL_CB_FINE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x142))

#define GP_WB_WRITE_FLL_CB_FINE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x142), (val)); \
        } while (0)


#define GP_WB_READ_FLL_CLK_DELAY() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x143))

#define GP_WB_WRITE_FLL_CLK_DELAY(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x143), (val)); \
        } while (0)


#define GP_WB_READ_FLL_DTC_STEP() \
        (GP_WB_S8(GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x144)), 7))

#define GP_WB_WRITE_FLL_DTC_STEP(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -64, 63); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x144), (UInt8)((val))); \
        } while (0)


#define GP_WB_READ_FLL_DTC_MSB() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x145))

#define GP_WB_WRITE_FLL_DTC_MSB(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x145), (val)); \
        } while (0)


#define GP_WB_READ_FLL_DTC_LSB() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x146))

#define GP_WB_WRITE_FLL_DTC_LSB(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x146), (val)); \
        } while (0)


#define GP_WB_READ_FLL_CB_COARSE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x147))

#define GP_WB_WRITE_FLL_CB_COARSE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x147), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_FLL_PC_CFG() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x148))

#define GP_WB_WRITE_FLL_PC_CFG(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x148), (val))

/* enable precharging the crs cap bank with cb_coarse_pc_value during precharge_capbanks from phy_sig_gen */
#define GP_WB_READ_FLL_CB_COARSE_PC_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x148), 0)

#define GP_WB_GET_FLL_CB_COARSE_PC_ENABLE_FROM_PC_CFG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_FLL_CB_COARSE_PC_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x148), 0, (val)); \
        } while (0)

#define GP_WB_SET_FLL_CB_COARSE_PC_ENABLE_TO_PC_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F3E; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* precharging value for the crs cap bank.  bit 1 = msb bit, bit 0 = all other bits */
#define GP_WB_READ_FLL_CB_COARSE_PC_VALUE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x148)) >> 1) & 0x03)

#define GP_WB_GET_FLL_CB_COARSE_PC_VALUE_FROM_PC_CFG(tmp) \
        (((tmp) >> 1) & 0x03)

#define GP_WB_WRITE_FLL_CB_COARSE_PC_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x148), 0x06, (val) << 1); \
        } while (0)

#define GP_WB_SET_FLL_CB_COARSE_PC_VALUE_TO_PC_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3F39; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

/* enable precharging the fine cap bank with cb_coarse_pc_value during precharge_capbanks from phy_sig_gen */
#define GP_WB_READ_FLL_CB_FINE_PC_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x148), 3)

#define GP_WB_GET_FLL_CB_FINE_PC_ENABLE_FROM_PC_CFG(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_FLL_CB_FINE_PC_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x148), 3, (val)); \
        } while (0)

#define GP_WB_SET_FLL_CB_FINE_PC_ENABLE_TO_PC_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F37; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

/* precharging value for the fine cap bank.  bit 1 = msb bit, bit 0 = all other bits */
#define GP_WB_READ_FLL_CB_FINE_PC_VALUE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x148)) >> 4) & 0x03)

#define GP_WB_GET_FLL_CB_FINE_PC_VALUE_FROM_PC_CFG(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_FLL_CB_FINE_PC_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x148), 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_FLL_CB_FINE_PC_VALUE_TO_PC_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3F0F; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* precharging time in 125ns units. */
#define GP_WB_READ_FLL_CB_COARSE_PC_TIME() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x149))

#define GP_WB_GET_FLL_CB_COARSE_PC_TIME_FROM_PC_CFG(tmp) \
        (((tmp) >> 8) & 0x3F)

#define GP_WB_WRITE_FLL_CB_COARSE_PC_TIME(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x149), (val)); \
        } while (0)

#define GP_WB_SET_FLL_CB_COARSE_PC_TIME_TO_PC_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0x003F; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)


/* unit in 0.25 us */
#define GP_WB_READ_FLL_PA_ON_COUNT_LFF_CLR() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x14c))

#define GP_WB_WRITE_FLL_PA_ON_COUNT_LFF_CLR(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x14c), (val)); \
        } while (0)

/* unit in 0.25 us */
#define GP_WB_READ_FLL_PA_ON_COUNT_ERR_CORR_DIS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x14d))

#define GP_WB_WRITE_FLL_PA_ON_COUNT_ERR_CORR_DIS(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x14d), (val)); \
        } while (0)

/* unit in 0.25 us */
#define GP_WB_READ_FLL_PA_ON_COUNT_ERR_GAIN() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x14e))

#define GP_WB_WRITE_FLL_PA_ON_COUNT_ERR_GAIN(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x14e), (val)); \
        } while (0)


/* gain setting used for closed loop rx: 0:div1, 2:div2, 3:div4 */
#define GP_WB_READ_FLL_ERR_GAIN_NORMAL_RX() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x14f)) & 0x03)

#define GP_WB_WRITE_FLL_ERR_GAIN_NORMAL_RX(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x14f), 0x03, (val)); \
        } while (0)

/* gain setting used for closed loop rx: 0:div1, 2:div2, 3:div4 */
#define GP_WB_READ_FLL_ERR_GAIN_NORMAL_TX() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x14f)) >> 2) & 0x03)

#define GP_WB_WRITE_FLL_ERR_GAIN_NORMAL_TX(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x14f), 0x0C, (val) << 2); \
        } while (0)

/* gain setting used for locking or when changing channel: 0:div1, 2:div2, 3:div4 */
#define GP_WB_READ_FLL_ERR_GAIN_FAST() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x14f)) >> 4) & 0x03)

#define GP_WB_WRITE_FLL_ERR_GAIN_FAST(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x14f), 0x30, (val) << 4); \
        } while (0)


/* Enable pseudo random generation when 0x1 */
#define GP_WB_READ_FLL_PRG_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x150), 0)

#define GP_WB_WRITE_FLL_PRG_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x150), (val)); \
        } while (0)


#define GP_WB_READ_FLL_PRG_UPDATE_RATE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x151))

#define GP_WB_WRITE_FLL_PRG_UPDATE_RATE(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x151), (val)); \
        } while (0)


#define GP_WB_READ_FLL_PRG_BIT_MASK() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x152))

#define GP_WB_WRITE_FLL_PRG_BIT_MASK(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x152), (val)); \
        } while (0)


#define GP_WB_READ_FLL_PRG_OFFSET() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x154))

#define GP_WB_WRITE_FLL_PRG_OFFSET(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x154), (val)); \
        } while (0)


/* fll-ldo: set output voltage by changing reference voltage */
#define GP_WB_READ_FLL_FLL_LDO_REFBITS() \
        (GP_WB_S8((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x156)) & 0x0F), 4))

#define GP_WB_WRITE_FLL_FLL_LDO_REFBITS(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -8, 7); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x156), 0x0F, (UInt8)((val))); \
        } while (0)

/* set ldo resistance ladder reference. tweak the output voltage of the ldo */
#define GP_WB_READ_FLL_SX_LDO_REFBITS() \
        (GP_WB_S8(((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x156)) >> 4) & 0x0F), 4))

#define GP_WB_WRITE_FLL_SX_LDO_REFBITS(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -8, 7); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x156), 0xF0, (UInt8)((val) << 4)); \
        } while (0)


/* selection of bias current of the dco, twos complement */
#define GP_WB_READ_FLL_SX_DCO_PBIAS_SEL() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x158)) & 0x07)

#define GP_WB_WRITE_FLL_SX_DCO_PBIAS_SEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x158), 0x07, (val)); \
        } while (0)

/* calibration of the resistor value in the dco biasing. use procmon to find correct value */
#define GP_WB_READ_FLL_SX_DCO_RBIAS_CAL() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x158)) >> 3) & 0x07)

#define GP_WB_WRITE_FLL_SX_DCO_RBIAS_CAL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x158), 0x38, (val) << 3); \
        } while (0)

/* selection of bias current of the dco, twos complement */
#define GP_WB_READ_FLL_SX_DCO_RBIAS_SEL() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x158)) >> 6) & 0x03)

#define GP_WB_WRITE_FLL_SX_DCO_RBIAS_SEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x158), 0xC0, (val) << 6); \
        } while (0)

/* bypass of the clock delay */
#define GP_WB_READ_FLL_FLL_CLK_DELAY_BYPASS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x159), 0)

#define GP_WB_WRITE_FLL_FLL_CLK_DELAY_BYPASS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x159), 0, (val)); \
        } while (0)

/* selects the edge of the retimes sampler output (either positive or negative edge of the xo signal) */
#define GP_WB_READ_FLL_FLL_DIVSAMP_EDGE_SEL() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x159), 1)

#define GP_WB_WRITE_FLL_FLL_DIVSAMP_EDGE_SEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x159), 1, (val)); \
        } while (0)

/* fll: enabled dedicated ldo with fine tuning voltage (7 bits) and high psr for dtc */
#define GP_WB_READ_FLL_FLL_DTC_LDO_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x159), 2)

#define GP_WB_WRITE_FLL_FLL_DTC_LDO_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x159), 2, (val)); \
        } while (0)

/* selects dtc clock output to be connected */
#define GP_WB_READ_FLL_FLL_DTC_SEL_CAL_DIV_OUTPUT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x159), 3)

#define GP_WB_WRITE_FLL_FLL_DTC_SEL_CAL_DIV_OUTPUT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x159), 3, (val)); \
        } while (0)

/* fll-ldo: bleed circuit disable */
#define GP_WB_READ_FLL_FLL_LDO_BLEED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x159), 4)

#define GP_WB_WRITE_FLL_FLL_LDO_BLEED(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x159), 4, (val)); \
        } while (0)

/* power up the fll-ldo */
#define GP_WB_READ_FLL_FLL_LDO_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x159), 5)

#define GP_WB_WRITE_FLL_FLL_LDO_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x159), 5, (val)); \
        } while (0)

/* fll-ldo: resistor bypass to speed up settling */
#define GP_WB_READ_FLL_FLL_LDO_RES_BYPASS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x159), 6)

#define GP_WB_WRITE_FLL_FLL_LDO_RES_BYPASS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x159), 6, (val)); \
        } while (0)

/* selects the edge of the retimes sampler output (either positive or negative edge of the xo signal) */
#define GP_WB_READ_FLL_FLL_SAMPLER_EDGE_SEL() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x159), 7)

#define GP_WB_WRITE_FLL_FLL_SAMPLER_EDGE_SEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x159), 7, (val)); \
        } while (0)

/* select which edge of the xo signal to use for retiming */
#define GP_WB_READ_FLL_SX_CLK_EDGE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x15a), 0)

#define GP_WB_WRITE_FLL_SX_CLK_EDGE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x15a), 0, (val)); \
        } while (0)

/* bypass the noise filter of the biasing of the dco. */
#define GP_WB_READ_FLL_SX_DCO_PBIAS_FILTER_BYPASS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x15a), 1)

#define GP_WB_WRITE_FLL_SX_DCO_PBIAS_FILTER_BYPASS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x15a), 1, (val)); \
        } while (0)

/* disable bleed circuit on ldo */
#define GP_WB_READ_FLL_SX_LDO_BLEED_OFF() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x15a), 2)

#define GP_WB_WRITE_FLL_SX_LDO_BLEED_OFF(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x15a), 2, (val)); \
        } while (0)

/* enables the dco-ldo */
#define GP_WB_READ_FLL_SX_LDO_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x15a), 3)

#define GP_WB_WRITE_FLL_SX_LDO_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x15a), 3, (val)); \
        } while (0)

/* bypass the noise filter resistor (of the 0.6v bandgap reference) for speed up settling */
#define GP_WB_READ_FLL_SX_LDO_RES_BYPASS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x15a), 4)

#define GP_WB_WRITE_FLL_SX_LDO_RES_BYPASS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x15a), 4, (val)); \
        } while (0)

/* enable the retimer of the dco capbank bits */
#define GP_WB_READ_FLL_SX_RETIMER_EN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x15a), 5)

#define GP_WB_WRITE_FLL_SX_RETIMER_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x15a), 5, (val)); \
        } while (0)

/***************************
 * layout: radioitf
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_RX_OVERRULE_CONTROL() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x180))

#define GP_WB_WRITE_RADIOITF_RX_OVERRULE_CONTROL(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x180), (val))

/* swaps I and Q of incoming stream */
#define GP_WB_READ_RADIOITF_SWAP_RX_IQ() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x180), 0)

#define GP_WB_GET_RADIOITF_SWAP_RX_IQ_FROM_RX_OVERRULE_CONTROL(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RADIOITF_SWAP_RX_IQ(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x180), 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_SWAP_RX_IQ_TO_RX_OVERRULE_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FFE; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* swaps I and Q of incoming stream */
#define GP_WB_READ_RADIOITF_RX_IQ_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x180), 1)

#define GP_WB_GET_RADIOITF_RX_IQ_OVERRULE_ENA_FROM_RX_OVERRULE_CONTROL(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_IQ_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x180), 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_IQ_OVERRULE_ENA_TO_RX_OVERRULE_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FFD; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

/* use pos edge sampling instead of negedge */
#define GP_WB_READ_RADIOITF_DIVSAMPLER_POS_EDGE_SAMPLING() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x180), 2)

#define GP_WB_GET_RADIOITF_DIVSAMPLER_POS_EDGE_SAMPLING_FROM_RX_OVERRULE_CONTROL(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RADIOITF_DIVSAMPLER_POS_EDGE_SAMPLING(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x180), 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_DIVSAMPLER_POS_EDGE_SAMPLING_TO_RX_OVERRULE_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FFB; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* use pos edge sampling instead of negedge */
#define GP_WB_READ_RADIOITF_RFSAMPLER_POS_EDGE_SAMPLING() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x180), 3)

#define GP_WB_GET_RADIOITF_RFSAMPLER_POS_EDGE_SAMPLING_FROM_RX_OVERRULE_CONTROL(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RADIOITF_RFSAMPLER_POS_EDGE_SAMPLING(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x180), 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RFSAMPLER_POS_EDGE_SAMPLING_TO_RX_OVERRULE_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FF7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

/* use pos edge sampling instead of negedge */
#define GP_WB_READ_RADIOITF_CALSAMPLER_POS_EDGE_SAMPLING() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x180), 4)

#define GP_WB_GET_RADIOITF_CALSAMPLER_POS_EDGE_SAMPLING_FROM_RX_OVERRULE_CONTROL(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RADIOITF_CALSAMPLER_POS_EDGE_SAMPLING(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x180), 4, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_CALSAMPLER_POS_EDGE_SAMPLING_TO_RX_OVERRULE_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FEF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* overrule 32 MHz output stream from sampler */
#define GP_WB_READ_RADIOITF_DIVSAMPLER_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x180), 5)

#define GP_WB_GET_RADIOITF_DIVSAMPLER_OVERRULE_ENA_FROM_RX_OVERRULE_CONTROL(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RADIOITF_DIVSAMPLER_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x180), 5, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_DIVSAMPLER_OVERRULE_ENA_TO_RX_OVERRULE_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FDF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

/* overrule 32 MHz output stream from sampler */
#define GP_WB_READ_RADIOITF_RFSAMPLER_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x180), 6)

#define GP_WB_GET_RADIOITF_RFSAMPLER_OVERRULE_ENA_FROM_RX_OVERRULE_CONTROL(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RADIOITF_RFSAMPLER_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x180), 6, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RFSAMPLER_OVERRULE_ENA_TO_RX_OVERRULE_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FBF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

/* overrule 32 MHz output stream from sampler */
#define GP_WB_READ_RADIOITF_CALSAMPLER_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x180), 7)

#define GP_WB_GET_RADIOITF_CALSAMPLER_OVERRULE_ENA_FROM_RX_OVERRULE_CONTROL(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_RADIOITF_CALSAMPLER_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x180), 7, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_CALSAMPLER_OVERRULE_ENA_TO_RX_OVERRULE_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* overrule in phase rx output */
#define GP_WB_READ_RADIOITF_RXI_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x181), 0)

#define GP_WB_GET_RADIOITF_RXI_OVERRULE_FROM_RX_OVERRULE_CONTROL(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_RADIOITF_RXI_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x181), 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RXI_OVERRULE_TO_RX_OVERRULE_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1EFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* overrule quadrature rx output */
#define GP_WB_READ_RADIOITF_RXQ_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x181), 1)

#define GP_WB_GET_RADIOITF_RXQ_OVERRULE_FROM_RX_OVERRULE_CONTROL(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_RADIOITF_RXQ_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x181), 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RXQ_OVERRULE_TO_RX_OVERRULE_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1DFF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)

/* overrule 32 MHz output stream from sampler */
#define GP_WB_READ_RADIOITF_DIVSAMPLER_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x181), 2)

#define GP_WB_GET_RADIOITF_DIVSAMPLER_OVERRULE_FROM_RX_OVERRULE_CONTROL(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_RADIOITF_DIVSAMPLER_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x181), 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_DIVSAMPLER_OVERRULE_TO_RX_OVERRULE_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1BFF; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)

/* overrule 32 MHz output stream from sampler */
#define GP_WB_READ_RADIOITF_RFSAMPLER_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x181), 3)

#define GP_WB_GET_RADIOITF_RFSAMPLER_OVERRULE_FROM_RX_OVERRULE_CONTROL(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_RADIOITF_RFSAMPLER_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x181), 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RFSAMPLER_OVERRULE_TO_RX_OVERRULE_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x17FF; \
          (tmp) |= (((UInt16)(val)) << 11); \
        } while (0)

/* overrule 32 MHz output stream from sampler */
#define GP_WB_READ_RADIOITF_CALSAMPLER_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x181), 4)

#define GP_WB_GET_RADIOITF_CALSAMPLER_OVERRULE_FROM_RX_OVERRULE_CONTROL(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_RADIOITF_CALSAMPLER_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x181), 4, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_CALSAMPLER_OVERRULE_TO_RX_OVERRULE_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFF; \
          (tmp) |= (((UInt16)(val)) << 12); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_TX_OVERRULE_ENA() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x182))

#define GP_WB_WRITE_RADIOITF_TX_OVERRULE_ENA(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x182), (val))

/* disable esd protection, only in tx-mode */
#define GP_WB_READ_RADIOITF_MATCH_ANT_ESD_DISABLE_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x182), 0)

#define GP_WB_GET_RADIOITF_MATCH_ANT_ESD_DISABLE_OVERRULE_ENA_FROM_TX_OVERRULE_ENA(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RADIOITF_MATCH_ANT_ESD_DISABLE_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x182), 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_MATCH_ANT_ESD_DISABLE_OVERRULE_ENA_TO_TX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FFE; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* enables the 1,8v biasing for external pa */
#define GP_WB_READ_RADIOITF_SW_EXT_PA_EN_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x182), 1)

#define GP_WB_GET_RADIOITF_SW_EXT_PA_EN_OVERRULE_ENA_FROM_TX_OVERRULE_ENA(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RADIOITF_SW_EXT_PA_EN_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x182), 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_SW_EXT_PA_EN_OVERRULE_ENA_TO_TX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FFD; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

/* power up the transmitter biasing */
#define GP_WB_READ_RADIOITF_TX_BIAS_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x182), 2)

#define GP_WB_GET_RADIOITF_TX_BIAS_PUP_OVERRULE_ENA_FROM_TX_OVERRULE_ENA(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RADIOITF_TX_BIAS_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x182), 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_TX_BIAS_PUP_OVERRULE_ENA_TO_TX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FFB; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* power up the transmitter driver */
#define GP_WB_READ_RADIOITF_TX_DRIVER_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x182), 3)

#define GP_WB_GET_RADIOITF_TX_DRIVER_PUP_OVERRULE_ENA_FROM_TX_OVERRULE_ENA(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RADIOITF_TX_DRIVER_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x182), 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_TX_DRIVER_PUP_OVERRULE_ENA_TO_TX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FF7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

/* power up the transmitter 4.8ghz input buffer */
#define GP_WB_READ_RADIOITF_TX_LO_BUF_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x182), 4)

#define GP_WB_GET_RADIOITF_TX_LO_BUF_PUP_OVERRULE_ENA_FROM_TX_OVERRULE_ENA(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RADIOITF_TX_LO_BUF_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x182), 4, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_TX_LO_BUF_PUP_OVERRULE_ENA_TO_TX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FEF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* power up the transmitter power amplifier biasing */
#define GP_WB_READ_RADIOITF_TX_PA_BIAS_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x182), 5)

#define GP_WB_GET_RADIOITF_TX_PA_BIAS_PUP_OVERRULE_ENA_FROM_TX_OVERRULE_ENA(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RADIOITF_TX_PA_BIAS_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x182), 5, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_TX_PA_BIAS_PUP_OVERRULE_ENA_TO_TX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FDF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

/* tx: adjust the pa-reference bias multiplier */
#define GP_WB_READ_RADIOITF_TX_PA_BIASTRIM_MULT_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x182), 6)

#define GP_WB_GET_RADIOITF_TX_PA_BIASTRIM_MULT_OVERRULE_ENA_FROM_TX_OVERRULE_ENA(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RADIOITF_TX_PA_BIASTRIM_MULT_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x182), 6, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_TX_PA_BIASTRIM_MULT_OVERRULE_ENA_TO_TX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FBF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

/* power up the transmitter rf-reference mirror, must be on when bias goes on */
#define GP_WB_READ_RADIOITF_TX_PA_REFMIR_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x182), 7)

#define GP_WB_GET_RADIOITF_TX_PA_REFMIR_PUP_OVERRULE_ENA_FROM_TX_OVERRULE_ENA(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_RADIOITF_TX_PA_REFMIR_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x182), 7, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_TX_PA_REFMIR_PUP_OVERRULE_ENA_TO_TX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* power up the transmitter the peak detector comparator (not used) */
#define GP_WB_READ_RADIOITF_TX_PEAK_DETECT_COMP_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x183), 0)

#define GP_WB_GET_RADIOITF_TX_PEAK_DETECT_COMP_PUP_OVERRULE_ENA_FROM_TX_OVERRULE_ENA(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_RADIOITF_TX_PEAK_DETECT_COMP_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x183), 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_TX_PEAK_DETECT_COMP_PUP_OVERRULE_ENA_TO_TX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1EFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* power up the transmitter the peak detector (not used) */
#define GP_WB_READ_RADIOITF_TX_PEAK_DETECT_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x183), 1)

#define GP_WB_GET_RADIOITF_TX_PEAK_DETECT_PUP_OVERRULE_ENA_FROM_TX_OVERRULE_ENA(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_RADIOITF_TX_PEAK_DETECT_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x183), 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_TX_PEAK_DETECT_PUP_OVERRULE_ENA_TO_TX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1DFF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)

/* tx: set the output power level: this is a linear scale (output current proportional to code) */
#define GP_WB_READ_RADIOITF_TX_POWER_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x183), 2)

#define GP_WB_GET_RADIOITF_TX_POWER_OVERRULE_ENA_FROM_TX_OVERRULE_ENA(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_RADIOITF_TX_POWER_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x183), 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_TX_POWER_OVERRULE_ENA_TO_TX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1BFF; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)

/* tx: disable 1 of the 2 balanced input signals, for test only */
#define GP_WB_READ_RADIOITF_TX_RF_N_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x183), 3)

#define GP_WB_GET_RADIOITF_TX_RF_N_PUP_OVERRULE_ENA_FROM_TX_OVERRULE_ENA(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_RADIOITF_TX_RF_N_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x183), 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_TX_RF_N_PUP_OVERRULE_ENA_TO_TX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x17FF; \
          (tmp) |= (((UInt16)(val)) << 11); \
        } while (0)

/* tx: disable 1 of the 2 balanced input signals, for test only */
#define GP_WB_READ_RADIOITF_TX_RF_P_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x183), 4)

#define GP_WB_GET_RADIOITF_TX_RF_P_PUP_OVERRULE_ENA_FROM_TX_OVERRULE_ENA(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_RADIOITF_TX_RF_P_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x183), 4, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_TX_RF_P_PUP_OVERRULE_ENA_TO_TX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFF; \
          (tmp) |= (((UInt16)(val)) << 12); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_RX_OVERRULE_ENA() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x184))

#define GP_WB_WRITE_RADIOITF_RX_OVERRULE_ENA(val) \
      GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x184), (val))

/* pup signal for the adc comparator biasing */
#define GP_WB_READ_RADIOITF_RSSI_COMP_BIAS_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x184), 0)

#define GP_WB_GET_RADIOITF_RSSI_COMP_BIAS_PUP_OVERRULE_ENA_FROM_RX_OVERRULE_ENA(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RADIOITF_RSSI_COMP_BIAS_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x184), 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RSSI_COMP_BIAS_PUP_OVERRULE_ENA_TO_RX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFFFFE; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* request for the adc to do conversions */
#define GP_WB_READ_RADIOITF_RSSI_CONV_REQUEST_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x184), 1)

#define GP_WB_GET_RADIOITF_RSSI_CONV_REQUEST_OVERRULE_ENA_FROM_RX_OVERRULE_ENA(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RADIOITF_RSSI_CONV_REQUEST_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x184), 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RSSI_CONV_REQUEST_OVERRULE_ENA_TO_RX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFFFFD; \
          (tmp) |= (((UInt32)(val)) << 1); \
        } while (0)

/* pup signal for the adc input buffer */
#define GP_WB_READ_RADIOITF_RSSI_INPUT_BUFFER_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x184), 2)

#define GP_WB_GET_RADIOITF_RSSI_INPUT_BUFFER_PUP_OVERRULE_ENA_FROM_RX_OVERRULE_ENA(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RADIOITF_RSSI_INPUT_BUFFER_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x184), 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RSSI_INPUT_BUFFER_PUP_OVERRULE_ENA_TO_RX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFFFFB; \
          (tmp) |= (((UInt32)(val)) << 2); \
        } while (0)

/* pulse to integrate on the integrator 1 */
#define GP_WB_READ_RADIOITF_RSSI_INTG1_ACTIVE_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x184), 3)

#define GP_WB_GET_RADIOITF_RSSI_INTG1_ACTIVE_OVERRULE_ENA_FROM_RX_OVERRULE_ENA(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RADIOITF_RSSI_INTG1_ACTIVE_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x184), 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RSSI_INTG1_ACTIVE_OVERRULE_ENA_TO_RX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFFFF7; \
          (tmp) |= (((UInt32)(val)) << 3); \
        } while (0)

/* pulse to discharge the integrator 1 */
#define GP_WB_READ_RADIOITF_RSSI_INTG1_DISCHARGE_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x184), 4)

#define GP_WB_GET_RADIOITF_RSSI_INTG1_DISCHARGE_OVERRULE_ENA_FROM_RX_OVERRULE_ENA(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RADIOITF_RSSI_INTG1_DISCHARGE_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x184), 4, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RSSI_INTG1_DISCHARGE_OVERRULE_ENA_TO_RX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFFFEF; \
          (tmp) |= (((UInt32)(val)) << 4); \
        } while (0)

/* pulse to connect the integrator 1 to the rssi output node and the adc buffer */
#define GP_WB_READ_RADIOITF_RSSI_INTG1_SAMPLE_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x184), 5)

#define GP_WB_GET_RADIOITF_RSSI_INTG1_SAMPLE_OVERRULE_ENA_FROM_RX_OVERRULE_ENA(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RADIOITF_RSSI_INTG1_SAMPLE_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x184), 5, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RSSI_INTG1_SAMPLE_OVERRULE_ENA_TO_RX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFFFDF; \
          (tmp) |= (((UInt32)(val)) << 5); \
        } while (0)

/* pulse to integrate on the integrator 2 */
#define GP_WB_READ_RADIOITF_RSSI_INTG2_ACTIVE_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x184), 6)

#define GP_WB_GET_RADIOITF_RSSI_INTG2_ACTIVE_OVERRULE_ENA_FROM_RX_OVERRULE_ENA(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RADIOITF_RSSI_INTG2_ACTIVE_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x184), 6, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RSSI_INTG2_ACTIVE_OVERRULE_ENA_TO_RX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFFFBF; \
          (tmp) |= (((UInt32)(val)) << 6); \
        } while (0)

/* pulse to discharge the integrator 2 */
#define GP_WB_READ_RADIOITF_RSSI_INTG2_DISCHARGE_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x184), 7)

#define GP_WB_GET_RADIOITF_RSSI_INTG2_DISCHARGE_OVERRULE_ENA_FROM_RX_OVERRULE_ENA(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_RADIOITF_RSSI_INTG2_DISCHARGE_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x184), 7, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RSSI_INTG2_DISCHARGE_OVERRULE_ENA_TO_RX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFFF7F; \
          (tmp) |= (((UInt32)(val)) << 7); \
        } while (0)

/* pulse to connect the integrator 2 to the rssi output node and the adc buffer */
#define GP_WB_READ_RADIOITF_RSSI_INTG2_SAMPLE_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x185), 0)

#define GP_WB_GET_RADIOITF_RSSI_INTG2_SAMPLE_OVERRULE_ENA_FROM_RX_OVERRULE_ENA(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_RADIOITF_RSSI_INTG2_SAMPLE_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x185), 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RSSI_INTG2_SAMPLE_OVERRULE_ENA_TO_RX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFFEFF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* pulse to connect the reference voltage to an integrator */
#define GP_WB_READ_RADIOITF_RSSI_INTG_CALIBRATION_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x185), 1)

#define GP_WB_GET_RADIOITF_RSSI_INTG_CALIBRATION_OVERRULE_ENA_FROM_RX_OVERRULE_ENA(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_RADIOITF_RSSI_INTG_CALIBRATION_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x185), 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RSSI_INTG_CALIBRATION_OVERRULE_ENA_TO_RX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFFDFF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* enables the integrating mode of the rssi, to be used in the ble slots of the concurrent mode. when set_rssi_integrating_mode is '0', the rssi works in continuous mode. */
#define GP_WB_READ_RADIOITF_RSSI_INTG_MODE_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x185), 2)

#define GP_WB_GET_RADIOITF_RSSI_INTG_MODE_OVERRULE_ENA_FROM_RX_OVERRULE_ENA(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_RADIOITF_RSSI_INTG_MODE_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x185), 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RSSI_INTG_MODE_OVERRULE_ENA_TO_RX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFFBFF; \
          (tmp) |= (((UInt32)(val)) << 10); \
        } while (0)

/* pulse to discharge the rssi output node */
#define GP_WB_READ_RADIOITF_RSSI_OUT_DISCHARGE_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x185), 3)

#define GP_WB_GET_RADIOITF_RSSI_OUT_DISCHARGE_OVERRULE_ENA_FROM_RX_OVERRULE_ENA(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_RADIOITF_RSSI_OUT_DISCHARGE_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x185), 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RSSI_OUT_DISCHARGE_OVERRULE_ENA_TO_RX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFF7FF; \
          (tmp) |= (((UInt32)(val)) << 11); \
        } while (0)

/* pup signal for the adc vcm buffer (vcm: common-mode voltage) */
#define GP_WB_READ_RADIOITF_RSSI_VCM_BUFFER_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x185), 4)

#define GP_WB_GET_RADIOITF_RSSI_VCM_BUFFER_PUP_OVERRULE_ENA_FROM_RX_OVERRULE_ENA(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_RADIOITF_RSSI_VCM_BUFFER_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x185), 4, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RSSI_VCM_BUFFER_PUP_OVERRULE_ENA_TO_RX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFEFFF; \
          (tmp) |= (((UInt32)(val)) << 12); \
        } while (0)

/* enable 5ua current mirrors to feed ldo, lna, bpf and lim */
#define GP_WB_READ_RADIOITF_RX_BIAS_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x185), 5)

#define GP_WB_GET_RADIOITF_RX_BIAS_PUP_OVERRULE_ENA_FROM_RX_OVERRULE_ENA(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_BIAS_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x185), 5, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_BIAS_PUP_OVERRULE_ENA_TO_RX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFDFFF; \
          (tmp) |= (((UInt32)(val)) << 13); \
        } while (0)

/* power up the whole bpf without affecting biasing, this is intended for lpl mode */
#define GP_WB_READ_RADIOITF_RX_BPF_BIAS_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x185), 6)

#define GP_WB_GET_RADIOITF_RX_BPF_BIAS_PUP_OVERRULE_ENA_FROM_RX_OVERRULE_ENA(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_BPF_BIAS_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x185), 6, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_BPF_BIAS_PUP_OVERRULE_ENA_TO_RX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFBFFF; \
          (tmp) |= (((UInt32)(val)) << 14); \
        } while (0)

/* 0=zigbee, 1=ble */
#define GP_WB_READ_RADIOITF_RX_BPF_BLE_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x185), 7)

#define GP_WB_GET_RADIOITF_RX_BPF_BLE_OVERRULE_ENA_FROM_RX_OVERRULE_ENA(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_BPF_BLE_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x185), 7, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_BPF_BLE_OVERRULE_ENA_TO_RX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFF7FFF; \
          (tmp) |= (((UInt32)(val)) << 15); \
        } while (0)

/* powers up the digital part of the bpf, like levelshifts, non-overlapping-clock generator, etc */
#define GP_WB_READ_RADIOITF_RX_BPF_DIG_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x186), 0)

#define GP_WB_GET_RADIOITF_RX_BPF_DIG_PUP_OVERRULE_ENA_FROM_RX_OVERRULE_ENA(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_BPF_DIG_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x186), 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_BPF_DIG_PUP_OVERRULE_ENA_TO_RX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFEFFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* powers up the constant-gm ldo for the bpf core */
#define GP_WB_READ_RADIOITF_RX_BPF_LDO_CGM_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x186), 1)

#define GP_WB_GET_RADIOITF_RX_BPF_LDO_CGM_PUP_OVERRULE_ENA_FROM_RX_OVERRULE_ENA(tmp) \
        (((tmp) >> 17) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_BPF_LDO_CGM_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x186), 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_BPF_LDO_CGM_PUP_OVERRULE_ENA_TO_RX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFDFFFF; \
          (tmp) |= (((UInt32)(val)) << 17); \
        } while (0)

/* powers up the switched cap biasing n-side */
#define GP_WB_READ_RADIOITF_RX_BPF_SC_BIAS_N_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x186), 2)

#define GP_WB_GET_RADIOITF_RX_BPF_SC_BIAS_N_PUP_OVERRULE_ENA_FROM_RX_OVERRULE_ENA(tmp) \
        (((tmp) >> 18) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_BPF_SC_BIAS_N_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x186), 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_BPF_SC_BIAS_N_PUP_OVERRULE_ENA_TO_RX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFBFFFF; \
          (tmp) |= (((UInt32)(val)) << 18); \
        } while (0)

/* powers up the switched cap biasing p-side */
#define GP_WB_READ_RADIOITF_RX_BPF_SC_BIAS_P_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x186), 3)

#define GP_WB_GET_RADIOITF_RX_BPF_SC_BIAS_P_PUP_OVERRULE_ENA_FROM_RX_OVERRULE_ENA(tmp) \
        (((tmp) >> 19) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_BPF_SC_BIAS_P_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x186), 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_BPF_SC_BIAS_P_PUP_OVERRULE_ENA_TO_RX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FF7FFFF; \
          (tmp) |= (((UInt32)(val)) << 19); \
        } while (0)

/* power up of limiter bias currents */
#define GP_WB_READ_RADIOITF_RX_LIM_BIAS_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x186), 4)

#define GP_WB_GET_RADIOITF_RX_LIM_BIAS_PUP_OVERRULE_ENA_FROM_RX_OVERRULE_ENA(tmp) \
        (((tmp) >> 20) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_LIM_BIAS_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x186), 4, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_LIM_BIAS_PUP_OVERRULE_ENA_TO_RX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FEFFFFF; \
          (tmp) |= (((UInt32)(val)) << 20); \
        } while (0)

/* powers up the limiter chain. this is independent of biasing. this is for lpl mode */
#define GP_WB_READ_RADIOITF_RX_LIM_CHAIN_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x186), 5)

#define GP_WB_GET_RADIOITF_RX_LIM_CHAIN_PUP_OVERRULE_ENA_FROM_RX_OVERRULE_ENA(tmp) \
        (((tmp) >> 21) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_LIM_CHAIN_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x186), 5, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_LIM_CHAIN_PUP_OVERRULE_ENA_TO_RX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FDFFFFF; \
          (tmp) |= (((UInt32)(val)) << 21); \
        } while (0)

/* powers up the diff2se. intended for debugging. if lot's of pollution thanks to this block, we can disable it. can also use it to measure current of diff2se */
#define GP_WB_READ_RADIOITF_RX_LIM_DIFF2SE_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x186), 6)

#define GP_WB_GET_RADIOITF_RX_LIM_DIFF2SE_PUP_OVERRULE_ENA_FROM_RX_OVERRULE_ENA(tmp) \
        (((tmp) >> 22) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_LIM_DIFF2SE_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x186), 6, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_LIM_DIFF2SE_PUP_OVERRULE_ENA_TO_RX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FBFFFFF; \
          (tmp) |= (((UInt32)(val)) << 22); \
        } while (0)

/* enable lna and its constant-gm biasing */
#define GP_WB_READ_RADIOITF_RX_LNA_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x186), 7)

#define GP_WB_GET_RADIOITF_RX_LNA_PUP_OVERRULE_ENA_FROM_RX_OVERRULE_ENA(tmp) \
        (((tmp) >> 23) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_LNA_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x186), 7, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_LNA_PUP_OVERRULE_ENA_TO_RX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F7FFFFF; \
          (tmp) |= (((UInt32)(val)) << 23); \
        } while (0)

/* enables receiver to be connected to one or both antenna's. this is a half-t-switch */
#define GP_WB_READ_RADIOITF_RX_LNA_SWITCH_EN_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x187), 0)

#define GP_WB_GET_RADIOITF_RX_LNA_SWITCH_EN_OVERRULE_ENA_FROM_RX_OVERRULE_ENA(tmp) \
        (((tmp) >> 24) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_LNA_SWITCH_EN_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x187), 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_LNA_SWITCH_EN_OVERRULE_ENA_TO_RX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0EFFFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)

/* rx-lo-signal buffer enable, this is after shared divide/2 */
#define GP_WB_READ_RADIOITF_RX_LOBUF_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x187), 1)

#define GP_WB_GET_RADIOITF_RX_LOBUF_PUP_OVERRULE_ENA_FROM_RX_OVERRULE_ENA(tmp) \
        (((tmp) >> 25) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_LOBUF_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x187), 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_LOBUF_PUP_OVERRULE_ENA_TO_RX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0DFFFFFF; \
          (tmp) |= (((UInt32)(val)) << 25); \
        } while (0)

/* enables the 16mhz clock output to rx-bpf */
#define GP_WB_READ_RADIOITF_XO_CLK_16M_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x187), 2)

#define GP_WB_GET_RADIOITF_XO_CLK_16M_PUP_OVERRULE_ENA_FROM_RX_OVERRULE_ENA(tmp) \
        (((tmp) >> 26) & 0x01)

#define GP_WB_WRITE_RADIOITF_XO_CLK_16M_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x187), 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_XO_CLK_16M_PUP_OVERRULE_ENA_TO_RX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0BFFFFFF; \
          (tmp) |= (((UInt32)(val)) << 26); \
        } while (0)

/* enables the 8 mhz clock towards the rssi block */
#define GP_WB_READ_RADIOITF_XO_CLK_8M_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x187), 3)

#define GP_WB_GET_RADIOITF_XO_CLK_8M_PUP_OVERRULE_ENA_FROM_RX_OVERRULE_ENA(tmp) \
        (((tmp) >> 27) & 0x01)

#define GP_WB_WRITE_RADIOITF_XO_CLK_8M_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x187), 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_XO_CLK_8M_PUP_OVERRULE_ENA_TO_RX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 27); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_TRX_OVERRULE_ENA() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x188))

#define GP_WB_WRITE_RADIOITF_TRX_OVERRULE_ENA(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x188), (val))

/* resistive termination of unused antenna 1 when receiving at antenna 2, lsb=antenna size, msb+msb-1=parallel to antenna switch */
#define GP_WB_READ_RADIOITF_MATCH_ANT1_RLOAD_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x188), 0)

#define GP_WB_GET_RADIOITF_MATCH_ANT1_RLOAD_OVERRULE_ENA_FROM_TRX_OVERRULE_ENA(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RADIOITF_MATCH_ANT1_RLOAD_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x188), 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_MATCH_ANT1_RLOAD_OVERRULE_ENA_TO_TRX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FE; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* select antenna 1 to connect to tx or rx */
#define GP_WB_READ_RADIOITF_MATCH_ANT1_SELECT_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x188), 1)

#define GP_WB_GET_RADIOITF_MATCH_ANT1_SELECT_OVERRULE_ENA_FROM_TRX_OVERRULE_ENA(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RADIOITF_MATCH_ANT1_SELECT_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x188), 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_MATCH_ANT1_SELECT_OVERRULE_ENA_TO_TRX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FD; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

/* tune capacitance at ant1-side */
#define GP_WB_READ_RADIOITF_MATCH_ANT1_TUNE_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x188), 2)

#define GP_WB_GET_RADIOITF_MATCH_ANT1_TUNE_OVERRULE_ENA_FROM_TRX_OVERRULE_ENA(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RADIOITF_MATCH_ANT1_TUNE_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x188), 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_MATCH_ANT1_TUNE_OVERRULE_ENA_TO_TRX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FB; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* resistive termination of unused antenna 2 when receiving at antenna 2, lsb=antenna size, msb+msb-1=parallel to antenna switch */
#define GP_WB_READ_RADIOITF_MATCH_ANT2_RLOAD_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x188), 3)

#define GP_WB_GET_RADIOITF_MATCH_ANT2_RLOAD_OVERRULE_ENA_FROM_TRX_OVERRULE_ENA(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RADIOITF_MATCH_ANT2_RLOAD_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x188), 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_MATCH_ANT2_RLOAD_OVERRULE_ENA_TO_TRX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07F7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

/* select antenna 2 to connect to tx or rx */
#define GP_WB_READ_RADIOITF_MATCH_ANT2_SELECT_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x188), 4)

#define GP_WB_GET_RADIOITF_MATCH_ANT2_SELECT_OVERRULE_ENA_FROM_TRX_OVERRULE_ENA(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RADIOITF_MATCH_ANT2_SELECT_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x188), 4, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_MATCH_ANT2_SELECT_OVERRULE_ENA_TO_TRX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07EF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* tune capacitance at ant2-side */
#define GP_WB_READ_RADIOITF_MATCH_ANT2_TUNE_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x188), 5)

#define GP_WB_GET_RADIOITF_MATCH_ANT2_TUNE_OVERRULE_ENA_FROM_TRX_OVERRULE_ENA(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RADIOITF_MATCH_ANT2_TUNE_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x188), 5, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_MATCH_ANT2_TUNE_OVERRULE_ENA_TO_TRX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07DF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

/* tune capacitance at tx-side */
#define GP_WB_READ_RADIOITF_MATCH_TX_TUNE_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x188), 6)

#define GP_WB_GET_RADIOITF_MATCH_TX_TUNE_OVERRULE_ENA_FROM_TRX_OVERRULE_ENA(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RADIOITF_MATCH_TX_TUNE_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x188), 6, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_MATCH_TX_TUNE_OVERRULE_ENA_TO_TRX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07BF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

/* sets gain of filter, 000=8db gain, 111=19db gain, etc. default tbd */
#define GP_WB_READ_RADIOITF_RX_BPF_GAIN_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x188), 7)

#define GP_WB_GET_RADIOITF_RX_BPF_GAIN_OVERRULE_ENA_FROM_TRX_OVERRULE_ENA(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_BPF_GAIN_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x188), 7, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_BPF_GAIN_OVERRULE_ENA_TO_TRX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x077F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* low bias option for lna to reduce the current by factor 2 when enabled */
#define GP_WB_READ_RADIOITF_RX_LNA_LOWBIAS_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x189), 0)

#define GP_WB_GET_RADIOITF_RX_LNA_LOWBIAS_OVERRULE_ENA_FROM_TRX_OVERRULE_ENA(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_LNA_LOWBIAS_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x189), 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_LNA_LOWBIAS_OVERRULE_ENA_TO_TRX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* set lna in low-gain mode. this improves overall linearity without sacrificing much sensitivity */
#define GP_WB_READ_RADIOITF_RX_LNA_LOWGAIN_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x189), 1)

#define GP_WB_GET_RADIOITF_RX_LNA_LOWGAIN_OVERRULE_ENA_FROM_TRX_OVERRULE_ENA(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_LNA_LOWGAIN_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x189), 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_LNA_LOWGAIN_OVERRULE_ENA_TO_TRX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05FF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)

/* pup of the voltage doubler */
#define GP_WB_READ_RADIOITF_VDOUBLER_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x189), 2)

#define GP_WB_GET_RADIOITF_VDOUBLER_PUP_OVERRULE_ENA_FROM_TRX_OVERRULE_ENA(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_RADIOITF_VDOUBLER_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x189), 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_VDOUBLER_PUP_OVERRULE_ENA_TO_TRX_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FF; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_FLL_OVERRULE_ENA() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18c))

#define GP_WB_WRITE_RADIOITF_FLL_OVERRULE_ENA(val) \
      GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18c), (val))

/* power up of fll bias mirrors */
#define GP_WB_READ_RADIOITF_FLL_BIAS_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18c), 0)

#define GP_WB_GET_RADIOITF_FLL_BIAS_PUP_OVERRULE_ENA_FROM_FLL_OVERRULE_ENA(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_BIAS_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18c), 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_BIAS_PUP_OVERRULE_ENA_TO_FLL_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFE; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* xo delay setting */
#define GP_WB_READ_RADIOITF_FLL_CLK_DELAY_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18c), 1)

#define GP_WB_GET_RADIOITF_FLL_CLK_DELAY_OVERRULE_ENA_FROM_FLL_OVERRULE_ENA(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_CLK_DELAY_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18c), 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_CLK_DELAY_OVERRULE_ENA_TO_FLL_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFD; \
          (tmp) |= (((UInt32)(val)) << 1); \
        } while (0)

/* xo delay calibration */
#define GP_WB_READ_RADIOITF_FLL_CLK_DELAY_CAL_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18c), 2)

#define GP_WB_GET_RADIOITF_FLL_CLK_DELAY_CAL_OVERRULE_ENA_FROM_FLL_OVERRULE_ENA(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_CLK_DELAY_CAL_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18c), 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_CLK_DELAY_CAL_OVERRULE_ENA_TO_FLL_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFB; \
          (tmp) |= (((UInt32)(val)) << 2); \
        } while (0)

/* fll divider selection of divider ratio: divide by 64(=1) or 16(=0) */
#define GP_WB_READ_RADIOITF_FLL_DIV16_64_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18c), 3)

#define GP_WB_GET_RADIOITF_FLL_DIV16_64_OVERRULE_ENA_FROM_FLL_OVERRULE_ENA(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_DIV16_64_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18c), 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_DIV16_64_OVERRULE_ENA_TO_FLL_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFF7; \
          (tmp) |= (((UInt32)(val)) << 3); \
        } while (0)

/* pup of divider sampler */
#define GP_WB_READ_RADIOITF_FLL_DIVSAMP_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18c), 4)

#define GP_WB_GET_RADIOITF_FLL_DIVSAMP_PUP_OVERRULE_ENA_FROM_FLL_OVERRULE_ENA(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_DIVSAMP_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18c), 4, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_DIVSAMP_PUP_OVERRULE_ENA_TO_FLL_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFEF; \
          (tmp) |= (((UInt32)(val)) << 4); \
        } while (0)

/* sets the frequency for calibration of dtc. */
#define GP_WB_READ_RADIOITF_FLL_DTC_CAL_DIV_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18c), 5)

#define GP_WB_GET_RADIOITF_FLL_DTC_CAL_DIV_OVERRULE_ENA_FROM_FLL_OVERRULE_ENA(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_DTC_CAL_DIV_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18c), 5, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_DTC_CAL_DIV_OVERRULE_ENA_TO_FLL_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFDF; \
          (tmp) |= (((UInt32)(val)) << 5); \
        } while (0)

/* msb bits are put to slow mode,to enable succesfull calibration */
#define GP_WB_READ_RADIOITF_FLL_DTC_CAL_SLOW_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18c), 6)

#define GP_WB_GET_RADIOITF_FLL_DTC_CAL_SLOW_OVERRULE_ENA_FROM_FLL_OVERRULE_ENA(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_DTC_CAL_SLOW_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18c), 6, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_DTC_CAL_SLOW_OVERRULE_ENA_TO_FLL_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFBF; \
          (tmp) |= (((UInt32)(val)) << 6); \
        } while (0)

/* fll: high current capability of dedicated ldo, only for dtc calibration mode */
#define GP_WB_READ_RADIOITF_FLL_DTC_LDO_HP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18c), 7)

#define GP_WB_GET_RADIOITF_FLL_DTC_LDO_HP_OVERRULE_ENA_FROM_FLL_OVERRULE_ENA(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_DTC_LDO_HP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18c), 7, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_DTC_LDO_HP_OVERRULE_ENA_TO_FLL_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FF7F; \
          (tmp) |= (((UInt32)(val)) << 7); \
        } while (0)

/* dtc lsb bits (digital to time convervter) */
#define GP_WB_READ_RADIOITF_FLL_DTC_LSB_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18d), 0)

#define GP_WB_GET_RADIOITF_FLL_DTC_LSB_OVERRULE_ENA_FROM_FLL_OVERRULE_ENA(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_DTC_LSB_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18d), 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_DTC_LSB_OVERRULE_ENA_TO_FLL_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FEFF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* dtc msb bits (digital to time convervter) */
#define GP_WB_READ_RADIOITF_FLL_DTC_MSB_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18d), 1)

#define GP_WB_GET_RADIOITF_FLL_DTC_MSB_OVERRULE_ENA_FROM_FLL_OVERRULE_ENA(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_DTC_MSB_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18d), 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_DTC_MSB_OVERRULE_ENA_TO_FLL_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FDFF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* pup of main fll lobuf */
#define GP_WB_READ_RADIOITF_FLL_LOBUF_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18d), 2)

#define GP_WB_GET_RADIOITF_FLL_LOBUF_PUP_OVERRULE_ENA_FROM_FLL_OVERRULE_ENA(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_LOBUF_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18d), 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_LOBUF_PUP_OVERRULE_ENA_TO_FLL_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FBFF; \
          (tmp) |= (((UInt32)(val)) << 10); \
        } while (0)

/* pup of main fll sampler( only needed during cap bank cal) */
#define GP_WB_READ_RADIOITF_FLL_SAMPLER_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18d), 3)

#define GP_WB_GET_RADIOITF_FLL_SAMPLER_PUP_OVERRULE_ENA_FROM_FLL_OVERRULE_ENA(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_SAMPLER_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18d), 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_SAMPLER_PUP_OVERRULE_ENA_TO_FLL_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01F7FF; \
          (tmp) |= (((UInt32)(val)) << 11); \
        } while (0)

/* enables bias currents feeding dco ldo */
#define GP_WB_READ_RADIOITF_SX_BIAS_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18d), 4)

#define GP_WB_GET_RADIOITF_SX_BIAS_PUP_OVERRULE_ENA_FROM_FLL_OVERRULE_ENA(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_RADIOITF_SX_BIAS_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18d), 4, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_SX_BIAS_PUP_OVERRULE_ENA_TO_FLL_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01EFFF; \
          (tmp) |= (((UInt32)(val)) << 12); \
        } while (0)

/* coarse cap bank for pvt and channel select */
#define GP_WB_READ_RADIOITF_SX_DCO_CAPBANK_CRS_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18d), 5)

#define GP_WB_GET_RADIOITF_SX_DCO_CAPBANK_CRS_OVERRULE_ENA_FROM_FLL_OVERRULE_ENA(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_RADIOITF_SX_DCO_CAPBANK_CRS_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18d), 5, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_SX_DCO_CAPBANK_CRS_OVERRULE_ENA_TO_FLL_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01DFFF; \
          (tmp) |= (((UInt32)(val)) << 13); \
        } while (0)

/* fine cap bank for channel select */
#define GP_WB_READ_RADIOITF_SX_DCO_CAPBANK_FINE_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18d), 6)

#define GP_WB_GET_RADIOITF_SX_DCO_CAPBANK_FINE_OVERRULE_ENA_FROM_FLL_OVERRULE_ENA(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_RADIOITF_SX_DCO_CAPBANK_FINE_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18d), 6, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_SX_DCO_CAPBANK_FINE_OVERRULE_ENA_TO_FLL_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01BFFF; \
          (tmp) |= (((UInt32)(val)) << 14); \
        } while (0)

/* tune cap bank to replace vtune and vmod */
#define GP_WB_READ_RADIOITF_SX_DCO_CAPBANK_TUNE_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18d), 7)

#define GP_WB_GET_RADIOITF_SX_DCO_CAPBANK_TUNE_OVERRULE_ENA_FROM_FLL_OVERRULE_ENA(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_RADIOITF_SX_DCO_CAPBANK_TUNE_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18d), 7, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_SX_DCO_CAPBANK_TUNE_OVERRULE_ENA_TO_FLL_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x017FFF; \
          (tmp) |= (((UInt32)(val)) << 15); \
        } while (0)

/* enables dco-core current, this is a slow and filtered behaviour, like a biasing */
#define GP_WB_READ_RADIOITF_SX_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18e), 0)

#define GP_WB_GET_RADIOITF_SX_PUP_OVERRULE_ENA_FROM_FLL_OVERRULE_ENA(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_RADIOITF_SX_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x18e), (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_SX_PUP_OVERRULE_ENA_TO_FLL_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x00FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)


/* tune cap bank to replace vtune and vmod */
#define GP_WB_READ_RADIOITF_SX_DCO_CAPBANK_TUNE_OVERRULE() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x190))

#define GP_WB_WRITE_RADIOITF_SX_DCO_CAPBANK_TUNE_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x190), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_ANA_OVERRULE_1() \
        GP_WB_READ_U64(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x194))

#define GP_WB_WRITE_RADIOITF_ANA_OVERRULE_1(val) \
      GP_WB_WRITE_U64(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x194), (val))

/* dtc msb bits (digital to time convervter) */
#define GP_WB_READ_RADIOITF_FLL_DTC_MSB_OVERRULE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x194))

#define GP_WB_GET_RADIOITF_FLL_DTC_MSB_OVERRULE_FROM_ANA_OVERRULE_1(tmp) \
        ((tmp) & 0xFF)

#define GP_WB_WRITE_RADIOITF_FLL_DTC_MSB_OVERRULE(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x194), (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_DTC_MSB_OVERRULE_TO_ANA_OVERRULE_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFFFFFFFFFF00; \
          (tmp) |= ((UInt64)(val)); \
        } while (0)

/* fine cap bank for channel select */
#define GP_WB_READ_RADIOITF_SX_DCO_CAPBANK_FINE_OVERRULE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x195)) & 0x7F)

#define GP_WB_GET_RADIOITF_SX_DCO_CAPBANK_FINE_OVERRULE_FROM_ANA_OVERRULE_1(tmp) \
        (((tmp) >> 8) & 0x7F)

#define GP_WB_WRITE_RADIOITF_SX_DCO_CAPBANK_FINE_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x195), 0x7F, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_SX_DCO_CAPBANK_FINE_OVERRULE_TO_ANA_OVERRULE_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          (tmp) &= 0xFFFFFFFFFFFF80FF; \
          (tmp) |= (((UInt64)(val)) << 8); \
        } while (0)

/* disable esd protection, only in tx-mode */
#define GP_WB_READ_RADIOITF_MATCH_ANT_ESD_DISABLE_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x195), 7)

#define GP_WB_GET_RADIOITF_MATCH_ANT_ESD_DISABLE_OVERRULE_FROM_ANA_OVERRULE_1(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_RADIOITF_MATCH_ANT_ESD_DISABLE_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x195), 7, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_MATCH_ANT_ESD_DISABLE_OVERRULE_TO_ANA_OVERRULE_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFF7FFF; \
          (tmp) |= (((UInt64)(val)) << 15); \
        } while (0)

/* tx: set the output power level: this is a linear scale (output current proportional to code) */
#define GP_WB_READ_RADIOITF_TX_POWER_OVERRULE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x196)) & 0x3F)

#define GP_WB_GET_RADIOITF_TX_POWER_OVERRULE_FROM_ANA_OVERRULE_1(tmp) \
        (((tmp) >> 16) & 0x3F)

#define GP_WB_WRITE_RADIOITF_TX_POWER_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x196), 0x3F, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_TX_POWER_OVERRULE_TO_ANA_OVERRULE_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0xFFFFFFFFFFC0FFFF; \
          (tmp) |= (((UInt64)(val)) << 16); \
        } while (0)

/* tx: adjust the pa-reference bias multiplier */
#define GP_WB_READ_RADIOITF_TX_PA_BIASTRIM_MULT_OVERRULE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x196)) >> 6) & 0x03)

#define GP_WB_GET_RADIOITF_TX_PA_BIASTRIM_MULT_OVERRULE_FROM_ANA_OVERRULE_1(tmp) \
        (((tmp) >> 22) & 0x03)

#define GP_WB_WRITE_RADIOITF_TX_PA_BIASTRIM_MULT_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x196), 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_RADIOITF_TX_PA_BIASTRIM_MULT_OVERRULE_TO_ANA_OVERRULE_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0xFFFFFFFFFF3FFFFF; \
          (tmp) |= (((UInt64)(val)) << 22); \
        } while (0)

/* xo delay setting */
#define GP_WB_READ_RADIOITF_FLL_CLK_DELAY_OVERRULE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x197)) & 0x3F)

#define GP_WB_GET_RADIOITF_FLL_CLK_DELAY_OVERRULE_FROM_ANA_OVERRULE_1(tmp) \
        (((tmp) >> 24) & 0x3F)

#define GP_WB_WRITE_RADIOITF_FLL_CLK_DELAY_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x197), 0x3F, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_CLK_DELAY_OVERRULE_TO_ANA_OVERRULE_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0xFFFFFFFFC0FFFFFF; \
          (tmp) |= (((UInt64)(val)) << 24); \
        } while (0)

/* enables the 1,8v biasing for external pa */
#define GP_WB_READ_RADIOITF_SW_EXT_PA_EN_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x197), 6)

#define GP_WB_GET_RADIOITF_SW_EXT_PA_EN_OVERRULE_FROM_ANA_OVERRULE_1(tmp) \
        (((tmp) >> 30) & 0x01)

#define GP_WB_WRITE_RADIOITF_SW_EXT_PA_EN_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x197), 6, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_SW_EXT_PA_EN_OVERRULE_TO_ANA_OVERRULE_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFBFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 30); \
        } while (0)

/* power up the transmitter biasing */
#define GP_WB_READ_RADIOITF_TX_BIAS_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x197), 7)

#define GP_WB_GET_RADIOITF_TX_BIAS_PUP_OVERRULE_FROM_ANA_OVERRULE_1(tmp) \
        (((tmp) >> 31) & 0x01)

#define GP_WB_WRITE_RADIOITF_TX_BIAS_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x197), 7, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_TX_BIAS_PUP_OVERRULE_TO_ANA_OVERRULE_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFF7FFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 31); \
        } while (0)

/* dtc lsb bits (digital to time convervter) */
#define GP_WB_READ_RADIOITF_FLL_DTC_LSB_OVERRULE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x198)) & 0x3F)

#define GP_WB_GET_RADIOITF_FLL_DTC_LSB_OVERRULE_FROM_ANA_OVERRULE_1(tmp) \
        (((tmp) >> 32) & 0x3F)

#define GP_WB_WRITE_RADIOITF_FLL_DTC_LSB_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x198), 0x3F, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_DTC_LSB_OVERRULE_TO_ANA_OVERRULE_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0xFFFFFFC0FFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 32); \
        } while (0)

/* power up the transmitter driver */
#define GP_WB_READ_RADIOITF_TX_DRIVER_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x198), 6)

#define GP_WB_GET_RADIOITF_TX_DRIVER_PUP_OVERRULE_FROM_ANA_OVERRULE_1(tmp) \
        (((tmp) >> 38) & 0x01)

#define GP_WB_WRITE_RADIOITF_TX_DRIVER_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x198), 6, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_TX_DRIVER_PUP_OVERRULE_TO_ANA_OVERRULE_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFBFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 38); \
        } while (0)

/* power up the transmitter 4.8ghz input buffer */
#define GP_WB_READ_RADIOITF_TX_LO_BUF_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x198), 7)

#define GP_WB_GET_RADIOITF_TX_LO_BUF_PUP_OVERRULE_FROM_ANA_OVERRULE_1(tmp) \
        (((tmp) >> 39) & 0x01)

#define GP_WB_WRITE_RADIOITF_TX_LO_BUF_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x198), 7, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_TX_LO_BUF_PUP_OVERRULE_TO_ANA_OVERRULE_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFF7FFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 39); \
        } while (0)

/* sets gain of filter, 000=8db gain, 111=19db gain, etc. default tbd */
#define GP_WB_READ_RADIOITF_RX_BPF_GAIN_OVERRULE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x199)) & 0x0F)

#define GP_WB_GET_RADIOITF_RX_BPF_GAIN_OVERRULE_FROM_ANA_OVERRULE_1(tmp) \
        (((tmp) >> 40) & 0x0F)

#define GP_WB_WRITE_RADIOITF_RX_BPF_GAIN_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x199), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_BPF_GAIN_OVERRULE_TO_ANA_OVERRULE_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0xFFFFF0FFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 40); \
        } while (0)

/* coarse cap bank for pvt and channel select */
#define GP_WB_READ_RADIOITF_SX_DCO_CAPBANK_CRS_OVERRULE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x199)) >> 4) & 0x0F)

#define GP_WB_GET_RADIOITF_SX_DCO_CAPBANK_CRS_OVERRULE_FROM_ANA_OVERRULE_1(tmp) \
        (((tmp) >> 44) & 0x0F)

#define GP_WB_WRITE_RADIOITF_SX_DCO_CAPBANK_CRS_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x199), 0xF0, (val) << 4); \
        } while (0)

#define GP_WB_SET_RADIOITF_SX_DCO_CAPBANK_CRS_OVERRULE_TO_ANA_OVERRULE_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0xFFFF0FFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 44); \
        } while (0)

/* resistive termination of unused antenna 1 when receiving at antenna 2, lsb=antenna size, msb+msb-1=parallel to antenna switch */
#define GP_WB_READ_RADIOITF_MATCH_ANT1_RLOAD_OVERRULE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19a)) & 0x07)

#define GP_WB_GET_RADIOITF_MATCH_ANT1_RLOAD_OVERRULE_FROM_ANA_OVERRULE_1(tmp) \
        (((tmp) >> 48) & 0x07)

#define GP_WB_WRITE_RADIOITF_MATCH_ANT1_RLOAD_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19a), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_MATCH_ANT1_RLOAD_OVERRULE_TO_ANA_OVERRULE_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0xFFF8FFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 48); \
        } while (0)

/* tune capacitance at ant1-side */
#define GP_WB_READ_RADIOITF_MATCH_ANT1_TUNE_OVERRULE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19a)) >> 3) & 0x07)

#define GP_WB_GET_RADIOITF_MATCH_ANT1_TUNE_OVERRULE_FROM_ANA_OVERRULE_1(tmp) \
        (((tmp) >> 51) & 0x07)

#define GP_WB_WRITE_RADIOITF_MATCH_ANT1_TUNE_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19a), 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_RADIOITF_MATCH_ANT1_TUNE_OVERRULE_TO_ANA_OVERRULE_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0xFFC7FFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 51); \
        } while (0)

/* power up the transmitter power amplifier biasing */
#define GP_WB_READ_RADIOITF_TX_PA_BIAS_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19a), 6)

#define GP_WB_GET_RADIOITF_TX_PA_BIAS_PUP_OVERRULE_FROM_ANA_OVERRULE_1(tmp) \
        (((tmp) >> 54) & 0x01)

#define GP_WB_WRITE_RADIOITF_TX_PA_BIAS_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19a), 6, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_TX_PA_BIAS_PUP_OVERRULE_TO_ANA_OVERRULE_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFBFFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 54); \
        } while (0)

/* power up the transmitter rf-reference mirror, must be on when bias goes on */
#define GP_WB_READ_RADIOITF_TX_PA_REFMIR_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19a), 7)

#define GP_WB_GET_RADIOITF_TX_PA_REFMIR_PUP_OVERRULE_FROM_ANA_OVERRULE_1(tmp) \
        (((tmp) >> 55) & 0x01)

#define GP_WB_WRITE_RADIOITF_TX_PA_REFMIR_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19a), 7, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_TX_PA_REFMIR_PUP_OVERRULE_TO_ANA_OVERRULE_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7FFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 55); \
        } while (0)

/* resistive termination of unused antenna 2 when receiving at antenna 2, lsb=antenna size, msb+msb-1=parallel to antenna switch */
#define GP_WB_READ_RADIOITF_MATCH_ANT2_RLOAD_OVERRULE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19b)) & 0x07)

#define GP_WB_GET_RADIOITF_MATCH_ANT2_RLOAD_OVERRULE_FROM_ANA_OVERRULE_1(tmp) \
        (((tmp) >> 56) & 0x07)

#define GP_WB_WRITE_RADIOITF_MATCH_ANT2_RLOAD_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19b), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_MATCH_ANT2_RLOAD_OVERRULE_TO_ANA_OVERRULE_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0xF8FFFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 56); \
        } while (0)

/* tune capacitance at ant2-side */
#define GP_WB_READ_RADIOITF_MATCH_ANT2_TUNE_OVERRULE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19b)) >> 3) & 0x07)

#define GP_WB_GET_RADIOITF_MATCH_ANT2_TUNE_OVERRULE_FROM_ANA_OVERRULE_1(tmp) \
        (((tmp) >> 59) & 0x07)

#define GP_WB_WRITE_RADIOITF_MATCH_ANT2_TUNE_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19b), 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_RADIOITF_MATCH_ANT2_TUNE_OVERRULE_TO_ANA_OVERRULE_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0xC7FFFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 59); \
        } while (0)

/* power up the transmitter the peak detector comparator (not used) */
#define GP_WB_READ_RADIOITF_TX_PEAK_DETECT_COMP_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19b), 6)

#define GP_WB_GET_RADIOITF_TX_PEAK_DETECT_COMP_PUP_OVERRULE_FROM_ANA_OVERRULE_1(tmp) \
        (((tmp) >> 62) & 0x01)

#define GP_WB_WRITE_RADIOITF_TX_PEAK_DETECT_COMP_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19b), 6, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_TX_PEAK_DETECT_COMP_PUP_OVERRULE_TO_ANA_OVERRULE_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBFFFFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 62); \
        } while (0)

/* power up the transmitter the peak detector (not used) */
#define GP_WB_READ_RADIOITF_TX_PEAK_DETECT_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19b), 7)

#define GP_WB_GET_RADIOITF_TX_PEAK_DETECT_PUP_OVERRULE_FROM_ANA_OVERRULE_1(tmp) \
        (((tmp) >> 63) & 0x01)

#define GP_WB_WRITE_RADIOITF_TX_PEAK_DETECT_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19b), 7, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_TX_PEAK_DETECT_PUP_OVERRULE_TO_ANA_OVERRULE_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7FFFFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 63); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_ANA_OVERRULE_2() \
        GP_WB_READ_U56(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19c))

#define GP_WB_WRITE_RADIOITF_ANA_OVERRULE_2(val) \
      GP_WB_WRITE_U56(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19c), (val))

/* tune capacitance at tx-side */
#define GP_WB_READ_RADIOITF_MATCH_TX_TUNE_OVERRULE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19c)) & 0x07)

#define GP_WB_GET_RADIOITF_MATCH_TX_TUNE_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_RADIOITF_MATCH_TX_TUNE_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19c), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_MATCH_TX_TUNE_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x07FFFFFFFFFFF8; \
          (tmp) |= ((UInt64)(val)); \
        } while (0)

/* sets the frequency for calibration of dtc. */
#define GP_WB_READ_RADIOITF_FLL_DTC_CAL_DIV_OVERRULE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19c)) >> 3) & 0x07)

#define GP_WB_GET_RADIOITF_FLL_DTC_CAL_DIV_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_RADIOITF_FLL_DTC_CAL_DIV_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19c), 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_DTC_CAL_DIV_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x07FFFFFFFFFFC7; \
          (tmp) |= (((UInt64)(val)) << 3); \
        } while (0)

/* tx: disable 1 of the 2 balanced input signals, for test only */
#define GP_WB_READ_RADIOITF_TX_RF_N_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19c), 6)

#define GP_WB_GET_RADIOITF_TX_RF_N_PUP_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RADIOITF_TX_RF_N_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19c), 6, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_TX_RF_N_PUP_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFFFFFFFFBF; \
          (tmp) |= (((UInt64)(val)) << 6); \
        } while (0)

/* tx: disable 1 of the 2 balanced input signals, for test only */
#define GP_WB_READ_RADIOITF_TX_RF_P_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19c), 7)

#define GP_WB_GET_RADIOITF_TX_RF_P_PUP_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_RADIOITF_TX_RF_P_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19c), 7, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_TX_RF_P_PUP_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFFFFFFFF7F; \
          (tmp) |= (((UInt64)(val)) << 7); \
        } while (0)

/* pup signal for the adc comparator biasing */
#define GP_WB_READ_RADIOITF_RSSI_COMP_BIAS_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19d), 0)

#define GP_WB_GET_RADIOITF_RSSI_COMP_BIAS_PUP_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_RADIOITF_RSSI_COMP_BIAS_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19d), 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RSSI_COMP_BIAS_PUP_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFFFFFFFEFF; \
          (tmp) |= (((UInt64)(val)) << 8); \
        } while (0)

/* request for the adc to do conversions */
#define GP_WB_READ_RADIOITF_RSSI_CONV_REQUEST_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19d), 1)

#define GP_WB_GET_RADIOITF_RSSI_CONV_REQUEST_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_RADIOITF_RSSI_CONV_REQUEST_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19d), 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RSSI_CONV_REQUEST_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFFFFFFFDFF; \
          (tmp) |= (((UInt64)(val)) << 9); \
        } while (0)

/* pup signal for the adc input buffer */
#define GP_WB_READ_RADIOITF_RSSI_INPUT_BUFFER_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19d), 2)

#define GP_WB_GET_RADIOITF_RSSI_INPUT_BUFFER_PUP_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_RADIOITF_RSSI_INPUT_BUFFER_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19d), 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RSSI_INPUT_BUFFER_PUP_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFFFFFFFBFF; \
          (tmp) |= (((UInt64)(val)) << 10); \
        } while (0)

/* pulse to integrate on the integrator 1 */
#define GP_WB_READ_RADIOITF_RSSI_INTG1_ACTIVE_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19d), 3)

#define GP_WB_GET_RADIOITF_RSSI_INTG1_ACTIVE_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_RADIOITF_RSSI_INTG1_ACTIVE_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19d), 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RSSI_INTG1_ACTIVE_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFFFFFFF7FF; \
          (tmp) |= (((UInt64)(val)) << 11); \
        } while (0)

/* pulse to discharge the integrator 1 */
#define GP_WB_READ_RADIOITF_RSSI_INTG1_DISCHARGE_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19d), 4)

#define GP_WB_GET_RADIOITF_RSSI_INTG1_DISCHARGE_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_RADIOITF_RSSI_INTG1_DISCHARGE_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19d), 4, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RSSI_INTG1_DISCHARGE_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFFFFFFEFFF; \
          (tmp) |= (((UInt64)(val)) << 12); \
        } while (0)

/* pulse to connect the integrator 1 to the rssi output node and the adc buffer */
#define GP_WB_READ_RADIOITF_RSSI_INTG1_SAMPLE_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19d), 5)

#define GP_WB_GET_RADIOITF_RSSI_INTG1_SAMPLE_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_RADIOITF_RSSI_INTG1_SAMPLE_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19d), 5, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RSSI_INTG1_SAMPLE_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFFFFFFDFFF; \
          (tmp) |= (((UInt64)(val)) << 13); \
        } while (0)

/* pulse to integrate on the integrator 2 */
#define GP_WB_READ_RADIOITF_RSSI_INTG2_ACTIVE_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19d), 6)

#define GP_WB_GET_RADIOITF_RSSI_INTG2_ACTIVE_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_RADIOITF_RSSI_INTG2_ACTIVE_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19d), 6, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RSSI_INTG2_ACTIVE_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFFFFFFBFFF; \
          (tmp) |= (((UInt64)(val)) << 14); \
        } while (0)

/* pulse to discharge the integrator 2 */
#define GP_WB_READ_RADIOITF_RSSI_INTG2_DISCHARGE_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19d), 7)

#define GP_WB_GET_RADIOITF_RSSI_INTG2_DISCHARGE_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_RADIOITF_RSSI_INTG2_DISCHARGE_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19d), 7, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RSSI_INTG2_DISCHARGE_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFFFFFF7FFF; \
          (tmp) |= (((UInt64)(val)) << 15); \
        } while (0)

/* pulse to connect the integrator 2 to the rssi output node and the adc buffer */
#define GP_WB_READ_RADIOITF_RSSI_INTG2_SAMPLE_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19e), 0)

#define GP_WB_GET_RADIOITF_RSSI_INTG2_SAMPLE_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_RADIOITF_RSSI_INTG2_SAMPLE_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19e), 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RSSI_INTG2_SAMPLE_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFFFFFEFFFF; \
          (tmp) |= (((UInt64)(val)) << 16); \
        } while (0)

/* pulse to connect the reference voltage to an integrator */
#define GP_WB_READ_RADIOITF_RSSI_INTG_CALIBRATION_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19e), 1)

#define GP_WB_GET_RADIOITF_RSSI_INTG_CALIBRATION_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 17) & 0x01)

#define GP_WB_WRITE_RADIOITF_RSSI_INTG_CALIBRATION_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19e), 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RSSI_INTG_CALIBRATION_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFFFFFDFFFF; \
          (tmp) |= (((UInt64)(val)) << 17); \
        } while (0)

/* enables the integrating mode of the rssi, to be used in the ble slots of the concurrent mode. when set_rssi_integrating_mode is '0', the rssi works in continuous mode. */
#define GP_WB_READ_RADIOITF_RSSI_INTG_MODE_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19e), 2)

#define GP_WB_GET_RADIOITF_RSSI_INTG_MODE_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 18) & 0x01)

#define GP_WB_WRITE_RADIOITF_RSSI_INTG_MODE_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19e), 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RSSI_INTG_MODE_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFFFFFBFFFF; \
          (tmp) |= (((UInt64)(val)) << 18); \
        } while (0)

/* pulse to discharge the rssi output node */
#define GP_WB_READ_RADIOITF_RSSI_OUT_DISCHARGE_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19e), 3)

#define GP_WB_GET_RADIOITF_RSSI_OUT_DISCHARGE_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 19) & 0x01)

#define GP_WB_WRITE_RADIOITF_RSSI_OUT_DISCHARGE_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19e), 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RSSI_OUT_DISCHARGE_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFFFFF7FFFF; \
          (tmp) |= (((UInt64)(val)) << 19); \
        } while (0)

/* pup signal for the adc vcm buffer (vcm: common-mode voltage) */
#define GP_WB_READ_RADIOITF_RSSI_VCM_BUFFER_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19e), 4)

#define GP_WB_GET_RADIOITF_RSSI_VCM_BUFFER_PUP_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 20) & 0x01)

#define GP_WB_WRITE_RADIOITF_RSSI_VCM_BUFFER_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19e), 4, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RSSI_VCM_BUFFER_PUP_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFFFFEFFFFF; \
          (tmp) |= (((UInt64)(val)) << 20); \
        } while (0)

/* enable 5ua current mirrors to feed ldo, lna, bpf and lim */
#define GP_WB_READ_RADIOITF_RX_BIAS_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19e), 5)

#define GP_WB_GET_RADIOITF_RX_BIAS_PUP_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 21) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_BIAS_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19e), 5, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_BIAS_PUP_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFFFFDFFFFF; \
          (tmp) |= (((UInt64)(val)) << 21); \
        } while (0)

/* power up the whole bpf without affecting biasing, this is intended for lpl mode */
#define GP_WB_READ_RADIOITF_RX_BPF_BIAS_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19e), 6)

#define GP_WB_GET_RADIOITF_RX_BPF_BIAS_PUP_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 22) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_BPF_BIAS_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19e), 6, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_BPF_BIAS_PUP_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFFFFBFFFFF; \
          (tmp) |= (((UInt64)(val)) << 22); \
        } while (0)

/* 0=zigbee, 1=ble */
#define GP_WB_READ_RADIOITF_RX_BPF_BLE_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19e), 7)

#define GP_WB_GET_RADIOITF_RX_BPF_BLE_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 23) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_BPF_BLE_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19e), 7, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_BPF_BLE_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFFFF7FFFFF; \
          (tmp) |= (((UInt64)(val)) << 23); \
        } while (0)

/* powers up the digital part of the bpf, like levelshifts, non-overlapping-clock generator, etc */
#define GP_WB_READ_RADIOITF_RX_BPF_DIG_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19f), 0)

#define GP_WB_GET_RADIOITF_RX_BPF_DIG_PUP_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 24) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_BPF_DIG_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19f), 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_BPF_DIG_PUP_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFFFEFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 24); \
        } while (0)

/* powers up the constant-gm ldo for the bpf core */
#define GP_WB_READ_RADIOITF_RX_BPF_LDO_CGM_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19f), 1)

#define GP_WB_GET_RADIOITF_RX_BPF_LDO_CGM_PUP_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 25) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_BPF_LDO_CGM_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19f), 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_BPF_LDO_CGM_PUP_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFFFDFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 25); \
        } while (0)

/* powers up the switched cap biasing n-side */
#define GP_WB_READ_RADIOITF_RX_BPF_SC_BIAS_N_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19f), 2)

#define GP_WB_GET_RADIOITF_RX_BPF_SC_BIAS_N_PUP_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 26) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_BPF_SC_BIAS_N_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19f), 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_BPF_SC_BIAS_N_PUP_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFFFBFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 26); \
        } while (0)

/* powers up the switched cap biasing p-side */
#define GP_WB_READ_RADIOITF_RX_BPF_SC_BIAS_P_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19f), 3)

#define GP_WB_GET_RADIOITF_RX_BPF_SC_BIAS_P_PUP_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 27) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_BPF_SC_BIAS_P_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19f), 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_BPF_SC_BIAS_P_PUP_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFFF7FFFFFF; \
          (tmp) |= (((UInt64)(val)) << 27); \
        } while (0)

/* power up of limiter bias currents */
#define GP_WB_READ_RADIOITF_RX_LIM_BIAS_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19f), 4)

#define GP_WB_GET_RADIOITF_RX_LIM_BIAS_PUP_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 28) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_LIM_BIAS_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19f), 4, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_LIM_BIAS_PUP_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFFEFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 28); \
        } while (0)

/* powers up the limiter chain. this is independent of biasing. this is for lpl mode */
#define GP_WB_READ_RADIOITF_RX_LIM_CHAIN_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19f), 5)

#define GP_WB_GET_RADIOITF_RX_LIM_CHAIN_PUP_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 29) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_LIM_CHAIN_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19f), 5, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_LIM_CHAIN_PUP_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFFDFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 29); \
        } while (0)

/* powers up the diff2se. intended for debugging. if lot's of pollution thanks to this block, we can disable it. can also use it to measure current of diff2se */
#define GP_WB_READ_RADIOITF_RX_LIM_DIFF2SE_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19f), 6)

#define GP_WB_GET_RADIOITF_RX_LIM_DIFF2SE_PUP_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 30) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_LIM_DIFF2SE_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19f), 6, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_LIM_DIFF2SE_PUP_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFFBFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 30); \
        } while (0)

/* enable lna and its constant-gm biasing */
#define GP_WB_READ_RADIOITF_RX_LNA_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19f), 7)

#define GP_WB_GET_RADIOITF_RX_LNA_PUP_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 31) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_LNA_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x19f), 7, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_LNA_PUP_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFF7FFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 31); \
        } while (0)

/* enables receiver to be connected to one or both antenna's. this is a half-t-switch */
#define GP_WB_READ_RADIOITF_RX_LNA_SWITCH_EN_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a0), 0)

#define GP_WB_GET_RADIOITF_RX_LNA_SWITCH_EN_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 32) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_LNA_SWITCH_EN_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a0), 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_LNA_SWITCH_EN_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFEFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 32); \
        } while (0)

/* rx-lo-signal buffer enable, this is after shared divide/2 */
#define GP_WB_READ_RADIOITF_RX_LOBUF_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a0), 1)

#define GP_WB_GET_RADIOITF_RX_LOBUF_PUP_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 33) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_LOBUF_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a0), 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_LOBUF_PUP_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFDFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 33); \
        } while (0)

/* enables the 16mhz clock output to rx-bpf */
#define GP_WB_READ_RADIOITF_XO_CLK_16M_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a0), 2)

#define GP_WB_GET_RADIOITF_XO_CLK_16M_PUP_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 34) & 0x01)

#define GP_WB_WRITE_RADIOITF_XO_CLK_16M_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a0), 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_XO_CLK_16M_PUP_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFBFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 34); \
        } while (0)

/* enables the 8 mhz clock towards the rssi block */
#define GP_WB_READ_RADIOITF_XO_CLK_8M_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a0), 3)

#define GP_WB_GET_RADIOITF_XO_CLK_8M_PUP_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 35) & 0x01)

#define GP_WB_WRITE_RADIOITF_XO_CLK_8M_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a0), 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_XO_CLK_8M_PUP_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFF7FFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 35); \
        } while (0)

/* select antenna 1 to connect to tx or rx */
#define GP_WB_READ_RADIOITF_MATCH_ANT1_SELECT_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a0), 4)

#define GP_WB_GET_RADIOITF_MATCH_ANT1_SELECT_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 36) & 0x01)

#define GP_WB_WRITE_RADIOITF_MATCH_ANT1_SELECT_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a0), 4, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_MATCH_ANT1_SELECT_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFEFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 36); \
        } while (0)

/* select antenna 2 to connect to tx or rx */
#define GP_WB_READ_RADIOITF_MATCH_ANT2_SELECT_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a0), 5)

#define GP_WB_GET_RADIOITF_MATCH_ANT2_SELECT_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 37) & 0x01)

#define GP_WB_WRITE_RADIOITF_MATCH_ANT2_SELECT_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a0), 5, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_MATCH_ANT2_SELECT_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFDFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 37); \
        } while (0)

/* low bias option for lna to reduce the current by factor 2 when enabled */
#define GP_WB_READ_RADIOITF_RX_LNA_LOWBIAS_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a0), 6)

#define GP_WB_GET_RADIOITF_RX_LNA_LOWBIAS_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 38) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_LNA_LOWBIAS_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a0), 6, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_LNA_LOWBIAS_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFBFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 38); \
        } while (0)

/* set lna in low-gain mode. this improves overall linearity without sacrificing much sensitivity */
#define GP_WB_READ_RADIOITF_RX_LNA_LOWGAIN_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a0), 7)

#define GP_WB_GET_RADIOITF_RX_LNA_LOWGAIN_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 39) & 0x01)

#define GP_WB_WRITE_RADIOITF_RX_LNA_LOWGAIN_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a0), 7, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_RX_LNA_LOWGAIN_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FF7FFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 39); \
        } while (0)

/* pup of the voltage doubler */
#define GP_WB_READ_RADIOITF_VDOUBLER_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a1), 0)

#define GP_WB_GET_RADIOITF_VDOUBLER_PUP_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 40) & 0x01)

#define GP_WB_WRITE_RADIOITF_VDOUBLER_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a1), 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_VDOUBLER_PUP_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FEFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 40); \
        } while (0)

/* power up of fll bias mirrors */
#define GP_WB_READ_RADIOITF_FLL_BIAS_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a1), 1)

#define GP_WB_GET_RADIOITF_FLL_BIAS_PUP_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 41) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_BIAS_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a1), 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_BIAS_PUP_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FDFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 41); \
        } while (0)

/* xo delay calibration */
#define GP_WB_READ_RADIOITF_FLL_CLK_DELAY_CAL_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a1), 2)

#define GP_WB_GET_RADIOITF_FLL_CLK_DELAY_CAL_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 42) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_CLK_DELAY_CAL_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a1), 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_CLK_DELAY_CAL_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FBFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 42); \
        } while (0)

/* fll divider selection of divider ratio: divide by 64(=1) or 16(=0) */
#define GP_WB_READ_RADIOITF_FLL_DIV16_64_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a1), 3)

#define GP_WB_GET_RADIOITF_FLL_DIV16_64_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 43) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_DIV16_64_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a1), 3, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_DIV16_64_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07F7FFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 43); \
        } while (0)

/* pup of divider sampler */
#define GP_WB_READ_RADIOITF_FLL_DIVSAMP_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a1), 4)

#define GP_WB_GET_RADIOITF_FLL_DIVSAMP_PUP_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 44) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_DIVSAMP_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a1), 4, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_DIVSAMP_PUP_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07EFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 44); \
        } while (0)

/* msb bits are put to slow mode,to enable succesfull calibration */
#define GP_WB_READ_RADIOITF_FLL_DTC_CAL_SLOW_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a1), 5)

#define GP_WB_GET_RADIOITF_FLL_DTC_CAL_SLOW_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 45) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_DTC_CAL_SLOW_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a1), 5, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_DTC_CAL_SLOW_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07DFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 45); \
        } while (0)

/* fll: high current capability of dedicated ldo, only for dtc calibration mode */
#define GP_WB_READ_RADIOITF_FLL_DTC_LDO_HP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a1), 6)

#define GP_WB_GET_RADIOITF_FLL_DTC_LDO_HP_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 46) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_DTC_LDO_HP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a1), 6, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_DTC_LDO_HP_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07BFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 46); \
        } while (0)

/* pup of main fll lobuf */
#define GP_WB_READ_RADIOITF_FLL_LOBUF_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a1), 7)

#define GP_WB_GET_RADIOITF_FLL_LOBUF_PUP_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 47) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_LOBUF_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a1), 7, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_LOBUF_PUP_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x077FFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 47); \
        } while (0)

/* pup of main fll sampler( only needed during cap bank cal) */
#define GP_WB_READ_RADIOITF_FLL_SAMPLER_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a2), 0)

#define GP_WB_GET_RADIOITF_FLL_SAMPLER_PUP_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 48) & 0x01)

#define GP_WB_WRITE_RADIOITF_FLL_SAMPLER_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a2), 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_FLL_SAMPLER_PUP_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06FFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 48); \
        } while (0)

/* enables bias currents feeding dco ldo */
#define GP_WB_READ_RADIOITF_SX_BIAS_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a2), 1)

#define GP_WB_GET_RADIOITF_SX_BIAS_PUP_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 49) & 0x01)

#define GP_WB_WRITE_RADIOITF_SX_BIAS_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a2), 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_SX_BIAS_PUP_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05FFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 49); \
        } while (0)

/* enables dco-core current, this is a slow and filtered behaviour, like a biasing */
#define GP_WB_READ_RADIOITF_SX_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a2), 2)

#define GP_WB_GET_RADIOITF_SX_PUP_OVERRULE_FROM_ANA_OVERRULE_2(tmp) \
        (((tmp) >> 50) & 0x01)

#define GP_WB_WRITE_RADIOITF_SX_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a2), 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIOITF_SX_PUP_OVERRULE_TO_ANA_OVERRULE_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 50); \
        } while (0)


/* tune cap bank to replace vtune and vmod */
#define GP_WB_READ_RADIOITF_SX_DCO_CAPBANK_TUNE_STATUS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a4))


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_ANA_STATUS_1() \
        GP_WB_READ_U64(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a8))

/* dtc msb bits (digital to time convervter) */
#define GP_WB_READ_RADIOITF_FLL_DTC_MSB_STATUS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a8))

#define GP_WB_GET_RADIOITF_FLL_DTC_MSB_STATUS_FROM_ANA_STATUS_1(tmp) \
        ((tmp) & 0xFF)

/* fine cap bank for channel select */
#define GP_WB_READ_RADIOITF_SX_DCO_CAPBANK_FINE_STATUS() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a9)) & 0x7F)

#define GP_WB_GET_RADIOITF_SX_DCO_CAPBANK_FINE_STATUS_FROM_ANA_STATUS_1(tmp) \
        (((tmp) >> 8) & 0x7F)

/* disable esd protection, only in tx-mode */
#define GP_WB_READ_RADIOITF_MATCH_ANT_ESD_DISABLE_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1a9), 7)

#define GP_WB_GET_RADIOITF_MATCH_ANT_ESD_DISABLE_STATUS_FROM_ANA_STATUS_1(tmp) \
        (((tmp) >> 15) & 0x01)

/* tx: set the output power level: this is a linear scale (output current proportional to code) */
#define GP_WB_READ_RADIOITF_TX_POWER_STATUS() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1aa)) & 0x3F)

#define GP_WB_GET_RADIOITF_TX_POWER_STATUS_FROM_ANA_STATUS_1(tmp) \
        (((tmp) >> 16) & 0x3F)

/* tx: adjust the pa-reference bias multiplier */
#define GP_WB_READ_RADIOITF_TX_PA_BIASTRIM_MULT_STATUS() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1aa)) >> 6) & 0x03)

#define GP_WB_GET_RADIOITF_TX_PA_BIASTRIM_MULT_STATUS_FROM_ANA_STATUS_1(tmp) \
        (((tmp) >> 22) & 0x03)

/* xo delay setting */
#define GP_WB_READ_RADIOITF_FLL_CLK_DELAY_STATUS() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1ab)) & 0x3F)

#define GP_WB_GET_RADIOITF_FLL_CLK_DELAY_STATUS_FROM_ANA_STATUS_1(tmp) \
        (((tmp) >> 24) & 0x3F)

/* enables the 1,8v biasing for external pa */
#define GP_WB_READ_RADIOITF_SW_EXT_PA_EN_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1ab), 6)

#define GP_WB_GET_RADIOITF_SW_EXT_PA_EN_STATUS_FROM_ANA_STATUS_1(tmp) \
        (((tmp) >> 30) & 0x01)

/* power up the transmitter biasing */
#define GP_WB_READ_RADIOITF_TX_BIAS_PUP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1ab), 7)

#define GP_WB_GET_RADIOITF_TX_BIAS_PUP_STATUS_FROM_ANA_STATUS_1(tmp) \
        (((tmp) >> 31) & 0x01)

/* dtc lsb bits (digital to time convervter) */
#define GP_WB_READ_RADIOITF_FLL_DTC_LSB_STATUS() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1ac)) & 0x3F)

#define GP_WB_GET_RADIOITF_FLL_DTC_LSB_STATUS_FROM_ANA_STATUS_1(tmp) \
        (((tmp) >> 32) & 0x3F)

/* power up the transmitter driver */
#define GP_WB_READ_RADIOITF_TX_DRIVER_PUP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1ac), 6)

#define GP_WB_GET_RADIOITF_TX_DRIVER_PUP_STATUS_FROM_ANA_STATUS_1(tmp) \
        (((tmp) >> 38) & 0x01)

/* power up the transmitter 4.8ghz input buffer */
#define GP_WB_READ_RADIOITF_TX_LO_BUF_PUP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1ac), 7)

#define GP_WB_GET_RADIOITF_TX_LO_BUF_PUP_STATUS_FROM_ANA_STATUS_1(tmp) \
        (((tmp) >> 39) & 0x01)

/* sets gain of filter, 000=8db gain, 111=19db gain, etc. default tbd */
#define GP_WB_READ_RADIOITF_RX_BPF_GAIN_STATUS() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1ad)) & 0x0F)

#define GP_WB_GET_RADIOITF_RX_BPF_GAIN_STATUS_FROM_ANA_STATUS_1(tmp) \
        (((tmp) >> 40) & 0x0F)

/* coarse cap bank for pvt and channel select */
#define GP_WB_READ_RADIOITF_SX_DCO_CAPBANK_CRS_STATUS() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1ad)) >> 4) & 0x0F)

#define GP_WB_GET_RADIOITF_SX_DCO_CAPBANK_CRS_STATUS_FROM_ANA_STATUS_1(tmp) \
        (((tmp) >> 44) & 0x0F)

/* resistive termination of unused antenna 1 when receiving at antenna 2, lsb=antenna size, msb+msb-1=parallel to antenna switch */
#define GP_WB_READ_RADIOITF_MATCH_ANT1_RLOAD_STATUS() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1ae)) & 0x07)

#define GP_WB_GET_RADIOITF_MATCH_ANT1_RLOAD_STATUS_FROM_ANA_STATUS_1(tmp) \
        (((tmp) >> 48) & 0x07)

/* tune capacitance at ant1-side */
#define GP_WB_READ_RADIOITF_MATCH_ANT1_TUNE_STATUS() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1ae)) >> 3) & 0x07)

#define GP_WB_GET_RADIOITF_MATCH_ANT1_TUNE_STATUS_FROM_ANA_STATUS_1(tmp) \
        (((tmp) >> 51) & 0x07)

/* power up the transmitter power amplifier biasing */
#define GP_WB_READ_RADIOITF_TX_PA_BIAS_PUP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1ae), 6)

#define GP_WB_GET_RADIOITF_TX_PA_BIAS_PUP_STATUS_FROM_ANA_STATUS_1(tmp) \
        (((tmp) >> 54) & 0x01)

/* power up the transmitter rf-reference mirror, must be on when bias goes on */
#define GP_WB_READ_RADIOITF_TX_PA_REFMIR_PUP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1ae), 7)

#define GP_WB_GET_RADIOITF_TX_PA_REFMIR_PUP_STATUS_FROM_ANA_STATUS_1(tmp) \
        (((tmp) >> 55) & 0x01)

/* resistive termination of unused antenna 2 when receiving at antenna 2, lsb=antenna size, msb+msb-1=parallel to antenna switch */
#define GP_WB_READ_RADIOITF_MATCH_ANT2_RLOAD_STATUS() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1af)) & 0x07)

#define GP_WB_GET_RADIOITF_MATCH_ANT2_RLOAD_STATUS_FROM_ANA_STATUS_1(tmp) \
        (((tmp) >> 56) & 0x07)

/* tune capacitance at ant2-side */
#define GP_WB_READ_RADIOITF_MATCH_ANT2_TUNE_STATUS() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1af)) >> 3) & 0x07)

#define GP_WB_GET_RADIOITF_MATCH_ANT2_TUNE_STATUS_FROM_ANA_STATUS_1(tmp) \
        (((tmp) >> 59) & 0x07)

/* power up the transmitter the peak detector comparator (not used) */
#define GP_WB_READ_RADIOITF_TX_PEAK_DETECT_COMP_PUP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1af), 6)

#define GP_WB_GET_RADIOITF_TX_PEAK_DETECT_COMP_PUP_STATUS_FROM_ANA_STATUS_1(tmp) \
        (((tmp) >> 62) & 0x01)

/* power up the transmitter the peak detector (not used) */
#define GP_WB_READ_RADIOITF_TX_PEAK_DETECT_PUP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1af), 7)

#define GP_WB_GET_RADIOITF_TX_PEAK_DETECT_PUP_STATUS_FROM_ANA_STATUS_1(tmp) \
        (((tmp) >> 63) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIOITF_ANA_STATUS_2() \
        GP_WB_READ_U56(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b0))

/* tune capacitance at tx-side */
#define GP_WB_READ_RADIOITF_MATCH_TX_TUNE_STATUS() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b0)) & 0x07)

#define GP_WB_GET_RADIOITF_MATCH_TX_TUNE_STATUS_FROM_ANA_STATUS_2(tmp) \
        ((tmp) & 0x07)

/* sets the frequency for calibration of dtc. */
#define GP_WB_READ_RADIOITF_FLL_DTC_CAL_DIV_STATUS() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b0)) >> 3) & 0x07)

#define GP_WB_GET_RADIOITF_FLL_DTC_CAL_DIV_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 3) & 0x07)

/* tx: disable 1 of the 2 balanced input signals, for test only */
#define GP_WB_READ_RADIOITF_TX_RF_N_PUP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b0), 6)

#define GP_WB_GET_RADIOITF_TX_RF_N_PUP_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 6) & 0x01)

/* tx: disable 1 of the 2 balanced input signals, for test only */
#define GP_WB_READ_RADIOITF_TX_RF_P_PUP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b0), 7)

#define GP_WB_GET_RADIOITF_TX_RF_P_PUP_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 7) & 0x01)

/* pup signal for the adc comparator biasing */
#define GP_WB_READ_RADIOITF_RSSI_COMP_BIAS_PUP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b1), 0)

#define GP_WB_GET_RADIOITF_RSSI_COMP_BIAS_PUP_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 8) & 0x01)

/* request for the adc to do conversions */
#define GP_WB_READ_RADIOITF_RSSI_CONV_REQUEST_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b1), 1)

#define GP_WB_GET_RADIOITF_RSSI_CONV_REQUEST_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 9) & 0x01)

/* pup signal for the adc input buffer */
#define GP_WB_READ_RADIOITF_RSSI_INPUT_BUFFER_PUP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b1), 2)

#define GP_WB_GET_RADIOITF_RSSI_INPUT_BUFFER_PUP_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 10) & 0x01)

/* pulse to integrate on the integrator 1 */
#define GP_WB_READ_RADIOITF_RSSI_INTG1_ACTIVE_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b1), 3)

#define GP_WB_GET_RADIOITF_RSSI_INTG1_ACTIVE_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 11) & 0x01)

/* pulse to discharge the integrator 1 */
#define GP_WB_READ_RADIOITF_RSSI_INTG1_DISCHARGE_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b1), 4)

#define GP_WB_GET_RADIOITF_RSSI_INTG1_DISCHARGE_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 12) & 0x01)

/* pulse to connect the integrator 1 to the rssi output node and the adc buffer */
#define GP_WB_READ_RADIOITF_RSSI_INTG1_SAMPLE_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b1), 5)

#define GP_WB_GET_RADIOITF_RSSI_INTG1_SAMPLE_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 13) & 0x01)

/* pulse to integrate on the integrator 2 */
#define GP_WB_READ_RADIOITF_RSSI_INTG2_ACTIVE_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b1), 6)

#define GP_WB_GET_RADIOITF_RSSI_INTG2_ACTIVE_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 14) & 0x01)

/* pulse to discharge the integrator 2 */
#define GP_WB_READ_RADIOITF_RSSI_INTG2_DISCHARGE_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b1), 7)

#define GP_WB_GET_RADIOITF_RSSI_INTG2_DISCHARGE_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 15) & 0x01)

/* pulse to connect the integrator 2 to the rssi output node and the adc buffer */
#define GP_WB_READ_RADIOITF_RSSI_INTG2_SAMPLE_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b2), 0)

#define GP_WB_GET_RADIOITF_RSSI_INTG2_SAMPLE_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 16) & 0x01)

/* pulse to connect the reference voltage to an integrator */
#define GP_WB_READ_RADIOITF_RSSI_INTG_CALIBRATION_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b2), 1)

#define GP_WB_GET_RADIOITF_RSSI_INTG_CALIBRATION_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 17) & 0x01)

/* enables the integrating mode of the rssi, to be used in the ble slots of the concurrent mode. when set_rssi_integrating_mode is '0', the rssi works in continuous mode. */
#define GP_WB_READ_RADIOITF_RSSI_INTG_MODE_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b2), 2)

#define GP_WB_GET_RADIOITF_RSSI_INTG_MODE_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 18) & 0x01)

/* pulse to discharge the rssi output node */
#define GP_WB_READ_RADIOITF_RSSI_OUT_DISCHARGE_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b2), 3)

#define GP_WB_GET_RADIOITF_RSSI_OUT_DISCHARGE_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 19) & 0x01)

/* pup signal for the adc vcm buffer (vcm: common-mode voltage) */
#define GP_WB_READ_RADIOITF_RSSI_VCM_BUFFER_PUP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b2), 4)

#define GP_WB_GET_RADIOITF_RSSI_VCM_BUFFER_PUP_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 20) & 0x01)

/* enable 5ua current mirrors to feed ldo, lna, bpf and lim */
#define GP_WB_READ_RADIOITF_RX_BIAS_PUP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b2), 5)

#define GP_WB_GET_RADIOITF_RX_BIAS_PUP_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 21) & 0x01)

/* power up the whole bpf without affecting biasing, this is intended for lpl mode */
#define GP_WB_READ_RADIOITF_RX_BPF_BIAS_PUP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b2), 6)

#define GP_WB_GET_RADIOITF_RX_BPF_BIAS_PUP_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 22) & 0x01)

/* 0=zigbee, 1=ble */
#define GP_WB_READ_RADIOITF_RX_BPF_BLE_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b2), 7)

#define GP_WB_GET_RADIOITF_RX_BPF_BLE_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 23) & 0x01)

/* powers up the digital part of the bpf, like levelshifts, non-overlapping-clock generator, etc */
#define GP_WB_READ_RADIOITF_RX_BPF_DIG_PUP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b3), 0)

#define GP_WB_GET_RADIOITF_RX_BPF_DIG_PUP_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 24) & 0x01)

/* powers up the constant-gm ldo for the bpf core */
#define GP_WB_READ_RADIOITF_RX_BPF_LDO_CGM_PUP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b3), 1)

#define GP_WB_GET_RADIOITF_RX_BPF_LDO_CGM_PUP_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 25) & 0x01)

/* powers up the switched cap biasing n-side */
#define GP_WB_READ_RADIOITF_RX_BPF_SC_BIAS_N_PUP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b3), 2)

#define GP_WB_GET_RADIOITF_RX_BPF_SC_BIAS_N_PUP_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 26) & 0x01)

/* powers up the switched cap biasing p-side */
#define GP_WB_READ_RADIOITF_RX_BPF_SC_BIAS_P_PUP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b3), 3)

#define GP_WB_GET_RADIOITF_RX_BPF_SC_BIAS_P_PUP_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 27) & 0x01)

/* power up of limiter bias currents */
#define GP_WB_READ_RADIOITF_RX_LIM_BIAS_PUP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b3), 4)

#define GP_WB_GET_RADIOITF_RX_LIM_BIAS_PUP_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 28) & 0x01)

/* powers up the limiter chain. this is independent of biasing. this is for lpl mode */
#define GP_WB_READ_RADIOITF_RX_LIM_CHAIN_PUP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b3), 5)

#define GP_WB_GET_RADIOITF_RX_LIM_CHAIN_PUP_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 29) & 0x01)

/* powers up the diff2se. intended for debugging. if lot's of pollution thanks to this block, we can disable it. can also use it to measure current of diff2se */
#define GP_WB_READ_RADIOITF_RX_LIM_DIFF2SE_PUP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b3), 6)

#define GP_WB_GET_RADIOITF_RX_LIM_DIFF2SE_PUP_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 30) & 0x01)

/* enable lna and its constant-gm biasing */
#define GP_WB_READ_RADIOITF_RX_LNA_PUP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b3), 7)

#define GP_WB_GET_RADIOITF_RX_LNA_PUP_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 31) & 0x01)

/* enables receiver to be connected to one or both antenna's. this is a half-t-switch */
#define GP_WB_READ_RADIOITF_RX_LNA_SWITCH_EN_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b4), 0)

#define GP_WB_GET_RADIOITF_RX_LNA_SWITCH_EN_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 32) & 0x01)

/* rx-lo-signal buffer enable, this is after shared divide/2 */
#define GP_WB_READ_RADIOITF_RX_LOBUF_PUP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b4), 1)

#define GP_WB_GET_RADIOITF_RX_LOBUF_PUP_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 33) & 0x01)

/* enables the 16mhz clock output to rx-bpf */
#define GP_WB_READ_RADIOITF_XO_CLK_16M_PUP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b4), 2)

#define GP_WB_GET_RADIOITF_XO_CLK_16M_PUP_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 34) & 0x01)

/* enables the 8 mhz clock towards the rssi block */
#define GP_WB_READ_RADIOITF_XO_CLK_8M_PUP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b4), 3)

#define GP_WB_GET_RADIOITF_XO_CLK_8M_PUP_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 35) & 0x01)

/* select antenna 1 to connect to tx or rx */
#define GP_WB_READ_RADIOITF_MATCH_ANT1_SELECT_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b4), 4)

#define GP_WB_GET_RADIOITF_MATCH_ANT1_SELECT_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 36) & 0x01)

/* select antenna 2 to connect to tx or rx */
#define GP_WB_READ_RADIOITF_MATCH_ANT2_SELECT_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b4), 5)

#define GP_WB_GET_RADIOITF_MATCH_ANT2_SELECT_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 37) & 0x01)

/* low bias option for lna to reduce the current by factor 2 when enabled */
#define GP_WB_READ_RADIOITF_RX_LNA_LOWBIAS_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b4), 6)

#define GP_WB_GET_RADIOITF_RX_LNA_LOWBIAS_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 38) & 0x01)

/* set lna in low-gain mode. this improves overall linearity without sacrificing much sensitivity */
#define GP_WB_READ_RADIOITF_RX_LNA_LOWGAIN_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b4), 7)

#define GP_WB_GET_RADIOITF_RX_LNA_LOWGAIN_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 39) & 0x01)

/* pup of the voltage doubler */
#define GP_WB_READ_RADIOITF_VDOUBLER_PUP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b5), 0)

#define GP_WB_GET_RADIOITF_VDOUBLER_PUP_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 40) & 0x01)

/* power up of fll bias mirrors */
#define GP_WB_READ_RADIOITF_FLL_BIAS_PUP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b5), 1)

#define GP_WB_GET_RADIOITF_FLL_BIAS_PUP_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 41) & 0x01)

/* xo delay calibration */
#define GP_WB_READ_RADIOITF_FLL_CLK_DELAY_CAL_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b5), 2)

#define GP_WB_GET_RADIOITF_FLL_CLK_DELAY_CAL_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 42) & 0x01)

/* fll divider selection of divider ratio: divide by 64(=1) or 16(=0) */
#define GP_WB_READ_RADIOITF_FLL_DIV16_64_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b5), 3)

#define GP_WB_GET_RADIOITF_FLL_DIV16_64_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 43) & 0x01)

/* pup of divider sampler */
#define GP_WB_READ_RADIOITF_FLL_DIVSAMP_PUP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b5), 4)

#define GP_WB_GET_RADIOITF_FLL_DIVSAMP_PUP_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 44) & 0x01)

/* msb bits are put to slow mode,to enable succesfull calibration */
#define GP_WB_READ_RADIOITF_FLL_DTC_CAL_SLOW_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b5), 5)

#define GP_WB_GET_RADIOITF_FLL_DTC_CAL_SLOW_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 45) & 0x01)

/* fll: high current capability of dedicated ldo, only for dtc calibration mode */
#define GP_WB_READ_RADIOITF_FLL_DTC_LDO_HP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b5), 6)

#define GP_WB_GET_RADIOITF_FLL_DTC_LDO_HP_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 46) & 0x01)

/* pup of main fll lobuf */
#define GP_WB_READ_RADIOITF_FLL_LOBUF_PUP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b5), 7)

#define GP_WB_GET_RADIOITF_FLL_LOBUF_PUP_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 47) & 0x01)

/* pup of main fll sampler( only needed during cap bank cal) */
#define GP_WB_READ_RADIOITF_FLL_SAMPLER_PUP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b6), 0)

#define GP_WB_GET_RADIOITF_FLL_SAMPLER_PUP_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 48) & 0x01)

/* enables bias currents feeding dco ldo */
#define GP_WB_READ_RADIOITF_SX_BIAS_PUP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b6), 1)

#define GP_WB_GET_RADIOITF_SX_BIAS_PUP_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 49) & 0x01)

/* enables dco-core current, this is a slow and filtered behaviour, like a biasing */
#define GP_WB_READ_RADIOITF_SX_PUP_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1b6), 2)

#define GP_WB_GET_RADIOITF_SX_PUP_STATUS_FROM_ANA_STATUS_2(tmp) \
        (((tmp) >> 50) & 0x01)

/***************************
 * layout: rx
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_RX_ANTSEL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x200))

#define GP_WB_WRITE_RX_RX_ANTSEL(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x200), (val))

/* Rx antenna select internal */
#define GP_WB_READ_RX_RX_ANTSEL_INT() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x200)) & 0x03)

#define GP_WB_GET_RX_RX_ANTSEL_INT_FROM_RX_ANTSEL(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_RX_RX_ANTSEL_INT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x200), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_RX_RX_ANTSEL_INT_TO_RX_ANTSEL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x0C; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Rx antenna select external */
#define GP_WB_READ_RX_RX_ANTSEL_EXT() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x200)) >> 2) & 0x03)

#define GP_WB_GET_RX_RX_ANTSEL_EXT_FROM_RX_ANTSEL(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_RX_RX_ANTSEL_EXT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x200), 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_RX_RX_ANTSEL_EXT_TO_RX_ANTSEL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_RX_ANT_EXT() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x201))

#define GP_WB_WRITE_RX_RX_ANT_EXT(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x201), (val))

/* External antenna to use when internal antenna id 0 is active */
#define GP_WB_READ_RX_RX_ANT_EXT_0() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x201)) & 0x0F)

#define GP_WB_GET_RX_RX_ANT_EXT_0_FROM_RX_ANT_EXT(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_RX_RX_ANT_EXT_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x201), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_RX_RX_ANT_EXT_0_TO_RX_ANT_EXT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0xF0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* External antenna to use when internal antenna id 1 is active */
#define GP_WB_READ_RX_RX_ANT_EXT_1() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x201)) >> 4) & 0x0F)

#define GP_WB_GET_RX_RX_ANT_EXT_1_FROM_RX_ANT_EXT(tmp) \
        (((tmp) >> 4) & 0x0F)

#define GP_WB_WRITE_RX_RX_ANT_EXT_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x201), 0xF0, (val) << 4); \
        } while (0)

#define GP_WB_SET_RX_RX_ANT_EXT_1_TO_RX_ANT_EXT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_BBPRX_CONFIG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x202))

#define GP_WB_WRITE_RX_BBPRX_CONFIG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x202), (val))

/* use the lna agc (front end attenuator switched based on RSSI) */
#define GP_WB_READ_RX_EN_LNA_AGC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x202), 0)

#define GP_WB_GET_RX_EN_LNA_AGC_FROM_BBPRX_CONFIG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RX_EN_LNA_AGC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x202), 0, (val)); \
        } while (0)

#define GP_WB_SET_RX_EN_LNA_AGC_TO_BBPRX_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* antenna to use when antenna diversity is not enabled (and the mode is zb) */
#define GP_WB_READ_RX_ANT_USE_ZB() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x202), 1)

#define GP_WB_GET_RX_ANT_USE_ZB_FROM_BBPRX_CONFIG(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RX_ANT_USE_ZB(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x202), 1, (val)); \
        } while (0)

#define GP_WB_SET_RX_ANT_USE_ZB_TO_BBPRX_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* antenna to use when antenna diversity is not enabled (and the mode is ble) */
#define GP_WB_READ_RX_ANT_USE_BLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x202), 2)

#define GP_WB_GET_RX_ANT_USE_BLE_FROM_BBPRX_CONFIG(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RX_ANT_USE_BLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x202), 2, (val)); \
        } while (0)

#define GP_WB_SET_RX_ANT_USE_BLE_TO_BBPRX_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* enable Packet In Packet detection */
#define GP_WB_READ_RX_EN_PIP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x202), 3)

#define GP_WB_GET_RX_EN_PIP_FROM_BBPRX_CONFIG(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RX_EN_PIP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x202), 3, (val)); \
        } while (0)

#define GP_WB_SET_RX_EN_PIP_TO_BBPRX_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x77; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* enable Packet In Packet detection for BLE. More a debug feature, as PIP for BLE should be disabled */
#define GP_WB_READ_RX_EN_PIP_FOR_BLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x202), 4)

#define GP_WB_GET_RX_EN_PIP_FOR_BLE_FROM_BBPRX_CONFIG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RX_EN_PIP_FOR_BLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x202), 4, (val)); \
        } while (0)

#define GP_WB_SET_RX_EN_PIP_FOR_BLE_TO_BBPRX_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x6F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Range switch for lqi measurement (1 is full range/low resolution, 0 is limited range/high resolution) */
#define GP_WB_READ_RX_LQI_RANGE_SWITCH() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x202), 5)

#define GP_WB_GET_RX_LQI_RANGE_SWITCH_FROM_BBPRX_CONFIG(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RX_LQI_RANGE_SWITCH(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x202), 5, (val)); \
        } while (0)

#define GP_WB_SET_RX_LQI_RANGE_SWITCH_TO_BBPRX_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x5F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* IQ will be swapped whe the RX chain is configured in BLE mode */
#define GP_WB_READ_RX_SWAP_IQ_BLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x202), 6)

#define GP_WB_GET_RX_SWAP_IQ_BLE_FROM_BBPRX_CONFIG(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RX_SWAP_IQ_BLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x202), 6, (val)); \
        } while (0)

#define GP_WB_SET_RX_SWAP_IQ_BLE_TO_BBPRX_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* Low power preamble detect threshold */
#define GP_WB_READ_RX_PREAMBLE_THRESH_LP() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x203))

#define GP_WB_WRITE_RX_PREAMBLE_THRESH_LP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x203), (val)); \
        } while (0)


/* Zigbee preamble detect threshold used in the evaluation slot after a BLE PIP (should be same as ZB MCH) */
#define GP_WB_READ_RX_PREAMBLE_THRESH_LP_BLE_PIP() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x204))

#define GP_WB_WRITE_RX_PREAMBLE_THRESH_LP_BLE_PIP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x204), (val)); \
        } while (0)


/* BlueTooth preamble detect threshold */
#define GP_WB_READ_RX_PREAMBLE_THRESH_BT() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x206))

#define GP_WB_WRITE_RX_PREAMBLE_THRESH_BT(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x206), (val)); \
        } while (0)


/* symbol sample start, low part, (in 16MHz periods). Delay added to the preamble_det_ddec to indicate when a complete symbol is available in the delayline for starting the correlation (only relevant in sfdsearch and data_phase) */
#define GP_WB_READ_RX_SYMBOL_SAMPLE_START() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x208))

#define GP_WB_WRITE_RX_SYMBOL_SAMPLE_START(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x208), (val)); \
        } while (0)


/* timeout quard timer. Determines sfd timeout. Needs to be set differently for normal mode (10) versus LP/multichannel (12) */
#define GP_WB_READ_RX_ZB_TIMEOUT_QUARD_TIMER() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x20a))

#define GP_WB_WRITE_RX_ZB_TIMEOUT_QUARD_TIMER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x20a), (val)); \
        } while (0)

/* timeout quard timer. Determines sfd timeout. */
#define GP_WB_READ_RX_BT_TIMEOUT_QUARD_TIMER() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x20b))

#define GP_WB_WRITE_RX_BT_TIMEOUT_QUARD_TIMER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x20b), (val)); \
        } while (0)


/* antenna switch variable delay (8MHz periods) */
#define GP_WB_READ_RX_ANT_SW_VAR_DELAY() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x20c))

#define GP_WB_WRITE_RX_ANT_SW_VAR_DELAY(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x20c), (val)); \
        } while (0)


/* Carrier sense Continuous wave threshold */
#define GP_WB_READ_RX_CS_CW_THRESHOLD() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x20d))

#define GP_WB_WRITE_RX_CS_CW_THRESHOLD(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x20d), (val)); \
        } while (0)


/* Carrier sense upper threshold */
#define GP_WB_READ_RX_CS_UPPER_THRESHOLD() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x20e))

#define GP_WB_WRITE_RX_CS_UPPER_THRESHOLD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x20e), (val)); \
        } while (0)


/* Carrier sense lower threshold */
#define GP_WB_READ_RX_CS_LOWER_THRESHOLD() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x210))

#define GP_WB_WRITE_RX_CS_LOWER_THRESHOLD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x210), (val)); \
        } while (0)


/* Amount of time (in 8MHz periods) that will pass between the BBPRX being enabled and the start of the actual listening */
#define GP_WB_READ_RX_START_LISTENING_FROM_RX_ON_DELAY() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x212))

#define GP_WB_WRITE_RX_START_LISTENING_FROM_RX_ON_DELAY(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x212), (val)); \
        } while (0)


/* Amount of time (in 8MHz periods) that will pass between the sequence trigger and the start of the internal houskeeping */
#define GP_WB_READ_RX_SEQUENCE_TRIGGER_TO_INTERNAL_DELAY() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x213))

#define GP_WB_WRITE_RX_SEQUENCE_TRIGGER_TO_INTERNAL_DELAY(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x213), (val)); \
        } while (0)


/* Zb Packet In Packet threshold (in rssi_units*2) */
#define GP_WB_READ_RX_PIP_THRESH() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x214))

#define GP_WB_WRITE_RX_PIP_THRESH(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x214), (val)); \
        } while (0)


/* Half of the channel change duration in 8MHz period (theoretically equalt to 2.5us) */
#define GP_WB_READ_RX_CH_CHANGE_TUNING() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x215))

#define GP_WB_WRITE_RX_CH_CHANGE_TUNING(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x215), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_RSSI_OVERRULE_SETTINGS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x216))

#define GP_WB_WRITE_RX_RSSI_OVERRULE_SETTINGS(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x216), (val))

/* RSSI overrule value */
#define GP_WB_READ_RX_RSSI_OVERRULE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x216))

#define GP_WB_GET_RX_RSSI_OVERRULE_FROM_RSSI_OVERRULE_SETTINGS(tmp) \
        ((tmp) & 0xFF)

#define GP_WB_WRITE_RX_RSSI_OVERRULE(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x216), (val)); \
        } while (0)

#define GP_WB_SET_RX_RSSI_OVERRULE_TO_RSSI_OVERRULE_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          (tmp) &= 0x0100; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* RSSI overrule enable bit, if set to 1 the RSSI of the received packets is forced to RSSI_OVERRULE */
#define GP_WB_READ_RX_RSSI_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x217), 0)

#define GP_WB_GET_RX_RSSI_OVERRULE_ENA_FROM_RSSI_OVERRULE_SETTINGS(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_RX_RSSI_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x217), (val)); \
        } while (0)

#define GP_WB_SET_RX_RSSI_OVERRULE_ENA_TO_RSSI_OVERRULE_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x00FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_BBPRX_EVENT() \
        GP_WB_READ_SER_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x218))

/* preamble detect event */
#define GP_WB_READ_RX_ZB_PREAMBLE_DET_EV() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x218), 0)

#define GP_WB_GET_RX_ZB_PREAMBLE_DET_EV_FROM_BBPRX_EVENT(tmp) \
        ((tmp) & 0x01)

/* SFD detect event */
#define GP_WB_READ_RX_ZB_SFD_DET_EV() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x218), 1)

#define GP_WB_GET_RX_ZB_SFD_DET_EV_FROM_BBPRX_EVENT(tmp) \
        (((tmp) >> 1) & 0x01)

/* Timeout while waiting for SFD */
#define GP_WB_READ_RX_ZB_SFD_TIMEOUT_EV() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x218), 2)

#define GP_WB_GET_RX_ZB_SFD_TIMEOUT_EV_FROM_BBPRX_EVENT(tmp) \
        (((tmp) >> 2) & 0x01)

/* Packet In Packet detect event */
#define GP_WB_READ_RX_ZB_PIP_DET_EV() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x218), 3)

#define GP_WB_GET_RX_ZB_PIP_DET_EV_FROM_BBPRX_EVENT(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_READ_RX_ZB_PREAMBLE_VALIDATION_FAILED_EV() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x218), 4)

#define GP_WB_GET_RX_ZB_PREAMBLE_VALIDATION_FAILED_EV_FROM_BBPRX_EVENT(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_READ_RX_ZB_DATA_VALIDATION_FAILED_EV() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x218), 5)

#define GP_WB_GET_RX_ZB_DATA_VALIDATION_FAILED_EV_FROM_BBPRX_EVENT(tmp) \
        (((tmp) >> 5) & 0x01)

/* preamble detect event */
#define GP_WB_READ_RX_BLE_PREAMBLE_DET_EV() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x218), 6)

#define GP_WB_GET_RX_BLE_PREAMBLE_DET_EV_FROM_BBPRX_EVENT(tmp) \
        (((tmp) >> 6) & 0x01)

/* access_address detected (when bt_fen=1) */
#define GP_WB_READ_RX_BLE_FS_DET_EV() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x218), 7)

#define GP_WB_GET_RX_BLE_FS_DET_EV_FROM_BBPRX_EVENT(tmp) \
        (((tmp) >> 7) & 0x01)

/* timeout while waiting for access_address frame sync */
#define GP_WB_READ_RX_BLE_FS_TIMEOUT_EV() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x219), 0)

#define GP_WB_GET_RX_BLE_FS_TIMEOUT_EV_FROM_BBPRX_EVENT(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_READ_RX_BLE_FS_FAILED_EV() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x219), 1)

#define GP_WB_GET_RX_BLE_FS_FAILED_EV_FROM_BBPRX_EVENT(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_READ_RX_BLE_DATA_VALIDATION_FAILED_EV() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x219), 2)

#define GP_WB_GET_RX_BLE_DATA_VALIDATION_FAILED_EV_FROM_BBPRX_EVENT(tmp) \
        (((tmp) >> 10) & 0x01)

/* RSSI jump detection event */
#define GP_WB_READ_RX_RSSI_DET_EV() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x219), 3)

#define GP_WB_GET_RX_RSSI_DET_EV_FROM_BBPRX_EVENT(tmp) \
        (((tmp) >> 11) & 0x01)

/* RSSI PIP detect event */
#define GP_WB_READ_RX_RSSI_PIP_DET_EV() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x219), 4)

#define GP_WB_GET_RX_RSSI_PIP_DET_EV_FROM_BBPRX_EVENT(tmp) \
        (((tmp) >> 12) & 0x01)

/* timeout on the RSSI jump */
#define GP_WB_READ_RX_RSSI_TIMEOUT_EV() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x219), 5)

#define GP_WB_GET_RX_RSSI_TIMEOUT_EV_FROM_BBPRX_EVENT(tmp) \
        (((tmp) >> 13) & 0x01)

/* BLE Packet In Packet event, indicates a frame was aborted for the reception of a higher power frame */
#define GP_WB_READ_RX_BLE_PIP_DET_EV() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x219), 6)

#define GP_WB_GET_RX_BLE_PIP_DET_EV_FROM_BBPRX_EVENT(tmp) \
        (((tmp) >> 14) & 0x01)

/* CW detected */
#define GP_WB_READ_RX_CW_DET_EV() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x219), 7)

#define GP_WB_GET_RX_CW_DET_EV_FROM_BBPRX_EVENT(tmp) \
        (((tmp) >> 15) & 0x01)

/* packet too large event */
#define GP_WB_READ_RX_PACKET_TOO_LARGE_EV() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x21a), 0)

#define GP_WB_GET_RX_PACKET_TOO_LARGE_EV_FROM_BBPRX_EVENT(tmp) \
        (((tmp) >> 16) & 0x01)

/* packet too small event */
#define GP_WB_READ_RX_PACKET_TOO_SMALL_EV() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x21a), 1)

#define GP_WB_GET_RX_PACKET_TOO_SMALL_EV_FROM_BBPRX_EVENT(tmp) \
        (((tmp) >> 17) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_BLE_TIMEOUT_EVENTS() \
        GP_WB_READ_SER_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x21b))

#define GP_WB_READ_RX_BLE_TIMEOUT_PIP_EV() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x21b), 0)

#define GP_WB_GET_RX_BLE_TIMEOUT_PIP_EV_FROM_BLE_TIMEOUT_EVENTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_RX_BLE_TIMEOUT_PIP_ZB_FIRST_EV() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x21b), 1)

#define GP_WB_GET_RX_BLE_TIMEOUT_PIP_ZB_FIRST_EV_FROM_BLE_TIMEOUT_EVENTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_RX_BLE_TIMEOUT_SHORT_EV() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x21b), 2)

#define GP_WB_GET_RX_BLE_TIMEOUT_SHORT_EV_FROM_BLE_TIMEOUT_EVENTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_RX_BLE_TIMEOUT_LONG_EV() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x21b), 3)

#define GP_WB_GET_RX_BLE_TIMEOUT_LONG_EV_FROM_BLE_TIMEOUT_EVENTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_READ_RX_BLE_TIMEOUT_CW_END_EV() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x21b), 4)

#define GP_WB_GET_RX_BLE_TIMEOUT_CW_END_EV_FROM_BLE_TIMEOUT_EVENTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_READ_RX_BLE_TIMEOUT_CW_EV() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x21b), 5)

#define GP_WB_GET_RX_BLE_TIMEOUT_CW_EV_FROM_BLE_TIMEOUT_EVENTS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_READ_RX_BLE_TIMEOUT_BT_FAIL_EV() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x21b), 6)

#define GP_WB_GET_RX_BLE_TIMEOUT_BT_FAIL_EV_FROM_BLE_TIMEOUT_EVENTS(tmp) \
        (((tmp) >> 6) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_BLE_TIMEOUT_SET_EVENTS() \
        GP_WB_READ_SER_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x21c))

#define GP_WB_READ_RX_BLE_TIMEOUT_SET_PIP_EV() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x21c), 0)

#define GP_WB_GET_RX_BLE_TIMEOUT_SET_PIP_EV_FROM_BLE_TIMEOUT_SET_EVENTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_RX_BLE_TIMEOUT_SET_PIP_ZB_FIRST_EV() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x21c), 1)

#define GP_WB_GET_RX_BLE_TIMEOUT_SET_PIP_ZB_FIRST_EV_FROM_BLE_TIMEOUT_SET_EVENTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_RX_BLE_TIMEOUT_SET_SHORT_EV() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x21c), 2)

#define GP_WB_GET_RX_BLE_TIMEOUT_SET_SHORT_EV_FROM_BLE_TIMEOUT_SET_EVENTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_RX_BLE_TIMEOUT_SET_LONG_EV() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x21c), 3)

#define GP_WB_GET_RX_BLE_TIMEOUT_SET_LONG_EV_FROM_BLE_TIMEOUT_SET_EVENTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_READ_RX_BLE_TIMEOUT_SET_CW_END_EV() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x21c), 4)

#define GP_WB_GET_RX_BLE_TIMEOUT_SET_CW_END_EV_FROM_BLE_TIMEOUT_SET_EVENTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_READ_RX_BLE_TIMEOUT_SET_CW_EV() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x21c), 5)

#define GP_WB_GET_RX_BLE_TIMEOUT_SET_CW_EV_FROM_BLE_TIMEOUT_SET_EVENTS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_READ_RX_BLE_TIMEOUT_SET_BT_FAIL_EV() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x21c), 6)

#define GP_WB_GET_RX_BLE_TIMEOUT_SET_BT_FAIL_EV_FROM_BLE_TIMEOUT_SET_EVENTS(tmp) \
        (((tmp) >> 6) & 0x01)


/* frequency offset value */
#define GP_WB_READ_RX_FREQ_OFFSET() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x21d)) & 0x0F)

/* antenna used for last received packet */
#define GP_WB_READ_RX_ANT_USED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x21d), 4)

/* attenuation used for last received packet */
#define GP_WB_READ_RX_ATT_EN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x21d), 5)

#define GP_WB_READ_RX_DSP_POWERED_DOWN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x21d), 6)


/* RSSI (Received Signal Strength Indication) from BBP-RX, not valid when multiple rx channels active */
#define GP_WB_READ_RX_RSSI_BBPRX() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x21e))

/* RSSI (Received Signal Strength Indication) from BBP-RX, not valid when multiple rx channels active, low pass filtered version */
#define GP_WB_READ_RX_RSSI_AVE_BBPRX() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x21f))


/* LQI (Link Quality Indication) of last received packet */
#define GP_WB_READ_RX_LQI() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x220))


/* RSSI (Received Signal Strength Indication) of last received packet */
#define GP_WB_READ_RX_RSSI() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x221))


/* delay (in us) after the (early_)sfd_det at which to sample the RSSI of the incomming BLE packet */
#define GP_WB_READ_RX_BT_SAMPLE_RSSI_DELAY() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x222))

#define GP_WB_WRITE_RX_BT_SAMPLE_RSSI_DELAY(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x222), (val)); \
        } while (0)

/* selects the early_sfd_det as rssi sample source iso sfd_det */
#define GP_WB_READ_RX_BT_SAMPLE_RSSI_ON_EARLY_SFD() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x223), 0)

#define GP_WB_WRITE_RX_BT_SAMPLE_RSSI_ON_EARLY_SFD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x223), (val)); \
        } while (0)


/* 0 = off (data ind used), 1 = SFD, 2 = preamble, 3 = early preamble */
#define GP_WB_READ_RX_EARLY_IND_CONFIG() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x224)) & 0x03)

#define GP_WB_WRITE_RX_EARLY_IND_CONFIG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x224), 0x03, (val)); \
        } while (0)

/* Configures RSSI Low pass filter (only for PHY-MAC RSSI value),  0 = off, 1 = on, 2 = on (s)lower, 3 = on even (s)lower */
#define GP_WB_READ_RX_RSSI_FILTER_CONF() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x224)) >> 2) & 0x03)

#define GP_WB_WRITE_RX_RSSI_FILTER_CONF(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x224), 0x0C, (val) << 2); \
        } while (0)

/* Configures the sample rate for the RSSI low pass filter, 0=500kHz, 1=250kHz, 2=125kHz, 3=62.5kHz */
#define GP_WB_READ_RX_RSSI_AVG_SAMPLE_RATE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x224)) >> 4) & 0x03)

#define GP_WB_WRITE_RX_RSSI_AVG_SAMPLE_RATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x224), 0x30, (val) << 4); \
        } while (0)

/* when 1 disables the BLE timeout mechanism */
#define GP_WB_READ_RX_BLE_TIMEOUT_DISABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x224), 6)

#define GP_WB_WRITE_RX_BLE_TIMEOUT_DISABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x224), 6, (val)); \
        } while (0)

/* when 1 disables the DSP powerdown in experimental receive modes */
#define GP_WB_READ_RX_BT_EXP_DSP_POWERDOWN_DISABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x224), 7)

#define GP_WB_WRITE_RX_BT_EXP_DSP_POWERDOWN_DISABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x224), 7, (val)); \
        } while (0)


/* Threshold for SFD detection */
#define GP_WB_READ_RX_SFD_THRESH() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x225))

#define GP_WB_WRITE_RX_SFD_THRESH(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x225), (val)); \
        } while (0)


/* frequency tracking value */
#define GP_WB_READ_RX_FREQ_TRACK() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x226))


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_FREQUENCY_COMPENSATION() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x228))

#define GP_WB_WRITE_RX_FREQUENCY_COMPENSATION(val) \
      GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x228), (val))

/* ZigBee frequency compensation added to 2 MHz IF. Signed value with resolution of 976Hz (1kHz/1.024) */
#define GP_WB_READ_RX_FREQUENCY_COMPENSATION_ZB() \
        (GP_WB_S16(GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x228)), 16))

#define GP_WB_GET_RX_FREQUENCY_COMPENSATION_ZB_FROM_FREQUENCY_COMPENSATION(tmp) \
        (GP_WB_S16(((tmp) & 0xFFFF), 16))

#define GP_WB_WRITE_RX_FREQUENCY_COMPENSATION_ZB(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x228), (UInt16)((val))); \
        } while (0)

#define GP_WB_SET_RX_FREQUENCY_COMPENSATION_ZB_TO_FREQUENCY_COMPENSATION(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0xFFFF0000; \
          (tmp) |= (((Int32)(val)) & 0x0000FFFF); \
        } while (0)

/* BLE frequency compensation. Signed value with resolution of 244Hz (1MHz/4096) */
#define GP_WB_READ_RX_FREQUENCY_COMPENSATION_BLE() \
        (GP_WB_S16(GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x22a)), 16))

#define GP_WB_GET_RX_FREQUENCY_COMPENSATION_BLE_FROM_FREQUENCY_COMPENSATION(tmp) \
        (GP_WB_S16((((tmp) >> 16) & 0xFFFF), 16))

#define GP_WB_WRITE_RX_FREQUENCY_COMPENSATION_BLE(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x22a), (UInt16)((val))); \
        } while (0)

#define GP_WB_SET_RX_FREQUENCY_COMPENSATION_BLE_TO_FREQUENCY_COMPENSATION(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x0000FFFF; \
          (tmp) |= ((((Int32)(val)) << 16) & 0xFFFF0000); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_RSSI_THRESHOLD_CFG() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x22c))

#define GP_WB_WRITE_RX_RSSI_THRESHOLD_CFG(val) \
      GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x22c), (val))

/* Defines the RSSI jump needed in BLE only receive modes to activate the DSP */
#define GP_WB_READ_RX_RSSI_THRESHOLD_BLE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x22c))

#define GP_WB_GET_RX_RSSI_THRESHOLD_BLE_FROM_RSSI_THRESHOLD_CFG(tmp) \
        ((tmp) & 0xFF)

#define GP_WB_WRITE_RX_RSSI_THRESHOLD_BLE(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x22c), (val)); \
        } while (0)

#define GP_WB_SET_RX_RSSI_THRESHOLD_BLE_TO_RSSI_THRESHOLD_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0xFFFF00; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Defines the RSSI jump needed to trigger a rssi_pip event (rssi jump in rssi jump) */
#define GP_WB_READ_RX_RSSI_THRESHOLD_PIP() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x22d))

#define GP_WB_GET_RX_RSSI_THRESHOLD_PIP_FROM_RSSI_THRESHOLD_CFG(tmp) \
        (((tmp) >> 8) & 0xFF)

#define GP_WB_WRITE_RX_RSSI_THRESHOLD_PIP(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x22d), (val)); \
        } while (0)

#define GP_WB_SET_RX_RSSI_THRESHOLD_PIP_TO_RSSI_THRESHOLD_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0xFF00FF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* Defines the RSSI jump needed to trigger a rssi_pip event (rssi jump in rssi jump) when an active packet reception is busy */
#define GP_WB_READ_RX_RSSI_THRESHOLD_PACKET_PIP() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x22e))

#define GP_WB_GET_RX_RSSI_THRESHOLD_PACKET_PIP_FROM_RSSI_THRESHOLD_CFG(tmp) \
        (((tmp) >> 16) & 0xFF)

#define GP_WB_WRITE_RX_RSSI_THRESHOLD_PACKET_PIP(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x22e), (val)); \
        } while (0)

#define GP_WB_SET_RX_RSSI_THRESHOLD_PACKET_PIP_TO_RSSI_THRESHOLD_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x00FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_RSSI_REF_CFG() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x230))

#define GP_WB_WRITE_RX_RSSI_REF_CFG(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x230), (val))

/* Integrator window size. 0 = 32 samples, 1 = 16 samples, 2 = 8 samples */
#define GP_WB_READ_RX_RSSI_REF_WINDOW_SIZE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x230)) & 0x03)

#define GP_WB_GET_RX_RSSI_REF_WINDOW_SIZE_FROM_RSSI_REF_CFG(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_RX_RSSI_REF_WINDOW_SIZE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x230), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_RX_RSSI_REF_WINDOW_SIZE_TO_RSSI_REF_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x03FC; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Integrator window size. 0 = 32 samples, 1 = 16 samples, 2 = 8 samples */
#define GP_WB_READ_RX_RSSI_REF_WINDOW_SIZE_PIP() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x230)) >> 2) & 0x03)

#define GP_WB_GET_RX_RSSI_REF_WINDOW_SIZE_PIP_FROM_RSSI_REF_CFG(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_RX_RSSI_REF_WINDOW_SIZE_PIP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x230), 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_RX_RSSI_REF_WINDOW_SIZE_PIP_TO_RSSI_REF_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x03F3; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

#define GP_WB_READ_RX_RSSI_REF_RST_ON_RSSI_DET() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x230), 4)

#define GP_WB_GET_RX_RSSI_REF_RST_ON_RSSI_DET_FROM_RSSI_REF_CFG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RX_RSSI_REF_RST_ON_RSSI_DET(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x230), 4, (val)); \
        } while (0)

#define GP_WB_SET_RX_RSSI_REF_RST_ON_RSSI_DET_TO_RSSI_REF_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03EF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

#define GP_WB_READ_RX_RSSI_REF_RST_ON_RESTART_PACKET_DET() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x230), 5)

#define GP_WB_GET_RX_RSSI_REF_RST_ON_RESTART_PACKET_DET_FROM_RSSI_REF_CFG(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RX_RSSI_REF_RST_ON_RESTART_PACKET_DET(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x230), 5, (val)); \
        } while (0)

#define GP_WB_SET_RX_RSSI_REF_RST_ON_RESTART_PACKET_DET_TO_RSSI_REF_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03DF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

#define GP_WB_READ_RX_RSSI_REF_RST_ON_BLE_TIMEOUT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x230), 6)

#define GP_WB_GET_RX_RSSI_REF_RST_ON_BLE_TIMEOUT_FROM_RSSI_REF_CFG(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RX_RSSI_REF_RST_ON_BLE_TIMEOUT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x230), 6, (val)); \
        } while (0)

#define GP_WB_SET_RX_RSSI_REF_RST_ON_BLE_TIMEOUT_TO_RSSI_REF_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03BF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

#define GP_WB_READ_RX_RSSI_REF_RST_ON_ZB_PRE_DET() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x230), 7)

#define GP_WB_GET_RX_RSSI_REF_RST_ON_ZB_PRE_DET_FROM_RSSI_REF_CFG(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_RX_RSSI_REF_RST_ON_ZB_PRE_DET(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x230), 7, (val)); \
        } while (0)

#define GP_WB_SET_RX_RSSI_REF_RST_ON_ZB_PRE_DET_TO_RSSI_REF_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x037F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_RX_RSSI_REF_RST_ON_ZB_SFD_DET() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x231), 0)

#define GP_WB_GET_RX_RSSI_REF_RST_ON_ZB_SFD_DET_FROM_RSSI_REF_CFG(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_RX_RSSI_REF_RST_ON_ZB_SFD_DET(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x231), 0, (val)); \
        } while (0)

#define GP_WB_SET_RX_RSSI_REF_RST_ON_ZB_SFD_DET_TO_RSSI_REF_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

#define GP_WB_READ_RX_RSSI_REF_RST_ON_VALIDATION_FAIL() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x231), 1)

#define GP_WB_GET_RX_RSSI_REF_RST_ON_VALIDATION_FAIL_FROM_RSSI_REF_CFG(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_RX_RSSI_REF_RST_ON_VALIDATION_FAIL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x231), 1, (val)); \
        } while (0)

#define GP_WB_SET_RX_RSSI_REF_RST_ON_VALIDATION_FAIL_TO_RSSI_REF_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_RSSI_CONFIG3() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x232))

#define GP_WB_WRITE_RX_RSSI_CONFIG3(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x232), (val))

/* Initial delay when entering BLE slot in CC mode. default = 9 x (8 x 62.5ns) = 4.5us */
#define GP_WB_READ_RX_RSSI_CC_DELAY() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x232)) & 0x0F)

#define GP_WB_GET_RX_RSSI_CC_DELAY_FROM_RSSI_CONFIG3(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_RX_RSSI_CC_DELAY(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x232), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_RX_RSSI_CC_DELAY_TO_RSSI_CONFIG3(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0xF0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Bandpass filter overrule enable bit */
#define GP_WB_READ_RX_RSSI_BPF_BLE_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x232), 4)

#define GP_WB_GET_RX_RSSI_BPF_BLE_OVERRULE_ENA_FROM_RSSI_CONFIG3(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RX_RSSI_BPF_BLE_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x232), 4, (val)); \
        } while (0)

#define GP_WB_SET_RX_RSSI_BPF_BLE_OVERRULE_ENA_TO_RSSI_CONFIG3(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Bandpass filter overrule value. 0 = 2 MHz (Zigbee), 1 = 1 MHz (BLE) */
#define GP_WB_READ_RX_RSSI_BPF_BLE_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x232), 5)

#define GP_WB_GET_RX_RSSI_BPF_BLE_VALUE_FROM_RSSI_CONFIG3(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RX_RSSI_BPF_BLE_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x232), 5, (val)); \
        } while (0)

#define GP_WB_SET_RX_RSSI_BPF_BLE_VALUE_TO_RSSI_CONFIG3(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* Set to 1 to use the BLE_CT rssi_mode instead of BLE_EXP rssi_mode for all BLE RX activities (except MS training) */
#define GP_WB_READ_RX_RSSI_USE_BLE_CT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x232), 6)

#define GP_WB_GET_RX_RSSI_USE_BLE_CT_FROM_RSSI_CONFIG3(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RX_RSSI_USE_BLE_CT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x232), 6, (val)); \
        } while (0)

#define GP_WB_SET_RX_RSSI_USE_BLE_CT_TO_RSSI_CONFIG3(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* Set to 1 to enable the search for ZB preamlbe on an RSSI PIP detect event. */
#define GP_WB_READ_RX_RSSI_PIP_ZB_TRAIN_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x232), 7)

#define GP_WB_GET_RX_RSSI_PIP_ZB_TRAIN_ENA_FROM_RSSI_CONFIG3(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_RX_RSSI_PIP_ZB_TRAIN_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x232), 7, (val)); \
        } while (0)

#define GP_WB_SET_RX_RSSI_PIP_ZB_TRAIN_ENA_TO_RSSI_CONFIG3(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


#define GP_WB_WRITE_RX_RSSI_CALIBRATION_TRIGGER(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x233), (val))

/* Start rssi calibration */
#define GP_WB_RX_RSSI_START_CAL() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x233), 0x01)

#define GP_WB_SET_RX_RSSI_START_CAL_TO_RSSI_CALIBRATION_TRIGGER(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_RX_CLR_MAX_HOLD_RSSI2FRAMEDET() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x233), 0x02)

#define GP_WB_SET_RX_CLR_MAX_HOLD_RSSI2FRAMEDET_TO_RSSI_CALIBRATION_TRIGGER(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* Timeout value between RSSI detect and BLE packet detect, in microseconds */
#define GP_WB_READ_RX_BLE_TIMEOUT_VALUE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x234))

#define GP_WB_WRITE_RX_BLE_TIMEOUT_VALUE(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x234), (val)); \
        } while (0)


/* Long timeout value between RSSI detect and BLE packet detect, in microseconds */
#define GP_WB_READ_RX_BLE_TIMEOUT_VALUE_LONG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x235))

#define GP_WB_WRITE_RX_BLE_TIMEOUT_VALUE_LONG(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x235), (val)); \
        } while (0)


/* Timeout value to between the CW end and the BLE packet detect, in microseconds */
#define GP_WB_READ_RX_BLE_TIMEOUT_VALUE_CW_END() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x236))

#define GP_WB_WRITE_RX_BLE_TIMEOUT_VALUE_CW_END(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x236), (val)); \
        } while (0)


/* Indicates that current rssi_gain value is valid */
#define GP_WB_READ_RX_RSSI_GAIN_VALID() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x237), 0)


/* Current rssi_gain value */
#define GP_WB_READ_RX_RSSI_GAIN() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x238))


#define GP_WB_READ_RX_BLE_TIMEOUT_VALUE_PIP() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x239))

#define GP_WB_WRITE_RX_BLE_TIMEOUT_VALUE_PIP(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x239), (val)); \
        } while (0)


#define GP_WB_READ_RX_BLE_TIMEOUT_VALUE_PIP_ZB_FIRST() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x23a))

#define GP_WB_WRITE_RX_BLE_TIMEOUT_VALUE_PIP_ZB_FIRST(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x23a), (val)); \
        } while (0)


/* number of RSSI samples needed to allow the pip_zb_first feature to work. (this is to prevent zb_first on RSSI detects with too much delay) */
#define GP_WB_READ_RX_RSSI_PIP_ZB_FIRST_THR() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x23b))

#define GP_WB_WRITE_RX_RSSI_PIP_ZB_FIRST_THR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x23b), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_RSSI_OFFSET() \
        GP_WB_READ_U64(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x23c))

#define GP_WB_WRITE_RX_RSSI_OFFSET(val) \
      GP_WB_WRITE_U64(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x23c), (val))

/* Calibrated offset compensation setting for rx modes without attenuation, applied to all rssi, pip, ed and cca measurements */
#define GP_WB_READ_RX_RSSI_OFFSET_NO_ATT() \
        (GP_WB_S8(GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x23c)), 8))

#define GP_WB_GET_RX_RSSI_OFFSET_NO_ATT_FROM_RSSI_OFFSET(tmp) \
        (GP_WB_S8(((tmp) & 0xFF), 8))

#define GP_WB_WRITE_RX_RSSI_OFFSET_NO_ATT(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x23c), (UInt8)((val))); \
        } while (0)

#define GP_WB_SET_RX_RSSI_OFFSET_NO_ATT_TO_RSSI_OFFSET(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFFFFFFFFFF00; \
          (tmp) |= (((Int64)(val)) & 0x00000000000000FF); \
        } while (0)

/* Calibrated offset compensation setting for rx modes with low attenuation, applied to all rssi, pip, ed and cca measurements */
#define GP_WB_READ_RX_RSSI_OFFSET_LOW_ATT() \
        (GP_WB_S8(GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x23d)), 8))

#define GP_WB_GET_RX_RSSI_OFFSET_LOW_ATT_FROM_RSSI_OFFSET(tmp) \
        (GP_WB_S8((((tmp) >> 8) & 0xFF), 8))

#define GP_WB_WRITE_RX_RSSI_OFFSET_LOW_ATT(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x23d), (UInt8)((val))); \
        } while (0)

#define GP_WB_SET_RX_RSSI_OFFSET_LOW_ATT_TO_RSSI_OFFSET(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFFFFFFFF00FF; \
          (tmp) |= ((((Int64)(val)) << 8) & 0x000000000000FF00); \
        } while (0)

/* Calibrated offset compensation setting for rx modes with attenuation, applied to all rssi, pip, ed and cca measurements */
#define GP_WB_READ_RX_RSSI_OFFSET_ATT() \
        (GP_WB_S8(GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x23e)), 8))

#define GP_WB_GET_RX_RSSI_OFFSET_ATT_FROM_RSSI_OFFSET(tmp) \
        (GP_WB_S8((((tmp) >> 16) & 0xFF), 8))

#define GP_WB_WRITE_RX_RSSI_OFFSET_ATT(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x23e), (UInt8)((val))); \
        } while (0)

#define GP_WB_SET_RX_RSSI_OFFSET_ATT_TO_RSSI_OFFSET(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFFFFFF00FFFF; \
          (tmp) |= ((((Int64)(val)) << 16) & 0x0000000000FF0000); \
        } while (0)

/* Calibrated offset compensation setting for fast-synchronous rssi mode and rx modes without attenuation, applied to all rssi, pip, ed and cca measurements */
#define GP_WB_READ_RX_RSSI_OFFSET_FS_MODE_NO_ATT() \
        (GP_WB_S8(GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x23f)), 8))

#define GP_WB_GET_RX_RSSI_OFFSET_FS_MODE_NO_ATT_FROM_RSSI_OFFSET(tmp) \
        (GP_WB_S8((((tmp) >> 24) & 0xFF), 8))

#define GP_WB_WRITE_RX_RSSI_OFFSET_FS_MODE_NO_ATT(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x23f), (UInt8)((val))); \
        } while (0)

#define GP_WB_SET_RX_RSSI_OFFSET_FS_MODE_NO_ATT_TO_RSSI_OFFSET(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFFFF00FFFFFF; \
          (tmp) |= ((((Int64)(val)) << 24) & 0x00000000FF000000); \
        } while (0)

/* Calibrated offset compensation setting for fast-synchronous rssi mode and rx modes with low attenuation, applied to all rssi, pip, ed and cca measurements */
#define GP_WB_READ_RX_RSSI_OFFSET_FS_MODE_LOW_ATT() \
        (GP_WB_S8(GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x240)), 8))

#define GP_WB_GET_RX_RSSI_OFFSET_FS_MODE_LOW_ATT_FROM_RSSI_OFFSET(tmp) \
        (GP_WB_S8((((tmp) >> 32) & 0xFF), 8))

#define GP_WB_WRITE_RX_RSSI_OFFSET_FS_MODE_LOW_ATT(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x240), (UInt8)((val))); \
        } while (0)

#define GP_WB_SET_RX_RSSI_OFFSET_FS_MODE_LOW_ATT_TO_RSSI_OFFSET(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFF00FFFFFFFF; \
          (tmp) |= ((((Int64)(val)) << 32) & 0x000000FF00000000); \
        } while (0)

/* Calibrated offset compensation setting for fast-synchronous rssi mode and rx modes with attenuation, applied to all rssi, pip, ed and cca measurements */
#define GP_WB_READ_RX_RSSI_OFFSET_FS_MODE_ATT() \
        (GP_WB_S8(GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x241)), 8))

#define GP_WB_GET_RX_RSSI_OFFSET_FS_MODE_ATT_FROM_RSSI_OFFSET(tmp) \
        (GP_WB_S8((((tmp) >> 40) & 0xFF), 8))

#define GP_WB_WRITE_RX_RSSI_OFFSET_FS_MODE_ATT(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x241), (UInt8)((val))); \
        } while (0)

#define GP_WB_SET_RX_RSSI_OFFSET_FS_MODE_ATT_TO_RSSI_OFFSET(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFF00FFFFFFFFFF; \
          (tmp) |= ((((Int64)(val)) << 40) & 0x0000FF0000000000); \
        } while (0)

/* Additional offset to be applied depending on the external PA/LNA configuration */
#define GP_WB_READ_RX_RSSI_OFFSET_A() \
        (GP_WB_S8(GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x242)), 8))

#define GP_WB_GET_RX_RSSI_OFFSET_A_FROM_RSSI_OFFSET(tmp) \
        (GP_WB_S8((((tmp) >> 48) & 0xFF), 8))

#define GP_WB_WRITE_RX_RSSI_OFFSET_A(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x242), (UInt8)((val))); \
        } while (0)

#define GP_WB_SET_RX_RSSI_OFFSET_A_TO_RSSI_OFFSET(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFF00FFFFFFFFFFFF; \
          (tmp) |= ((((Int64)(val)) << 48) & 0x00FF000000000000); \
        } while (0)

/* Additional alternative offset to be applied depending on the external PA/LNA configuration (rssi_offset_sel selects either a or b offset) */
#define GP_WB_READ_RX_RSSI_OFFSET_B() \
        (GP_WB_S8(GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x243)), 8))

#define GP_WB_GET_RX_RSSI_OFFSET_B_FROM_RSSI_OFFSET(tmp) \
        (GP_WB_S8((((tmp) >> 56) & 0xFF), 8))

#define GP_WB_WRITE_RX_RSSI_OFFSET_B(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x243), (UInt8)((val))); \
        } while (0)

#define GP_WB_SET_RX_RSSI_OFFSET_B_TO_RSSI_OFFSET(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0x00FFFFFFFFFFFFFF; \
          (tmp) |= ((((Int64)(val)) << 56) & 0xFF00000000000000); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_RSSI_OFFSET_1() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x244))

#define GP_WB_WRITE_RX_RSSI_OFFSET_1(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x244), (val))

/* Selects one of the calibrated offset compensation settings */
#define GP_WB_READ_RX_RSSI_OFFSET_SEL() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x244), 0)

#define GP_WB_GET_RX_RSSI_OFFSET_SEL_FROM_RSSI_OFFSET_1(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RX_RSSI_OFFSET_SEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x244), 0, (val)); \
        } while (0)

#define GP_WB_SET_RX_RSSI_OFFSET_SEL_TO_RSSI_OFFSET_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Use the internal (0) or external (1) antenna switch signal for the RSSI and LNA AGC */
#define GP_WB_READ_RX_RSSI_USE_ANTSW() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x244), 1)

#define GP_WB_GET_RX_RSSI_USE_ANTSW_FROM_RSSI_OFFSET_1(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RX_RSSI_USE_ANTSW(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x244), 1, (val)); \
        } while (0)

#define GP_WB_SET_RX_RSSI_USE_ANTSW_TO_RSSI_OFFSET_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* DEBUG, MAY BE REMOVED BEFORE TAPEOUT. Selects which RSSI source to use for the RSSI_DSP */
#define GP_WB_READ_RX_RSSI_DSP_USE_RAW_RSSI() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x244), 2)

#define GP_WB_GET_RX_RSSI_DSP_USE_RAW_RSSI_FROM_RSSI_OFFSET_1(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RX_RSSI_DSP_USE_RAW_RSSI(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x244), 2, (val)); \
        } while (0)

#define GP_WB_SET_RX_RSSI_DSP_USE_RAW_RSSI_TO_RSSI_OFFSET_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* option to force on the RSSI DSP in non RSSI based modes. RSSI DSP will then be able to generate rssi detect events etc. */
#define GP_WB_READ_RX_RSSI_DSP_FORCE_ON() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x244), 3)

#define GP_WB_GET_RX_RSSI_DSP_FORCE_ON_FROM_RSSI_OFFSET_1(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RX_RSSI_DSP_FORCE_ON(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x244), 3, (val)); \
        } while (0)

#define GP_WB_SET_RX_RSSI_DSP_FORCE_ON_TO_RSSI_OFFSET_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_LNA_AGC_EN_CH() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x245))

#define GP_WB_WRITE_RX_LNA_AGC_EN_CH(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x245), (val))

/* use the lna agc (front end attenuator switched based on RSSI) */
#define GP_WB_READ_RX_LNA_AGC_EN_CH0() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x245), 0)

#define GP_WB_GET_RX_LNA_AGC_EN_CH0_FROM_LNA_AGC_EN_CH(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RX_LNA_AGC_EN_CH0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x245), 0, (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_AGC_EN_CH0_TO_LNA_AGC_EN_CH(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* config for chidx1 */
#define GP_WB_READ_RX_LNA_AGC_EN_CH1() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x245), 1)

#define GP_WB_GET_RX_LNA_AGC_EN_CH1_FROM_LNA_AGC_EN_CH(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RX_LNA_AGC_EN_CH1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x245), 1, (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_AGC_EN_CH1_TO_LNA_AGC_EN_CH(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* config for chidx2 */
#define GP_WB_READ_RX_LNA_AGC_EN_CH2() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x245), 2)

#define GP_WB_GET_RX_LNA_AGC_EN_CH2_FROM_LNA_AGC_EN_CH(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RX_LNA_AGC_EN_CH2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x245), 2, (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_AGC_EN_CH2_TO_LNA_AGC_EN_CH(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* config for chidx2 */
#define GP_WB_READ_RX_LNA_AGC_EN_CH3() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x245), 3)

#define GP_WB_GET_RX_LNA_AGC_EN_CH3_FROM_LNA_AGC_EN_CH(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RX_LNA_AGC_EN_CH3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x245), 3, (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_AGC_EN_CH3_TO_LNA_AGC_EN_CH(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* config for chidx3 */
#define GP_WB_READ_RX_LNA_AGC_EN_CH4() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x245), 4)

#define GP_WB_GET_RX_LNA_AGC_EN_CH4_FROM_LNA_AGC_EN_CH(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RX_LNA_AGC_EN_CH4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x245), 4, (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_AGC_EN_CH4_TO_LNA_AGC_EN_CH(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* config for chidx4 */
#define GP_WB_READ_RX_LNA_AGC_EN_CH5() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x245), 5)

#define GP_WB_GET_RX_LNA_AGC_EN_CH5_FROM_LNA_AGC_EN_CH(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RX_LNA_AGC_EN_CH5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x245), 5, (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_AGC_EN_CH5_TO_LNA_AGC_EN_CH(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_LNA_FIXED_ATT_CH() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x246))

#define GP_WB_WRITE_RX_LNA_FIXED_ATT_CH(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x246), (val))

/* lna config (attenuated or not) to be used when the agc is not enabled */
#define GP_WB_READ_RX_LNA_FIXED_ATT_CH0() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x246), 0)

#define GP_WB_GET_RX_LNA_FIXED_ATT_CH0_FROM_LNA_FIXED_ATT_CH(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RX_LNA_FIXED_ATT_CH0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x246), 0, (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_FIXED_ATT_CH0_TO_LNA_FIXED_ATT_CH(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* config for chidx1 */
#define GP_WB_READ_RX_LNA_FIXED_ATT_CH1() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x246), 1)

#define GP_WB_GET_RX_LNA_FIXED_ATT_CH1_FROM_LNA_FIXED_ATT_CH(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RX_LNA_FIXED_ATT_CH1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x246), 1, (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_FIXED_ATT_CH1_TO_LNA_FIXED_ATT_CH(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* config for chidx2 */
#define GP_WB_READ_RX_LNA_FIXED_ATT_CH2() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x246), 2)

#define GP_WB_GET_RX_LNA_FIXED_ATT_CH2_FROM_LNA_FIXED_ATT_CH(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RX_LNA_FIXED_ATT_CH2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x246), 2, (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_FIXED_ATT_CH2_TO_LNA_FIXED_ATT_CH(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* config for chidx3 */
#define GP_WB_READ_RX_LNA_FIXED_ATT_CH3() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x246), 3)

#define GP_WB_GET_RX_LNA_FIXED_ATT_CH3_FROM_LNA_FIXED_ATT_CH(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RX_LNA_FIXED_ATT_CH3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x246), 3, (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_FIXED_ATT_CH3_TO_LNA_FIXED_ATT_CH(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* config for chidx4 */
#define GP_WB_READ_RX_LNA_FIXED_ATT_CH4() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x246), 4)

#define GP_WB_GET_RX_LNA_FIXED_ATT_CH4_FROM_LNA_FIXED_ATT_CH(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RX_LNA_FIXED_ATT_CH4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x246), 4, (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_FIXED_ATT_CH4_TO_LNA_FIXED_ATT_CH(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* config for chidx5 */
#define GP_WB_READ_RX_LNA_FIXED_ATT_CH5() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x246), 5)

#define GP_WB_GET_RX_LNA_FIXED_ATT_CH5_FROM_LNA_FIXED_ATT_CH(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RX_LNA_FIXED_ATT_CH5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x246), 5, (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_FIXED_ATT_CH5_TO_LNA_FIXED_ATT_CH(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_LNA_AGC_SETTINGS_0() \
        GP_WB_READ_U40(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x248))

#define GP_WB_WRITE_RX_LNA_AGC_SETTINGS_0(val) \
      GP_WB_WRITE_U40(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x248), (val))

/* Delay (62.5ns units) before updating rssi after a front end change (e.g. LNA switched) happened.  in 16MHz clks. */
#define GP_WB_READ_RX_RSSI_SETTLE_DELAY() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x248))

#define GP_WB_GET_RX_RSSI_SETTLE_DELAY_FROM_LNA_AGC_SETTINGS_0(tmp) \
        ((tmp) & 0xFF)

#define GP_WB_WRITE_RX_RSSI_SETTLE_DELAY(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x248), (val)); \
        } while (0)

#define GP_WB_SET_RX_RSSI_SETTLE_DELAY_TO_LNA_AGC_SETTINGS_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0x0FFFFFFF00; \
          (tmp) |= ((UInt64)(val)); \
        } while (0)

/* Delay (62.5ns units) before updating rssi after a front end change (e.g. LNA switched) happened.  in 16MHz clks. */
#define GP_WB_READ_RX_RSSI_SETTLE_DELAY_FS_MODE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x249))

#define GP_WB_GET_RX_RSSI_SETTLE_DELAY_FS_MODE_FROM_LNA_AGC_SETTINGS_0(tmp) \
        (((tmp) >> 8) & 0xFF)

#define GP_WB_WRITE_RX_RSSI_SETTLE_DELAY_FS_MODE(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x249), (val)); \
        } while (0)

#define GP_WB_SET_RX_RSSI_SETTLE_DELAY_FS_MODE_TO_LNA_AGC_SETTINGS_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0x0FFFFF00FF; \
          (tmp) |= (((UInt64)(val)) << 8); \
        } while (0)

/* Fast attack resets the averaging integrator with the current rssi if the current rssi is thr_fast_attack (rssi units) above the averaged rssi. */
#define GP_WB_READ_RX_LNA_AGC_THR_FAST_ATTACK() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x24a))

#define GP_WB_GET_RX_LNA_AGC_THR_FAST_ATTACK_FROM_LNA_AGC_SETTINGS_0(tmp) \
        (((tmp) >> 16) & 0xFF)

#define GP_WB_WRITE_RX_LNA_AGC_THR_FAST_ATTACK(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x24a), (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_AGC_THR_FAST_ATTACK_TO_LNA_AGC_SETTINGS_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0x0FFF00FFFF; \
          (tmp) |= (((UInt64)(val)) << 16); \
        } while (0)

/* Fast decay resets the averaging integrator with the current rssi if the current rssi is thr_fast_decay (rssi units) below the averaged rssi. */
#define GP_WB_READ_RX_LNA_AGC_THR_FAST_DECAY() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x24b))

#define GP_WB_GET_RX_LNA_AGC_THR_FAST_DECAY_FROM_LNA_AGC_SETTINGS_0(tmp) \
        (((tmp) >> 24) & 0xFF)

#define GP_WB_WRITE_RX_LNA_AGC_THR_FAST_DECAY(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x24b), (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_AGC_THR_FAST_DECAY_TO_LNA_AGC_SETTINGS_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0x0F00FFFFFF; \
          (tmp) |= (((UInt64)(val)) << 24); \
        } while (0)

/* Amount of samples-1 during which the old reference is still used to detect a fast attack or decay situation */
#define GP_WB_READ_RX_LNA_AGC_FAST_LEN() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x24c)) & 0x03)

#define GP_WB_GET_RX_LNA_AGC_FAST_LEN_FROM_LNA_AGC_SETTINGS_0(tmp) \
        (((tmp) >> 32) & 0x03)

#define GP_WB_WRITE_RX_LNA_AGC_FAST_LEN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x24c), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_AGC_FAST_LEN_TO_LNA_AGC_SETTINGS_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x0CFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 32); \
        } while (0)

/* Amount of samples-1 that need to be in the averaging filter before it is considered valid. More is slower, but less noisy. Less is faster but noisier. */
#define GP_WB_READ_RX_LNA_AGC_AVG_LEN() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x24c)) >> 2) & 0x03)

#define GP_WB_GET_RX_LNA_AGC_AVG_LEN_FROM_LNA_AGC_SETTINGS_0(tmp) \
        (((tmp) >> 34) & 0x03)

#define GP_WB_WRITE_RX_LNA_AGC_AVG_LEN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x24c), 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_RX_LNA_AGC_AVG_LEN_TO_LNA_AGC_SETTINGS_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x03FFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 34); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_LNA_AGC_SETTINGS_1() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x250))

#define GP_WB_WRITE_RX_LNA_AGC_SETTINGS_1(val) \
      GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x250), (val))

/* rssi threshold to switch to low attentuation (high sensitivity) mode for ZigBee */
#define GP_WB_READ_RX_LNA_AGC_THR_LOW_ZB() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x250))

#define GP_WB_GET_RX_LNA_AGC_THR_LOW_ZB_FROM_LNA_AGC_SETTINGS_1(tmp) \
        ((tmp) & 0xFF)

#define GP_WB_WRITE_RX_LNA_AGC_THR_LOW_ZB(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x250), (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_AGC_THR_LOW_ZB_TO_LNA_AGC_SETTINGS_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0xFFFFFF00; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* rssi threshold to switch to high attentuation (low sensitivity) mode for ZigBee */
#define GP_WB_READ_RX_LNA_AGC_THR_HIGH_ZB() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x251))

#define GP_WB_GET_RX_LNA_AGC_THR_HIGH_ZB_FROM_LNA_AGC_SETTINGS_1(tmp) \
        (((tmp) >> 8) & 0xFF)

#define GP_WB_WRITE_RX_LNA_AGC_THR_HIGH_ZB(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x251), (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_AGC_THR_HIGH_ZB_TO_LNA_AGC_SETTINGS_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0xFFFF00FF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* rssi threshold to switch to low attentuation (high sensitivity) mode for BLE */
#define GP_WB_READ_RX_LNA_AGC_THR_LOW_BLE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x252))

#define GP_WB_GET_RX_LNA_AGC_THR_LOW_BLE_FROM_LNA_AGC_SETTINGS_1(tmp) \
        (((tmp) >> 16) & 0xFF)

#define GP_WB_WRITE_RX_LNA_AGC_THR_LOW_BLE(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x252), (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_AGC_THR_LOW_BLE_TO_LNA_AGC_SETTINGS_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0xFF00FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* rssi threshold to switch to high attentuation (low sensitivity) mode for BLE */
#define GP_WB_READ_RX_LNA_AGC_THR_HIGH_BLE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x253))

#define GP_WB_GET_RX_LNA_AGC_THR_HIGH_BLE_FROM_LNA_AGC_SETTINGS_1(tmp) \
        (((tmp) >> 24) & 0xFF)

#define GP_WB_WRITE_RX_LNA_AGC_THR_HIGH_BLE(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x253), (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_AGC_THR_HIGH_BLE_TO_LNA_AGC_SETTINGS_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x00FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_LNA_AGC_SETTINGS_2() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x254))

#define GP_WB_WRITE_RX_LNA_AGC_SETTINGS_2(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x254), (val))

/* Enable timeout feature */
#define GP_WB_READ_RX_LNA_AGC_ENABLE_TIMEOUT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x254), 0)

#define GP_WB_GET_RX_LNA_AGC_ENABLE_TIMEOUT_FROM_LNA_AGC_SETTINGS_2(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RX_LNA_AGC_ENABLE_TIMEOUT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x254), 0, (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_AGC_ENABLE_TIMEOUT_TO_LNA_AGC_SETTINGS_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FE; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Enable attenuation during the timeout */
#define GP_WB_READ_RX_LNA_AGC_ENABLE_ATT_DURING_TIMEOUT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x254), 1)

#define GP_WB_GET_RX_LNA_AGC_ENABLE_ATT_DURING_TIMEOUT_FROM_LNA_AGC_SETTINGS_2(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RX_LNA_AGC_ENABLE_ATT_DURING_TIMEOUT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x254), 1, (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_AGC_ENABLE_ATT_DURING_TIMEOUT_TO_LNA_AGC_SETTINGS_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FD; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

/* Set avg_len to 0 during the ZB training phase in RX concurrent mode */
#define GP_WB_READ_RX_LNA_AGC_EN_AVG_LEN_0_DURING_ZB_TRAINING() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x254), 2)

#define GP_WB_GET_RX_LNA_AGC_EN_AVG_LEN_0_DURING_ZB_TRAINING_FROM_LNA_AGC_SETTINGS_2(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RX_LNA_AGC_EN_AVG_LEN_0_DURING_ZB_TRAINING(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x254), 2, (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_AGC_EN_AVG_LEN_0_DURING_ZB_TRAINING_TO_LNA_AGC_SETTINGS_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FB; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* Select frame detection */
#define GP_WB_READ_RX_LNA_AGC_FRAME_DET_SEL_ZB() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x254)) >> 3) & 0x03)

#define GP_WB_GET_RX_LNA_AGC_FRAME_DET_SEL_ZB_FROM_LNA_AGC_SETTINGS_2(tmp) \
        (((tmp) >> 3) & 0x03)

#define GP_WB_WRITE_RX_LNA_AGC_FRAME_DET_SEL_ZB(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x254), 0x18, (val) << 3); \
        } while (0)

#define GP_WB_SET_RX_LNA_AGC_FRAME_DET_SEL_ZB_TO_LNA_AGC_SETTINGS_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x01E7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

/* Select frame detection */
#define GP_WB_READ_RX_LNA_AGC_FRAME_DET_SEL_BLE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x254)) >> 5) & 0x07)

#define GP_WB_GET_RX_LNA_AGC_FRAME_DET_SEL_BLE_FROM_LNA_AGC_SETTINGS_2(tmp) \
        (((tmp) >> 5) & 0x07)

#define GP_WB_WRITE_RX_LNA_AGC_FRAME_DET_SEL_BLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x254), 0xE0, (val) << 5); \
        } while (0)

#define GP_WB_SET_RX_LNA_AGC_FRAME_DET_SEL_BLE_TO_LNA_AGC_SETTINGS_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x011F; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

/* Enable the timeout extension when a BLE PIP is detected during the timeout window */
#define GP_WB_READ_RX_LNA_AGC_EN_BLE_PIP_DET_TIMEOUT_EXT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x255), 0)

#define GP_WB_GET_RX_LNA_AGC_EN_BLE_PIP_DET_TIMEOUT_EXT_FROM_LNA_AGC_SETTINGS_2(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_RX_LNA_AGC_EN_BLE_PIP_DET_TIMEOUT_EXT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x255), (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_AGC_EN_BLE_PIP_DET_TIMEOUT_EXT_TO_LNA_AGC_SETTINGS_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x00FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_LNA_AGC_TIMEOUT_VALUES_0() \
        GP_WB_READ_U64(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x258))

#define GP_WB_WRITE_RX_LNA_AGC_TIMEOUT_VALUES_0(val) \
      GP_WB_WRITE_U64(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x258), (val))

/* Timeout value in us, minus 1, config for antenna 0, chidx0 */
#define GP_WB_READ_RX_LNA_AGC_TIMEOUT_ANT0_CH0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x258))

#define GP_WB_GET_RX_LNA_AGC_TIMEOUT_ANT0_CH0_FROM_LNA_AGC_TIMEOUT_VALUES_0(tmp) \
        ((tmp) & 0xFF)

#define GP_WB_WRITE_RX_LNA_AGC_TIMEOUT_ANT0_CH0(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x258), (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_AGC_TIMEOUT_ANT0_CH0_TO_LNA_AGC_TIMEOUT_VALUES_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFFFFFFFFFF00; \
          (tmp) |= ((UInt64)(val)); \
        } while (0)

/* config for antenna 1, chidx0 */
#define GP_WB_READ_RX_LNA_AGC_TIMEOUT_ANT1_CH0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x259))

#define GP_WB_GET_RX_LNA_AGC_TIMEOUT_ANT1_CH0_FROM_LNA_AGC_TIMEOUT_VALUES_0(tmp) \
        (((tmp) >> 8) & 0xFF)

#define GP_WB_WRITE_RX_LNA_AGC_TIMEOUT_ANT1_CH0(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x259), (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_AGC_TIMEOUT_ANT1_CH0_TO_LNA_AGC_TIMEOUT_VALUES_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFFFFFFFF00FF; \
          (tmp) |= (((UInt64)(val)) << 8); \
        } while (0)

/* config for antenna 0, chidx1 */
#define GP_WB_READ_RX_LNA_AGC_TIMEOUT_ANT0_CH1() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x25a))

#define GP_WB_GET_RX_LNA_AGC_TIMEOUT_ANT0_CH1_FROM_LNA_AGC_TIMEOUT_VALUES_0(tmp) \
        (((tmp) >> 16) & 0xFF)

#define GP_WB_WRITE_RX_LNA_AGC_TIMEOUT_ANT0_CH1(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x25a), (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_AGC_TIMEOUT_ANT0_CH1_TO_LNA_AGC_TIMEOUT_VALUES_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFFFFFF00FFFF; \
          (tmp) |= (((UInt64)(val)) << 16); \
        } while (0)

/* config for antenna 1, chidx1 */
#define GP_WB_READ_RX_LNA_AGC_TIMEOUT_ANT1_CH1() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x25b))

#define GP_WB_GET_RX_LNA_AGC_TIMEOUT_ANT1_CH1_FROM_LNA_AGC_TIMEOUT_VALUES_0(tmp) \
        (((tmp) >> 24) & 0xFF)

#define GP_WB_WRITE_RX_LNA_AGC_TIMEOUT_ANT1_CH1(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x25b), (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_AGC_TIMEOUT_ANT1_CH1_TO_LNA_AGC_TIMEOUT_VALUES_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFFFF00FFFFFF; \
          (tmp) |= (((UInt64)(val)) << 24); \
        } while (0)

/* config for antenna 0, chidx2 */
#define GP_WB_READ_RX_LNA_AGC_TIMEOUT_ANT0_CH2() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x25c))

#define GP_WB_GET_RX_LNA_AGC_TIMEOUT_ANT0_CH2_FROM_LNA_AGC_TIMEOUT_VALUES_0(tmp) \
        (((tmp) >> 32) & 0xFF)

#define GP_WB_WRITE_RX_LNA_AGC_TIMEOUT_ANT0_CH2(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x25c), (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_AGC_TIMEOUT_ANT0_CH2_TO_LNA_AGC_TIMEOUT_VALUES_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFF00FFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 32); \
        } while (0)

/* config for antenna 1, chidx2 */
#define GP_WB_READ_RX_LNA_AGC_TIMEOUT_ANT1_CH2() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x25d))

#define GP_WB_GET_RX_LNA_AGC_TIMEOUT_ANT1_CH2_FROM_LNA_AGC_TIMEOUT_VALUES_0(tmp) \
        (((tmp) >> 40) & 0xFF)

#define GP_WB_WRITE_RX_LNA_AGC_TIMEOUT_ANT1_CH2(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x25d), (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_AGC_TIMEOUT_ANT1_CH2_TO_LNA_AGC_TIMEOUT_VALUES_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFF00FFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 40); \
        } while (0)

/* config for antenna 0, chidx3 */
#define GP_WB_READ_RX_LNA_AGC_TIMEOUT_ANT0_CH3() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x25e))

#define GP_WB_GET_RX_LNA_AGC_TIMEOUT_ANT0_CH3_FROM_LNA_AGC_TIMEOUT_VALUES_0(tmp) \
        (((tmp) >> 48) & 0xFF)

#define GP_WB_WRITE_RX_LNA_AGC_TIMEOUT_ANT0_CH3(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x25e), (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_AGC_TIMEOUT_ANT0_CH3_TO_LNA_AGC_TIMEOUT_VALUES_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFF00FFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 48); \
        } while (0)

/* config for antenna 1, chidx3 */
#define GP_WB_READ_RX_LNA_AGC_TIMEOUT_ANT1_CH3() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x25f))

#define GP_WB_GET_RX_LNA_AGC_TIMEOUT_ANT1_CH3_FROM_LNA_AGC_TIMEOUT_VALUES_0(tmp) \
        (((tmp) >> 56) & 0xFF)

#define GP_WB_WRITE_RX_LNA_AGC_TIMEOUT_ANT1_CH3(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x25f), (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_AGC_TIMEOUT_ANT1_CH3_TO_LNA_AGC_TIMEOUT_VALUES_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0x00FFFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 56); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_LNA_AGC_TIMEOUT_VALUES_1() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x260))

#define GP_WB_WRITE_RX_LNA_AGC_TIMEOUT_VALUES_1(val) \
      GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x260), (val))

/* config for antenna 0, chidx4 */
#define GP_WB_READ_RX_LNA_AGC_TIMEOUT_ANT0_CH4() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x260))

#define GP_WB_GET_RX_LNA_AGC_TIMEOUT_ANT0_CH4_FROM_LNA_AGC_TIMEOUT_VALUES_1(tmp) \
        ((tmp) & 0xFF)

#define GP_WB_WRITE_RX_LNA_AGC_TIMEOUT_ANT0_CH4(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x260), (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_AGC_TIMEOUT_ANT0_CH4_TO_LNA_AGC_TIMEOUT_VALUES_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0xFFFFFF00; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* config for antenna 1, chidx4 */
#define GP_WB_READ_RX_LNA_AGC_TIMEOUT_ANT1_CH4() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x261))

#define GP_WB_GET_RX_LNA_AGC_TIMEOUT_ANT1_CH4_FROM_LNA_AGC_TIMEOUT_VALUES_1(tmp) \
        (((tmp) >> 8) & 0xFF)

#define GP_WB_WRITE_RX_LNA_AGC_TIMEOUT_ANT1_CH4(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x261), (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_AGC_TIMEOUT_ANT1_CH4_TO_LNA_AGC_TIMEOUT_VALUES_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0xFFFF00FF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* config for antenna 0, chidx5 */
#define GP_WB_READ_RX_LNA_AGC_TIMEOUT_ANT0_CH5() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x262))

#define GP_WB_GET_RX_LNA_AGC_TIMEOUT_ANT0_CH5_FROM_LNA_AGC_TIMEOUT_VALUES_1(tmp) \
        (((tmp) >> 16) & 0xFF)

#define GP_WB_WRITE_RX_LNA_AGC_TIMEOUT_ANT0_CH5(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x262), (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_AGC_TIMEOUT_ANT0_CH5_TO_LNA_AGC_TIMEOUT_VALUES_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0xFF00FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* config for antenna 1, chidx5 */
#define GP_WB_READ_RX_LNA_AGC_TIMEOUT_ANT1_CH5() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x263))

#define GP_WB_GET_RX_LNA_AGC_TIMEOUT_ANT1_CH5_FROM_LNA_AGC_TIMEOUT_VALUES_1(tmp) \
        (((tmp) >> 24) & 0xFF)

#define GP_WB_WRITE_RX_LNA_AGC_TIMEOUT_ANT1_CH5(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x263), (val)); \
        } while (0)

#define GP_WB_SET_RX_LNA_AGC_TIMEOUT_ANT1_CH5_TO_LNA_AGC_TIMEOUT_VALUES_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x00FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_LNA_AGC_STATUS() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x264))

/* current lna agc status for chidx and antenna (1=attenuated), for debug */
#define GP_WB_READ_RX_LNA_AGC_ATT_ANT0_CH0() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x264)) & 0x03)

#define GP_WB_GET_RX_LNA_AGC_ATT_ANT0_CH0_FROM_LNA_AGC_STATUS(tmp) \
        ((tmp) & 0x03)

/* status for chidx and antenna */
#define GP_WB_READ_RX_LNA_AGC_ATT_ANT1_CH0() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x264)) >> 2) & 0x03)

#define GP_WB_GET_RX_LNA_AGC_ATT_ANT1_CH0_FROM_LNA_AGC_STATUS(tmp) \
        (((tmp) >> 2) & 0x03)

/* status for chidx and antenna */
#define GP_WB_READ_RX_LNA_AGC_ATT_ANT0_CH1() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x264)) >> 4) & 0x03)

#define GP_WB_GET_RX_LNA_AGC_ATT_ANT0_CH1_FROM_LNA_AGC_STATUS(tmp) \
        (((tmp) >> 4) & 0x03)

/* status for chidx and antenna */
#define GP_WB_READ_RX_LNA_AGC_ATT_ANT1_CH1() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x264)) >> 6) & 0x03)

#define GP_WB_GET_RX_LNA_AGC_ATT_ANT1_CH1_FROM_LNA_AGC_STATUS(tmp) \
        (((tmp) >> 6) & 0x03)

/* status for chidx and antenna */
#define GP_WB_READ_RX_LNA_AGC_ATT_ANT0_CH2() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x265)) & 0x03)

#define GP_WB_GET_RX_LNA_AGC_ATT_ANT0_CH2_FROM_LNA_AGC_STATUS(tmp) \
        (((tmp) >> 8) & 0x03)

/* status for chidx and antenna */
#define GP_WB_READ_RX_LNA_AGC_ATT_ANT1_CH2() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x265)) >> 2) & 0x03)

#define GP_WB_GET_RX_LNA_AGC_ATT_ANT1_CH2_FROM_LNA_AGC_STATUS(tmp) \
        (((tmp) >> 10) & 0x03)

/* status for chidx and antenna */
#define GP_WB_READ_RX_LNA_AGC_ATT_ANT0_CH3() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x265)) >> 4) & 0x03)

#define GP_WB_GET_RX_LNA_AGC_ATT_ANT0_CH3_FROM_LNA_AGC_STATUS(tmp) \
        (((tmp) >> 12) & 0x03)

/* status for chidx and antenna */
#define GP_WB_READ_RX_LNA_AGC_ATT_ANT1_CH3() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x265)) >> 6) & 0x03)

#define GP_WB_GET_RX_LNA_AGC_ATT_ANT1_CH3_FROM_LNA_AGC_STATUS(tmp) \
        (((tmp) >> 14) & 0x03)

/* status for chidx and antenna */
#define GP_WB_READ_RX_LNA_AGC_ATT_ANT0_CH4() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x266)) & 0x03)

#define GP_WB_GET_RX_LNA_AGC_ATT_ANT0_CH4_FROM_LNA_AGC_STATUS(tmp) \
        (((tmp) >> 16) & 0x03)

/* status for chidx and antenna */
#define GP_WB_READ_RX_LNA_AGC_ATT_ANT1_CH4() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x266)) >> 2) & 0x03)

#define GP_WB_GET_RX_LNA_AGC_ATT_ANT1_CH4_FROM_LNA_AGC_STATUS(tmp) \
        (((tmp) >> 18) & 0x03)

/* status for chidx and antenna */
#define GP_WB_READ_RX_LNA_AGC_ATT_ANT0_CH5() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x266)) >> 4) & 0x03)

#define GP_WB_GET_RX_LNA_AGC_ATT_ANT0_CH5_FROM_LNA_AGC_STATUS(tmp) \
        (((tmp) >> 20) & 0x03)

/* status for chidx and antenna */
#define GP_WB_READ_RX_LNA_AGC_ATT_ANT1_CH5() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x266)) >> 6) & 0x03)

#define GP_WB_GET_RX_LNA_AGC_ATT_ANT1_CH5_FROM_LNA_AGC_STATUS(tmp) \
        (((tmp) >> 22) & 0x03)


/* Timeout value between CW detect and BLE packet detect, in microseconds */
#define GP_WB_READ_RX_CW_TIMEOUT_VALUE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x267))

#define GP_WB_WRITE_RX_CW_TIMEOUT_VALUE(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x267), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_LR_CW_CONFIG() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x268))

#define GP_WB_WRITE_RX_LR_CW_CONFIG(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x268), (val))

/* Threshold for the programmable CCWD (it will be multiplied by 1024) */
#define GP_WB_READ_RX_LR_CW_DET_THR() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x268))

#define GP_WB_GET_RX_LR_CW_DET_THR_FROM_LR_CW_CONFIG(tmp) \
        ((tmp) & 0xFF)

#define GP_WB_WRITE_RX_LR_CW_DET_THR(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x268), (val)); \
        } while (0)

#define GP_WB_SET_RX_LR_CW_DET_THR_TO_LR_CW_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          (tmp) &= 0x0F00; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* When set the LR double autocorrelator will be used to detect CW and hold the timeout counter */
#define GP_WB_READ_RX_USE_LR_CW_DET() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x269), 0)

#define GP_WB_GET_RX_USE_LR_CW_DET_FROM_LR_CW_CONFIG(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_RX_USE_LR_CW_DET(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x269), 0, (val)); \
        } while (0)

#define GP_WB_SET_RX_USE_LR_CW_DET_TO_LR_CW_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0EFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* When set the LR double autocorrelator will be used to detect CW and hold the timeout counter */
#define GP_WB_READ_RX_USE_LR_CW_DET_MS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x269), 1)

#define GP_WB_GET_RX_USE_LR_CW_DET_MS_FROM_LR_CW_CONFIG(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_RX_USE_LR_CW_DET_MS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x269), 1, (val)); \
        } while (0)

#define GP_WB_SET_RX_USE_LR_CW_DET_MS_TO_LR_CW_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0DFF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)

/* When set the CW detetc event generateb by the continuous CW detector will hold the ble timeout counter. Active only if use_lr_cw_det is set */
#define GP_WB_READ_RX_CW_DET_HOLDS_TIMEOUT_COUNTER() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x269), 2)

#define GP_WB_GET_RX_CW_DET_HOLDS_TIMEOUT_COUNTER_FROM_LR_CW_CONFIG(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_RX_CW_DET_HOLDS_TIMEOUT_COUNTER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x269), 2, (val)); \
        } while (0)

#define GP_WB_SET_RX_CW_DET_HOLDS_TIMEOUT_COUNTER_TO_LR_CW_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0BFF; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)

/* When the CW detect will be resetted on an RSSI PiP event. */
#define GP_WB_READ_RX_RESTART_CW_DETECTOR_ON_PIP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x269), 3)

#define GP_WB_GET_RX_RESTART_CW_DETECTOR_ON_PIP_FROM_LR_CW_CONFIG(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_RX_RESTART_CW_DETECTOR_ON_PIP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x269), 3, (val)); \
        } while (0)

#define GP_WB_SET_RX_RESTART_CW_DETECTOR_ON_PIP_TO_LR_CW_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FF; \
          (tmp) |= (((UInt16)(val)) << 11); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_VALIDATION_CFG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x26a))

#define GP_WB_WRITE_RX_VALIDATION_CFG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x26a), (val))

/* The validation logic is enabled when set to 1, disabled otherwise */
#define GP_WB_READ_RX_VALIDATION_EN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x26a), 0)

#define GP_WB_GET_RX_VALIDATION_EN_FROM_VALIDATION_CFG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RX_VALIDATION_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x26a), 0, (val)); \
        } while (0)

#define GP_WB_SET_RX_VALIDATION_EN_TO_VALIDATION_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When set the decoded data will be also used to determine the validation status */
#define GP_WB_READ_RX_VALIDATION_PRE_DATA_CHECK_EN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x26a), 1)

#define GP_WB_GET_RX_VALIDATION_PRE_DATA_CHECK_EN_FROM_VALIDATION_CFG(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RX_VALIDATION_PRE_DATA_CHECK_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x26a), 1, (val)); \
        } while (0)

#define GP_WB_SET_RX_VALIDATION_PRE_DATA_CHECK_EN_TO_VALIDATION_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* Threshold for preamble validation */
#define GP_WB_READ_RX_VALIDATION_THRESH() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x26c))

#define GP_WB_WRITE_RX_VALIDATION_THRESH(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x26c), (val)); \
        } while (0)


/* Threshold for data_phase validation (the actual value used is twice the value of this register) */
#define GP_WB_READ_RX_VALIDATION_DATA_PHASE_THRESH() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x26e))

#define GP_WB_WRITE_RX_VALIDATION_DATA_PHASE_THRESH(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x26e), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_DBG_0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x270))

#define GP_WB_WRITE_RX_DBG_0(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x270), (val))

/* Enable input data stream for antenna 0 and 1 */
#define GP_WB_READ_RX_EN_DATA() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x270)) & 0x03)

#define GP_WB_GET_RX_EN_DATA_FROM_DBG_0(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_RX_EN_DATA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x270), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_RX_EN_DATA_TO_DBG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0xFC; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When 0 the evaluation of the second slot will be skipped in case a preamble is found during the evaluation of the first slot. Valid only in AD mode */
#define GP_WB_READ_RX_WAIT_SECOND_ANTENNA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x270), 2)

#define GP_WB_GET_RX_WAIT_SECOND_ANTENNA_FROM_DBG_0(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RX_WAIT_SECOND_ANTENNA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x270), 2, (val)); \
        } while (0)

#define GP_WB_SET_RX_WAIT_SECOND_ANTENNA_TO_DBG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* When set to 1, the preamble shall be evaluated over 3 slots. Only valid for AD mode. Overrules the wait_second_antenna setting. Intended use is for high sensitivity MCH mode */
#define GP_WB_READ_RX_USE_LONG_PREAMBLE_EVAL() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x270), 3)

#define GP_WB_GET_RX_USE_LONG_PREAMBLE_EVAL_FROM_DBG_0(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RX_USE_LONG_PREAMBLE_EVAL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x270), 3, (val)); \
        } while (0)

#define GP_WB_SET_RX_USE_LONG_PREAMBLE_EVAL_TO_DBG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* 0=default, 1=during SFD validation only the decoded data will be used, 2=TBD, 3=TBD */
#define GP_WB_READ_RX_VALIDATION_PRE_DATA_CHECK_CFG() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x270)) >> 4) & 0x03)

#define GP_WB_GET_RX_VALIDATION_PRE_DATA_CHECK_CFG_FROM_DBG_0(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_RX_VALIDATION_PRE_DATA_CHECK_CFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x270), 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_RX_VALIDATION_PRE_DATA_CHECK_CFG_TO_DBG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0xCF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_READ_RX_RESTART_PACKET_DET_EN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x270), 6)

#define GP_WB_GET_RX_RESTART_PACKET_DET_EN_FROM_DBG_0(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RX_RESTART_PACKET_DET_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x270), 6, (val)); \
        } while (0)

#define GP_WB_SET_RX_RESTART_PACKET_DET_EN_TO_DBG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* When enabled, packet detection will be restarted on a frame sync failure. When not enabled, the packet detect will only start after sfd timeout */
#define GP_WB_READ_RX_RESTART_PACKET_DET_ON_FSYNC_FAIL() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x270), 7)

#define GP_WB_GET_RX_RESTART_PACKET_DET_ON_FSYNC_FAIL_FROM_DBG_0(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_RX_RESTART_PACKET_DET_ON_FSYNC_FAIL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x270), 7, (val)); \
        } while (0)

#define GP_WB_SET_RX_RESTART_PACKET_DET_ON_FSYNC_FAIL_TO_DBG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_BT_DATA_CFG_0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x271))

#define GP_WB_WRITE_RX_BT_DATA_CFG_0(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x271), (val))

/* Time Tracking threshold */
#define GP_WB_READ_RX_TTRACK_THR() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x271)) & 0x0F)

#define GP_WB_GET_RX_TTRACK_THR_FROM_BT_DATA_CFG_0(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_RX_TTRACK_THR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x271), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_RX_TTRACK_THR_TO_BT_DATA_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0xF0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Exponent of the CFO gain which is equal to 2^(cfo_gain) */
#define GP_WB_READ_RX_CFO_GAIN() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x271)) >> 4) & 0x0F)

#define GP_WB_GET_RX_CFO_GAIN_FROM_BT_DATA_CFG_0(tmp) \
        (((tmp) >> 4) & 0x0F)

#define GP_WB_WRITE_RX_CFO_GAIN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x271), 0xF0, (val) << 4); \
        } while (0)

#define GP_WB_SET_RX_CFO_GAIN_TO_BT_DATA_CFG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_BT_DATA_CFG_1() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x272))

#define GP_WB_WRITE_RX_BT_DATA_CFG_1(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x272), (val))

/* Offset to be applied to the calculated validation start time */
#define GP_WB_READ_RX_BT_VALIDATION_START_TUNE() \
        (GP_WB_S8((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x272)) & 0x0F), 4))

#define GP_WB_GET_RX_BT_VALIDATION_START_TUNE_FROM_BT_DATA_CFG_1(tmp) \
        (GP_WB_S8(((tmp) & 0x0F), 4))

#define GP_WB_WRITE_RX_BT_VALIDATION_START_TUNE(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -8, 7); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x272), 0x0F, (UInt8)((val))); \
        } while (0)

#define GP_WB_SET_RX_BT_VALIDATION_START_TUNE_TO_BT_DATA_CFG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK_SIGNED(val, -8, 7); \
          (tmp) &= 0x70; \
          (tmp) |= (((Int8)(val)) & 0x0F); \
        } while (0)

/* Bias value: 0 = 1 (no bias), 1 = 1.25, 2 = 1.5, 3 = NA (no bias) */
#define GP_WB_READ_RX_BT_BIAS_GAIN() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x272)) >> 4) & 0x03)

#define GP_WB_GET_RX_BT_BIAS_GAIN_FROM_BT_DATA_CFG_1(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_RX_BT_BIAS_GAIN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x272), 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_RX_BT_BIAS_GAIN_TO_BT_DATA_CFG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x4F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* The bias will be enabled in MB(R) mode when set, disabled otherwise */
#define GP_WB_READ_RX_BT_BIAS_MBR_EN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x272), 6)

#define GP_WB_GET_RX_BT_BIAS_MBR_EN_FROM_BT_DATA_CFG_1(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RX_BT_BIAS_MBR_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x272), 6, (val)); \
        } while (0)

#define GP_WB_SET_RX_BT_BIAS_MBR_EN_TO_BT_DATA_CFG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* Threshold for BLE preamble validation */
#define GP_WB_READ_RX_BT_VALIDATION_THRESH() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x274))

#define GP_WB_WRITE_RX_BT_VALIDATION_THRESH(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x274), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_DYN_VALIDATION_CFG() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x276))

#define GP_WB_WRITE_RX_DYN_VALIDATION_CFG(val) \
      GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x276), (val))

/* Amount of symbols inside the access code the validation is going to start (range 0-25 if bt_use_ext_buffer is set, 0-21 otherwise) */
#define GP_WB_READ_RX_BT_VALIDATION_N() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x276))

#define GP_WB_GET_RX_BT_VALIDATION_N_FROM_DYN_VALIDATION_CFG(tmp) \
        ((tmp) & 0x1F)

#define GP_WB_WRITE_RX_BT_VALIDATION_N(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x276), (val)); \
        } while (0)

#define GP_WB_SET_RX_BT_VALIDATION_N_TO_DYN_VALIDATION_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x0F9F00; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* The index inside the access code where a fake preamble starts (range 0-25 if bt_use_ext_buffer is set, 0-21 otherwise) */
#define GP_WB_READ_RX_BT_FAKE_PREAMBLE_N() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x277)) & 0x1F)

#define GP_WB_GET_RX_BT_FAKE_PREAMBLE_N_FROM_DYN_VALIDATION_CFG(tmp) \
        (((tmp) >> 8) & 0x1F)

#define GP_WB_WRITE_RX_BT_FAKE_PREAMBLE_N(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x277), 0x1F, (val)); \
        } while (0)

#define GP_WB_SET_RX_BT_FAKE_PREAMBLE_N_TO_DYN_VALIDATION_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x0F801F; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* Indicates wheter a fake preamble is present in the access code or not (valid flag for bt_fake_preamble_n) */
#define GP_WB_READ_RX_BT_FAKE_PREAMBLE_PRESENT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x277), 7)

#define GP_WB_GET_RX_BT_FAKE_PREAMBLE_PRESENT_FROM_DYN_VALIDATION_CFG(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_RX_BT_FAKE_PREAMBLE_PRESENT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x277), 7, (val)); \
        } while (0)

#define GP_WB_SET_RX_BT_FAKE_PREAMBLE_PRESENT_TO_DYN_VALIDATION_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F1F1F; \
          (tmp) |= (((UInt32)(val)) << 15); \
        } while (0)

/* When set the buffer will be extended to allow the full possible range for bt_validation_n, 32us (=k8.1) otherwise */
#define GP_WB_READ_RX_BT_USE_EXT_BUFFER() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x278), 0)

#define GP_WB_GET_RX_BT_USE_EXT_BUFFER_FROM_DYN_VALIDATION_CFG(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_RX_BT_USE_EXT_BUFFER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x278), 0, (val)); \
        } while (0)

#define GP_WB_SET_RX_BT_USE_EXT_BUFFER_TO_DYN_VALIDATION_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E9F1F; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* IQ buffer depth correction with resolution of 1us */
#define GP_WB_READ_RX_BT_IQ_BUFFER_DEPTH_CORR() \
        (GP_WB_S8(((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x278)) >> 1) & 0x07), 3))

#define GP_WB_GET_RX_BT_IQ_BUFFER_DEPTH_CORR_FROM_DYN_VALIDATION_CFG(tmp) \
        (GP_WB_S8((((tmp) >> 17) & 0x07), 3))

#define GP_WB_WRITE_RX_BT_IQ_BUFFER_DEPTH_CORR(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x278), 0x0E, (UInt8)((val) << 1)); \
        } while (0)

#define GP_WB_SET_RX_BT_IQ_BUFFER_DEPTH_CORR_TO_DYN_VALIDATION_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          (tmp) &= 0x019F1F; \
          (tmp) |= ((((Int32)(val)) << 17) & 0x0E0000); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_DBG_1() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x279))

#define GP_WB_WRITE_RX_DBG_1(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x279), (val))

/* Enable frame synchronization */
#define GP_WB_READ_RX_BT_FEN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x279), 0)

#define GP_WB_GET_RX_BT_FEN_FROM_DBG_1(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RX_BT_FEN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x279), 0, (val)); \
        } while (0)

#define GP_WB_SET_RX_BT_FEN_TO_DBG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Enable auto correlation logic */
#define GP_WB_READ_RX_BT_ACEN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x279), 1)

#define GP_WB_GET_RX_BT_ACEN_FROM_DBG_1(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RX_BT_ACEN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x279), 1, (val)); \
        } while (0)

#define GP_WB_SET_RX_BT_ACEN_TO_DBG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Enable fast frame synchronozation failure */
#define GP_WB_READ_RX_BT_FAST_FRAME_SYNC_FAIL_EN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x279), 2)

#define GP_WB_GET_RX_BT_FAST_FRAME_SYNC_FAIL_EN_FROM_DBG_1(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RX_BT_FAST_FRAME_SYNC_FAIL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x279), 2, (val)); \
        } while (0)

#define GP_WB_SET_RX_BT_FAST_FRAME_SYNC_FAIL_EN_TO_DBG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Extra data path delay in normal BLE AC mode: 0 = no delay, 1 = 1us, 2 = 2us, 3 = 4us */
#define GP_WB_READ_RX_BT_DELAY_DATA_AC_MODE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x279)) >> 3) & 0x03)

#define GP_WB_GET_RX_BT_DELAY_DATA_AC_MODE_FROM_DBG_1(tmp) \
        (((tmp) >> 3) & 0x03)

#define GP_WB_WRITE_RX_BT_DELAY_DATA_AC_MODE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x279), 0x18, (val) << 3); \
        } while (0)

#define GP_WB_SET_RX_BT_DELAY_DATA_AC_MODE_TO_DBG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x67; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Round festimate (BLE AC mode) when set, trunk it otherwise */
#define GP_WB_READ_RX_BT_ROUND_FESTIMATE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x279), 5)

#define GP_WB_GET_RX_BT_ROUND_FESTIMATE_FROM_DBG_1(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RX_BT_ROUND_FESTIMATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x279), 5, (val)); \
        } while (0)

#define GP_WB_SET_RX_BT_ROUND_FESTIMATE_TO_DBG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x5F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* When set the moving average for BLE 1Mb ac mode will be set to 5us, 7us otherwise */
#define GP_WB_READ_RX_BT_MAVGLEN_IS_5US() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x279), 6)

#define GP_WB_GET_RX_BT_MAVGLEN_IS_5US_FROM_DBG_1(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RX_BT_MAVGLEN_IS_5US(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x279), 6, (val)); \
        } while (0)

#define GP_WB_SET_RX_BT_MAVGLEN_IS_5US_TO_DBG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* BLE LR fine autocorrelator threshold */
#define GP_WB_READ_RX_BT_LR_AC_ACTHR() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x27a))

#define GP_WB_WRITE_RX_BT_LR_AC_ACTHR(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x27a), (val)); \
        } while (0)


/* BLE LR coarse autocorrelator threshold */
#define GP_WB_READ_RX_BT_LR_AC_CWTHR() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x27c))

#define GP_WB_WRITE_RX_BT_LR_AC_CWTHR(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x27c), (val)); \
        } while (0)


/* Connect the muxed IQ generated inside the BPF instead of the signals coming from the radio to the debug bus */
#define GP_WB_READ_RX_OBSERVE_BPF_IQ() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x27e), 0)

#define GP_WB_WRITE_RX_OBSERVE_BPF_IQ(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x27e), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_DBG_6() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x280))

#define GP_WB_WRITE_RX_DBG_6(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x280), (val))

/* Correlators output to connect to the debug bus (0:14) */
#define GP_WB_READ_RX_BT_OBSERVE_CO_0() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x280)) & 0x0F)

#define GP_WB_GET_RX_BT_OBSERVE_CO_0_FROM_DBG_6(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_RX_BT_OBSERVE_CO_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x280), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_RX_BT_OBSERVE_CO_0_TO_DBG_6(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0xFFF0; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Correlators output to connect to the debug bus (0:14) */
#define GP_WB_READ_RX_BT_OBSERVE_CO_1() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x280)) >> 4) & 0x0F)

#define GP_WB_GET_RX_BT_OBSERVE_CO_1_FROM_DBG_6(tmp) \
        (((tmp) >> 4) & 0x0F)

#define GP_WB_WRITE_RX_BT_OBSERVE_CO_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x280), 0xF0, (val) << 4); \
        } while (0)

#define GP_WB_SET_RX_BT_OBSERVE_CO_1_TO_DBG_6(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0xFF0F; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* Correlators output to connect to the debug bus (0:14) */
#define GP_WB_READ_RX_BT_OBSERVE_CO_2() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x281)) & 0x0F)

#define GP_WB_GET_RX_BT_OBSERVE_CO_2_FROM_DBG_6(tmp) \
        (((tmp) >> 8) & 0x0F)

#define GP_WB_WRITE_RX_BT_OBSERVE_CO_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x281), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_RX_BT_OBSERVE_CO_2_TO_DBG_6(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0xF0FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* Correlators output to connect to the debug bus (0:14) */
#define GP_WB_READ_RX_BT_OBSERVE_CO_3() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x281)) >> 4) & 0x0F)

#define GP_WB_GET_RX_BT_OBSERVE_CO_3_FROM_DBG_6(tmp) \
        (((tmp) >> 12) & 0x0F)

#define GP_WB_WRITE_RX_BT_OBSERVE_CO_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x281), 0xF0, (val) << 4); \
        } while (0)

#define GP_WB_SET_RX_BT_OBSERVE_CO_3_TO_DBG_6(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x0FFF; \
          (tmp) |= (((UInt16)(val)) << 12); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_DBG_9() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x282))

#define GP_WB_WRITE_RX_DBG_9(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x282), (val))

/* When set the CFO will be hold when a timing correction is performed */
#define GP_WB_READ_RX_BT_HOLD_CFO_ON_TIME_ADJ() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x282), 0)

#define GP_WB_GET_RX_BT_HOLD_CFO_ON_TIME_ADJ_FROM_DBG_9(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RX_BT_HOLD_CFO_ON_TIME_ADJ(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x282), 0, (val)); \
        } while (0)

#define GP_WB_SET_RX_BT_HOLD_CFO_ON_TIME_ADJ_TO_DBG_9(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When set the BLE validation will be activated */
#define GP_WB_READ_RX_BT_DATA_VALID_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x282), 1)

#define GP_WB_GET_RX_BT_DATA_VALID_ENABLE_FROM_DBG_9(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RX_BT_DATA_VALID_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x282), 1, (val)); \
        } while (0)

#define GP_WB_SET_RX_BT_DATA_VALID_ENABLE_TO_DBG_9(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_DBG_10() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x284))

#define GP_WB_WRITE_RX_DBG_10(val) \
      GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x284), (val))

/* BLE data validation threshold */
#define GP_WB_READ_RX_BT_DATA_VALID_THRESH() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x284))

#define GP_WB_GET_RX_BT_DATA_VALID_THRESH_FROM_DBG_10(tmp) \
        ((tmp) & 0xFF)

#define GP_WB_WRITE_RX_BT_DATA_VALID_THRESH(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x284), (val)); \
        } while (0)

#define GP_WB_SET_RX_BT_DATA_VALID_THRESH_TO_DBG_10(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x3FFF00; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* BLE data validation high threshold */
#define GP_WB_READ_RX_BT_DATA_VALID_HIGH_THRESH() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x285))

#define GP_WB_GET_RX_BT_DATA_VALID_HIGH_THRESH_FROM_DBG_10(tmp) \
        (((tmp) >> 8) & 0xFF)

#define GP_WB_WRITE_RX_BT_DATA_VALID_HIGH_THRESH(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x285), (val)); \
        } while (0)

#define GP_WB_SET_RX_BT_DATA_VALID_HIGH_THRESH_TO_DBG_10(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x3F00FF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* BLE data validation average length: 0 = 4, 1 = 8, 2 = 12, 3 = 16 */
#define GP_WB_READ_RX_BT_DATA_VALID_LEN() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x286)) & 0x03)

#define GP_WB_GET_RX_BT_DATA_VALID_LEN_FROM_DBG_10(tmp) \
        (((tmp) >> 16) & 0x03)

#define GP_WB_WRITE_RX_BT_DATA_VALID_LEN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x286), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_RX_BT_DATA_VALID_LEN_TO_DBG_10(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3CFFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* When set the convolutions necessary for the BT validation will be performed only during the length of the validation, always performed otherwise (like in k8.1) */
#define GP_WB_READ_RX_EN_DYN_VALIDATION() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x286), 2)

#define GP_WB_GET_RX_EN_DYN_VALIDATION_FROM_DBG_10(tmp) \
        (((tmp) >> 18) & 0x01)

#define GP_WB_WRITE_RX_EN_DYN_VALIDATION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x286), 2, (val)); \
        } while (0)

#define GP_WB_SET_RX_EN_DYN_VALIDATION_TO_DBG_10(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3BFFFF; \
          (tmp) |= (((UInt32)(val)) << 18); \
        } while (0)

/* When set the BPF inputs will be dynamically gated, always enabled otherwise */
#define GP_WB_READ_RX_EN_DYN_BPF_AD() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x286), 3)

#define GP_WB_GET_RX_EN_DYN_BPF_AD_FROM_DBG_10(tmp) \
        (((tmp) >> 19) & 0x01)

#define GP_WB_WRITE_RX_EN_DYN_BPF_AD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x286), 3, (val)); \
        } while (0)

#define GP_WB_SET_RX_EN_DYN_BPF_AD_TO_DBG_10(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x37FFFF; \
          (tmp) |= (((UInt32)(val)) << 19); \
        } while (0)

/* When set the AD BPF are bypassed, used otherwise */
#define GP_WB_READ_RX_BYPASS_BPF_AD() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x286), 4)

#define GP_WB_GET_RX_BYPASS_BPF_AD_FROM_DBG_10(tmp) \
        (((tmp) >> 20) & 0x01)

#define GP_WB_WRITE_RX_BYPASS_BPF_AD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x286), 4, (val)); \
        } while (0)

#define GP_WB_SET_RX_BYPASS_BPF_AD_TO_DBG_10(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2FFFFF; \
          (tmp) |= (((UInt32)(val)) << 20); \
        } while (0)

/* When set in multistandard mode it will hold the BLE timeout counter when the packet_det and signal_det are both set to give time to the LR frame to be received in case of long pre-packet CW */
#define GP_WB_READ_RX_HOLD_BLE_TIMEOUT_COUNTER_EN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x286), 5)

#define GP_WB_GET_RX_HOLD_BLE_TIMEOUT_COUNTER_EN_FROM_DBG_10(tmp) \
        (((tmp) >> 21) & 0x01)

#define GP_WB_WRITE_RX_HOLD_BLE_TIMEOUT_COUNTER_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x286), 5, (val)); \
        } while (0)

#define GP_WB_SET_RX_HOLD_BLE_TIMEOUT_COUNTER_EN_TO_DBG_10(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FFFFF; \
          (tmp) |= (((UInt32)(val)) << 21); \
        } while (0)


/* Amount of IQ sampling rate periods that the channel*not*valid will be extended */
#define GP_WB_READ_RX_CHANNEL_INVALID_EXT() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x288))

#define GP_WB_WRITE_RX_CHANNEL_INVALID_EXT(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x288), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_DBG_13() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x28a))

#define GP_WB_WRITE_RX_DBG_13(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x28a), (val))

/* When set the BLE early_birdy will be delayed until the moment at which packet_det is set. Active only in MS mode */
#define GP_WB_READ_RX_BT_DELAY_EARLY_BIRDY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x28a), 0)

#define GP_WB_GET_RX_BT_DELAY_EARLY_BIRDY_FROM_DBG_13(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RX_BT_DELAY_EARLY_BIRDY(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x28a), 0, (val)); \
        } while (0)

#define GP_WB_SET_RX_BT_DELAY_EARLY_BIRDY_TO_DBG_13(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When set the 16us autoccorrelators output will be used to create a timeout in case of a BT frame_sync or data validation error */
#define GP_WB_READ_RX_EN_ZB_PACKET_FOUND() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x28a), 1)

#define GP_WB_GET_RX_EN_ZB_PACKET_FOUND_FROM_DBG_13(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RX_EN_ZB_PACKET_FOUND(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x28a), 1, (val)); \
        } while (0)

#define GP_WB_SET_RX_EN_ZB_PACKET_FOUND_TO_DBG_13(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_DBG_14() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x28b))

#define GP_WB_WRITE_RX_DBG_14(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x28b), (val))

/* Extra delay in us to be applied to the BLE path in MS mode. Range 0 to 32 */
#define GP_WB_READ_RX_BT_MS_DELAY_BLE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x28b)) & 0x3F)

#define GP_WB_GET_RX_BT_MS_DELAY_BLE_FROM_DBG_14(tmp) \
        ((tmp) & 0x3F)

#define GP_WB_WRITE_RX_BT_MS_DELAY_BLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x28b), 0x3F, (val)); \
        } while (0)

#define GP_WB_SET_RX_BT_MS_DELAY_BLE_TO_DBG_14(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0xC0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Amount of 500ns by which the acutocorrelator module will be delayed in experimental mode after the rssi event */
#define GP_WB_READ_RX_BT_ACEN_MASKED_CNT_INIT() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x28b)) >> 6) & 0x03)

#define GP_WB_GET_RX_BT_ACEN_MASKED_CNT_INIT_FROM_DBG_14(tmp) \
        (((tmp) >> 6) & 0x03)

#define GP_WB_WRITE_RX_BT_ACEN_MASKED_CNT_INIT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x28b), 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_RX_BT_ACEN_MASKED_CNT_INIT_TO_DBG_14(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* When set to '1', the BIST is allowed to take control of the RAM interface. */
#define GP_WB_READ_RX_BIST_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x28c), 0)

#define GP_WB_WRITE_RX_BIST_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x28c), (val)); \
        } while (0)


/* Triggers the BIST test (when enabled !). Beware ... this will block all other RAM accesses and overwrite ALL memory content !!! */
#define GP_WB_RX_BIST_START() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x28d), 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_RAM_OPERATION_STATUS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x28e))

/* Indicates that the BIST test is finished */
#define GP_WB_READ_RX_BIST_RDY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x28e), 0)

#define GP_WB_GET_RX_BIST_RDY_FROM_RAM_OPERATION_STATUS(tmp) \
        ((tmp) & 0x01)

/* Indicates that the BIST test passed or failed */
#define GP_WB_READ_RX_BIST_OK() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x28e), 1)

#define GP_WB_GET_RX_BIST_OK_FROM_RAM_OPERATION_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)


#define GP_WB_READ_RX_PLL_CFO_BLE_ZB() \
        (GP_WB_S16(GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x290)), 16))


#define GP_WB_READ_RX_PLL_CFO_BLE_LR() \
        (GP_WB_S16(GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x292)), 16))


/* set ldo resistance ladder reference. tweak the output voltage of the ldo */
#define GP_WB_READ_RX_RX_BPF_LDO_DIG_REFBITS() \
        (GP_WB_S8((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x294)) & 0x0F), 4))

#define GP_WB_WRITE_RX_RX_BPF_LDO_DIG_REFBITS(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -8, 7); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x294), 0x0F, (UInt8)((val))); \
        } while (0)

/* lim-ldo: set output voltage by changing reference voltage */
#define GP_WB_READ_RX_RX_LIM_LDO_REFBITS() \
        (GP_WB_S8(((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x294)) >> 4) & 0x0F), 4))

#define GP_WB_WRITE_RX_RX_LIM_LDO_REFBITS(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -8, 7); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x294), 0xF0, (UInt8)((val) << 4)); \
        } while (0)

/* set ldo resistance ladder reference. tweak the output voltage of the ldo */
#define GP_WB_READ_RX_RX_RF_LDO_REFBITS() \
        (GP_WB_S8(GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x295)), 4))

#define GP_WB_WRITE_RX_RX_RF_LDO_REFBITS(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -8, 7); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x295), (UInt8)((val))); \
        } while (0)


/* tuning bits for the adc reference ldo output voltage */
#define GP_WB_READ_RX_RSSI_REF_LDO_REFBITS() \
        (GP_WB_S8((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x298)) & 0x1F), 5))

#define GP_WB_WRITE_RX_RSSI_REF_LDO_REFBITS(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -16, 15); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x298), 0x1F, (UInt8)((val))); \
        } while (0)

/* bits to set the adc in debug mode. to be used and defined if necessary... */
#define GP_WB_READ_RX_RSSI_DEBUG() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x298)) >> 5) & 0x07)

#define GP_WB_WRITE_RX_RSSI_DEBUG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x298), 0xE0, (val) << 5); \
        } while (0)

/* bias current dac for integrator calibration */
#define GP_WB_READ_RX_RX_LIM_CUR_DAC() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x299)) & 0x1F)

#define GP_WB_WRITE_RX_RX_LIM_CUR_DAC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x299), 0x1F, (val)); \
        } while (0)

/* debug bits, to be defined, bit0 = speed-up of rssi (factor 2) settling, other 2 bits are unused */
#define GP_WB_READ_RX_RX_LIM_DEBUG() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x299)) >> 5) & 0x07)

#define GP_WB_WRITE_RX_RX_LIM_DEBUG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x299), 0xE0, (val) << 5); \
        } while (0)

/* tuning bits for the adc analogue ldo output voltage */
#define GP_WB_READ_RX_RSSI_ANA_LDO_REFBITS() \
        (GP_WB_S8((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29a)) & 0x0F), 4))

#define GP_WB_WRITE_RX_RSSI_ANA_LDO_REFBITS(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -8, 7); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29a), 0x0F, (UInt8)((val))); \
        } while (0)

/* tuning bits for the adc digital ldo output voltage */
#define GP_WB_READ_RX_RSSI_DIG_LDO_REFBITS() \
        (GP_WB_S8(((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29a)) >> 4) & 0x0F), 4))

#define GP_WB_WRITE_RX_RSSI_DIG_LDO_REFBITS(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -8, 7); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29a), 0xF0, (UInt8)((val) << 4)); \
        } while (0)

/* twos complement from -8 to +7 tune gm of gmc filter, nmos part */
#define GP_WB_READ_RX_RX_BPF_BIASTUNE_N() \
        (GP_WB_S8((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29b)) & 0x0F), 4))

#define GP_WB_WRITE_RX_RX_BPF_BIASTUNE_N(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -8, 7); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29b), 0x0F, (UInt8)((val))); \
        } while (0)

/* twos complement from -8 to +7 tune gm of gmc filter, pmos part */
#define GP_WB_READ_RX_RX_BPF_BIASTUNE_P() \
        (GP_WB_S8(((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29b)) >> 4) & 0x0F), 4))

#define GP_WB_WRITE_RX_RX_BPF_BIASTUNE_P(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -8, 7); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29b), 0xF0, (UInt8)((val) << 4)); \
        } while (0)

/* set the bias current of the lna. */
#define GP_WB_READ_RX_RX_LNA_BIAS() \
        (GP_WB_S8((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29c)) & 0x07), 3))

#define GP_WB_WRITE_RX_RX_LNA_BIAS(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29c), 0x07, (UInt8)((val))); \
        } while (0)

/* 00=low-pass-filter, 10 is upper sideband, 01 = lower sideband, 11=low pass filter */
#define GP_WB_READ_RX_RX_BPF_SIDEB_SEL() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29c)) >> 3) & 0x03)

#define GP_WB_WRITE_RX_RX_BPF_SIDEB_SEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29c), 0x18, (val) << 3); \
        } while (0)

/* disable for the bleed transistor at the adc analogue ldo output */
#define GP_WB_READ_RX_RSSI_ANA_LDO_BLEED_OFF() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29c), 5)

#define GP_WB_WRITE_RX_RSSI_ANA_LDO_BLEED_OFF(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29c), 5, (val)); \
        } while (0)

/* pup signal for the adc analogue ldo */
#define GP_WB_READ_RX_RSSI_ANA_LDO_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29c), 6)

#define GP_WB_WRITE_RX_RSSI_ANA_LDO_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29c), 6, (val)); \
        } while (0)

/* signal to bypass the lpf resistor in the adc analogue ldo */
#define GP_WB_READ_RX_RSSI_ANA_LDO_RES_BYPASS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29c), 7)

#define GP_WB_WRITE_RX_RSSI_ANA_LDO_RES_BYPASS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29c), 7, (val)); \
        } while (0)

/* debug bit. keeps the reference for the integrator calibration always on. */
#define GP_WB_READ_RX_RSSI_CALIBR_REF_ALWAYS_ON() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29d), 0)

#define GP_WB_WRITE_RX_RSSI_CALIBR_REF_ALWAYS_ON(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29d), 0, (val)); \
        } while (0)

/* disable for the bleed transistor at the adc digital ldo output */
#define GP_WB_READ_RX_RSSI_DIG_LDO_BLEED_OFF() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29d), 1)

#define GP_WB_WRITE_RX_RSSI_DIG_LDO_BLEED_OFF(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29d), 1, (val)); \
        } while (0)

/* pup signal for the adc digital ldo */
#define GP_WB_READ_RX_RSSI_DIG_LDO_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29d), 2)

#define GP_WB_WRITE_RX_RSSI_DIG_LDO_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29d), 2, (val)); \
        } while (0)

/* signal to bypass the lpf resistor in the adc digital ldo */
#define GP_WB_READ_RX_RSSI_DIG_LDO_RES_BYPASS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29d), 3)

#define GP_WB_WRITE_RX_RSSI_DIG_LDO_RES_BYPASS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29d), 3, (val)); \
        } while (0)

/* enables additional filter cap for integrator */
#define GP_WB_READ_RX_RSSI_EXTRA_CAP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29d), 4)

#define GP_WB_WRITE_RX_RSSI_EXTRA_CAP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29d), 4, (val)); \
        } while (0)

/* pup signal for the adc reference ldo */
#define GP_WB_READ_RX_RSSI_REF_LDO_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29d), 5)

#define GP_WB_WRITE_RX_RSSI_REF_LDO_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29d), 5, (val)); \
        } while (0)

/* signal to bypass the lpf resistor in the adc reference ldo */
#define GP_WB_READ_RX_RSSI_REF_LDO_RES_BYPASS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29d), 6)

#define GP_WB_WRITE_RX_RSSI_REF_LDO_RES_BYPASS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29d), 6, (val)); \
        } while (0)

/* enables selfbiasing of inputstage bpf (self biased inverter pair) */
#define GP_WB_READ_RX_RX_BPF_BIAS_FB_EN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29d), 7)

#define GP_WB_WRITE_RX_RX_BPF_BIAS_FB_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29d), 7, (val)); \
        } while (0)

/* bypass filter time constant in switched cap biasing n-side */
#define GP_WB_READ_RX_RX_BPF_EN_RESBYPASS_N() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29e), 0)

#define GP_WB_WRITE_RX_RX_BPF_EN_RESBYPASS_N(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29e), 0, (val)); \
        } while (0)

/* bypass filter time constant in switched cap biasing p-side */
#define GP_WB_READ_RX_RX_BPF_EN_RESBYPASS_P() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29e), 1)

#define GP_WB_WRITE_RX_RX_BPF_EN_RESBYPASS_P(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29e), 1, (val)); \
        } while (0)

/* powers up the 1.2v supply for all digital stuff in the bpf */
#define GP_WB_READ_RX_RX_BPF_LDO_DIG_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29e), 2)

#define GP_WB_WRITE_RX_RX_BPF_LDO_DIG_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29e), 2, (val)); \
        } while (0)

/* overrides possible protections that slow down the startup of the biasing. */
#define GP_WB_READ_RX_RX_BPF_OVERR_INT_DELAY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29e), 3)

#define GP_WB_WRITE_RX_RX_BPF_OVERR_INT_DELAY(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29e), 3, (val)); \
        } while (0)

/* enables dc feedback path from bpf to lna-input, bypassing ac coupling in lna input and ac coupling in mixer output */
#define GP_WB_READ_RX_RX_DCFB() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29e), 4)

#define GP_WB_WRITE_RX_RX_DCFB(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29e), 4, (val)); \
        } while (0)

/* lim -ldo:bleed circuit disable */
#define GP_WB_READ_RX_RX_LIM_LDO_BLEED_OFF() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29e), 5)

#define GP_WB_WRITE_RX_RX_LIM_LDO_BLEED_OFF(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29e), 5, (val)); \
        } while (0)

/* power up the limiter-ldo */
#define GP_WB_READ_RX_RX_LIM_LDO_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29e), 6)

#define GP_WB_WRITE_RX_RX_LIM_LDO_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29e), 6, (val)); \
        } while (0)

/* lim-ldo: resistor bypass to speed up settling */
#define GP_WB_READ_RX_RX_LIM_LDO_RES_BYPASS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29e), 7)

#define GP_WB_WRITE_RX_RX_LIM_LDO_RES_BYPASS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29e), 7, (val)); \
        } while (0)

/* enables a dc path from mixer output to bpf when enabled */
#define GP_WB_READ_RX_RX_MXRDC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29f), 0)

#define GP_WB_WRITE_RX_RX_MXRDC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29f), 0, (val)); \
        } while (0)

/* disable bleed circuit on ldo */
#define GP_WB_READ_RX_RX_RF_LDO_BLEED_OFF() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29f), 1)

#define GP_WB_WRITE_RX_RX_RF_LDO_BLEED_OFF(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29f), 1, (val)); \
        } while (0)

/* bypass the noise filter of the biasing of the dco. */
#define GP_WB_READ_RX_RX_RF_LDO_BYPASS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29f), 2)

#define GP_WB_WRITE_RX_RX_RF_LDO_BYPASS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29f), 2, (val)); \
        } while (0)

/* enables the ldo that powers the dividers for rx/fll and the buffers to both parts */
#define GP_WB_READ_RX_RX_RF_LDO_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29f), 3)

#define GP_WB_WRITE_RX_RX_RF_LDO_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x29f), 3, (val)); \
        } while (0)


#define GP_WB_READ_RX_BT_EXP_DELAY() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2a0))

#define GP_WB_WRITE_RX_BT_EXP_DELAY(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2a0), (val)); \
        } while (0)


/* Restart the convolution engine also on BLE timeout */
#define GP_WB_READ_RX_RESTART_CONV_ENGINE_ON_BLE_TIMEOUT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2a1), 0)

#define GP_WB_WRITE_RX_RESTART_CONV_ENGINE_ON_BLE_TIMEOUT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2a1), 0, (val)); \
        } while (0)

/* The BLE timeout counter will be stopped whenever the training measures a magnitude above the threshold */
#define GP_WB_READ_RX_USE_TRAINING_BLE_RUNNING_ISO_EARLY_BIRDY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2a1), 1)

#define GP_WB_WRITE_RX_USE_TRAINING_BLE_RUNNING_ISO_EARLY_BIRDY(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2a1), 1, (val)); \
        } while (0)

/* set to 1 if an interrupt should only be generated if going to/from concurrent mode */
#define GP_WB_READ_RX_RX_MODE_CHANGE_CONCURRENT_ONLY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2a1), 2)

#define GP_WB_WRITE_RX_RX_MODE_CHANGE_CONCURRENT_ONLY(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2a1), 2, (val)); \
        } while (0)


/* Low power preamble detect threshold */
#define GP_WB_READ_RX_PREAMBLE_THRESH_LP_MS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2a2))

#define GP_WB_WRITE_RX_PREAMBLE_THRESH_LP_MS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2a2), (val)); \
        } while (0)


/* Defines the RSSI jump needed in concurrent mode to trigger a search for a BLE frame */
#define GP_WB_READ_RX_RSSI_THRESHOLD_BLE_MS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2a4))

#define GP_WB_WRITE_RX_RSSI_THRESHOLD_BLE_MS(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2a4), (val)); \
        } while (0)

/* Defines the RSSI jump needed to trigger a rssi_pip event (rssi jump in rssi jump) */
#define GP_WB_READ_RX_RSSI_THRESHOLD_PIP_MS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2a5))

#define GP_WB_WRITE_RX_RSSI_THRESHOLD_PIP_MS(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2a5), (val)); \
        } while (0)

/* Defines the RSSI jump needed to trigger a rssi_pip event (rssi jump in rssi jump) when an active packet reception is busy */
#define GP_WB_READ_RX_RSSI_THRESHOLD_PACKET_PIP_MS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2a6))

#define GP_WB_WRITE_RX_RSSI_THRESHOLD_PACKET_PIP_MS(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2a6), (val)); \
        } while (0)


/* BLE LR coarse autocorrelator threshold - value for ms */
#define GP_WB_READ_RX_BT_LR_AC_HYS_LEN_MS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2a7))

#define GP_WB_WRITE_RX_BT_LR_AC_HYS_LEN_MS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2a7), (val)); \
        } while (0)


/* BLE LR fine autocorrelator threshold - value for ms */
#define GP_WB_READ_RX_BT_LR_AC_ACTHR_MS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2a8))

#define GP_WB_WRITE_RX_BT_LR_AC_ACTHR_MS(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2a8), (val)); \
        } while (0)


/* BLE LR coarse autocorrelator threshold - value for ms */
#define GP_WB_READ_RX_BT_LR_AC_CWTHR_MS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2aa))

#define GP_WB_WRITE_RX_BT_LR_AC_CWTHR_MS(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2aa), (val)); \
        } while (0)


/* timeout quard timer. Determines sfd timeout. */
#define GP_WB_READ_RX_BT_TIMEOUT_QUARD_TIMER_MS() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2ac)) & 0x1F)

#define GP_WB_WRITE_RX_BT_TIMEOUT_QUARD_TIMER_MS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2ac), 0x1F, (val)); \
        } while (0)

/* Enable auto correlation logic  -value for MS mode */
#define GP_WB_READ_RX_BT_ACEN_MS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2ac), 5)

#define GP_WB_WRITE_RX_BT_ACEN_MS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2ac), 5, (val)); \
        } while (0)


/* BlueTooth preamble detect threshold  -value for MS mode */
#define GP_WB_READ_RX_PREAMBLE_THRESH_BT_MS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2ae))

#define GP_WB_WRITE_RX_PREAMBLE_THRESH_BT_MS(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2ae), (val)); \
        } while (0)


/* clears the rx_mode change interrupt */
#define GP_WB_RX_CLR_RX_MODE_CHANGE_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b0), 0x01)


/* indicates that there was a receiver mode change */
#define GP_WB_READ_RX_UNMASKED_RX_MODE_CHANGE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b1), 0)


/* currently active RX mode */
#define GP_WB_READ_RX_ACTIVE_RX_MODE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b2))


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_DBG_17() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b3))

#define GP_WB_WRITE_RX_DBG_17(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b3), (val))

/* 0 => correlators output, 1 => scaled correlators output, others => pseudo magnitude */
#define GP_WB_READ_RX_VALIDATION_MODE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b3)) & 0x03)

#define GP_WB_GET_RX_VALIDATION_MODE_FROM_DBG_17(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_RX_VALIDATION_MODE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b3), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_RX_VALIDATION_MODE_TO_DBG_17(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0xFC; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When set during the ZB preamble will be evaluated twice before being set */
#define GP_WB_READ_RX_ZB_DOUBLE_PRE_CORR_EN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b3), 2)

#define GP_WB_GET_RX_ZB_DOUBLE_PRE_CORR_EN_FROM_DBG_17(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RX_ZB_DOUBLE_PRE_CORR_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b3), 2, (val)); \
        } while (0)

#define GP_WB_SET_RX_ZB_DOUBLE_PRE_CORR_EN_TO_DBG_17(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* 0 => 0us, 1 => 16us, others => 32 us, active only in MBR mode */
#define GP_WB_READ_RX_ZB_BUFFER_DEPTH() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b3)) >> 3) & 0x03)

#define GP_WB_GET_RX_ZB_BUFFER_DEPTH_FROM_DBG_17(tmp) \
        (((tmp) >> 3) & 0x03)

#define GP_WB_WRITE_RX_ZB_BUFFER_DEPTH(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b3), 0x18, (val) << 3); \
        } while (0)

#define GP_WB_SET_RX_ZB_BUFFER_DEPTH_TO_DBG_17(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0xE7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* BT preamble detection fine tune in 62.5ns units */
#define GP_WB_READ_RX_BT_PRE_DET_TIME_TUNE() \
        (GP_WB_S8(((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b3)) >> 5) & 0x07), 3))

#define GP_WB_GET_RX_BT_PRE_DET_TIME_TUNE_FROM_DBG_17(tmp) \
        (GP_WB_S8((((tmp) >> 5) & 0x07), 3))

#define GP_WB_WRITE_RX_BT_PRE_DET_TIME_TUNE(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b3), 0xE0, (UInt8)((val) << 5)); \
        } while (0)

#define GP_WB_SET_RX_BT_PRE_DET_TIME_TUNE_TO_DBG_17(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          (tmp) &= 0x1F; \
          (tmp) |= ((((Int8)(val)) << 5) & 0xE0); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_DBG_18() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b4))

#define GP_WB_WRITE_RX_DBG_18(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b4), (val))

/* Tune the set of the channel_blanking when in BLE_CC RSSI mode insided the BT slot */
#define GP_WB_READ_RX_SET_CH_BLANKING_TUNE() \
        (GP_WB_S8(GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b4)), 8))

#define GP_WB_GET_RX_SET_CH_BLANKING_TUNE_FROM_DBG_18(tmp) \
        (GP_WB_S8(((tmp) & 0xFF), 8))

#define GP_WB_WRITE_RX_SET_CH_BLANKING_TUNE(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b4), (UInt8)((val))); \
        } while (0)

#define GP_WB_SET_RX_SET_CH_BLANKING_TUNE_TO_DBG_18(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          (tmp) &= 0xFF00; \
          (tmp) |= (((Int16)(val)) & 0x00FF); \
        } while (0)

/* Tune the release of the BPF filter when going from BT to ZB */
#define GP_WB_READ_RX_CLR_BPF_BLE_TUNE() \
        (GP_WB_S8(GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b5)), 8))

#define GP_WB_GET_RX_CLR_BPF_BLE_TUNE_FROM_DBG_18(tmp) \
        (GP_WB_S8((((tmp) >> 8) & 0xFF), 8))

#define GP_WB_WRITE_RX_CLR_BPF_BLE_TUNE(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b5), (UInt8)((val))); \
        } while (0)

#define GP_WB_SET_RX_CLR_BPF_BLE_TUNE_TO_DBG_18(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          (tmp) &= 0x00FF; \
          (tmp) |= ((((Int16)(val)) << 8) & 0xFF00); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_DBG_19() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b6))

#define GP_WB_WRITE_RX_DBG_19(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b6), (val))

/* Amount of access code last symbols that will be decoded in MBR mode. Used is bt_bias_mbr_en is set. Values 1 and 2 and greater than 18 are not currently supported */
#define GP_WB_READ_RX_BT_BIAS_MBR_LEN() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b6)) & 0x1F)

#define GP_WB_GET_RX_BT_BIAS_MBR_LEN_FROM_DBG_19(tmp) \
        ((tmp) & 0x1F)

#define GP_WB_WRITE_RX_BT_BIAS_MBR_LEN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b6), 0x1F, (val)); \
        } while (0)

#define GP_WB_SET_RX_BT_BIAS_MBR_LEN_TO_DBG_19(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x07E0; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Enable frame sync and biasing for MBR modes. Active if bt_bias_mbr_en is set */
#define GP_WB_READ_RX_BT_BIAS_MBR_FS_EN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b6), 5)

#define GP_WB_GET_RX_BT_BIAS_MBR_FS_EN_FROM_DBG_19(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RX_BT_BIAS_MBR_FS_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b6), 5, (val)); \
        } while (0)

#define GP_WB_SET_RX_BT_BIAS_MBR_FS_EN_TO_DBG_19(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07DF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

/* Enable frame sync and biasing for MBR modes. Active if bt_bias_mbr_en is set */
#define GP_WB_READ_RX_ZB_MCH_DC_EN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b6), 6)

#define GP_WB_GET_RX_ZB_MCH_DC_EN_FROM_DBG_19(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RX_ZB_MCH_DC_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b6), 6, (val)); \
        } while (0)

#define GP_WB_SET_RX_ZB_MCH_DC_EN_TO_DBG_19(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07BF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

/* IQ masking when the channel is not stable will be applied on FOCOM level, in the BPF otherwise, */
#define GP_WB_READ_RX_FOCOM_IQ_MASK_EN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b6), 7)

#define GP_WB_GET_RX_FOCOM_IQ_MASK_EN_FROM_DBG_19(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_RX_FOCOM_IQ_MASK_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b6), 7, (val)); \
        } while (0)

#define GP_WB_SET_RX_FOCOM_IQ_MASK_EN_TO_DBG_19(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x077F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* The peamble detection will be delayed 16us when the second peak is NOT following a BLE timeout. Active only when zb_double_pre_corr_en is set and in MB(R) mode */
#define GP_WB_READ_RX_ALLOW_16US_PRE_DELAY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b7), 0)

#define GP_WB_GET_RX_ALLOW_16US_PRE_DELAY_FROM_DBG_19(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_RX_ALLOW_16US_PRE_DELAY(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b7), 0, (val)); \
        } while (0)

#define GP_WB_SET_RX_ALLOW_16US_PRE_DELAY_TO_DBG_19(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* When set and either a frame sync or a data validation failure happens the device will stay on the BT channel. Active only in MB(R) mode */
#define GP_WB_READ_RX_BT_STAY_ON_CH_IF_DATA_FAIL() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b7), 1)

#define GP_WB_GET_RX_BT_STAY_ON_CH_IF_DATA_FAIL_FROM_DBG_19(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_RX_BT_STAY_ON_CH_IF_DATA_FAIL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b7), 1, (val)); \
        } while (0)

#define GP_WB_SET_RX_BT_STAY_ON_CH_IF_DATA_FAIL_TO_DBG_19(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05FF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)

/* When set the dynamic buffer pointer will b corrected byt the already existing buffer delay and the worst RSSI event timing. Active only if bt_mbr_use_dyn_buffer_ptr is set */
#define GP_WB_READ_RX_BT_MBR_DYN_BUFFER_PTR_CORR_EN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b7), 2)

#define GP_WB_GET_RX_BT_MBR_DYN_BUFFER_PTR_CORR_EN_FROM_DBG_19(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_RX_BT_MBR_DYN_BUFFER_PTR_CORR_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b7), 2, (val)); \
        } while (0)

#define GP_WB_SET_RX_BT_MBR_DYN_BUFFER_PTR_CORR_EN_TO_DBG_19(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FF; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_DBG_20() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b8))

#define GP_WB_WRITE_RX_DBG_20(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b8), (val))

/* Amount of us the cw_signal_det needs to be set before releasing it to the rest of the design */
#define GP_WB_READ_RX_BT_CW_SIGNAL_DET_CNT_INIT() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b8)) & 0x0F)

#define GP_WB_GET_RX_BT_CW_SIGNAL_DET_CNT_INIT_FROM_DBG_20(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_RX_BT_CW_SIGNAL_DET_CNT_INIT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b8), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_RX_BT_CW_SIGNAL_DET_CNT_INIT_TO_DBG_20(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0xF0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Amount of us the cw_signal_det needs to be set before releasing it to the rest of the design - value for MS mode */
#define GP_WB_READ_RX_BT_CW_SIGNAL_DET_CNT_INIT_MS() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b8)) >> 4) & 0x0F)

#define GP_WB_GET_RX_BT_CW_SIGNAL_DET_CNT_INIT_MS_FROM_DBG_20(tmp) \
        (((tmp) >> 4) & 0x0F)

#define GP_WB_WRITE_RX_BT_CW_SIGNAL_DET_CNT_INIT_MS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2b8), 0xF0, (val) << 4); \
        } while (0)

#define GP_WB_SET_RX_BT_CW_SIGNAL_DET_CNT_INIT_MS_TO_DBG_20(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_DBG_21() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2ba))

#define GP_WB_WRITE_RX_DBG_21(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2ba), (val))

/* When set the BT early detection in MBR mode will hold the timeout counter */
#define GP_WB_READ_RX_ALLOW_BLE_TO_HOLD_TIMEOUT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2ba), 0)

#define GP_WB_GET_RX_ALLOW_BLE_TO_HOLD_TIMEOUT_FROM_DBG_21(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RX_ALLOW_BLE_TO_HOLD_TIMEOUT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2ba), 0, (val)); \
        } while (0)

#define GP_WB_SET_RX_ALLOW_BLE_TO_HOLD_TIMEOUT_TO_DBG_21(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FFE; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* When set the ZB data path will always be delayed by the time specified in zb_buffer_depth */
#define GP_WB_READ_RX_ALWAYS_USE_ZB_DATA_BUFFER() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2ba), 1)

#define GP_WB_GET_RX_ALWAYS_USE_ZB_DATA_BUFFER_FROM_DBG_21(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RX_ALWAYS_USE_ZB_DATA_BUFFER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2ba), 1, (val)); \
        } while (0)

#define GP_WB_SET_RX_ALWAYS_USE_ZB_DATA_BUFFER_TO_DBG_21(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FFD; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

/* When set the LR data path will be delaye an extra 32us in MBR mode in order to have the same timeing like in normal LR mode */
#define GP_WB_READ_RX_ADD_32US_ON_LR_IN_MBR_MODE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2ba), 2)

#define GP_WB_GET_RX_ADD_32US_ON_LR_IN_MBR_MODE_FROM_DBG_21(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RX_ADD_32US_ON_LR_IN_MBR_MODE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2ba), 2, (val)); \
        } while (0)

#define GP_WB_SET_RX_ADD_32US_ON_LR_IN_MBR_MODE_TO_DBG_21(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FFB; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* When set the BLE validation will start after the frame synchronization, immediately otherwise */
#define GP_WB_READ_RX_BT_DATA_VALID_AFTER_FS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2ba), 3)

#define GP_WB_GET_RX_BT_DATA_VALID_AFTER_FS_FROM_DBG_21(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RX_BT_DATA_VALID_AFTER_FS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2ba), 3, (val)); \
        } while (0)

#define GP_WB_SET_RX_BT_DATA_VALID_AFTER_FS_TO_DBG_21(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FF7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

/* When set the BLE dynamic buffer pointer will be used. Active only in MB(R) mode */
#define GP_WB_READ_RX_BT_MBR_USE_DYN_BUFFER_PTR() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2ba), 4)

#define GP_WB_GET_RX_BT_MBR_USE_DYN_BUFFER_PTR_FROM_DBG_21(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RX_BT_MBR_USE_DYN_BUFFER_PTR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2ba), 4, (val)); \
        } while (0)

#define GP_WB_SET_RX_BT_MBR_USE_DYN_BUFFER_PTR_TO_DBG_21(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FEF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* When set the BLE timeout counter will be stopped when the Preamble is found, it will be kept running otherwise */
#define GP_WB_READ_RX_BT_MBR_STOP_TIMEOUT_ON_PREAMBLE_DET() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2ba), 5)

#define GP_WB_GET_RX_BT_MBR_STOP_TIMEOUT_ON_PREAMBLE_DET_FROM_DBG_21(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RX_BT_MBR_STOP_TIMEOUT_ON_PREAMBLE_DET(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2ba), 5, (val)); \
        } while (0)

#define GP_WB_SET_RX_BT_MBR_STOP_TIMEOUT_ON_PREAMBLE_DET_TO_DBG_21(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FDF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

/* When set if the BLE validation is enabled during the frame synchronization the magnitude used will be unbiased */
#define GP_WB_READ_RX_BT_DATA_VALID_NO_BIAS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2ba), 6)

#define GP_WB_GET_RX_BT_DATA_VALID_NO_BIAS_FROM_DBG_21(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RX_BT_DATA_VALID_NO_BIAS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2ba), 6, (val)); \
        } while (0)

#define GP_WB_SET_RX_BT_DATA_VALID_NO_BIAS_TO_DBG_21(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FBF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

/* When set if the BT peak queue is not empty, the BLE timrout will be put on hold */
#define GP_WB_READ_RX_BT_QUEUE_IS_EMPTY_HOLD_TIMEOUT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2ba), 7)

#define GP_WB_GET_RX_BT_QUEUE_IS_EMPTY_HOLD_TIMEOUT_FROM_DBG_21(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_RX_BT_QUEUE_IS_EMPTY_HOLD_TIMEOUT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2ba), 7, (val)); \
        } while (0)

#define GP_WB_SET_RX_BT_QUEUE_IS_EMPTY_HOLD_TIMEOUT_TO_DBG_21(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* BT preamble detection fine tune in 62.5ns units for MS mode */
#define GP_WB_READ_RX_BT_PRE_DET_TIME_TUNE_MS() \
        (GP_WB_S8((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2bb)) & 0x07), 3))

#define GP_WB_GET_RX_BT_PRE_DET_TIME_TUNE_MS_FROM_DBG_21(tmp) \
        (GP_WB_S8((((tmp) >> 8) & 0x07), 3))

#define GP_WB_WRITE_RX_BT_PRE_DET_TIME_TUNE_MS(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2bb), 0x07, (UInt8)((val))); \
        } while (0)

#define GP_WB_SET_RX_BT_PRE_DET_TIME_TUNE_MS_TO_DBG_21(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          (tmp) &= 0x18FF; \
          (tmp) |= ((((Int16)(val)) << 8) & 0x0700); \
        } while (0)

/* When set the BLE timeout counter will be stopped when the Preamble is found, it will be kept running otherwise */
#define GP_WB_READ_RX_BT_MBR_STOP_TIMEOUT_ON_EARLY_BIRDY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2bb), 3)

#define GP_WB_GET_RX_BT_MBR_STOP_TIMEOUT_ON_EARLY_BIRDY_FROM_DBG_21(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_RX_BT_MBR_STOP_TIMEOUT_ON_EARLY_BIRDY(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2bb), 3, (val)); \
        } while (0)

#define GP_WB_SET_RX_BT_MBR_STOP_TIMEOUT_ON_EARLY_BIRDY_TO_DBG_21(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x17FF; \
          (tmp) |= (((UInt16)(val)) << 11); \
        } while (0)

/* When set the delay lines will be reset if clk_enable_for_reset is set */
#define GP_WB_READ_RX_RESET_DLYS_WHEN_CLK_ENABLE_FOR_RESET() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2bb), 4)

#define GP_WB_GET_RX_RESET_DLYS_WHEN_CLK_ENABLE_FOR_RESET_FROM_DBG_21(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_RX_RESET_DLYS_WHEN_CLK_ENABLE_FOR_RESET(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2bb), 4, (val)); \
        } while (0)

#define GP_WB_SET_RX_RESET_DLYS_WHEN_CLK_ENABLE_FOR_RESET_TO_DBG_21(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFF; \
          (tmp) |= (((UInt16)(val)) << 12); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RX_DBG_22() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2bc))

#define GP_WB_WRITE_RX_DBG_22(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2bc), (val))

/* Timeout value after a data validation failure or a frame sync failure. Active only when bt_stay_on_ch_if_data_fail is set */
#define GP_WB_READ_RX_FAIL_TIMEOUT_VALUE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2bc))

#define GP_WB_GET_RX_FAIL_TIMEOUT_VALUE_FROM_DBG_22(tmp) \
        ((tmp) & 0xFF)

#define GP_WB_WRITE_RX_FAIL_TIMEOUT_VALUE(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2bc), (val)); \
        } while (0)

#define GP_WB_SET_RX_FAIL_TIMEOUT_VALUE_TO_DBG_22(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          (tmp) &= 0x0300; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* If set to 1, then fail_timeout_value will be used when one of the corresponding events happens. Active only in MBR mode. */
#define GP_WB_READ_RX_FAIL_TIMEOUT_EN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2bd), 0)

#define GP_WB_GET_RX_FAIL_TIMEOUT_EN_FROM_DBG_22(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_RX_FAIL_TIMEOUT_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2bd), 0, (val)); \
        } while (0)

#define GP_WB_SET_RX_FAIL_TIMEOUT_EN_TO_DBG_22(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* If set to 1, then the CW detect will be set only if also the FINE autocorrelator trigger */
#define GP_WB_READ_RX_CW_DET_DEPENDS_ON_FINE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2bd), 1)

#define GP_WB_GET_RX_CW_DET_DEPENDS_ON_FINE_FROM_DBG_22(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_RX_CW_DET_DEPENDS_ON_FINE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2bd), 1, (val)); \
        } while (0)

#define GP_WB_SET_RX_CW_DET_DEPENDS_ON_FINE_TO_DBG_22(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)


#define GP_WB_READ_RX_MAX_HOLD_RSSI2FRAMEDET() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2be))


/* Amount of us the signal_det used for the CW generation needs to be set before releasing it to the rest of the design. Active only if cw_det_depends_on_fine is set - value for MS mode */
#define GP_WB_READ_RX_BT_LR_SIGNAL_DET_FOR_CW_CNT_INIT_MS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2c0))

#define GP_WB_WRITE_RX_BT_LR_SIGNAL_DET_FOR_CW_CNT_INIT_MS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2c0), (val)); \
        } while (0)


/* when set, the AC8 result is not used to generate the zb_packet found signal. */
#define GP_WB_READ_RX_ZB_PACKET_FOUND_DIS_AC8() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2c1), 0)

#define GP_WB_WRITE_RX_ZB_PACKET_FOUND_DIS_AC8(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x2c1), (val)); \
        } while (0)

/***************************
 * layout: tx
 ***************************/

/* enable overrule control of fll_locked */
#define GP_WB_READ_TX_FLL_LOCKED_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x300), 0)

#define GP_WB_WRITE_TX_FLL_LOCKED_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x300), (val)); \
        } while (0)


/* fll_locked, overrule value */
#define GP_WB_READ_TX_FLL_LOCKED_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x301), 0)

#define GP_WB_WRITE_TX_FLL_LOCKED_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x301), (val)); \
        } while (0)


/* fll_locked status */
#define GP_WB_READ_TX_FLL_LOCKED_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x302), 0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TX_BBPTX_CONFIG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x303))

#define GP_WB_WRITE_TX_BBPTX_CONFIG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x303), (val))

/* enable invertion of MSK data */
#define GP_WB_READ_TX_EN_INV_MSK() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x303), 0)

#define GP_WB_GET_TX_EN_INV_MSK_FROM_BBPTX_CONFIG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_TX_EN_INV_MSK(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x303), 0, (val)); \
        } while (0)

#define GP_WB_SET_TX_EN_INV_MSK_TO_BBPTX_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* enable generation of continuous modulated carrier */
#define GP_WB_READ_TX_EN_CONT_MOD() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x303), 1)

#define GP_WB_GET_TX_EN_CONT_MOD_FROM_BBPTX_CONFIG(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_TX_EN_CONT_MOD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x303), 1, (val)); \
        } while (0)

#define GP_WB_SET_TX_EN_CONT_MOD_TO_BBPTX_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* enable PA always on when in Tx mode */
#define GP_WB_READ_TX_EN_TX_PA_ON() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x303), 2)

#define GP_WB_GET_TX_EN_TX_PA_ON_FROM_BBPTX_CONFIG(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_TX_EN_TX_PA_ON(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x303), 2, (val)); \
        } while (0)

#define GP_WB_SET_TX_EN_TX_PA_ON_TO_BBPTX_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Set the generation of continuous modulated carrier to use ble (1) or zb (0) */
#define GP_WB_READ_TX_CONT_MOD_BLE_MODE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x303), 3)

#define GP_WB_GET_TX_CONT_MOD_BLE_MODE_FROM_BBPTX_CONFIG(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_TX_CONT_MOD_BLE_MODE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x303), 3, (val)); \
        } while (0)

#define GP_WB_SET_TX_CONT_MOD_BLE_MODE_TO_BBPTX_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* Adjusts the preframe pa enable delay by 16 us */
#define GP_WB_READ_TX_PAEN_VAR_DELAY_CRS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x304))

#define GP_WB_WRITE_TX_PAEN_VAR_DELAY_CRS(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x304), (val)); \
        } while (0)


/* PA enable variable delay = (paen_var_delay_crs+1)*16 us - (paen_var_delay+1)*62.5ns */
#define GP_WB_READ_TX_PAEN_VAR_DELAY() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x305))

#define GP_WB_WRITE_TX_PAEN_VAR_DELAY(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x305), (val)); \
        } while (0)


/* external PA enable variable delay = (paen_var_delay_crs+1)*16 us - (txen_var_delay+1)*62.5ns */
#define GP_WB_READ_TX_TXEN_VAR_DELAY() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x306))

#define GP_WB_WRITE_TX_TXEN_VAR_DELAY(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x306), (val)); \
        } while (0)


/* tx: adjust the pa-reference bias multiplier */
#define GP_WB_READ_TX_TX_PA_BIASTRIM_MULT() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x307))

#define GP_WB_WRITE_TX_TX_PA_BIASTRIM_MULT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x307), (val)); \
        } while (0)


/* tx: Enables 1 of the 2 balanced input signals */
#define GP_WB_READ_TX_TX_RF_P_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x308), 0)

#define GP_WB_WRITE_TX_TX_RF_P_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x308), 0, (val)); \
        } while (0)

/* tx: Enables 1 of the 2 balanced input signals */
#define GP_WB_READ_TX_TX_RF_N_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x308), 1)

#define GP_WB_WRITE_TX_TX_RF_N_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x308), 1, (val)); \
        } while (0)


/* set the internal PA ramp up and down time for zb frames */
#define GP_WB_READ_TX_PA_SLOPE_ZB() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x309)) & 0x07)

#define GP_WB_WRITE_TX_PA_SLOPE_ZB(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x309), 0x07, (val)); \
        } while (0)

/* set the internal PA ramp up and down time for ble frames */
#define GP_WB_READ_TX_PA_SLOPE_BLE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x309)) >> 3) & 0x07)

#define GP_WB_WRITE_TX_PA_SLOPE_BLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x309), 0x38, (val) << 3); \
        } while (0)

/* let the FLL pa on settling counter start at the start of the pa ramp (if 1) or when the pa ramp is complete (if 0) */
#define GP_WB_READ_TX_FLL_START_OF_RAMP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x309), 6)

#define GP_WB_WRITE_TX_FLL_START_OF_RAMP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x309), 6, (val)); \
        } while (0)

/* Enables 1.8 V biasing of external PA during transmission */
#define GP_WB_READ_TX_ENABLE_EXTERNAL_PA_BIASING() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x309), 7)

#define GP_WB_WRITE_TX_ENABLE_EXTERNAL_PA_BIASING(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x309), 7, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TX_TX_ANTSEL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x30a))

#define GP_WB_WRITE_TX_TX_ANTSEL(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x30a), (val))

/* Tx antenna select internal */
#define GP_WB_READ_TX_TX_ANTSEL_INT() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x30a)) & 0x03)

#define GP_WB_GET_TX_TX_ANTSEL_INT_FROM_TX_ANTSEL(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_TX_TX_ANTSEL_INT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x30a), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_TX_TX_ANTSEL_INT_TO_TX_ANTSEL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x0C; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Tx antenna select external */
#define GP_WB_READ_TX_TX_ANTSEL_EXT() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x30a)) >> 2) & 0x03)

#define GP_WB_GET_TX_TX_ANTSEL_EXT_FROM_TX_ANTSEL(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_TX_TX_ANTSEL_EXT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x30a), 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_TX_TX_ANTSEL_EXT_TO_TX_ANTSEL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TX_TX_ANT_EXT() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x30b))

#define GP_WB_WRITE_TX_TX_ANT_EXT(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x30b), (val))

/* External antenna to use when internal antenna id 0 is active */
#define GP_WB_READ_TX_TX_ANT_EXT_0() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x30b)) & 0x0F)

#define GP_WB_GET_TX_TX_ANT_EXT_0_FROM_TX_ANT_EXT(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_TX_TX_ANT_EXT_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x30b), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_TX_TX_ANT_EXT_0_TO_TX_ANT_EXT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0xF0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* External antenna to use when internal antenna id 1 is active */
#define GP_WB_READ_TX_TX_ANT_EXT_1() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x30b)) >> 4) & 0x0F)

#define GP_WB_GET_TX_TX_ANT_EXT_1_FROM_TX_ANT_EXT(tmp) \
        (((tmp) >> 4) & 0x0F)

#define GP_WB_WRITE_TX_TX_ANT_EXT_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x30b), 0xF0, (val) << 4); \
        } while (0)

#define GP_WB_SET_TX_TX_ANT_EXT_1_TO_TX_ANT_EXT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* tx-ldo: set output voltage by changing reference voltage */
#define GP_WB_READ_TX_TX_LDO_REFBITS() \
        (GP_WB_S8(GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x30c)), 4))

#define GP_WB_WRITE_TX_TX_LDO_REFBITS(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -8, 7); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x30c), (UInt8)((val))); \
        } while (0)


/* tx: adjust the duty cycle of the rf input signal of the pa (nmos) */
#define GP_WB_READ_TX_TX_DCA_N() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x30e)) & 0x07)

#define GP_WB_WRITE_TX_TX_DCA_N(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x30e), 0x07, (val)); \
        } while (0)

/* tx: adjust the duty cycle of the rf input signal of the pa (pmos) */
#define GP_WB_READ_TX_TX_DCA_P() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x30e)) >> 3) & 0x07)

#define GP_WB_WRITE_TX_TX_DCA_P(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x30e), 0x38, (val) << 3); \
        } while (0)

/* disable bleed circuit on ldo */
#define GP_WB_READ_TX_TX_LDO_BLEED_OFF() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x30e), 6)

#define GP_WB_WRITE_TX_TX_LDO_BLEED_OFF(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x30e), 6, (val)); \
        } while (0)

/* power up the transmitter ldo */
#define GP_WB_READ_TX_TX_LDO_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x30e), 7)

#define GP_WB_WRITE_TX_TX_LDO_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x30e), 7, (val)); \
        } while (0)

/* tx: adjust the pa-reference bias current. */
#define GP_WB_READ_TX_TX_PA_BIASTRIM() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x30f)) & 0x07)

#define GP_WB_WRITE_TX_TX_PA_BIASTRIM(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x30f), 0x07, (val)); \
        } while (0)

/* tx: set the peak detector level */
#define GP_WB_READ_TX_TX_PEAK_LVL() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x30f)) >> 3) & 0x07)

#define GP_WB_WRITE_TX_TX_PEAK_LVL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x30f), 0x38, (val) << 3); \
        } while (0)

/* tx-ldo: resistor bypass to speedup settling */
#define GP_WB_READ_TX_TX_LDO_RES_BYPASS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x30f), 6)

#define GP_WB_WRITE_TX_TX_LDO_RES_BYPASS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x30f), 6, (val)); \
        } while (0)

/***************************
 * layout: rib
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_PBM_PTR_CONTROL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x400))

#define GP_WB_WRITE_RIB_PBM_PTR_CONTROL(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x400), (val))

#define GP_WB_READ_RIB_RX_PBM_PTR() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x400)) & 0x1F)

#define GP_WB_GET_RIB_RX_PBM_PTR_FROM_PBM_PTR_CONTROL(tmp) \
        ((tmp) & 0x1F)

#define GP_WB_WRITE_RIB_RX_PBM_PTR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x400), 0x1F, (val)); \
        } while (0)

#define GP_WB_SET_RIB_RX_PBM_PTR_TO_PBM_PTR_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x20; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_RIB_RX_PBM_PTR_VALID() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x400), 5)

#define GP_WB_GET_RIB_RX_PBM_PTR_VALID_FROM_PBM_PTR_CONTROL(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RIB_RX_PBM_PTR_VALID(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x400), 5, (val)); \
        } while (0)

#define GP_WB_SET_RIB_RX_PBM_PTR_VALID_TO_PBM_PTR_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* pbm number the macfilter will use to prepare and send an ack */
#define GP_WB_READ_RIB_ACK_PBM_PTR() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x401))

#define GP_WB_WRITE_RIB_ACK_PBM_PTR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x401), (val)); \
        } while (0)


/* sets the time needed for the phy/radio to go from the off state to the TX state (=ready to transmit). Delay = (off2tx_delay+1)*16us */
#define GP_WB_READ_RIB_OFF2TX_DELAY() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x402))

#define GP_WB_WRITE_RIB_OFF2TX_DELAY(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x402), (val)); \
        } while (0)


/* sets the time needed for the phy/radio to go from the off state to the RX state (=ready to receive). Delay = (off2rx_delay+1)*16us */
#define GP_WB_READ_RIB_OFF2RX_DELAY() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x403))

#define GP_WB_WRITE_RIB_OFF2RX_DELAY(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x403), (val)); \
        } while (0)


/* Sets the time needed to perform a single channel calibration. This includes the time needed for the radio to switch to calibration mode. delay = (cal_delay+1) * 16 us */
#define GP_WB_READ_RIB_CAL_DELAY() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x404))

#define GP_WB_WRITE_RIB_CAL_DELAY(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x404), (val)); \
        } while (0)


/* Delay between reception of a byte and processing of this byte in the PAR (in 62.5ns periods), this ensures the ack timing is correct (simulations show a delay of about 9.25 us). Actual ack turnaround will be (ack_turnaround+3)*16 us - (rx_processing_delay*62.5ns - real_rx_processing_delay). For this formula to be valid, the rx_processing_delay should stay below 232. */
#define GP_WB_READ_RIB_PHY_RX_PROCESSING_DELAY() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x405))

#define GP_WB_WRITE_RIB_PHY_RX_PROCESSING_DELAY(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x405), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_ACK_CONTROL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x406))

#define GP_WB_WRITE_RIB_ACK_CONTROL(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x406), (val))

/* Sets the time between the packet rx and the start of the tx ack. delay = (ack_turnaround+1)*16us. According to the spec this value should be 12, but the value should compensate for internal data delay and therefore the setting 9 is the correct value. It is important to make sure that this value is always bigger than the off2tx_delay, if not the actual delay will wrap ((ack_turnaround-off2tx_delay) mod 16). For tests purposes small turnarounds can be obtained by decreasing off2tx_delay and setting ack_turnaround equal to off2tx_delay. In order for the radio to still function correctly dont_disable_radio_for_rx_to_txack should be set to 1 */
#define GP_WB_READ_RIB_ACK_TURNAROUND() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x406)) & 0x0F)

#define GP_WB_GET_RIB_ACK_TURNAROUND_FROM_ACK_CONTROL(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_RIB_ACK_TURNAROUND(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x406), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_RIB_ACK_TURNAROUND_TO_ACK_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0xF0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Enables a power optimisation feature, where the device stops listening for the ack if it has not seen the start of a packet in time for a complete ack to be received */
#define GP_WB_READ_RIB_ACK_TIMEOUT_ON_START() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x406), 4)

#define GP_WB_GET_RIB_ACK_TIMEOUT_ON_START_FROM_ACK_CONTROL(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RIB_ACK_TIMEOUT_ON_START(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x406), 4, (val)); \
        } while (0)

#define GP_WB_SET_RIB_ACK_TIMEOUT_ON_START_TO_ACK_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* When set to 1, the radio will not be shut off between the rx packet end and the ack tx start. Instead, the radio will go through a Rx to TX transition */
#define GP_WB_READ_RIB_DONT_DISABLE_RADIO_FOR_RX_TO_TXACK() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x406), 5)

#define GP_WB_GET_RIB_DONT_DISABLE_RADIO_FOR_RX_TO_TXACK_FROM_ACK_CONTROL(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RIB_DONT_DISABLE_RADIO_FOR_RX_TO_TXACK(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x406), 5, (val)); \
        } while (0)

#define GP_WB_SET_RIB_DONT_DISABLE_RADIO_FOR_RX_TO_TXACK_TO_ACK_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* When set to 1, the radio will not be shut off between the tx packet end and the ack rx start. Instead, the radio will go through a Tx to RX transition */
#define GP_WB_READ_RIB_DONT_DISABLE_RADIO_FOR_TX_TO_RXACK() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x406), 6)

#define GP_WB_GET_RIB_DONT_DISABLE_RADIO_FOR_TX_TO_RXACK_FROM_ACK_CONTROL(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RIB_DONT_DISABLE_RADIO_FOR_TX_TO_RXACK(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x406), 6, (val)); \
        } while (0)

#define GP_WB_SET_RIB_DONT_DISABLE_RADIO_FOR_TX_TO_RXACK_TO_ACK_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* When in multichannel receive mode, the radio will be forced to listen to 1 channel during ack listening when this setting is enabled */
#define GP_WB_READ_RIB_USE_SINGLE_CHANNEL_FOR_ACK() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x406), 7)

#define GP_WB_GET_RIB_USE_SINGLE_CHANNEL_FOR_ACK_FROM_ACK_CONTROL(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_RIB_USE_SINGLE_CHANNEL_FOR_ACK(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x406), 7, (val)); \
        } while (0)

#define GP_WB_SET_RIB_USE_SINGLE_CHANNEL_FOR_ACK_TO_ACK_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* Sets the duration of the ack listening window from the start of an incoming packet */
#define GP_WB_READ_RIB_ACK_TIMEOUT() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x407))

#define GP_WB_WRITE_RIB_ACK_TIMEOUT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x407), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_IFS_CONTROL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x408))

#define GP_WB_WRITE_RIB_IFS_CONTROL(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x408), (val))

/* Sets the minimum inter frame spacing time (= time between 2 consecutive TX) time = ifs_length * 16us */
#define GP_WB_READ_RIB_IFS_LENGTH() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x408)) & 0x3F)

#define GP_WB_GET_RIB_IFS_LENGTH_FROM_IFS_CONTROL(tmp) \
        ((tmp) & 0x3F)

#define GP_WB_WRITE_RIB_IFS_LENGTH(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x408), 0x3F, (val)); \
        } while (0)

#define GP_WB_SET_RIB_IFS_LENGTH_TO_IFS_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0xC0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When set to 1, no minimum inter frame spacing is guaranteed for packet tx after packet tx */
#define GP_WB_READ_RIB_IFS_SKIP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x408), 6)

#define GP_WB_GET_RIB_IFS_SKIP_FROM_IFS_CONTROL(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RIB_IFS_SKIP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x408), 6, (val)); \
        } while (0)

#define GP_WB_SET_RIB_IFS_SKIP_TO_IFS_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* When set to 1, no minimum inter frame spacing is guaranteed for packet tx after ack tx */
#define GP_WB_READ_RIB_IFS_AFTER_TX_ACK_SKIP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x408), 7)

#define GP_WB_GET_RIB_IFS_AFTER_TX_ACK_SKIP_FROM_IFS_CONTROL(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_RIB_IFS_AFTER_TX_ACK_SKIP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x408), 7, (val)); \
        } while (0)

#define GP_WB_SET_RIB_IFS_AFTER_TX_ACK_SKIP_TO_IFS_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_GEN_OPTIONS_0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x409))

#define GP_WB_WRITE_RIB_GEN_OPTIONS_0(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x409), (val))

/* power optimisation feature, that will disable the radio because we can't receive anything anyway ( having no pbm is clearly not wanted behavior !) */
#define GP_WB_READ_RIB_DISABLE_RADIO_WHEN_NO_FREE_PBM() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x409), 0)

#define GP_WB_GET_RIB_DISABLE_RADIO_WHEN_NO_FREE_PBM_FROM_GEN_OPTIONS_0(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RIB_DISABLE_RADIO_WHEN_NO_FREE_PBM(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x409), 0, (val)); \
        } while (0)

#define GP_WB_SET_RIB_DISABLE_RADIO_WHEN_NO_FREE_PBM_TO_GEN_OPTIONS_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* when enabled, a pip event will trigger a restart of the receiver */
#define GP_WB_READ_RIB_RESTART_PACKET_DET_WHEN_PIP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x409), 1)

#define GP_WB_GET_RIB_RESTART_PACKET_DET_WHEN_PIP_FROM_GEN_OPTIONS_0(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RIB_RESTART_PACKET_DET_WHEN_PIP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x409), 1, (val)); \
        } while (0)

#define GP_WB_SET_RIB_RESTART_PACKET_DET_WHEN_PIP_TO_GEN_OPTIONS_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Disables the low level clockgating of the trc block */
#define GP_WB_READ_RIB_DISABLE_TRC_CLK_GATING() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x409), 2)

#define GP_WB_GET_RIB_DISABLE_TRC_CLK_GATING_FROM_GEN_OPTIONS_0(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RIB_DISABLE_TRC_CLK_GATING(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x409), 2, (val)); \
        } while (0)

#define GP_WB_SET_RIB_DISABLE_TRC_CLK_GATING_TO_GEN_OPTIONS_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* When in multichannel receive mode, the radio will be forced to listen to 1 channel during the rx window when this setting is enabled */
#define GP_WB_READ_RIB_USE_SINGLE_CHANNEL_FOR_RX_WINDOW() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x409), 3)

#define GP_WB_GET_RIB_USE_SINGLE_CHANNEL_FOR_RX_WINDOW_FROM_GEN_OPTIONS_0(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RIB_USE_SINGLE_CHANNEL_FOR_RX_WINDOW(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x409), 3, (val)); \
        } while (0)

#define GP_WB_SET_RIB_USE_SINGLE_CHANNEL_FOR_RX_WINDOW_TO_GEN_OPTIONS_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* indicates if the TX_PHY states should be aborted when a stop_tx is issued (so in fact if aborting an ongoing TX is allowed) */
#define GP_WB_READ_RIB_ENABLE_TX_PHY_ABORT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x409), 4)

#define GP_WB_GET_RIB_ENABLE_TX_PHY_ABORT_FROM_GEN_OPTIONS_0(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RIB_ENABLE_TX_PHY_ABORT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x409), 4, (val)); \
        } while (0)

#define GP_WB_SET_RIB_ENABLE_TX_PHY_ABORT_TO_GEN_OPTIONS_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* When enabled tx operations are allowed, otherwise they will be skipped. */
#define GP_WB_READ_RIB_ALLOW_TX() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x409), 5)

#define GP_WB_GET_RIB_ALLOW_TX_FROM_GEN_OPTIONS_0(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RIB_ALLOW_TX(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x409), 5, (val)); \
        } while (0)

#define GP_WB_SET_RIB_ALLOW_TX_TO_GEN_OPTIONS_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


#define GP_WB_WRITE_RIB_GEN_CONTROL_0(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x40a), (val))

/* Tries to stop an ongoing TX */
#define GP_WB_RIB_STOP_TX() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x40a), 0x01)

#define GP_WB_SET_RIB_STOP_TX_TO_GEN_CONTROL_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_RIB_STOP_RX_ACK_WINDOW() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x40a), 0x02)

#define GP_WB_SET_RIB_STOP_RX_ACK_WINDOW_TO_GEN_CONTROL_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_RIB_RESTART_PACKET_DET() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x40a), 0x04)

#define GP_WB_SET_RIB_RESTART_PACKET_DET_TO_GEN_CONTROL_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* triggers a channel change (including the channel calibration), to the channel indicated by channel_nr on the multichannel slot indicated by channel_idx on timestamp start_timestamp (if start_timestamp_valid is enabled) */
#define GP_WB_RIB_CHANNEL_CHANGE_REQUEST() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x40a), 0x08)

#define GP_WB_SET_RIB_CHANNEL_CHANGE_REQUEST_TO_GEN_CONTROL_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Opens a window immediately or on a timestamp based on settings of start_timestamp_valid, start_timestamp and end_timestamp */
#define GP_WB_RIB_START_WINDOW_REQUEST() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x40a), 0x10)

#define GP_WB_SET_RIB_START_WINDOW_REQUEST_TO_GEN_CONTROL_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Immediately closes the window opened on channel_idx */
#define GP_WB_RIB_STOP_WINDOW_REQUEST() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x40a), 0x20)

#define GP_WB_SET_RIB_STOP_WINDOW_REQUEST_TO_GEN_CONTROL_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_CHANNEL_CHANGE_CONTROL() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x40c))

#define GP_WB_WRITE_RIB_CHANNEL_CHANGE_CONTROL(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x40c), (val))

/* the channel that will be used for multichannel slot indicated by channel_idx, when requesting a channel change (0 ... 55) */
#define GP_WB_READ_RIB_CHANNEL_NR() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x40c))

#define GP_WB_GET_RIB_CHANNEL_NR_FROM_CHANNEL_CHANGE_CONTROL(tmp) \
        ((tmp) & 0x3F)

#define GP_WB_WRITE_RIB_CHANNEL_NR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x40c), (val)); \
        } while (0)

#define GP_WB_SET_RIB_CHANNEL_NR_TO_CHANNEL_CHANGE_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0x0F00; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* the multichannel slot that of which the channel will change, when requesting a channel change. Slots 0 to 5 are packet detection slots. Slot 6 is a TX only slot and should not be set through the regmap channel change request interface (use tx pbm instead) */
#define GP_WB_READ_RIB_CHANNEL_IDX() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x40d)) & 0x07)

#define GP_WB_GET_RIB_CHANNEL_IDX_FROM_CHANNEL_CHANGE_CONTROL(tmp) \
        (((tmp) >> 8) & 0x07)

#define GP_WB_WRITE_RIB_CHANNEL_IDX(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x40d), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_RIB_CHANNEL_IDX_TO_CHANNEL_CHANGE_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x083F; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* Indicates whether the value of start_timestamp should be taken into account for the start_window_request and channel_change_request */
#define GP_WB_READ_RIB_START_TIMESTAMP_VALID() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x40d), 3)

#define GP_WB_GET_RIB_START_TIMESTAMP_VALID_FROM_CHANNEL_CHANGE_CONTROL(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_RIB_START_TIMESTAMP_VALID(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x40d), 3, (val)); \
        } while (0)

#define GP_WB_SET_RIB_START_TIMESTAMP_VALID_TO_CHANNEL_CHANGE_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x073F; \
          (tmp) |= (((UInt16)(val)) << 11); \
        } while (0)


/* Indicates the execution time of the channel change (channel_change_request) and/or the start of the rx window (start_window_request) (1us) */
#define GP_WB_READ_RIB_START_TIMESTAMP() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x410))

#define GP_WB_WRITE_RIB_START_TIMESTAMP(val) do { \
          GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x410), (val)); \
        } while (0)

/* Indicates the time of the end of the window (start_window_request), is always taken into account (1us) */
#define GP_WB_READ_RIB_END_TIMESTAMP() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x414))

#define GP_WB_WRITE_RIB_END_TIMESTAMP(val) do { \
          GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x414), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_RX_ON_WHEN_IDLE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x418))

#define GP_WB_WRITE_RIB_RX_ON_WHEN_IDLE(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x418), (val))

/* enables listening for channel idx 0 */
#define GP_WB_READ_RIB_RX_ON_WHEN_IDLE_CH0() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x418), 0)

#define GP_WB_GET_RIB_RX_ON_WHEN_IDLE_CH0_FROM_RX_ON_WHEN_IDLE(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RIB_RX_ON_WHEN_IDLE_CH0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x418), 0, (val)); \
        } while (0)

#define GP_WB_SET_RIB_RX_ON_WHEN_IDLE_CH0_TO_RX_ON_WHEN_IDLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* enables listening for the selected channels */
#define GP_WB_READ_RIB_RX_ON_WHEN_IDLE_CH() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x418)) & 0x3F)

#define GP_WB_GET_RIB_RX_ON_WHEN_IDLE_CH_FROM_RX_ON_WHEN_IDLE(tmp) \
        ((tmp) & 0x3F)

#define GP_WB_WRITE_RIB_RX_ON_WHEN_IDLE_CH(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x418), 0x3F, (val)); \
        } while (0)

#define GP_WB_SET_RIB_RX_ON_WHEN_IDLE_CH_TO_RX_ON_WHEN_IDLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0x00; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* enables listening for channel idx 1 */
#define GP_WB_READ_RIB_RX_ON_WHEN_IDLE_CH1() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x418), 1)

#define GP_WB_GET_RIB_RX_ON_WHEN_IDLE_CH1_FROM_RX_ON_WHEN_IDLE(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RIB_RX_ON_WHEN_IDLE_CH1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x418), 1, (val)); \
        } while (0)

#define GP_WB_SET_RIB_RX_ON_WHEN_IDLE_CH1_TO_RX_ON_WHEN_IDLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* enables listening for channel idx 2 */
#define GP_WB_READ_RIB_RX_ON_WHEN_IDLE_CH2() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x418), 2)

#define GP_WB_GET_RIB_RX_ON_WHEN_IDLE_CH2_FROM_RX_ON_WHEN_IDLE(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RIB_RX_ON_WHEN_IDLE_CH2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x418), 2, (val)); \
        } while (0)

#define GP_WB_SET_RIB_RX_ON_WHEN_IDLE_CH2_TO_RX_ON_WHEN_IDLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* enables listening for channel idx 3 */
#define GP_WB_READ_RIB_RX_ON_WHEN_IDLE_CH3() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x418), 3)

#define GP_WB_GET_RIB_RX_ON_WHEN_IDLE_CH3_FROM_RX_ON_WHEN_IDLE(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RIB_RX_ON_WHEN_IDLE_CH3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x418), 3, (val)); \
        } while (0)

#define GP_WB_SET_RIB_RX_ON_WHEN_IDLE_CH3_TO_RX_ON_WHEN_IDLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* enables listening for channel idx 4 */
#define GP_WB_READ_RIB_RX_ON_WHEN_IDLE_CH4() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x418), 4)

#define GP_WB_GET_RIB_RX_ON_WHEN_IDLE_CH4_FROM_RX_ON_WHEN_IDLE(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RIB_RX_ON_WHEN_IDLE_CH4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x418), 4, (val)); \
        } while (0)

#define GP_WB_SET_RIB_RX_ON_WHEN_IDLE_CH4_TO_RX_ON_WHEN_IDLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* enables listening for channel idx 5 */
#define GP_WB_READ_RIB_RX_ON_WHEN_IDLE_CH5() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x418), 5)

#define GP_WB_GET_RIB_RX_ON_WHEN_IDLE_CH5_FROM_RX_ON_WHEN_IDLE(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RIB_RX_ON_WHEN_IDLE_CH5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x418), 5, (val)); \
        } while (0)

#define GP_WB_SET_RIB_RX_ON_WHEN_IDLE_CH5_TO_RX_ON_WHEN_IDLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_IS_BLE_CH() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x419))

#define GP_WB_WRITE_RIB_IS_BLE_CH(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x419), (val))

/* indicates if channel idx 0 is a BLE channel idx */
#define GP_WB_READ_RIB_IS_BLE_CH0() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x419), 0)

#define GP_WB_GET_RIB_IS_BLE_CH0_FROM_IS_BLE_CH(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RIB_IS_BLE_CH0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x419), 0, (val)); \
        } while (0)

#define GP_WB_SET_RIB_IS_BLE_CH0_TO_IS_BLE_CH(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* indicates if channel idx 1 is a BLE channel idx */
#define GP_WB_READ_RIB_IS_BLE_CH1() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x419), 1)

#define GP_WB_GET_RIB_IS_BLE_CH1_FROM_IS_BLE_CH(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RIB_IS_BLE_CH1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x419), 1, (val)); \
        } while (0)

#define GP_WB_SET_RIB_IS_BLE_CH1_TO_IS_BLE_CH(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* indicates if channel idx 2 is a BLE channel idx */
#define GP_WB_READ_RIB_IS_BLE_CH2() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x419), 2)

#define GP_WB_GET_RIB_IS_BLE_CH2_FROM_IS_BLE_CH(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RIB_IS_BLE_CH2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x419), 2, (val)); \
        } while (0)

#define GP_WB_SET_RIB_IS_BLE_CH2_TO_IS_BLE_CH(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* indicates if channel idx 3 is a BLE channel idx */
#define GP_WB_READ_RIB_IS_BLE_CH3() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x419), 3)

#define GP_WB_GET_RIB_IS_BLE_CH3_FROM_IS_BLE_CH(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RIB_IS_BLE_CH3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x419), 3, (val)); \
        } while (0)

#define GP_WB_SET_RIB_IS_BLE_CH3_TO_IS_BLE_CH(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* indicates if channel idx 4 is a BLE channel idx */
#define GP_WB_READ_RIB_IS_BLE_CH4() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x419), 4)

#define GP_WB_GET_RIB_IS_BLE_CH4_FROM_IS_BLE_CH(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RIB_IS_BLE_CH4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x419), 4, (val)); \
        } while (0)

#define GP_WB_SET_RIB_IS_BLE_CH4_TO_IS_BLE_CH(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* indicates if channel idx 5 is a BLE channel idx */
#define GP_WB_READ_RIB_IS_BLE_CH5() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x419), 5)

#define GP_WB_GET_RIB_IS_BLE_CH5_FROM_IS_BLE_CH(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RIB_IS_BLE_CH5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x419), 5, (val)); \
        } while (0)

#define GP_WB_SET_RIB_IS_BLE_CH5_TO_IS_BLE_CH(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


#define GP_WB_RIB_RX_PBM_PTR_CLR() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x41a), 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_RX_ON_REASON() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x41c))

/* the receiver "could" be put on because the TRC has been granted a valid PBM entry. Only this bit set is not enough to conclude that the receiver is on. */
#define GP_WB_READ_RIB_ENABLE_RX_ON() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x41c), 0)

#define GP_WB_GET_RIB_ENABLE_RX_ON_FROM_RX_ON_REASON(tmp) \
        ((tmp) & 0x01)

/* the receiver is ON because of the rx_on_when_idle bit */
#define GP_WB_READ_RIB_RX_ON_WHEN_IDLE_SET() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x41c), 1)

#define GP_WB_GET_RIB_RX_ON_WHEN_IDLE_SET_FROM_RX_ON_REASON(tmp) \
        (((tmp) >> 1) & 0x01)

/* the receive is on because the PBM entry being processed contained a GP_RX_DURATION field not equal to zero */
#define GP_WB_READ_RIB_RX_ON_RUN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x41c), 2)

#define GP_WB_GET_RIB_RX_ON_RUN_FROM_RX_ON_REASON(tmp) \
        (((tmp) >> 2) & 0x01)

/* the receive is on because the cca is in progress */
#define GP_WB_READ_RIB_CCA_RUN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x41c), 3)

#define GP_WB_GET_RIB_CCA_RUN_FROM_RX_ON_REASON(tmp) \
        (((tmp) >> 3) & 0x01)

/* the receive is on because the RX_ON event 0 has been received */
#define GP_WB_READ_RIB_ES_RX_ON_0() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x41c), 4)

#define GP_WB_GET_RIB_ES_RX_ON_0_FROM_RX_ON_REASON(tmp) \
        (((tmp) >> 4) & 0x01)

/* the receive is on because the RX_ON event 1 has been received */
#define GP_WB_READ_RIB_ES_RX_ON_1() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x41c), 5)

#define GP_WB_GET_RIB_ES_RX_ON_1_FROM_RX_ON_REASON(tmp) \
        (((tmp) >> 5) & 0x01)

/* the receive is on because the RX_ON event 2 has been received */
#define GP_WB_READ_RIB_ES_RX_ON_2() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x41c), 6)

#define GP_WB_GET_RIB_ES_RX_ON_2_FROM_RX_ON_REASON(tmp) \
        (((tmp) >> 6) & 0x01)

/* the receive is on because the RX_ON event 3 has been received */
#define GP_WB_READ_RIB_ES_RX_ON_3() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x41c), 7)

#define GP_WB_GET_RIB_ES_RX_ON_3_FROM_RX_ON_REASON(tmp) \
        (((tmp) >> 7) & 0x01)

/* the receive is on because a window was triggered through the direct rib interface (this is a channel idx map) */
#define GP_WB_READ_RIB_DIRECT_RX_WINDOW_ON() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x41d)) & 0x3F)

#define GP_WB_GET_RIB_DIRECT_RX_WINDOW_ON_FROM_RX_ON_REASON(tmp) \
        (((tmp) >> 8) & 0x3F)

/* the receive is on because a window was triggered through the direct rib interface on ch_idx0 */
#define GP_WB_READ_RIB_DIRECT_RX_WINDOW_ON_CH0() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x41d), 0)

#define GP_WB_GET_RIB_DIRECT_RX_WINDOW_ON_CH0_FROM_RX_ON_REASON(tmp) \
        (((tmp) >> 8) & 0x01)

/* the receive is on because a window was triggered through the direct rib interface on ch_idx1 */
#define GP_WB_READ_RIB_DIRECT_RX_WINDOW_ON_CH1() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x41d), 1)

#define GP_WB_GET_RIB_DIRECT_RX_WINDOW_ON_CH1_FROM_RX_ON_REASON(tmp) \
        (((tmp) >> 9) & 0x01)

/* the receive is on because a window was triggered through the direct rib interface on ch_idx2 */
#define GP_WB_READ_RIB_DIRECT_RX_WINDOW_ON_CH2() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x41d), 2)

#define GP_WB_GET_RIB_DIRECT_RX_WINDOW_ON_CH2_FROM_RX_ON_REASON(tmp) \
        (((tmp) >> 10) & 0x01)

/* the receive is on because a window was triggered through the direct rib interface on ch_idx3 */
#define GP_WB_READ_RIB_DIRECT_RX_WINDOW_ON_CH3() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x41d), 3)

#define GP_WB_GET_RIB_DIRECT_RX_WINDOW_ON_CH3_FROM_RX_ON_REASON(tmp) \
        (((tmp) >> 11) & 0x01)

/* the receive is on because a window was triggered through the direct rib interface on ch_idx4 */
#define GP_WB_READ_RIB_DIRECT_RX_WINDOW_ON_CH4() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x41d), 4)

#define GP_WB_GET_RIB_DIRECT_RX_WINDOW_ON_CH4_FROM_RX_ON_REASON(tmp) \
        (((tmp) >> 12) & 0x01)

/* the receive is on because a window was triggered through the direct rib interface on ch_idx5 */
#define GP_WB_READ_RIB_DIRECT_RX_WINDOW_ON_CH5() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x41d), 5)

#define GP_WB_GET_RIB_DIRECT_RX_WINDOW_ON_CH5_FROM_RX_ON_REASON(tmp) \
        (((tmp) >> 13) & 0x01)


/* shows the status of the rx on counter. Only valid when rx_on_run = TRUE */
#define GP_WB_READ_RIB_RX_ON_CNT() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x420))


#define GP_WB_READ_RIB_CSMA_FORCE_FAIL() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x423), 0)

#define GP_WB_WRITE_RIB_CSMA_FORCE_FAIL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x423), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_UNMASKED_INTERRUPTS() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x424))

#define GP_WB_READ_RIB_UNMASKED_PBM_FULL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x424), 0)

#define GP_WB_GET_RIB_UNMASKED_PBM_FULL_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_RIB_UNMASKED_TX_STARTED_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x424), 1)

#define GP_WB_GET_RIB_UNMASKED_TX_STARTED_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* obsolete for new trc */
#define GP_WB_READ_RIB_UNMASKED_TX_ACK_STARTED_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x424), 2)

#define GP_WB_GET_RIB_UNMASKED_TX_ACK_STARTED_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* This interrupt indicates that the phy was not ready when the mac expected it to be (check your of2rx / off2tx delay settings) */
#define GP_WB_READ_RIB_UNMASKED_PHY_TRANSITION_NOT_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x424), 3)

#define GP_WB_GET_RIB_UNMASKED_PHY_TRANSITION_NOT_DONE_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

/* Indicates a TX cycle triggered by mes_req has been finished */
#define GP_WB_READ_RIB_UNMASKED_TX_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x424), 4)

#define GP_WB_GET_RIB_UNMASKED_TX_DONE_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_READ_RIB_UNMASKED_MSG_REQ_WHILE_BUSY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x424), 5)

#define GP_WB_GET_RIB_UNMASKED_MSG_REQ_WHILE_BUSY_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

/* indicates a calibration has ended either through a channel change, pre_tx or post_tx calibration */
#define GP_WB_READ_RIB_UNMASKED_CAL_DONE_INTERRUPTS() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x425)) & 0x3F)

#define GP_WB_GET_RIB_UNMASKED_CAL_DONE_INTERRUPTS_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x3F)

#define GP_WB_READ_RIB_UNMASKED_CAL_DONE_CH0_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x425), 0)

#define GP_WB_GET_RIB_UNMASKED_CAL_DONE_CH0_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_READ_RIB_UNMASKED_CAL_DONE_CH1_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x425), 1)

#define GP_WB_GET_RIB_UNMASKED_CAL_DONE_CH1_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_READ_RIB_UNMASKED_CAL_DONE_CH2_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x425), 2)

#define GP_WB_GET_RIB_UNMASKED_CAL_DONE_CH2_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_READ_RIB_UNMASKED_CAL_DONE_CH3_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x425), 3)

#define GP_WB_GET_RIB_UNMASKED_CAL_DONE_CH3_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_READ_RIB_UNMASKED_CAL_DONE_CH4_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x425), 4)

#define GP_WB_GET_RIB_UNMASKED_CAL_DONE_CH4_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_READ_RIB_UNMASKED_CAL_DONE_CH5_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x425), 5)

#define GP_WB_GET_RIB_UNMASKED_CAL_DONE_CH5_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 13) & 0x01)

/* indicates a window (scheduled through start_window_request) has ended */
#define GP_WB_READ_RIB_UNMASKED_RX_WINDOW_DONE_INTERRUPTS() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x426)) & 0x3F)

#define GP_WB_GET_RIB_UNMASKED_RX_WINDOW_DONE_INTERRUPTS_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0x3F)

#define GP_WB_READ_RIB_UNMASKED_RX_WINDOW_DONE_CH0_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x426), 0)

#define GP_WB_GET_RIB_UNMASKED_RX_WINDOW_DONE_CH0_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_READ_RIB_UNMASKED_RX_WINDOW_DONE_CH1_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x426), 1)

#define GP_WB_GET_RIB_UNMASKED_RX_WINDOW_DONE_CH1_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 17) & 0x01)

#define GP_WB_READ_RIB_UNMASKED_RX_WINDOW_DONE_CH2_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x426), 2)

#define GP_WB_GET_RIB_UNMASKED_RX_WINDOW_DONE_CH2_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 18) & 0x01)

#define GP_WB_READ_RIB_UNMASKED_RX_WINDOW_DONE_CH3_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x426), 3)

#define GP_WB_GET_RIB_UNMASKED_RX_WINDOW_DONE_CH3_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 19) & 0x01)

#define GP_WB_READ_RIB_UNMASKED_RX_WINDOW_DONE_CH4_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x426), 4)

#define GP_WB_GET_RIB_UNMASKED_RX_WINDOW_DONE_CH4_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 20) & 0x01)

#define GP_WB_READ_RIB_UNMASKED_RX_WINDOW_DONE_CH5_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x426), 5)

#define GP_WB_GET_RIB_UNMASKED_RX_WINDOW_DONE_CH5_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 21) & 0x01)


#define GP_WB_WRITE_RIB_CLR_INTERRUPTS(val) \
      GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x428), (val))

#define GP_WB_RIB_CLR_PBM_FULL_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x428), 0x01)

#define GP_WB_SET_RIB_CLR_PBM_FULL_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F3F3E; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

#define GP_WB_RIB_CLR_TX_STARTED_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x428), 0x02)

#define GP_WB_SET_RIB_CLR_TX_STARTED_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F3F3D; \
          (tmp) |= (((UInt32)(val)) << 1); \
        } while (0)

/* obsolete for new trc */
#define GP_WB_RIB_CLR_TX_ACK_STARTED_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x428), 0x04)

#define GP_WB_SET_RIB_CLR_TX_ACK_STARTED_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F3F3B; \
          (tmp) |= (((UInt32)(val)) << 2); \
        } while (0)

#define GP_WB_RIB_CLR_PHY_TRANSITION_NOT_DONE_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x428), 0x08)

#define GP_WB_SET_RIB_CLR_PHY_TRANSITION_NOT_DONE_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F3F37; \
          (tmp) |= (((UInt32)(val)) << 3); \
        } while (0)

#define GP_WB_RIB_CLR_TX_DONE_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x428), 0x10)

#define GP_WB_SET_RIB_CLR_TX_DONE_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F3F2F; \
          (tmp) |= (((UInt32)(val)) << 4); \
        } while (0)

#define GP_WB_RIB_CLR_MSG_REQ_WHILE_BUSY_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x428), 0x20)

#define GP_WB_SET_RIB_CLR_MSG_REQ_WHILE_BUSY_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F3F1F; \
          (tmp) |= (((UInt32)(val)) << 5); \
        } while (0)

#define GP_WB_WRITE_RIB_CLR_CAL_DONE_INTERRUPTS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x429), (val)); \
        } while (0)

#define GP_WB_SET_RIB_CLR_CAL_DONE_INTERRUPTS_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0x3F003F; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

#define GP_WB_RIB_CLR_CAL_DONE_CH0_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x429), 0x01)

#define GP_WB_SET_RIB_CLR_CAL_DONE_CH0_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F3E3F; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

#define GP_WB_RIB_CLR_CAL_DONE_CH1_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x429), 0x02)

#define GP_WB_SET_RIB_CLR_CAL_DONE_CH1_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F3D3F; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

#define GP_WB_RIB_CLR_CAL_DONE_CH2_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x429), 0x04)

#define GP_WB_SET_RIB_CLR_CAL_DONE_CH2_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F3B3F; \
          (tmp) |= (((UInt32)(val)) << 10); \
        } while (0)

#define GP_WB_RIB_CLR_CAL_DONE_CH3_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x429), 0x08)

#define GP_WB_SET_RIB_CLR_CAL_DONE_CH3_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F373F; \
          (tmp) |= (((UInt32)(val)) << 11); \
        } while (0)

#define GP_WB_RIB_CLR_CAL_DONE_CH4_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x429), 0x10)

#define GP_WB_SET_RIB_CLR_CAL_DONE_CH4_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F2F3F; \
          (tmp) |= (((UInt32)(val)) << 12); \
        } while (0)

#define GP_WB_RIB_CLR_CAL_DONE_CH5_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x429), 0x20)

#define GP_WB_SET_RIB_CLR_CAL_DONE_CH5_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F1F3F; \
          (tmp) |= (((UInt32)(val)) << 13); \
        } while (0)

#define GP_WB_WRITE_RIB_CLR_RX_WINDOW_DONE_INTERRUPTS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x42a), (val)); \
        } while (0)

#define GP_WB_SET_RIB_CLR_RX_WINDOW_DONE_INTERRUPTS_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0x003F3F; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

#define GP_WB_RIB_CLR_RX_WINDOW_DONE_CH0_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x42a), 0x01)

#define GP_WB_SET_RIB_CLR_RX_WINDOW_DONE_CH0_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E3F3F; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

#define GP_WB_RIB_CLR_RX_WINDOW_DONE_CH1_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x42a), 0x02)

#define GP_WB_SET_RIB_CLR_RX_WINDOW_DONE_CH1_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3D3F3F; \
          (tmp) |= (((UInt32)(val)) << 17); \
        } while (0)

#define GP_WB_RIB_CLR_RX_WINDOW_DONE_CH2_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x42a), 0x04)

#define GP_WB_SET_RIB_CLR_RX_WINDOW_DONE_CH2_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3B3F3F; \
          (tmp) |= (((UInt32)(val)) << 18); \
        } while (0)

#define GP_WB_RIB_CLR_RX_WINDOW_DONE_CH3_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x42a), 0x08)

#define GP_WB_SET_RIB_CLR_RX_WINDOW_DONE_CH3_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x373F3F; \
          (tmp) |= (((UInt32)(val)) << 19); \
        } while (0)

#define GP_WB_RIB_CLR_RX_WINDOW_DONE_CH4_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x42a), 0x10)

#define GP_WB_SET_RIB_CLR_RX_WINDOW_DONE_CH4_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F3F3F; \
          (tmp) |= (((UInt32)(val)) << 20); \
        } while (0)

#define GP_WB_RIB_CLR_RX_WINDOW_DONE_CH5_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x42a), 0x20)

#define GP_WB_SET_RIB_CLR_RX_WINDOW_DONE_CH5_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F3F3F; \
          (tmp) |= (((UInt32)(val)) << 21); \
        } while (0)


/* reflects the state of the internal TRC statemachine. This state is a good indication for what phase the packet transmission / reception is in */
#define GP_WB_READ_RIB_TRC_STATE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x42b))


/* Nr of the pan_id/short address table entries (table contains coord, channel_idx, pan_id, short_addr) (0xFF means 256 bytes) (table itself is in the macfilt regmap) - this effectively enables multi-pan feature */
#define GP_WB_READ_RIB_DST_PAN_ID_TABLE_SIZE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x42c))

#define GP_WB_WRITE_RIB_DST_PAN_ID_TABLE_SIZE(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x42c), (val)); \
        } while (0)


/* Sequence number observation register for the sequence number of ongoing transmission */
#define GP_WB_READ_RIB_TX_SEQ_NUMBER() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x42d))


/* Triggers tx flow of a frame */
#define GP_WB_RIB_TX_MSG_REQ() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x42e), 0x01)


/* Index of PBM to be sent */
#define GP_WB_READ_RIB_TX_PBM_INDEX() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x42f))

#define GP_WB_WRITE_RIB_TX_PBM_INDEX(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x42f), (val)); \
        } while (0)


/* Contains the return code of the tx flow (valid when tx_done interrupt was triggered) */
#define GP_WB_READ_RIB_TX_RETURN_CODE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x430))


/* timestamp on which tx should start(=PA on) (if tx_on_timestamp enabled). Afterwards: timestamp on actual transmission. */
#define GP_WB_READ_RIB_TX_TIMESTAMP() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x434))

#define GP_WB_WRITE_RIB_TX_TIMESTAMP(val) do { \
          GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x434), (val)); \
        } while (0)


#define GP_WB_READ_RIB_TX_FRAME_PTR() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x438))

#define GP_WB_WRITE_RIB_TX_FRAME_PTR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x438), (val)); \
        } while (0)


/* length of the frame to be sent */
#define GP_WB_READ_RIB_TX_FRAME_LEN() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x43a))

#define GP_WB_WRITE_RIB_TX_FRAME_LEN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x43a), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_TX_CHANNEL_SETTINGS() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x43c))

#define GP_WB_WRITE_RIB_TX_CHANNEL_SETTINGS(val) \
      GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x43c), (val))

/* Indicates to which stack, the pbm belongs. In a multichannel environment this will determine what channel in hte channel list will be changed during pre and post channel change */
#define GP_WB_READ_RIB_TX_CHANNEL_IDX() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x43c))

#define GP_WB_GET_RIB_TX_CHANNEL_IDX_FROM_TX_CHANNEL_SETTINGS(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_RIB_TX_CHANNEL_IDX(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x43c), (val)); \
        } while (0)

#define GP_WB_SET_RIB_TX_CHANNEL_IDX_TO_TX_CHANNEL_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x3F3F00; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* do pre-transmission channel change */
#define GP_WB_READ_RIB_TX_CHANNEL_CH0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x43d))

#define GP_WB_GET_RIB_TX_CHANNEL_CH0_FROM_TX_CHANNEL_SETTINGS(tmp) \
        (((tmp) >> 8) & 0x3F)

#define GP_WB_WRITE_RIB_TX_CHANNEL_CH0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x43d), (val)); \
        } while (0)

#define GP_WB_SET_RIB_TX_CHANNEL_CH0_TO_TX_CHANNEL_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0x3F0007; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* do post-transmission channel change */
#define GP_WB_READ_RIB_TX_CHANNEL_CH1() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x43e))

#define GP_WB_GET_RIB_TX_CHANNEL_CH1_FROM_TX_CHANNEL_SETTINGS(tmp) \
        (((tmp) >> 16) & 0x3F)

#define GP_WB_WRITE_RIB_TX_CHANNEL_CH1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x43e), (val)); \
        } while (0)

#define GP_WB_SET_RIB_TX_CHANNEL_CH1_TO_TX_CHANNEL_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0x003F07; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_TX_FLOW_CTRL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x43f))

#define GP_WB_WRITE_RIB_TX_FLOW_CTRL(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x43f), (val))

/* skip calibration before actual tx */
#define GP_WB_READ_RIB_TX_SKIP_CAL() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x43f), 0)

#define GP_WB_GET_RIB_TX_SKIP_CAL_FROM_TX_FLOW_CTRL(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RIB_TX_SKIP_CAL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x43f), 0, (val)); \
        } while (0)

#define GP_WB_SET_RIB_TX_SKIP_CAL_TO_TX_FLOW_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Before each packet transmission (including retransmission), the MAC will check the status of this bits in the sequence CH0A_EN (first transmission), CH0B_EN (first retransmission), CH0C_EN (second retransmission), CH0A_EN (third retransmission) etc. If the bit being analyzed is set, the PHY channel will be set to the corresponding value (MM_GP_CHANNEL_CH0[A/B/C]) */
#define GP_WB_READ_RIB_TX_CHANNEL_CH0_EN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x43f), 1)

#define GP_WB_GET_RIB_TX_CHANNEL_CH0_EN_FROM_TX_FLOW_CTRL(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RIB_TX_CHANNEL_CH0_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x43f), 1, (val)); \
        } while (0)

#define GP_WB_SET_RIB_TX_CHANNEL_CH0_EN_TO_TX_FLOW_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* If this bit is set, at the end of the transmission process the PHY channel will be set to the corresponding value */
#define GP_WB_READ_RIB_TX_CHANNEL_CH1_EN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x43f), 2)

#define GP_WB_GET_RIB_TX_CHANNEL_CH1_EN_FROM_TX_FLOW_CTRL(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RIB_TX_CHANNEL_CH1_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x43f), 2, (val)); \
        } while (0)

#define GP_WB_SET_RIB_TX_CHANNEL_CH1_EN_TO_TX_FLOW_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* start tx even when a frame is being received */
#define GP_WB_READ_RIB_TX_INTERRUPT_RX() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x43f), 3)

#define GP_WB_GET_RIB_TX_INTERRUPT_RX_FROM_TX_FLOW_CTRL(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_RIB_TX_INTERRUPT_RX(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x43f), 3, (val)); \
        } while (0)

#define GP_WB_SET_RIB_TX_INTERRUPT_RX_TO_TX_FLOW_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* perform tx even if timestamp has already passed (eg due to calibration taking too long) */
#define GP_WB_READ_RIB_TX_IF_TOO_LATE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x43f), 4)

#define GP_WB_GET_RIB_TX_IF_TOO_LATE_FROM_TX_FLOW_CTRL(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_RIB_TX_IF_TOO_LATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x43f), 4, (val)); \
        } while (0)

#define GP_WB_SET_RIB_TX_IF_TOO_LATE_TO_TX_FLOW_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* do tx on given timestamp */
#define GP_WB_READ_RIB_TX_ON_TIMESTAMP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x43f), 5)

#define GP_WB_GET_RIB_TX_ON_TIMESTAMP_FROM_TX_FLOW_CTRL(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_RIB_TX_ON_TIMESTAMP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x43f), 5, (val)); \
        } while (0)

#define GP_WB_SET_RIB_TX_ON_TIMESTAMP_TO_TX_FLOW_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* Enable or disable crc */
#define GP_WB_READ_RIB_TX_FCS_INSERT_DIS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x43f), 6)

#define GP_WB_GET_RIB_TX_FCS_INSERT_DIS_FROM_TX_FLOW_CTRL(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RIB_TX_FCS_INSERT_DIS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x43f), 6, (val)); \
        } while (0)

#define GP_WB_SET_RIB_TX_FCS_INSERT_DIS_TO_TX_FLOW_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* Enable whitening of the data */
#define GP_WB_READ_RIB_TX_WHITENING_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x43f), 7)

#define GP_WB_GET_RIB_TX_WHITENING_ENABLE_FROM_TX_FLOW_CTRL(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_RIB_TX_WHITENING_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x43f), 7, (val)); \
        } while (0)

#define GP_WB_SET_RIB_TX_WHITENING_ENABLE_TO_TX_FLOW_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_TX_EXTERNAL_PA_FEM_SETTINGS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x440))

#define GP_WB_WRITE_RIB_TX_EXTERNAL_PA_FEM_SETTINGS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x440), (val))

/* 4 general purpose mode bits that are output to the iob and can be put on pins during the TX phase. This allows for controlling external PA/FEM */
#define GP_WB_READ_RIB_TX_MODE_CTRL() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x440)) & 0x0F)

#define GP_WB_GET_RIB_TX_MODE_CTRL_FROM_TX_EXTERNAL_PA_FEM_SETTINGS(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_RIB_TX_MODE_CTRL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x440), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_RIB_TX_MODE_CTRL_TO_TX_EXTERNAL_PA_FEM_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0xF0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Extenal antenna to be used */
#define GP_WB_READ_RIB_TX_EXT_ANTENNA() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x440)) >> 4) & 0x0F)

#define GP_WB_GET_RIB_TX_EXT_ANTENNA_FROM_TX_EXTERNAL_PA_FEM_SETTINGS(tmp) \
        (((tmp) >> 4) & 0x0F)

#define GP_WB_WRITE_RIB_TX_EXT_ANTENNA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x440), 0xF0, (val) << 4); \
        } while (0)

#define GP_WB_SET_RIB_TX_EXT_ANTENNA_TO_TX_EXTERNAL_PA_FEM_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_TX_PA_POWER_SETTINGS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x441))

#define GP_WB_WRITE_RIB_TX_PA_POWER_SETTINGS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x441), (val))

/* Desired Power for transmitted packet */
#define GP_WB_READ_RIB_TX_POWER() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x441)) & 0x3F)

#define GP_WB_GET_RIB_TX_POWER_FROM_TX_PA_POWER_SETTINGS(tmp) \
        ((tmp) & 0x3F)

#define GP_WB_WRITE_RIB_TX_POWER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x441), 0x3F, (val)); \
        } while (0)

#define GP_WB_SET_RIB_TX_POWER_TO_TX_PA_POWER_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0xC0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* chooses the low PA power curve when set */
#define GP_WB_READ_RIB_TX_PA_LOW() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x441), 6)

#define GP_WB_GET_RIB_TX_PA_LOW_FROM_TX_PA_POWER_SETTINGS(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_RIB_TX_PA_LOW(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x441), 6, (val)); \
        } while (0)

#define GP_WB_SET_RIB_TX_PA_LOW_TO_TX_PA_POWER_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* chooses the low ultra low PA power curve when set */
#define GP_WB_READ_RIB_TX_PA_ULTRA_LOW() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x441), 7)

#define GP_WB_GET_RIB_TX_PA_ULTRA_LOW_FROM_TX_PA_POWER_SETTINGS(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_RIB_TX_PA_ULTRA_LOW(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x441), 7, (val)); \
        } while (0)

#define GP_WB_SET_RIB_TX_PA_ULTRA_LOW_TO_TX_PA_POWER_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* Supplemental length in us. Includes Guard and Reference periods */
#define GP_WB_READ_RIB_TX_SUPPLEMENTAL_LEN() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x442))

#define GP_WB_WRITE_RIB_TX_SUPPLEMENTAL_LEN(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x442), (val)); \
        } while (0)


/* Default is -250kHz */
#define GP_WB_READ_RIB_TX_SUPPLEMENTAL_INVERT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x443), 0)

#define GP_WB_WRITE_RIB_TX_SUPPLEMENTAL_INVERT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x443), (val)); \
        } while (0)


/* In what BLE mode to send the packet in, see enum */
#define GP_WB_READ_RIB_TX_PHY_MODE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x444))

#define GP_WB_WRITE_RIB_TX_PHY_MODE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x444), (val)); \
        } while (0)


/* symbol to use as preamble */
#define GP_WB_READ_RIB_TX_PREAMBLE_SYMBOL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x446))

#define GP_WB_WRITE_RIB_TX_PREAMBLE_SYMBOL(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x446), (val)); \
        } while (0)

/* number of preamble symbols to transmit */
#define GP_WB_READ_RIB_TX_PREAMBLE_LEN() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x447))

#define GP_WB_WRITE_RIB_TX_PREAMBLE_LEN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x447), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RIB_TX_PAT_START_BYTES() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x448))

#define GP_WB_WRITE_RIB_TX_PAT_START_BYTES(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x448), (val))

/* First byte to whiten (zero indexed, starting after the HW generated preamble) */
#define GP_WB_READ_RIB_TX_WHITENING_START_BYTE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x448)) & 0x0F)

#define GP_WB_GET_RIB_TX_WHITENING_START_BYTE_FROM_TX_PAT_START_BYTES(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_RIB_TX_WHITENING_START_BYTE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x448), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_RIB_TX_WHITENING_START_BYTE_TO_TX_PAT_START_BYTES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x1FF0; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* First byte to calculate crc on (zero indexed, starting after the HW generated preamble) */
#define GP_WB_READ_RIB_TX_CRC_START_BYTE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x448)) >> 4) & 0x0F)

#define GP_WB_GET_RIB_TX_CRC_START_BYTE_FROM_TX_PAT_START_BYTES(tmp) \
        (((tmp) >> 4) & 0x0F)

#define GP_WB_WRITE_RIB_TX_CRC_START_BYTE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x448), 0xF0, (val) << 4); \
        } while (0)

#define GP_WB_SET_RIB_TX_CRC_START_BYTE_TO_TX_PAT_START_BYTES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x1F0F; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* First byte to encode (zero indexed, starting after the HW generated preamble) */
#define GP_WB_READ_RIB_TX_LR_ENCODE_START_BYTE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x449))

#define GP_WB_GET_RIB_TX_LR_ENCODE_START_BYTE_FROM_TX_PAT_START_BYTES(tmp) \
        (((tmp) >> 8) & 0x1F)

#define GP_WB_WRITE_RIB_TX_LR_ENCODE_START_BYTE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x449), (val)); \
        } while (0)

#define GP_WB_SET_RIB_TX_LR_ENCODE_START_BYTE_TO_TX_PAT_START_BYTES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x00FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)


/* use antenna 0/1 */
#define GP_WB_READ_RIB_TX_ANTENNA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x44b), 0)

#define GP_WB_WRITE_RIB_TX_ANTENNA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x44b), (val)); \
        } while (0)


/* Initial value of the whitening shift register (bit_reversed => init == (0x40 | ble_ch_idx) ) */
#define GP_WB_READ_RIB_TX_WHITENING_INIT_REV() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x44c))

#define GP_WB_WRITE_RIB_TX_WHITENING_INIT_REV(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x44c), (val)); \
        } while (0)


/* Initial value of the CRC shift register */
#define GP_WB_READ_RIB_TX_FCS_INIT() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x450))

#define GP_WB_WRITE_RIB_TX_FCS_INIT(val) do { \
          GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x450), (val)); \
        } while (0)


/* Hold an active grant as long as the trc is busy (even when the request is dropped). Grant is cleared when request has dropped and trc is not busy */
#define GP_WB_READ_RIB_RETAIN_GRANT_ON_TRC_BUSY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x453), 0)

#define GP_WB_WRITE_RIB_RETAIN_GRANT_ON_TRC_BUSY(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x453), (val)); \
        } while (0)


/* Selects either the BLE or ZB pat when using the mgmt itf */
#define GP_WB_READ_RIB_MGMT_PAT_SELECT_BLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x454), 0)

#define GP_WB_WRITE_RIB_MGMT_PAT_SELECT_BLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x454), (val)); \
        } while (0)

/***************************
 * layout: qta
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_QTA_QTA_ENTRY_0() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x480))

#define GP_WB_READ_QTA_PBM_PTR_0() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x480)) & 0x1F)

#define GP_WB_GET_QTA_PBM_PTR_0_FROM_QTA_ENTRY_0(tmp) \
        ((tmp) & 0x1F)

#define GP_WB_READ_QTA_STATE_0() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x480)) >> 5) & 0x07)

#define GP_WB_GET_QTA_STATE_0_FROM_QTA_ENTRY_0(tmp) \
        (((tmp) >> 5) & 0x07)

#define GP_WB_READ_QTA_VQ_0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x481))

#define GP_WB_GET_QTA_VQ_0_FROM_QTA_ENTRY_0(tmp) \
        (((tmp) >> 8) & 0x07)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_QTA_QTA_ENTRY_1() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x482))

#define GP_WB_READ_QTA_PBM_PTR_1() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x482)) & 0x1F)

#define GP_WB_GET_QTA_PBM_PTR_1_FROM_QTA_ENTRY_1(tmp) \
        ((tmp) & 0x1F)

#define GP_WB_READ_QTA_STATE_1() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x482)) >> 5) & 0x07)

#define GP_WB_GET_QTA_STATE_1_FROM_QTA_ENTRY_1(tmp) \
        (((tmp) >> 5) & 0x07)

#define GP_WB_READ_QTA_VQ_1() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x483))

#define GP_WB_GET_QTA_VQ_1_FROM_QTA_ENTRY_1(tmp) \
        (((tmp) >> 8) & 0x07)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_QTA_QTA_ENTRY_2() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x484))

#define GP_WB_READ_QTA_PBM_PTR_2() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x484)) & 0x1F)

#define GP_WB_GET_QTA_PBM_PTR_2_FROM_QTA_ENTRY_2(tmp) \
        ((tmp) & 0x1F)

#define GP_WB_READ_QTA_STATE_2() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x484)) >> 5) & 0x07)

#define GP_WB_GET_QTA_STATE_2_FROM_QTA_ENTRY_2(tmp) \
        (((tmp) >> 5) & 0x07)

#define GP_WB_READ_QTA_VQ_2() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x485))

#define GP_WB_GET_QTA_VQ_2_FROM_QTA_ENTRY_2(tmp) \
        (((tmp) >> 8) & 0x07)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_QTA_QTA_ENTRY_3() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x486))

#define GP_WB_READ_QTA_PBM_PTR_3() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x486)) & 0x1F)

#define GP_WB_GET_QTA_PBM_PTR_3_FROM_QTA_ENTRY_3(tmp) \
        ((tmp) & 0x1F)

#define GP_WB_READ_QTA_STATE_3() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x486)) >> 5) & 0x07)

#define GP_WB_GET_QTA_STATE_3_FROM_QTA_ENTRY_3(tmp) \
        (((tmp) >> 5) & 0x07)

#define GP_WB_READ_QTA_VQ_3() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x487))

#define GP_WB_GET_QTA_VQ_3_FROM_QTA_ENTRY_3(tmp) \
        (((tmp) >> 8) & 0x07)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_QTA_QTA_ENTRY_4() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x488))

#define GP_WB_READ_QTA_PBM_PTR_4() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x488)) & 0x1F)

#define GP_WB_GET_QTA_PBM_PTR_4_FROM_QTA_ENTRY_4(tmp) \
        ((tmp) & 0x1F)

#define GP_WB_READ_QTA_STATE_4() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x488)) >> 5) & 0x07)

#define GP_WB_GET_QTA_STATE_4_FROM_QTA_ENTRY_4(tmp) \
        (((tmp) >> 5) & 0x07)

#define GP_WB_READ_QTA_VQ_4() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x489))

#define GP_WB_GET_QTA_VQ_4_FROM_QTA_ENTRY_4(tmp) \
        (((tmp) >> 8) & 0x07)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_QTA_QTA_ENTRY_5() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x48a))

#define GP_WB_READ_QTA_PBM_PTR_5() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x48a)) & 0x1F)

#define GP_WB_GET_QTA_PBM_PTR_5_FROM_QTA_ENTRY_5(tmp) \
        ((tmp) & 0x1F)

#define GP_WB_READ_QTA_STATE_5() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x48a)) >> 5) & 0x07)

#define GP_WB_GET_QTA_STATE_5_FROM_QTA_ENTRY_5(tmp) \
        (((tmp) >> 5) & 0x07)

#define GP_WB_READ_QTA_VQ_5() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x48b))

#define GP_WB_GET_QTA_VQ_5_FROM_QTA_ENTRY_5(tmp) \
        (((tmp) >> 8) & 0x07)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_QTA_QTA_ENTRY_6() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x48c))

#define GP_WB_READ_QTA_PBM_PTR_6() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x48c)) & 0x1F)

#define GP_WB_GET_QTA_PBM_PTR_6_FROM_QTA_ENTRY_6(tmp) \
        ((tmp) & 0x1F)

#define GP_WB_READ_QTA_STATE_6() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x48c)) >> 5) & 0x07)

#define GP_WB_GET_QTA_STATE_6_FROM_QTA_ENTRY_6(tmp) \
        (((tmp) >> 5) & 0x07)

#define GP_WB_READ_QTA_VQ_6() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x48d))

#define GP_WB_GET_QTA_VQ_6_FROM_QTA_ENTRY_6(tmp) \
        (((tmp) >> 8) & 0x07)


/* indicates wheter the queue is busy with memory accesses or not */
#define GP_WB_READ_QTA_BUSY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x48e), 0)


/* data request, only pbm entries smaller than 32 are accepted */
#define GP_WB_WRITE_QTA_PBEFE_DATA_REQ(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x48f), (val)); \
        } while (0)


/* Purge trigger */
#define GP_WB_QTA_PURGE_REQ() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x490), 0x01)


/* PBM entry purge request to RTMAC QTA */
#define GP_WB_READ_QTA_PBM_TO_PURGE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x491))

#define GP_WB_WRITE_QTA_PBM_TO_PURGE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x491), (val)); \
        } while (0)


#define GP_WB_READ_QTA_DISABLE_UNTIMED_QUEUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x492), 0)

#define GP_WB_WRITE_QTA_DISABLE_UNTIMED_QUEUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x492), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_QTA_UNMASKED_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x493))

#define GP_WB_READ_QTA_UNMASKED_SCH0_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x493), 0)

#define GP_WB_GET_QTA_UNMASKED_SCH0_EMPTY_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_QTA_UNMASKED_SCH1_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x493), 1)

#define GP_WB_GET_QTA_UNMASKED_SCH1_EMPTY_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_QTA_UNMASKED_SCH2_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x493), 2)

#define GP_WB_GET_QTA_UNMASKED_SCH2_EMPTY_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_QTA_UNMASKED_SCH3_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x493), 3)

#define GP_WB_GET_QTA_UNMASKED_SCH3_EMPTY_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_READ_QTA_UNMASKED_QUEUE_FULL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x493), 4)

#define GP_WB_GET_QTA_UNMASKED_QUEUE_FULL_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)


#define GP_WB_WRITE_QTA_CLR_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x494), (val))

#define GP_WB_QTA_CLR_SCH0_EMPTY_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x494), 0x01)

#define GP_WB_SET_QTA_CLR_SCH0_EMPTY_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_QTA_CLR_SCH1_EMPTY_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x494), 0x02)

#define GP_WB_SET_QTA_CLR_SCH1_EMPTY_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_QTA_CLR_SCH2_EMPTY_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x494), 0x04)

#define GP_WB_SET_QTA_CLR_SCH2_EMPTY_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_QTA_CLR_SCH3_EMPTY_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x494), 0x08)

#define GP_WB_SET_QTA_CLR_SCH3_EMPTY_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_QTA_CLR_QUEUE_FULL_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x494), 0x10)

#define GP_WB_SET_QTA_CLR_QUEUE_FULL_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/***************************
 * layout: radio_arb
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIO_ARB_GRANTED() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4c0))

#define GP_WB_READ_RADIO_ARB_MGMT_GRANTED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4c0), 0)

#define GP_WB_GET_RADIO_ARB_MGMT_GRANTED_FROM_GRANTED(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_RADIO_ARB_BLE_GRANTED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4c0), 1)

#define GP_WB_GET_RADIO_ARB_BLE_GRANTED_FROM_GRANTED(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_RADIO_ARB_ZB_GRANTED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4c0), 2)

#define GP_WB_GET_RADIO_ARB_ZB_GRANTED_FROM_GRANTED(tmp) \
        (((tmp) >> 2) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RADIO_ARB_CLAIM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4c1))

#define GP_WB_WRITE_RADIO_ARB_CLAIM(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4c1), (val))

#define GP_WB_READ_RADIO_ARB_MGMT_CLAIM() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4c1), 0)

#define GP_WB_GET_RADIO_ARB_MGMT_CLAIM_FROM_CLAIM(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_RADIO_ARB_MGMT_CLAIM(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4c1), 0, (val)); \
        } while (0)

#define GP_WB_SET_RADIO_ARB_MGMT_CLAIM_TO_CLAIM(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_RADIO_ARB_BLE_CLAIM() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4c1), 1)

#define GP_WB_GET_RADIO_ARB_BLE_CLAIM_FROM_CLAIM(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_RADIO_ARB_BLE_CLAIM(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4c1), 1, (val)); \
        } while (0)

#define GP_WB_SET_RADIO_ARB_BLE_CLAIM_TO_CLAIM(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_RADIO_ARB_ZB_CLAIM() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4c1), 2)

#define GP_WB_GET_RADIO_ARB_ZB_CLAIM_FROM_CLAIM(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_RADIO_ARB_ZB_CLAIM(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4c1), 2, (val)); \
        } while (0)

#define GP_WB_SET_RADIO_ARB_ZB_CLAIM_TO_CLAIM(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/***************************
 * layout: prg
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PRG_PRG_SETTING() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4d0))

#define GP_WB_WRITE_PRG_PRG_SETTING(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4d0), (val))

/* Enable clk_prg by uC  when 0x1 */
#define GP_WB_READ_PRG_ENABLE_CLK_PRG_BY_UC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4d0), 0)

#define GP_WB_GET_PRG_ENABLE_CLK_PRG_BY_UC_FROM_PRG_SETTING(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_PRG_ENABLE_CLK_PRG_BY_UC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4d0), 0, (val)); \
        } while (0)

#define GP_WB_SET_PRG_ENABLE_CLK_PRG_BY_UC_TO_PRG_SETTING(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Enable pseudo random generation when 0x1 */
#define GP_WB_READ_PRG_ENABLE_RANDOM_SEED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4d0), 1)

#define GP_WB_GET_PRG_ENABLE_RANDOM_SEED_FROM_PRG_SETTING(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_PRG_ENABLE_RANDOM_SEED(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4d0), 1, (val)); \
        } while (0)

#define GP_WB_SET_PRG_ENABLE_RANDOM_SEED_TO_PRG_SETTING(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Enables the use of a real single bit random source coming from the rx_i signal. Receiver needs to be on for this to work, otherwise a Pseudo random number is generated. */
#define GP_WB_READ_PRG_ENABLE_RANDOM_SOURCE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4d0), 2)

#define GP_WB_GET_PRG_ENABLE_RANDOM_SOURCE_FROM_PRG_SETTING(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_PRG_ENABLE_RANDOM_SOURCE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4d0), 2, (val)); \
        } while (0)

#define GP_WB_SET_PRG_ENABLE_RANDOM_SOURCE_TO_PRG_SETTING(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* Apply random seed */
#define GP_WB_PRG_APPLY_RANDOM_SEED() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4d1), 0x01)


/* Random seed */
#define GP_WB_READ_PRG_RANDOM_SEED() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4d2))

#define GP_WB_WRITE_PRG_RANDOM_SEED(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4d2), (val)); \
        } while (0)


/* Random value */
#define GP_WB_READ_PRG_RANDOM_VALUE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4d4))

/***************************
 * layout: parfcs
 ***************************/

/* number of bytes that were received and written to memory */
#define GP_WB_READ_PARFCS_BYTES_RECEIVED() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4e0))


/* Sets the default number of bytes on which an interrupt will be generated when this amount of bytes was received */
#define GP_WB_READ_PARFCS_DEFAULT_TRIGGER_LEVEL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4e1))

#define GP_WB_WRITE_PARFCS_DEFAULT_TRIGGER_LEVEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4e1), (val)); \
        } while (0)


/* Sets a number of bytes on which an interrupt will be generated when this amount of bytes was received */
#define GP_WB_WRITE_PARFCS_SET_TRIGGER_LEVEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4e2), (val)); \
        } while (0)


/* number of bytes that were received and written to memory */
#define GP_WB_READ_PARFCS_CURRENT_TRIGGER_LEVEL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4e3))


/* CLears the level trigger interrupt */
#define GP_WB_PARFCS_CLR_LEVEL_TRIGGER_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4e4), 0x01)

/* Use this to arm the drop reason latch. This clears th drop_reason_valid status */
#define GP_WB_PARFCS_CLR_DROP_REASON() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4e4), 0x02)


/* Set this bit when the the framepending bit in the received ack is set - used by macfilter only */
#define GP_WB_READ_PARFCS_ACK_FRAME_PENDING() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4e5), 0)

#define GP_WB_WRITE_PARFCS_ACK_FRAME_PENDING(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4e5), (val)); \
        } while (0)


#define GP_WB_WRITE_PARFCS_FRAME_ACTION_TRIGGERS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4e6), (val))

/* This action is triggered when the macfilter recognises the current packet as an matchin ack */
#define GP_WB_PARFCS_FRAME_IS_MATCHING_ACK() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4e6), 0x01)

#define GP_WB_SET_PARFCS_FRAME_IS_MATCHING_ACK_TO_FRAME_ACTION_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* set to trigger accepting the packet. This just means that enough of the packet has been processed to know if the packet is valid or not. */
#define GP_WB_PARFCS_ACCEPT_PACKET() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4e6), 0x02)

#define GP_WB_SET_PARFCS_ACCEPT_PACKET_TO_FRAME_ACTION_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* set to trigger an ack on the packet */
#define GP_WB_PARFCS_ACK_REQUEST() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4e6), 0x04)

#define GP_WB_SET_PARFCS_ACK_REQUEST_TO_FRAME_ACTION_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Set to queue the rx pbm in which the packet was received in order to enable SW handling on it */
#define GP_WB_PARFCS_QUEUE_PBM() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4e6), 0x08)

#define GP_WB_SET_PARFCS_QUEUE_PBM_TO_FRAME_ACTION_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* abort the reception of the packet - handle to drop packets if they fail a filter */
#define GP_WB_PARFCS_ABORT_PACKET() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4e6), 0x10)

#define GP_WB_SET_PARFCS_ABORT_PACKET_TO_FRAME_ACTION_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* This is setting can be used by the sniffer functionality to pass packets with bad fcs, even if the fcs check is on */
#define GP_WB_PARFCS_IGNORE_FCS_RESULT_FOR_QUEUEING() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4e6), 0x20)

#define GP_WB_SET_PARFCS_IGNORE_FCS_RESULT_FOR_QUEUEING_TO_FRAME_ACTION_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* Indicates why the last aborted packet was aborted */
#define GP_WB_READ_PARFCS_ABORT_REASON() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4e7))

#define GP_WB_WRITE_PARFCS_ABORT_REASON(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4e7), (val)); \
        } while (0)


/* interrupt triggered when the number of bytes receive reaches the configured threshold */
#define GP_WB_READ_PARFCS_UNMASKED_LEVEL_TRIGGER_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4e8), 0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PARFCS_META_DATA() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4e9))

/* Channel on which packet is being received */
#define GP_WB_READ_PARFCS_CHANNEL() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4e9)) & 0x3F)

#define GP_WB_GET_PARFCS_CHANNEL_FROM_META_DATA(tmp) \
        ((tmp) & 0x3F)

/* Antenna on which packet is being received */
#define GP_WB_READ_PARFCS_ANTENNA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4e9), 6)

#define GP_WB_GET_PARFCS_ANTENNA_FROM_META_DATA(tmp) \
        (((tmp) >> 6) & 0x01)


/* Channel idx on which packet is being received */
#define GP_WB_READ_PARFCS_CHANNEL_IDX() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4ea))


/* When this bit is set to '1', frames with a bad crc will not be received in the pbm, and will be ignored by the mac completely. When this bit is set to "0", frames with a bad crc still be received in the pbm. Note however that even in latter case, the mac will ignore them for the rest (will not trigger ack, ...) */
#define GP_WB_READ_PARFCS_FCS_CHECK_ON() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4eb), 0)

#define GP_WB_WRITE_PARFCS_FCS_CHECK_ON(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4eb), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PARFCS_DROP_REASON_PB() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4ec))

/* Drop Reason:\n0 : No Drop\n1 : Worng Frame Type\n2 : Wrong Version Type\n3 : Wrong SRC PAN ID\n4 : Wrong DST PAN ID\n5 : Wrong DST Address\n6 : Wrong Address\n7 : Wrong COmmand\n3 : Wrong CRC. */
#define GP_WB_READ_PARFCS_DROP_REASON() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4ec)) & 0x0F)

#define GP_WB_GET_PARFCS_DROP_REASON_FROM_DROP_REASON_PB(tmp) \
        ((tmp) & 0x0F)

/* Indicates that a rop reason was latched. The drop reason will no longer be updated until the drop reason was cleared */
#define GP_WB_READ_PARFCS_DROP_REASON_VALID() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4ec), 4)

#define GP_WB_GET_PARFCS_DROP_REASON_VALID_FROM_DROP_REASON_PB(tmp) \
        (((tmp) >> 4) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PARFCS_RX_STATUS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4ed))

/* time Slot on which the frame was received. Corresponds to the channel idx when all slots use different channel */
#define GP_WB_READ_PARFCS_SLOT_IDX() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4ed)) & 0x07)

#define GP_WB_GET_PARFCS_SLOT_IDX_FROM_RX_STATUS(tmp) \
        ((tmp) & 0x07)

/* Indicates whether attenuation was enabled during rx of the frame */
#define GP_WB_READ_PARFCS_ATTENUATED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4ed), 4)

#define GP_WB_GET_PARFCS_ATTENUATED_FROM_RX_STATUS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_READ_PARFCS_FCS_OK() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4ed), 5)

#define GP_WB_GET_PARFCS_FCS_OK_FROM_RX_STATUS(tmp) \
        (((tmp) >> 5) & 0x01)


/* Timestamp when the header is received in the par. 1us base */
#define GP_WB_READ_PARFCS_TIMESTAMP() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4f0))


/* actually a dummy reg, is always 0, used to prevent read errors on block copy */
#define GP_WB_READ_PARFCS_FRAME_PTR() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4f4))


/* number of bytes in the received frame, should only be used by rx_filter, field is only valid while receiving the packet! */
#define GP_WB_READ_PARFCS_FRAME_LEN() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4f6))


#define GP_WB_READ_PARFCS_LQI() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4f8))


#define GP_WB_READ_PARFCS_RSSI() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4f9))


#define GP_WB_READ_PARFCS_FOFFSET() \
        (GP_WB_S16(GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4fa)), 16))


/* Indicates what indexes were configured to use the same channel as the channel this packet is received on */
#define GP_WB_READ_PARFCS_MATCHING_CH_IDX_MASK() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x4fc))

/***************************
 * layout: parble
 ***************************/

/* perform dewhitening on incoming frames */
#define GP_WB_READ_PARBLE_ENABLE_DEWHITENING() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x500), 0)

#define GP_WB_WRITE_PARBLE_ENABLE_DEWHITENING(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x500), 0, (val)); \
        } while (0)

/* When this bit is set to '1', frames with a bad crc will not be received in the pbm, and will be ignored by the mac completely. When this bit is set to "0", frames with a bad crc still be received in the pbm. Note however that even in latter case, the mac will ignore them for the rest (will not trigger ack, ...) */
#define GP_WB_READ_PARBLE_ENABLE_CRC_CHECK() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x500), 1)

#define GP_WB_WRITE_PARBLE_ENABLE_CRC_CHECK(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x500), 1, (val)); \
        } while (0)

/* check access code of incoming frames (and fail if not matched) */
#define GP_WB_READ_PARBLE_ENABLE_ACCESS_CODE_CHECK() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x500), 2)

#define GP_WB_WRITE_PARBLE_ENABLE_ACCESS_CODE_CHECK(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x500), 2, (val)); \
        } while (0)

/* set if the HW should process the CTE (if any) after a packet and take in the samples */
#define GP_WB_READ_PARBLE_ENABLE_CTE_RX() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x500), 3)

#define GP_WB_WRITE_PARBLE_ENABLE_CTE_RX(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x500), 3, (val)); \
        } while (0)

/* Indicates to the HW if the incomming frames should be seen as data channel PDU's, this is needed to extract the CP bit for CTE */
#define GP_WB_READ_PARBLE_IS_DATA_CHANNEL_PDU() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x500), 4)

#define GP_WB_WRITE_PARBLE_IS_DATA_CHANNEL_PDU(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x500), 4, (val)); \
        } while (0)

/* if set, an ongoing CTE reception will be aborted when the packet is dropped by the HW */
#define GP_WB_READ_PARBLE_ABORT_CTE_RX_ON_HW_DROP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x500), 5)

#define GP_WB_WRITE_PARBLE_ABORT_CTE_RX_ON_HW_DROP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x500), 5, (val)); \
        } while (0)

/* if set, an ongoing CTE reception will be aborted when the packet contains a CRC error */
#define GP_WB_READ_PARBLE_ABORT_CTE_RX_ON_CRC_ERROR() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x500), 6)

#define GP_WB_WRITE_PARBLE_ABORT_CTE_RX_ON_CRC_ERROR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x500), 6, (val)); \
        } while (0)


/* initial value of crc shift register */
#define GP_WB_READ_PARBLE_CRC_INIT() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x504))

#define GP_WB_WRITE_PARBLE_CRC_INIT(val) do { \
          GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x504), (val)); \
        } while (0)


/* initial value of dewhitening shift register (bit_reversed => init == (0x40 | ble_ch_idx) ) */
#define GP_WB_READ_PARBLE_DEWHITENING_INIT_REV() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x507))

#define GP_WB_WRITE_PARBLE_DEWHITENING_INIT_REV(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x507), (val)); \
        } while (0)


/* Access code to be checked when receiving frame */
#define GP_WB_READ_PARBLE_ACCESS_CODE() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x508))

#define GP_WB_WRITE_PARBLE_ACCESS_CODE(val) do { \
          GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x508), (val)); \
        } while (0)


#define GP_WB_PARBLE_ABORT_PACKET() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x50c), 0x01)

#define GP_WB_PARBLE_ACCEPT_PACKET() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x50c), 0x02)

/* Use this to arm the drop reason latch. This clears the drop_reason_valid status */
#define GP_WB_PARBLE_CLR_DROP_REASON() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x50c), 0x04)

#define GP_WB_PARBLE_CLR_PACKET_DONE_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x50c), 0x08)

/* CLears the level trigger interrupt */
#define GP_WB_PARBLE_CLR_LEVEL_TRIGGER_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x50c), 0x10)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PARBLE_RX_STATUS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x50d))

/* time Slot on which the frame was received. Corresponds to the channel idx when all slots use different channel */
#define GP_WB_READ_PARBLE_SLOT_IDX() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x50d)) & 0x07)

#define GP_WB_GET_PARBLE_SLOT_IDX_FROM_RX_STATUS(tmp) \
        ((tmp) & 0x07)

/* Antenna on which packet is being received */
#define GP_WB_READ_PARBLE_ANTENNA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x50d), 3)

#define GP_WB_GET_PARBLE_ANTENNA_FROM_RX_STATUS(tmp) \
        (((tmp) >> 3) & 0x01)

/* Was attenuation on during reception */
#define GP_WB_READ_PARBLE_ATTENUATED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x50d), 4)

#define GP_WB_GET_PARBLE_ATTENUATED_FROM_RX_STATUS(tmp) \
        (((tmp) >> 4) & 0x01)

/* Indicates whether the received packet has a valid crc or not */
#define GP_WB_READ_PARBLE_CRC_OK() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x50d), 5)

#define GP_WB_GET_PARBLE_CRC_OK_FROM_RX_STATUS(tmp) \
        (((tmp) >> 5) & 0x01)

/* Indicates whether the access code was correct */
#define GP_WB_READ_PARBLE_ACCESS_CODE_OK() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x50d), 6)

#define GP_WB_GET_PARBLE_ACCESS_CODE_OK_FROM_RX_STATUS(tmp) \
        (((tmp) >> 6) & 0x01)

/* Indicates whether the packet contains a CTE info field */
#define GP_WB_READ_PARBLE_CTE_PRESENT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x50d), 7)

#define GP_WB_GET_PARBLE_CTE_PRESENT_FROM_RX_STATUS(tmp) \
        (((tmp) >> 7) & 0x01)


/* Timestamp when the header is received in the par. 1us base */
#define GP_WB_READ_PARBLE_TIMESTAMP() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x510))


/* actually a dummy reg, is always 0, used to prevent read errors on block copy */
#define GP_WB_READ_PARBLE_FRAME_PTR() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x514))


/* number of bytes in the received frame, should only be used by rx_filter, field is only valid while receiving the packet! */
#define GP_WB_READ_PARBLE_FRAME_LEN() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x516))


#define GP_WB_READ_PARBLE_LQI() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x518))


#define GP_WB_READ_PARBLE_RSSI() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x519))


#define GP_WB_READ_PARBLE_FOFFSET() \
        (GP_WB_S16(GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x51a)), 16))


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PARBLE_CHANNEL_INFO() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x51c))

/* Channel on which packet is being received */
#define GP_WB_READ_PARBLE_CHANNEL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x51c))

#define GP_WB_GET_PARBLE_CHANNEL_FROM_CHANNEL_INFO(tmp) \
        ((tmp) & 0x3F)

/* Channel idx on which packet is being received */
#define GP_WB_READ_PARBLE_CHANNEL_IDX() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x51d))

#define GP_WB_GET_PARBLE_CHANNEL_IDX_FROM_CHANNEL_INFO(tmp) \
        (((tmp) >> 8) & 0x07)


/* Indicates what indexes were configured to use the same channel as the channel this packet is received on */
#define GP_WB_READ_PARBLE_MATCHING_CH_IDX_MASK() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x51e))


#define GP_WB_READ_PARBLE_PHY_MODE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x51f)) & 0x03)

/* Indicates whether the packet was received in experimental mode or not */
#define GP_WB_READ_PARBLE_EXP_MODE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x51f), 2)


/* number of bytes that were received and written to memory */
#define GP_WB_READ_PARBLE_BYTES_RECEIVED() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x520))


/* Idx of the pbm data is written to */
#define GP_WB_READ_PARBLE_PBM_PTR() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x522))


/* Sets the default number of bytes on which an interrupt will be generated when this amount of bytes was received */
#define GP_WB_READ_PARBLE_DEFAULT_TRIGGER_LEVEL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x523))

#define GP_WB_WRITE_PARBLE_DEFAULT_TRIGGER_LEVEL(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x523), (val)); \
        } while (0)


/* Sets a number of bytes on which an interrupt will be generated when this amount of bytes was received */
#define GP_WB_WRITE_PARBLE_SET_TRIGGER_LEVEL(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x524), (val)); \
        } while (0)


/* The currently active trigger level */
#define GP_WB_READ_PARBLE_CURRENT_TRIGGER_LEVEL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x525))


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PARBLE_DROP_REASON_PB() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x526))

/* Drop Reason of the last frame. is not written again by HW until cleared by clr_drop_reason */
#define GP_WB_READ_PARBLE_DROP_REASON() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x526)) & 0x07)

#define GP_WB_GET_PARBLE_DROP_REASON_FROM_DROP_REASON_PB(tmp) \
        ((tmp) & 0x07)

/* Indicates that a rop reason was latched. The drop reason will no longer be updated until the drop reason was cleared */
#define GP_WB_READ_PARBLE_DROP_REASON_VALID() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x526), 3)

#define GP_WB_GET_PARBLE_DROP_REASON_VALID_FROM_DROP_REASON_PB(tmp) \
        (((tmp) >> 3) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PARBLE_UNMASKED_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x527))

/* interrupt triggered when the number of bytes receive reaches the configured threshold */
#define GP_WB_READ_PARBLE_UNMASKED_LEVEL_TRIGGER_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x527), 0)

#define GP_WB_GET_PARBLE_UNMASKED_LEVEL_TRIGGER_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* Indicates the reception of a (valid) packet has finished */
#define GP_WB_READ_PARBLE_UNMASKED_PACKET_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x527), 1)

#define GP_WB_GET_PARBLE_UNMASKED_PACKET_DONE_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)


/* DEBUG register for supporting frame_receive stop requests from SW. Set to 0 to enable normal functionality of parble */
#define GP_WB_READ_PARBLE_RECEIVE_STOP_LEVEL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x528))

#define GP_WB_WRITE_PARBLE_RECEIVE_STOP_LEVEL(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x528), (val)); \
        } while (0)

/***************************
 * layout: rci
 ***************************/

/* Logical queue to write the pbm_idx to */
#define GP_WB_READ_RCI_QUEUE_REQUEST_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x580))

#define GP_WB_WRITE_RCI_QUEUE_REQUEST_ENTRY_TYPE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x580), (val)); \
        } while (0)


/* PBM idx to be queued, to the queue_request_entry_type queue */
#define GP_WB_WRITE_RCI_QUEUE_REQUEST_PBM(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x581), (val)); \
        } while (0)


/* Index of the first pbm in the data_ind queue, reading pops this entry. 255 is the default value if no entries in queue */
#define GP_WB_READ_RCI_DATA_IND_PBM() \
        GP_WB_READ_SER_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x582))


/* Index of the first pbm in the data_cnf_0 queue, reading pops this entry. 255 is the default value if no entries in queue */
#define GP_WB_READ_RCI_DATA_CNF_0_PBM() \
        GP_WB_READ_SER_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x583))


/* Index of the first pbm in the data_cnf_1 queue, reading pops this entry. 255 is the default value if no entries in queue */
#define GP_WB_READ_RCI_DATA_CNF_1_PBM() \
        GP_WB_READ_SER_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x584))


/* Index of the first pbm in the data_cnf_2 queue, reading pops this entry. 255 is the default value if no entries in queue */
#define GP_WB_READ_RCI_DATA_CNF_2_PBM() \
        GP_WB_READ_SER_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x585))


/* Index of the first pbm in the data_cnf_3 queue, reading pops this entry. 255 is the default value if no entries in queue */
#define GP_WB_READ_RCI_DATA_CNF_3_PBM() \
        GP_WB_READ_SER_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x586))


/* Index of the first pbm in the ble_data_ind queue, reading pops this entry. 255 is the default value if no entries in queue */
#define GP_WB_READ_RCI_BLE_DATA_IND_PBM() \
        GP_WB_READ_SER_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x587))


/* Index of the first pbm in the ble_adv_ind queue, reading pops this entry. 255 is the default value if no entries in queue */
#define GP_WB_READ_RCI_BLE_ADV_IND_PBM() \
        GP_WB_READ_SER_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x588))


/* Index of the first pbm in the ble_conn_req_ind queue, reading pops this entry. 255 is the default value if no entries in queue */
#define GP_WB_READ_RCI_BLE_CONN_REQ_IND_PBM() \
        GP_WB_READ_SER_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x589))


/* Index of the first pbm in the ble_conn_rsp_ind queue, reading pops this entry. 255 is the default value if no entries in queue */
#define GP_WB_READ_RCI_BLE_CONN_RSP_IND_PBM() \
        GP_WB_READ_SER_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x58a))


/* Index of the first pbm in the ble_data_cnf queue, reading pops this entry. 255 is the default value if no entries in queue */
#define GP_WB_READ_RCI_BLE_DATA_CNF_PBM() \
        GP_WB_READ_SER_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x58b))


/* holds the pbm entry that is next in line for a data_ind. Only valid when there is a data_ind interrupt pending */
#define GP_WB_READ_RCI_DATA_IND_PBM_PEEK() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x58c))


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_QUEUE_DATA_0() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x58e))

/* type of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_0_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x58e))

#define GP_WB_GET_RCI_QUEUE_DATA_0_ENTRY_TYPE_FROM_QUEUE_DATA_0(tmp) \
        ((tmp) & 0x0F)

/* PBM idx of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_0_PBM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x58f))

#define GP_WB_GET_RCI_QUEUE_DATA_0_PBM_FROM_QUEUE_DATA_0(tmp) \
        (((tmp) >> 8) & 0x1F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_QUEUE_DATA_1() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x590))

/* type of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_1_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x590))

#define GP_WB_GET_RCI_QUEUE_DATA_1_ENTRY_TYPE_FROM_QUEUE_DATA_1(tmp) \
        ((tmp) & 0x0F)

/* PBM idx of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_1_PBM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x591))

#define GP_WB_GET_RCI_QUEUE_DATA_1_PBM_FROM_QUEUE_DATA_1(tmp) \
        (((tmp) >> 8) & 0x1F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_QUEUE_DATA_2() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x592))

/* type of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_2_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x592))

#define GP_WB_GET_RCI_QUEUE_DATA_2_ENTRY_TYPE_FROM_QUEUE_DATA_2(tmp) \
        ((tmp) & 0x0F)

/* PBM idx of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_2_PBM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x593))

#define GP_WB_GET_RCI_QUEUE_DATA_2_PBM_FROM_QUEUE_DATA_2(tmp) \
        (((tmp) >> 8) & 0x1F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_QUEUE_DATA_3() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x594))

/* type of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_3_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x594))

#define GP_WB_GET_RCI_QUEUE_DATA_3_ENTRY_TYPE_FROM_QUEUE_DATA_3(tmp) \
        ((tmp) & 0x0F)

/* PBM idx of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_3_PBM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x595))

#define GP_WB_GET_RCI_QUEUE_DATA_3_PBM_FROM_QUEUE_DATA_3(tmp) \
        (((tmp) >> 8) & 0x1F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_QUEUE_DATA_4() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x596))

/* type of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_4_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x596))

#define GP_WB_GET_RCI_QUEUE_DATA_4_ENTRY_TYPE_FROM_QUEUE_DATA_4(tmp) \
        ((tmp) & 0x0F)

/* PBM idx of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_4_PBM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x597))

#define GP_WB_GET_RCI_QUEUE_DATA_4_PBM_FROM_QUEUE_DATA_4(tmp) \
        (((tmp) >> 8) & 0x1F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_QUEUE_DATA_5() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x598))

/* type of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_5_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x598))

#define GP_WB_GET_RCI_QUEUE_DATA_5_ENTRY_TYPE_FROM_QUEUE_DATA_5(tmp) \
        ((tmp) & 0x0F)

/* PBM idx of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_5_PBM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x599))

#define GP_WB_GET_RCI_QUEUE_DATA_5_PBM_FROM_QUEUE_DATA_5(tmp) \
        (((tmp) >> 8) & 0x1F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_QUEUE_DATA_6() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x59a))

/* type of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_6_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x59a))

#define GP_WB_GET_RCI_QUEUE_DATA_6_ENTRY_TYPE_FROM_QUEUE_DATA_6(tmp) \
        ((tmp) & 0x0F)

/* PBM idx of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_6_PBM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x59b))

#define GP_WB_GET_RCI_QUEUE_DATA_6_PBM_FROM_QUEUE_DATA_6(tmp) \
        (((tmp) >> 8) & 0x1F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_QUEUE_DATA_7() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x59c))

/* type of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_7_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x59c))

#define GP_WB_GET_RCI_QUEUE_DATA_7_ENTRY_TYPE_FROM_QUEUE_DATA_7(tmp) \
        ((tmp) & 0x0F)

/* PBM idx of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_7_PBM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x59d))

#define GP_WB_GET_RCI_QUEUE_DATA_7_PBM_FROM_QUEUE_DATA_7(tmp) \
        (((tmp) >> 8) & 0x1F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_QUEUE_DATA_8() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x59e))

/* type of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_8_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x59e))

#define GP_WB_GET_RCI_QUEUE_DATA_8_ENTRY_TYPE_FROM_QUEUE_DATA_8(tmp) \
        ((tmp) & 0x0F)

/* PBM idx of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_8_PBM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x59f))

#define GP_WB_GET_RCI_QUEUE_DATA_8_PBM_FROM_QUEUE_DATA_8(tmp) \
        (((tmp) >> 8) & 0x1F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_QUEUE_DATA_9() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5a0))

/* type of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_9_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5a0))

#define GP_WB_GET_RCI_QUEUE_DATA_9_ENTRY_TYPE_FROM_QUEUE_DATA_9(tmp) \
        ((tmp) & 0x0F)

/* PBM idx of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_9_PBM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5a1))

#define GP_WB_GET_RCI_QUEUE_DATA_9_PBM_FROM_QUEUE_DATA_9(tmp) \
        (((tmp) >> 8) & 0x1F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_QUEUE_DATA_10() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5a2))

/* type of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_10_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5a2))

#define GP_WB_GET_RCI_QUEUE_DATA_10_ENTRY_TYPE_FROM_QUEUE_DATA_10(tmp) \
        ((tmp) & 0x0F)

/* PBM idx of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_10_PBM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5a3))

#define GP_WB_GET_RCI_QUEUE_DATA_10_PBM_FROM_QUEUE_DATA_10(tmp) \
        (((tmp) >> 8) & 0x1F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_QUEUE_DATA_11() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5a4))

/* type of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_11_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5a4))

#define GP_WB_GET_RCI_QUEUE_DATA_11_ENTRY_TYPE_FROM_QUEUE_DATA_11(tmp) \
        ((tmp) & 0x0F)

/* PBM idx of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_11_PBM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5a5))

#define GP_WB_GET_RCI_QUEUE_DATA_11_PBM_FROM_QUEUE_DATA_11(tmp) \
        (((tmp) >> 8) & 0x1F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_QUEUE_DATA_12() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5a6))

/* type of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_12_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5a6))

#define GP_WB_GET_RCI_QUEUE_DATA_12_ENTRY_TYPE_FROM_QUEUE_DATA_12(tmp) \
        ((tmp) & 0x0F)

/* PBM idx of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_12_PBM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5a7))

#define GP_WB_GET_RCI_QUEUE_DATA_12_PBM_FROM_QUEUE_DATA_12(tmp) \
        (((tmp) >> 8) & 0x1F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_QUEUE_DATA_13() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5a8))

/* type of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_13_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5a8))

#define GP_WB_GET_RCI_QUEUE_DATA_13_ENTRY_TYPE_FROM_QUEUE_DATA_13(tmp) \
        ((tmp) & 0x0F)

/* PBM idx of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_13_PBM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5a9))

#define GP_WB_GET_RCI_QUEUE_DATA_13_PBM_FROM_QUEUE_DATA_13(tmp) \
        (((tmp) >> 8) & 0x1F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_QUEUE_DATA_14() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5aa))

/* type of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_14_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5aa))

#define GP_WB_GET_RCI_QUEUE_DATA_14_ENTRY_TYPE_FROM_QUEUE_DATA_14(tmp) \
        ((tmp) & 0x0F)

/* PBM idx of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_14_PBM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5ab))

#define GP_WB_GET_RCI_QUEUE_DATA_14_PBM_FROM_QUEUE_DATA_14(tmp) \
        (((tmp) >> 8) & 0x1F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_QUEUE_DATA_15() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5ac))

/* type of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_15_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5ac))

#define GP_WB_GET_RCI_QUEUE_DATA_15_ENTRY_TYPE_FROM_QUEUE_DATA_15(tmp) \
        ((tmp) & 0x0F)

/* PBM idx of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_15_PBM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5ad))

#define GP_WB_GET_RCI_QUEUE_DATA_15_PBM_FROM_QUEUE_DATA_15(tmp) \
        (((tmp) >> 8) & 0x1F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_QUEUE_DATA_16() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5ae))

/* type of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_16_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5ae))

#define GP_WB_GET_RCI_QUEUE_DATA_16_ENTRY_TYPE_FROM_QUEUE_DATA_16(tmp) \
        ((tmp) & 0x0F)

/* PBM idx of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_16_PBM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5af))

#define GP_WB_GET_RCI_QUEUE_DATA_16_PBM_FROM_QUEUE_DATA_16(tmp) \
        (((tmp) >> 8) & 0x1F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_QUEUE_DATA_17() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5b0))

/* type of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_17_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5b0))

#define GP_WB_GET_RCI_QUEUE_DATA_17_ENTRY_TYPE_FROM_QUEUE_DATA_17(tmp) \
        ((tmp) & 0x0F)

/* PBM idx of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_17_PBM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5b1))

#define GP_WB_GET_RCI_QUEUE_DATA_17_PBM_FROM_QUEUE_DATA_17(tmp) \
        (((tmp) >> 8) & 0x1F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_QUEUE_DATA_18() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5b2))

/* type of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_18_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5b2))

#define GP_WB_GET_RCI_QUEUE_DATA_18_ENTRY_TYPE_FROM_QUEUE_DATA_18(tmp) \
        ((tmp) & 0x0F)

/* PBM idx of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_18_PBM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5b3))

#define GP_WB_GET_RCI_QUEUE_DATA_18_PBM_FROM_QUEUE_DATA_18(tmp) \
        (((tmp) >> 8) & 0x1F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_QUEUE_DATA_19() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5b4))

/* type of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_19_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5b4))

#define GP_WB_GET_RCI_QUEUE_DATA_19_ENTRY_TYPE_FROM_QUEUE_DATA_19(tmp) \
        ((tmp) & 0x0F)

/* PBM idx of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_19_PBM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5b5))

#define GP_WB_GET_RCI_QUEUE_DATA_19_PBM_FROM_QUEUE_DATA_19(tmp) \
        (((tmp) >> 8) & 0x1F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_QUEUE_DATA_20() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5b6))

/* type of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_20_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5b6))

#define GP_WB_GET_RCI_QUEUE_DATA_20_ENTRY_TYPE_FROM_QUEUE_DATA_20(tmp) \
        ((tmp) & 0x0F)

/* PBM idx of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_20_PBM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5b7))

#define GP_WB_GET_RCI_QUEUE_DATA_20_PBM_FROM_QUEUE_DATA_20(tmp) \
        (((tmp) >> 8) & 0x1F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_QUEUE_DATA_21() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5b8))

/* type of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_21_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5b8))

#define GP_WB_GET_RCI_QUEUE_DATA_21_ENTRY_TYPE_FROM_QUEUE_DATA_21(tmp) \
        ((tmp) & 0x0F)

/* PBM idx of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_21_PBM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5b9))

#define GP_WB_GET_RCI_QUEUE_DATA_21_PBM_FROM_QUEUE_DATA_21(tmp) \
        (((tmp) >> 8) & 0x1F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_QUEUE_DATA_22() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5ba))

/* type of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_22_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5ba))

#define GP_WB_GET_RCI_QUEUE_DATA_22_ENTRY_TYPE_FROM_QUEUE_DATA_22(tmp) \
        ((tmp) & 0x0F)

/* PBM idx of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_22_PBM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5bb))

#define GP_WB_GET_RCI_QUEUE_DATA_22_PBM_FROM_QUEUE_DATA_22(tmp) \
        (((tmp) >> 8) & 0x1F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_QUEUE_DATA_23() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5bc))

/* type of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_23_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5bc))

#define GP_WB_GET_RCI_QUEUE_DATA_23_ENTRY_TYPE_FROM_QUEUE_DATA_23(tmp) \
        ((tmp) & 0x0F)

/* PBM idx of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_23_PBM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5bd))

#define GP_WB_GET_RCI_QUEUE_DATA_23_PBM_FROM_QUEUE_DATA_23(tmp) \
        (((tmp) >> 8) & 0x1F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_QUEUE_DATA_24() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5be))

/* type of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_24_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5be))

#define GP_WB_GET_RCI_QUEUE_DATA_24_ENTRY_TYPE_FROM_QUEUE_DATA_24(tmp) \
        ((tmp) & 0x0F)

/* PBM idx of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_24_PBM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5bf))

#define GP_WB_GET_RCI_QUEUE_DATA_24_PBM_FROM_QUEUE_DATA_24(tmp) \
        (((tmp) >> 8) & 0x1F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_QUEUE_DATA_25() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5c0))

/* type of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_25_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5c0))

#define GP_WB_GET_RCI_QUEUE_DATA_25_ENTRY_TYPE_FROM_QUEUE_DATA_25(tmp) \
        ((tmp) & 0x0F)

/* PBM idx of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_25_PBM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5c1))

#define GP_WB_GET_RCI_QUEUE_DATA_25_PBM_FROM_QUEUE_DATA_25(tmp) \
        (((tmp) >> 8) & 0x1F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_QUEUE_DATA_26() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5c2))

/* type of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_26_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5c2))

#define GP_WB_GET_RCI_QUEUE_DATA_26_ENTRY_TYPE_FROM_QUEUE_DATA_26(tmp) \
        ((tmp) & 0x0F)

/* PBM idx of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_26_PBM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5c3))

#define GP_WB_GET_RCI_QUEUE_DATA_26_PBM_FROM_QUEUE_DATA_26(tmp) \
        (((tmp) >> 8) & 0x1F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_QUEUE_DATA_27() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5c4))

/* type of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_27_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5c4))

#define GP_WB_GET_RCI_QUEUE_DATA_27_ENTRY_TYPE_FROM_QUEUE_DATA_27(tmp) \
        ((tmp) & 0x0F)

/* PBM idx of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_27_PBM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5c5))

#define GP_WB_GET_RCI_QUEUE_DATA_27_PBM_FROM_QUEUE_DATA_27(tmp) \
        (((tmp) >> 8) & 0x1F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_QUEUE_DATA_28() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5c6))

/* type of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_28_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5c6))

#define GP_WB_GET_RCI_QUEUE_DATA_28_ENTRY_TYPE_FROM_QUEUE_DATA_28(tmp) \
        ((tmp) & 0x0F)

/* PBM idx of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_28_PBM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5c7))

#define GP_WB_GET_RCI_QUEUE_DATA_28_PBM_FROM_QUEUE_DATA_28(tmp) \
        (((tmp) >> 8) & 0x1F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_QUEUE_DATA_29() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5c8))

/* type of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_29_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5c8))

#define GP_WB_GET_RCI_QUEUE_DATA_29_ENTRY_TYPE_FROM_QUEUE_DATA_29(tmp) \
        ((tmp) & 0x0F)

/* PBM idx of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_29_PBM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5c9))

#define GP_WB_GET_RCI_QUEUE_DATA_29_PBM_FROM_QUEUE_DATA_29(tmp) \
        (((tmp) >> 8) & 0x1F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_QUEUE_DATA_30() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5ca))

/* type of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_30_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5ca))

#define GP_WB_GET_RCI_QUEUE_DATA_30_ENTRY_TYPE_FROM_QUEUE_DATA_30(tmp) \
        ((tmp) & 0x0F)

/* PBM idx of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_30_PBM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5cb))

#define GP_WB_GET_RCI_QUEUE_DATA_30_PBM_FROM_QUEUE_DATA_30(tmp) \
        (((tmp) >> 8) & 0x1F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_QUEUE_DATA_31() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5cc))

/* type of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_31_ENTRY_TYPE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5cc))

#define GP_WB_GET_RCI_QUEUE_DATA_31_ENTRY_TYPE_FROM_QUEUE_DATA_31(tmp) \
        ((tmp) & 0x0F)

/* PBM idx of the queue entry */
#define GP_WB_READ_RCI_QUEUE_DATA_31_PBM() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5cd))

#define GP_WB_GET_RCI_QUEUE_DATA_31_PBM_FROM_QUEUE_DATA_31(tmp) \
        (((tmp) >> 8) & 0x1F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RCI_UNMASKED_INTERRUPTS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5ce))

/* Indicates data is available in the data_ind_pbm register */
#define GP_WB_READ_RCI_UNMASKED_DATA_IND_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5ce), 0)

#define GP_WB_GET_RCI_UNMASKED_DATA_IND_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* Indicates data is available in the data_cnf_0_pbm register */
#define GP_WB_READ_RCI_UNMASKED_DATA_CNF_0_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5ce), 1)

#define GP_WB_GET_RCI_UNMASKED_DATA_CNF_0_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_RCI_UNMASKED_DATA_CNF_INTERRUPT() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5ce)) >> 1) & 0x0F)

#define GP_WB_GET_RCI_UNMASKED_DATA_CNF_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x0F)

/* Indicates data is available in the data_cnf_1_pbm register */
#define GP_WB_READ_RCI_UNMASKED_DATA_CNF_1_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5ce), 2)

#define GP_WB_GET_RCI_UNMASKED_DATA_CNF_1_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* Indicates data is available in the data_cnf_2_pbm register */
#define GP_WB_READ_RCI_UNMASKED_DATA_CNF_2_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5ce), 3)

#define GP_WB_GET_RCI_UNMASKED_DATA_CNF_2_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

/* Indicates data is available in the data_cnf_3_pbm register */
#define GP_WB_READ_RCI_UNMASKED_DATA_CNF_3_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5ce), 4)

#define GP_WB_GET_RCI_UNMASKED_DATA_CNF_3_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

/* Indicates data is available in the ble_data_ind_pbm register */
#define GP_WB_READ_RCI_UNMASKED_BLE_DATA_IND_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5ce), 5)

#define GP_WB_GET_RCI_UNMASKED_BLE_DATA_IND_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

/* Indicates data is available in the ble_adv_ind_pbm register */
#define GP_WB_READ_RCI_UNMASKED_BLE_ADV_IND_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5ce), 6)

#define GP_WB_GET_RCI_UNMASKED_BLE_ADV_IND_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 6) & 0x01)

/* Indicates data is available in the ble_conn_req_ind_pbm register */
#define GP_WB_READ_RCI_UNMASKED_BLE_CONN_REQ_IND_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5ce), 7)

#define GP_WB_GET_RCI_UNMASKED_BLE_CONN_REQ_IND_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 7) & 0x01)

/* Indicates data is available in the ble_conn_rsp_ind_pbm register */
#define GP_WB_READ_RCI_UNMASKED_BLE_CONN_RSP_IND_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5cf), 0)

#define GP_WB_GET_RCI_UNMASKED_BLE_CONN_RSP_IND_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x01)

/* Indicates data is available in the ble_data_cnf_pbm register */
#define GP_WB_READ_RCI_UNMASKED_BLE_DATA_CNF_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x5cf), 1)

#define GP_WB_GET_RCI_UNMASKED_BLE_DATA_CNF_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 9) & 0x01)

/***************************
 * layout: pmud
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_STANDBY_SETTINGS() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x600))

#define GP_WB_WRITE_PMUD_STANDBY_SETTINGS(val) \
      GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x600), (val))

/* Standby mode selection: 0x00 = Standby 0 (RC / 8 kHz osc.), 0x01 = Standby 1 (32 kHz osc.), 0x02 = Standby 2 (16 MHz) */
#define GP_WB_READ_PMUD_STBY_MODE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x600)) & 0x03)

#define GP_WB_GET_PMUD_STBY_MODE_FROM_STANDBY_SETTINGS(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_PMUD_STBY_MODE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x600), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_STBY_MODE_TO_STANDBY_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x03FFFC; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* This is a debug bit in order to be able to ignore the value of xo_ldo_rdy, used locally in pmud */
#define GP_WB_READ_PMUD_XO_LDO_RDY_OVERRIDE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x600), 2)

#define GP_WB_GET_PMUD_XO_LDO_RDY_OVERRIDE_FROM_STANDBY_SETTINGS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_PMUD_XO_LDO_RDY_OVERRIDE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x600), 2, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_XO_LDO_RDY_OVERRIDE_TO_STANDBY_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFFB; \
          (tmp) |= (((UInt32)(val)) << 2); \
        } while (0)

/* Make XOSC ready high for XOSC test used  locally in the pmud */
#define GP_WB_READ_PMUD_CLK_32M_RDY_OVERRIDE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x600), 3)

#define GP_WB_GET_PMUD_CLK_32M_RDY_OVERRIDE_FROM_STANDBY_SETTINGS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_PMUD_CLK_32M_RDY_OVERRIDE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x600), 3, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_CLK_32M_RDY_OVERRIDE_TO_STANDBY_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFF7; \
          (tmp) |= (((UInt32)(val)) << 3); \
        } while (0)

/* This is a debug bit in order to be able to ignore the value of clk_29m_rdy, used locally in pmud */
#define GP_WB_READ_PMUD_CLK_29M_RDY_OVERRIDE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x600), 4)

#define GP_WB_GET_PMUD_CLK_29M_RDY_OVERRIDE_FROM_STANDBY_SETTINGS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_PMUD_CLK_29M_RDY_OVERRIDE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x600), 4, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_CLK_29M_RDY_OVERRIDE_TO_STANDBY_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFEF; \
          (tmp) |= (((UInt32)(val)) << 4); \
        } while (0)

/* This is a debug bit in order to be able to ignore the value of vdddig_rdy, used locally in pmud */
#define GP_WB_READ_PMUD_PU_DIG_LDO_RDY_OVERRIDE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x600), 5)

#define GP_WB_GET_PMUD_PU_DIG_LDO_RDY_OVERRIDE_FROM_STANDBY_SETTINGS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_PMUD_PU_DIG_LDO_RDY_OVERRIDE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x600), 5, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_PU_DIG_LDO_RDY_OVERRIDE_TO_STANDBY_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFDF; \
          (tmp) |= (((UInt32)(val)) << 5); \
        } while (0)

/* This is a debug bit in order to be able to ignore the value of pu_global_ldo_rdy coming from analog */
#define GP_WB_READ_PMUD_PU_GLOBAL_LDO_RDY_OVERRIDE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x600), 6)

#define GP_WB_GET_PMUD_PU_GLOBAL_LDO_RDY_OVERRIDE_FROM_STANDBY_SETTINGS(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_PMUD_PU_GLOBAL_LDO_RDY_OVERRIDE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x600), 6, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_PU_GLOBAL_LDO_RDY_OVERRIDE_TO_STANDBY_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFBF; \
          (tmp) |= (((UInt32)(val)) << 6); \
        } while (0)

/* This allows the ldo rdy to be ignored during active */
#define GP_WB_READ_PMUD_PU_GLOBAL_LDO_RDY_IGNORE_DURING_ACTIVE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x600), 7)

#define GP_WB_GET_PMUD_PU_GLOBAL_LDO_RDY_IGNORE_DURING_ACTIVE_FROM_STANDBY_SETTINGS(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_PMUD_PU_GLOBAL_LDO_RDY_IGNORE_DURING_ACTIVE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x600), 7, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_PU_GLOBAL_LDO_RDY_IGNORE_DURING_ACTIVE_TO_STANDBY_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FF7F; \
          (tmp) |= (((UInt32)(val)) << 7); \
        } while (0)

/* when set, a POR will be generated if the ldo global ldo ready signal is 0 during active */
#define GP_WB_READ_PMUD_POR_ON_GLOBAL_LDO_NOK() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x601), 0)

#define GP_WB_GET_PMUD_POR_ON_GLOBAL_LDO_NOK_FROM_STANDBY_SETTINGS(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_PMUD_POR_ON_GLOBAL_LDO_NOK(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x601), 0, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_POR_ON_GLOBAL_LDO_NOK_TO_STANDBY_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FEFF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* This is a debug bit in order to be able to ignore the value of pu_io_ldo_rdy coming from analog. */
#define GP_WB_READ_PMUD_PU_IO_LDO_RDY_OVERRIDE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x601), 1)

#define GP_WB_GET_PMUD_PU_IO_LDO_RDY_OVERRIDE_FROM_STANDBY_SETTINGS(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_PMUD_PU_IO_LDO_RDY_OVERRIDE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x601), 1, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_PU_IO_LDO_RDY_OVERRIDE_TO_STANDBY_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FDFF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* This is a debug bit allowing to bypass the vmt_st check (which is used a a wakup gating condition) */
#define GP_WB_READ_PMUD_DISABLE_VMT_ST() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x601), 2)

#define GP_WB_GET_PMUD_DISABLE_VMT_ST_FROM_STANDBY_SETTINGS(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_PMUD_DISABLE_VMT_ST(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x601), 2, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_DISABLE_VMT_ST_TO_STANDBY_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FBFF; \
          (tmp) |= (((UInt32)(val)) << 10); \
        } while (0)

/* This is a debug bit allowing to bypass the vddb_cutoff result, which gates the power_up of the digital */
#define GP_WB_READ_PMUD_DISABLE_VDDB_CUTOFF() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x601), 3)

#define GP_WB_GET_PMUD_DISABLE_VDDB_CUTOFF_FROM_STANDBY_SETTINGS(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_PMUD_DISABLE_VDDB_CUTOFF(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x601), 3, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_DISABLE_VDDB_CUTOFF_TO_STANDBY_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03F7FF; \
          (tmp) |= (((UInt32)(val)) << 11); \
        } while (0)

/* when set, the chip will use the xtal oscillator as main osc source, if not set, the 29MHz ringosc should be used, so don't disable both use_xtal_oscillator as use_ring_oscillator */
#define GP_WB_READ_PMUD_USE_XTAL_OSCILLATOR() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x601), 4)

#define GP_WB_GET_PMUD_USE_XTAL_OSCILLATOR_FROM_STANDBY_SETTINGS(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_PMUD_USE_XTAL_OSCILLATOR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x601), 4, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_USE_XTAL_OSCILLATOR_TO_STANDBY_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03EFFF; \
          (tmp) |= (((UInt32)(val)) << 12); \
        } while (0)

/* when set, the chip will startup from the ring oscillator. It is advised to keep this on at all times, unless you want the chip to start up from the xtal oscillator */
#define GP_WB_READ_PMUD_USE_RING_OSCILLATOR() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x601), 5)

#define GP_WB_GET_PMUD_USE_RING_OSCILLATOR_FROM_STANDBY_SETTINGS(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_PMUD_USE_RING_OSCILLATOR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x601), 5, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_USE_RING_OSCILLATOR_TO_STANDBY_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03DFFF; \
          (tmp) |= (((UInt32)(val)) << 13); \
        } while (0)

/* Enables the startup ring oscillator */
#define GP_WB_READ_PMUD_CLK_29M_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x601), 6)

#define GP_WB_GET_PMUD_CLK_29M_PUP_FROM_STANDBY_SETTINGS(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_PMUD_CLK_29M_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x601), 6, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_CLK_29M_PUP_TO_STANDBY_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03BFFF; \
          (tmp) |= (((UInt32)(val)) << 14); \
        } while (0)

/* Enables the 32 MHz Xtal oscillator */
#define GP_WB_READ_PMUD_CLK_32M_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x601), 7)

#define GP_WB_GET_PMUD_CLK_32M_PUP_FROM_STANDBY_SETTINGS(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_PMUD_CLK_32M_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x601), 7, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_CLK_32M_PUP_TO_STANDBY_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x037FFF; \
          (tmp) |= (((UInt32)(val)) << 15); \
        } while (0)

/* forces on the 32 khz xtal clock */
#define GP_WB_READ_PMUD_CLK_XT32K_PUP_FORCE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x602), 0)

#define GP_WB_GET_PMUD_CLK_XT32K_PUP_FORCE_FROM_STANDBY_SETTINGS(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_PMUD_CLK_XT32K_PUP_FORCE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x602), 0, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_CLK_XT32K_PUP_FORCE_TO_STANDBY_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* when set to 1 the chip will immediately wakeup after entering sleep. Useful for ISH mode */
#define GP_WB_READ_PMUD_IMMEDIATE_WAKEUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x602), 1)

#define GP_WB_GET_PMUD_IMMEDIATE_WAKEUP_FROM_STANDBY_SETTINGS(tmp) \
        (((tmp) >> 17) & 0x01)

#define GP_WB_WRITE_PMUD_IMMEDIATE_WAKEUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x602), 1, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_IMMEDIATE_WAKEUP_TO_STANDBY_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFF; \
          (tmp) |= (((UInt32)(val)) << 17); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_SM_BLOCK_REMAP_ENTRIES() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x603))

#define GP_WB_WRITE_PMUD_SM_BLOCK_REMAP_ENTRIES(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x603), (val))

/* Does the logical to physical mapping of the first quarter of system ram addresses */
#define GP_WB_READ_PMUD_SM_BLOCK_REMAP_ENTRY_0() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x603)) & 0x03)

#define GP_WB_GET_PMUD_SM_BLOCK_REMAP_ENTRY_0_FROM_SM_BLOCK_REMAP_ENTRIES(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_PMUD_SM_BLOCK_REMAP_ENTRY_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x603), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_SM_BLOCK_REMAP_ENTRY_0_TO_SM_BLOCK_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0xFC; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Does the logical to physical mapping of the second quarter of system ram addresses */
#define GP_WB_READ_PMUD_SM_BLOCK_REMAP_ENTRY_1() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x603)) >> 2) & 0x03)

#define GP_WB_GET_PMUD_SM_BLOCK_REMAP_ENTRY_1_FROM_SM_BLOCK_REMAP_ENTRIES(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_PMUD_SM_BLOCK_REMAP_ENTRY_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x603), 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_PMUD_SM_BLOCK_REMAP_ENTRY_1_TO_SM_BLOCK_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0xF3; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Does the logical to physical mapping of the third quarter of system ram addresses */
#define GP_WB_READ_PMUD_SM_BLOCK_REMAP_ENTRY_2() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x603)) >> 4) & 0x03)

#define GP_WB_GET_PMUD_SM_BLOCK_REMAP_ENTRY_2_FROM_SM_BLOCK_REMAP_ENTRIES(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_PMUD_SM_BLOCK_REMAP_ENTRY_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x603), 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_PMUD_SM_BLOCK_REMAP_ENTRY_2_TO_SM_BLOCK_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0xCF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Does the logical to physical mapping of the fourth quarter of system ram addresses */
#define GP_WB_READ_PMUD_SM_BLOCK_REMAP_ENTRY_3() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x603)) >> 6) & 0x03)

#define GP_WB_GET_PMUD_SM_BLOCK_REMAP_ENTRY_3_FROM_SM_BLOCK_REMAP_ENTRIES(tmp) \
        (((tmp) >> 6) & 0x03)

#define GP_WB_WRITE_PMUD_SM_BLOCK_REMAP_ENTRY_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x603), 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_PMUD_SM_BLOCK_REMAP_ENTRY_3_TO_SM_BLOCK_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_UCRAM_BLOCK_REMAP_ENTRIES() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x604))

#define GP_WB_WRITE_PMUD_UCRAM_BLOCK_REMAP_ENTRIES(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x604), (val))

/* Does the logical to physical mapping of the first quarter of uc ram addresses */
#define GP_WB_READ_PMUD_UCRAM_BLOCK_REMAP_ENTRY_0() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x604)) & 0x03)

#define GP_WB_GET_PMUD_UCRAM_BLOCK_REMAP_ENTRY_0_FROM_UCRAM_BLOCK_REMAP_ENTRIES(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_PMUD_UCRAM_BLOCK_REMAP_ENTRY_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x604), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_UCRAM_BLOCK_REMAP_ENTRY_0_TO_UCRAM_BLOCK_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0xFC; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Does the logical to physical mapping of the second quarter of uc ram addresses */
#define GP_WB_READ_PMUD_UCRAM_BLOCK_REMAP_ENTRY_1() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x604)) >> 2) & 0x03)

#define GP_WB_GET_PMUD_UCRAM_BLOCK_REMAP_ENTRY_1_FROM_UCRAM_BLOCK_REMAP_ENTRIES(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_PMUD_UCRAM_BLOCK_REMAP_ENTRY_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x604), 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_PMUD_UCRAM_BLOCK_REMAP_ENTRY_1_TO_UCRAM_BLOCK_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0xF3; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Does the logical to physical mapping of the third quarter of uc ram addresses */
#define GP_WB_READ_PMUD_UCRAM_BLOCK_REMAP_ENTRY_2() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x604)) >> 4) & 0x03)

#define GP_WB_GET_PMUD_UCRAM_BLOCK_REMAP_ENTRY_2_FROM_UCRAM_BLOCK_REMAP_ENTRIES(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_PMUD_UCRAM_BLOCK_REMAP_ENTRY_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x604), 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_PMUD_UCRAM_BLOCK_REMAP_ENTRY_2_TO_UCRAM_BLOCK_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0xCF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Does the logical to physical mapping of the fourth quarter of uc ram addresses */
#define GP_WB_READ_PMUD_UCRAM_BLOCK_REMAP_ENTRY_3() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x604)) >> 6) & 0x03)

#define GP_WB_GET_PMUD_UCRAM_BLOCK_REMAP_ENTRY_3_FROM_UCRAM_BLOCK_REMAP_ENTRIES(tmp) \
        (((tmp) >> 6) & 0x03)

#define GP_WB_WRITE_PMUD_UCRAM_BLOCK_REMAP_ENTRY_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x604), 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_PMUD_UCRAM_BLOCK_REMAP_ENTRY_3_TO_UCRAM_BLOCK_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_LOCK_RAM_CONFIG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x605))

#define GP_WB_WRITE_PMUD_LOCK_RAM_CONFIG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x605), (val))

/* locks the pkey key 0 region for write and access and restricts read to the secure access (32 byte key region) - Once locked, can not be unlocked */
#define GP_WB_READ_PMUD_LOCK_RAM_PKEY_0() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x605), 1)

#define GP_WB_GET_PMUD_LOCK_RAM_PKEY_0_FROM_LOCK_RAM_CONFIG(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_PMUD_LOCK_RAM_PKEY_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x605), 1, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_LOCK_RAM_PKEY_0_TO_LOCK_RAM_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3C; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* locks the pkey key 1 region for write and access and restricts read to the secure access (32 byte key region) - Once locked, can not be unlocked */
#define GP_WB_READ_PMUD_LOCK_RAM_PKEY_1() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x605), 2)

#define GP_WB_GET_PMUD_LOCK_RAM_PKEY_1_FROM_LOCK_RAM_CONFIG(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_PMUD_LOCK_RAM_PKEY_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x605), 2, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_LOCK_RAM_PKEY_1_TO_LOCK_RAM_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3A; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* locks the pkey key 2 region for write and access and restricts read to the secure access (32 byte key region) - Once locked, can not be unlocked */
#define GP_WB_READ_PMUD_LOCK_RAM_PKEY_2() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x605), 3)

#define GP_WB_GET_PMUD_LOCK_RAM_PKEY_2_FROM_LOCK_RAM_CONFIG(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_PMUD_LOCK_RAM_PKEY_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x605), 3, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_LOCK_RAM_PKEY_2_TO_LOCK_RAM_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x36; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* locks the pkey key 3 region for write and access and restricts read to the secure access (32 byte key region) - Once locked, can not be unlocked */
#define GP_WB_READ_PMUD_LOCK_RAM_PKEY_3() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x605), 4)

#define GP_WB_GET_PMUD_LOCK_RAM_PKEY_3_FROM_LOCK_RAM_CONFIG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_PMUD_LOCK_RAM_PKEY_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x605), 4, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_LOCK_RAM_PKEY_3_TO_LOCK_RAM_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2E; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Locks the ram block remapping */
#define GP_WB_READ_PMUD_LOCK_RAM_BLOCK_REMAP_ENTRIES() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x605), 5)

#define GP_WB_GET_PMUD_LOCK_RAM_BLOCK_REMAP_ENTRIES_FROM_LOCK_RAM_CONFIG(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_PMUD_LOCK_RAM_BLOCK_REMAP_ENTRIES(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x605), 5, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_LOCK_RAM_BLOCK_REMAP_ENTRIES_TO_LOCK_RAM_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_DEBUG_CONTROL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x606))

#define GP_WB_WRITE_PMUD_DEBUG_CONTROL(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x606), (val))

/* disables debugging on the main application uController. Can only be set, can never be unset */
#define GP_WB_READ_PMUD_DISABLE_UC_DEBUG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x606), 0)

#define GP_WB_GET_PMUD_DISABLE_UC_DEBUG_FROM_DEBUG_CONTROL(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_PMUD_DISABLE_UC_DEBUG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x606), 0, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_DISABLE_UC_DEBUG_TO_DEBUG_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* disables the physical debug interface */
#define GP_WB_READ_PMUD_DISABLE_SWJDP_ITF() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x606), 1)

#define GP_WB_GET_PMUD_DISABLE_SWJDP_ITF_FROM_DEBUG_CONTROL(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_PMUD_DISABLE_SWJDP_ITF(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x606), 1, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_DISABLE_SWJDP_ITF_TO_DEBUG_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* disables all access to flash */
#define GP_WB_READ_PMUD_LOCK_ALL_FLASH_ACCESS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x606), 2)

#define GP_WB_GET_PMUD_LOCK_ALL_FLASH_ACCESS_FROM_DEBUG_CONTROL(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_PMUD_LOCK_ALL_FLASH_ACCESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x606), 2, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_LOCK_ALL_FLASH_ACCESS_TO_DEBUG_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_GPIO_CONTROL() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x608))

#define GP_WB_WRITE_PMUD_GPIO_CONTROL(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x608), (val))

/* When set to 1, the different gpio sources have access to the ioring. When set to 0, the ioring is in a off state, where all gpio macros are switched to input mode */
#define GP_WB_READ_PMUD_GPIO_FUNCTION_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x608), 0)

#define GP_WB_GET_PMUD_GPIO_FUNCTION_ENABLE_FROM_GPIO_CONTROL(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_PMUD_GPIO_FUNCTION_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x608), 0, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_GPIO_FUNCTION_ENABLE_TO_GPIO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F3E; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* When set to 1 a gpio wakeup event will be latched even if vmt status indicates that VDDB is too low. Actual wakeup occurs when the vddb is above vmt threshold */
#define GP_WB_READ_PMUD_GPIO_EV_DELAY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x608), 1)

#define GP_WB_GET_PMUD_GPIO_EV_DELAY_FROM_GPIO_CONTROL(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_PMUD_GPIO_EV_DELAY(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x608), 1, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_GPIO_EV_DELAY_TO_GPIO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F3D; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

/* Determines the repetition period of the pull-up enable / strong drive pulse during sleep. This enables a duty cycled pull up or strong drive for those io cells that have the duvty cycled pull up or strong drive enabled. The period is 2**gpio_pulse_period * standby_clk_period (which is around 30 us, but depends on the chosen sleep mode). When set to 0, to pulse is generated */
#define GP_WB_READ_PMUD_GPIO_PULSE_PERIOD() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x608)) >> 2) & 0x0F)

#define GP_WB_GET_PMUD_GPIO_PULSE_PERIOD_FROM_GPIO_CONTROL(tmp) \
        (((tmp) >> 2) & 0x0F)

#define GP_WB_WRITE_PMUD_GPIO_PULSE_PERIOD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x608), 0x3C, (val) << 2); \
        } while (0)

#define GP_WB_SET_PMUD_GPIO_PULSE_PERIOD_TO_GPIO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x3F03; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* When set, the gpio 0 input pin will be latched at the end of the gpio_pulse period before going to the edge detect logic */
#define GP_WB_READ_PMUD_GPIO_0_USE_LATCHED_DI() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x609), 0)

#define GP_WB_GET_PMUD_GPIO_0_USE_LATCHED_DI_FROM_GPIO_CONTROL(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_PMUD_GPIO_0_USE_LATCHED_DI(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x609), 0, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_GPIO_0_USE_LATCHED_DI_TO_GPIO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E3F; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* When set, the gpio 2 input pin will be latched at the end of the gpio_pulse period before going to the edge detect logic */
#define GP_WB_READ_PMUD_GPIO_2_USE_LATCHED_DI() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x609), 1)

#define GP_WB_GET_PMUD_GPIO_2_USE_LATCHED_DI_FROM_GPIO_CONTROL(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_PMUD_GPIO_2_USE_LATCHED_DI(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x609), 1, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_GPIO_2_USE_LATCHED_DI_TO_GPIO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3D3F; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)

/* When set, the gpio 15 input pin will be latched at the end of the gpio_pulse period before going to the edge detect logic */
#define GP_WB_READ_PMUD_GPIO_15_USE_LATCHED_DI() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x609), 2)

#define GP_WB_GET_PMUD_GPIO_15_USE_LATCHED_DI_FROM_GPIO_CONTROL(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_PMUD_GPIO_15_USE_LATCHED_DI(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x609), 2, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_GPIO_15_USE_LATCHED_DI_TO_GPIO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3B3F; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)

/* When set, the gpio 17 input pin will be latched at the end of the gpio_pulse period before going to the edge detect logic */
#define GP_WB_READ_PMUD_GPIO_17_USE_LATCHED_DI() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x609), 3)

#define GP_WB_GET_PMUD_GPIO_17_USE_LATCHED_DI_FROM_GPIO_CONTROL(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_PMUD_GPIO_17_USE_LATCHED_DI(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x609), 3, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_GPIO_17_USE_LATCHED_DI_TO_GPIO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x373F; \
          (tmp) |= (((UInt16)(val)) << 11); \
        } while (0)

/* When set to 1 the gpio pad input buffers will remain on during sleep. By default they are switched off */
#define GP_WB_READ_PMUD_KEEP_INPUT_BUFFERS_ON_DURING_SLEEP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x609), 4)

#define GP_WB_GET_PMUD_KEEP_INPUT_BUFFERS_ON_DURING_SLEEP_FROM_GPIO_CONTROL(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_PMUD_KEEP_INPUT_BUFFERS_ON_DURING_SLEEP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x609), 4, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_KEEP_INPUT_BUFFERS_ON_DURING_SLEEP_TO_GPIO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F3F; \
          (tmp) |= (((UInt16)(val)) << 12); \
        } while (0)

/* When set to 1 the gpio pad input schmitt trigger function will be enabled during sleep */
#define GP_WB_READ_PMUD_USE_SCHMITT_TRIGGER_DURING_SLEEP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x609), 5)

#define GP_WB_GET_PMUD_USE_SCHMITT_TRIGGER_DURING_SLEEP_FROM_GPIO_CONTROL(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_PMUD_USE_SCHMITT_TRIGGER_DURING_SLEEP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x609), 5, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_USE_SCHMITT_TRIGGER_DURING_SLEEP_TO_GPIO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F3F; \
          (tmp) |= (((UInt16)(val)) << 13); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_WAKEUP_PIN_SETTINGS() \
        GP_WB_READ_U48(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60c))

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_SETTINGS(val) \
      GP_WB_WRITE_U48(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60c), (val))

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_0() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60c)) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_0_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60c), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_0_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3FFFFFFFFFFC; \
          (tmp) |= ((UInt64)(val)); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_1() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60c)) >> 2) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_1_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60c), 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_1_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3FFFFFFFFFF3; \
          (tmp) |= (((UInt64)(val)) << 2); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_2() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60c)) >> 4) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_2_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60c), 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_2_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3FFFFFFFFFCF; \
          (tmp) |= (((UInt64)(val)) << 4); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_3() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60c)) >> 6) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_3_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 6) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60c), 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_3_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3FFFFFFFFF3F; \
          (tmp) |= (((UInt64)(val)) << 6); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_4() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60d)) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_4_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 8) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60d), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_4_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3FFFFFFFFCFF; \
          (tmp) |= (((UInt64)(val)) << 8); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_5() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60d)) >> 2) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_5_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 10) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60d), 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_5_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3FFFFFFFF3FF; \
          (tmp) |= (((UInt64)(val)) << 10); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_6() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60d)) >> 4) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_6_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 12) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_6(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60d), 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_6_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3FFFFFFFCFFF; \
          (tmp) |= (((UInt64)(val)) << 12); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_7() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60d)) >> 6) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_7_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 14) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_7(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60d), 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_7_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3FFFFFFF3FFF; \
          (tmp) |= (((UInt64)(val)) << 14); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_8() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60e)) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_8_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 16) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_8(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60e), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_8_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3FFFFFFCFFFF; \
          (tmp) |= (((UInt64)(val)) << 16); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_9() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60e)) >> 2) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_9_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 18) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_9(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60e), 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_9_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3FFFFFF3FFFF; \
          (tmp) |= (((UInt64)(val)) << 18); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_10() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60e)) >> 4) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_10_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 20) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_10(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60e), 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_10_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3FFFFFCFFFFF; \
          (tmp) |= (((UInt64)(val)) << 20); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_11() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60e)) >> 6) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_11_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 22) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_11(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60e), 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_11_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3FFFFF3FFFFF; \
          (tmp) |= (((UInt64)(val)) << 22); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_12() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60f)) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_12_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 24) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_12(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60f), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_12_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3FFFFCFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 24); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_13() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60f)) >> 2) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_13_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 26) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_13(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60f), 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_13_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3FFFF3FFFFFF; \
          (tmp) |= (((UInt64)(val)) << 26); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_14() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60f)) >> 4) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_14_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 28) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_14(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60f), 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_14_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3FFFCFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 28); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_15() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60f)) >> 6) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_15_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 30) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_15(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x60f), 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_15_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3FFF3FFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 30); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_16() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x610)) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_16_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 32) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_16(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x610), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_16_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3FFCFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 32); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_17() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x610)) >> 2) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_17_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 34) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_17(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x610), 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_17_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3FF3FFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 34); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_18() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x610)) >> 4) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_18_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 36) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_18(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x610), 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_18_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3FCFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 36); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_19() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x610)) >> 6) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_19_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 38) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_19(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x610), 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_19_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3F3FFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 38); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_20() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x611)) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_20_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 40) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_20(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x611), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_20_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3CFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 40); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_21() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x611)) >> 2) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_21_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 42) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_21(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x611), 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_21_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x33FFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 42); \
        } while (0)

/* wakeup on edge detect: 0x00 = no edge detect, 0x01 = rising, 0x02 = Falling 0x03 = Both */
#define GP_WB_READ_PMUD_WAKEUP_PIN_MODE_22() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x611)) >> 4) & 0x03)

#define GP_WB_GET_PMUD_WAKEUP_PIN_MODE_22_FROM_WAKEUP_PIN_SETTINGS(tmp) \
        (((tmp) >> 44) & 0x03)

#define GP_WB_WRITE_PMUD_WAKEUP_PIN_MODE_22(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x611), 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_PMUD_WAKEUP_PIN_MODE_22_TO_WAKEUP_PIN_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x0FFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 44); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_SOFT_POR_TRIGGERS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x612))

#define GP_WB_WRITE_PMUD_SOFT_POR_TRIGGERS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x612), (val))

/* Power on reset trigger - generic one to be used by main SW in active mode */
#define GP_WB_READ_PMUD_SOFT_POR() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x612), 0)

#define GP_WB_GET_PMUD_SOFT_POR_FROM_SOFT_POR_TRIGGERS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_PMUD_SOFT_POR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x612), 0, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_SOFT_POR_TO_SOFT_POR_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Power on reset trigger - to be used to trigger a soft por when ram mw was invalid at startup */
#define GP_WB_READ_PMUD_SOFT_POR_INVALID_RAM_MW() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x612), 1)

#define GP_WB_GET_PMUD_SOFT_POR_INVALID_RAM_MW_FROM_SOFT_POR_TRIGGERS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_PMUD_SOFT_POR_INVALID_RAM_MW(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x612), 1, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_SOFT_POR_INVALID_RAM_MW_TO_SOFT_POR_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Power on reset trigger - to be used to trigger a soft por when ram crc was invalid at startup */
#define GP_WB_READ_PMUD_SOFT_POR_INVALID_RAM_CRC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x612), 2)

#define GP_WB_GET_PMUD_SOFT_POR_INVALID_RAM_CRC_FROM_SOFT_POR_TRIGGERS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_PMUD_SOFT_POR_INVALID_RAM_CRC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x612), 2, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_SOFT_POR_INVALID_RAM_CRC_TO_SOFT_POR_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Power on reset trigger - Used to trigger a soft por when there is a flash bootloader crc failure */
#define GP_WB_READ_PMUD_SOFT_POR_INVALID_FLASH_BL_CRC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x612), 3)

#define GP_WB_GET_PMUD_SOFT_POR_INVALID_FLASH_BL_CRC_FROM_SOFT_POR_TRIGGERS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_PMUD_SOFT_POR_INVALID_FLASH_BL_CRC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x612), 3, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_SOFT_POR_INVALID_FLASH_BL_CRC_TO_SOFT_POR_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Power on reset trigger - Used to trigger a generic soft por from bootloader */
#define GP_WB_READ_PMUD_SOFT_POR_BOOTLOADER() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x612), 4)

#define GP_WB_GET_PMUD_SOFT_POR_BOOTLOADER_FROM_SOFT_POR_TRIGGERS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_PMUD_SOFT_POR_BOOTLOADER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x612), 4, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_SOFT_POR_BOOTLOADER_TO_SOFT_POR_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Power on reset trigger - Used to trigger a generic soft por, but keeping the debug part of the ioring intact */
#define GP_WB_READ_PMUD_SOFT_POR_PRESERVE_DBG_ITF() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x612), 5)

#define GP_WB_GET_PMUD_SOFT_POR_PRESERVE_DBG_ITF_FROM_SOFT_POR_TRIGGERS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_PMUD_SOFT_POR_PRESERVE_DBG_ITF(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x612), 5, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_SOFT_POR_PRESERVE_DBG_ITF_TO_SOFT_POR_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* When set to 1, the global ldo voltage will be activeley discharged during sleep */
#define GP_WB_READ_PMUD_PU_GLOBAL_LDO_OUT_DISCHARGE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x613), 0)

#define GP_WB_WRITE_PMUD_PU_GLOBAL_LDO_OUT_DISCHARGE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x613), (val)); \
        } while (0)


/* option to override the ready signal. the ready signal will be forced high */
#define GP_WB_READ_PMUD_XO_RDY_OVERRIDE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x614), 0)

#define GP_WB_WRITE_PMUD_XO_RDY_OVERRIDE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x614), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_LPCMP_CONFIG_A_SLOT_0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x615))

#define GP_WB_WRITE_PMUD_LPCMP_CONFIG_A_SLOT_0(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x615), (val))

/* sets the comparator level for slot 0 */
#define GP_WB_READ_PMUD_LPCMP_LVL_SLOT_0() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x615)) & 0x3F)

#define GP_WB_GET_PMUD_LPCMP_LVL_SLOT_0_FROM_LPCMP_CONFIG_A_SLOT_0(tmp) \
        ((tmp) & 0x3F)

#define GP_WB_WRITE_PMUD_LPCMP_LVL_SLOT_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x615), 0x3F, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_LPCMP_LVL_SLOT_0_TO_LPCMP_CONFIG_A_SLOT_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0xC0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* If the value is 0, the event will trigger if the measured value is below the configured comparator level. If the value is 1, the event occurs when the measured value is above the configured comparator level. */
#define GP_WB_READ_PMUD_LPCMP_COMPARE_VALUE_SLOT_0() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x615), 6)

#define GP_WB_GET_PMUD_LPCMP_COMPARE_VALUE_SLOT_0_FROM_LPCMP_CONFIG_A_SLOT_0(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_PMUD_LPCMP_COMPARE_VALUE_SLOT_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x615), 6, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_LPCMP_COMPARE_VALUE_SLOT_0_TO_LPCMP_CONFIG_A_SLOT_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* Enables the event on a comparator value match for slot 0 */
#define GP_WB_READ_PMUD_LPCMP_COMPARE_ENABLE_SLOT_0() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x615), 7)

#define GP_WB_GET_PMUD_LPCMP_COMPARE_ENABLE_SLOT_0_FROM_LPCMP_CONFIG_A_SLOT_0(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_PMUD_LPCMP_COMPARE_ENABLE_SLOT_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x615), 7, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_LPCMP_COMPARE_ENABLE_SLOT_0_TO_LPCMP_CONFIG_A_SLOT_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_LPCMP_CONFIG_A_SLOT_1() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x616))

#define GP_WB_WRITE_PMUD_LPCMP_CONFIG_A_SLOT_1(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x616), (val))

/* sets the comparator level for slot 1 */
#define GP_WB_READ_PMUD_LPCMP_LVL_SLOT_1() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x616)) & 0x3F)

#define GP_WB_GET_PMUD_LPCMP_LVL_SLOT_1_FROM_LPCMP_CONFIG_A_SLOT_1(tmp) \
        ((tmp) & 0x3F)

#define GP_WB_WRITE_PMUD_LPCMP_LVL_SLOT_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x616), 0x3F, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_LPCMP_LVL_SLOT_1_TO_LPCMP_CONFIG_A_SLOT_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0xC0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* If the value is 0, the event will trigger if the measured value is below the configured comparator level. If the value is 1, the event occurs when the measured value is above the configured comparator level. */
#define GP_WB_READ_PMUD_LPCMP_COMPARE_VALUE_SLOT_1() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x616), 6)

#define GP_WB_GET_PMUD_LPCMP_COMPARE_VALUE_SLOT_1_FROM_LPCMP_CONFIG_A_SLOT_1(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_PMUD_LPCMP_COMPARE_VALUE_SLOT_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x616), 6, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_LPCMP_COMPARE_VALUE_SLOT_1_TO_LPCMP_CONFIG_A_SLOT_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* Enables the event on a comparator value match for slot 1 */
#define GP_WB_READ_PMUD_LPCMP_COMPARE_ENABLE_SLOT_1() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x616), 7)

#define GP_WB_GET_PMUD_LPCMP_COMPARE_ENABLE_SLOT_1_FROM_LPCMP_CONFIG_A_SLOT_1(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_PMUD_LPCMP_COMPARE_ENABLE_SLOT_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x616), 7, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_LPCMP_COMPARE_ENABLE_SLOT_1_TO_LPCMP_CONFIG_A_SLOT_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_LPCMP_CONFIG_A_SLOT_2() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x617))

#define GP_WB_WRITE_PMUD_LPCMP_CONFIG_A_SLOT_2(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x617), (val))

/* sets the comparator level for slot 2 */
#define GP_WB_READ_PMUD_LPCMP_LVL_SLOT_2() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x617)) & 0x3F)

#define GP_WB_GET_PMUD_LPCMP_LVL_SLOT_2_FROM_LPCMP_CONFIG_A_SLOT_2(tmp) \
        ((tmp) & 0x3F)

#define GP_WB_WRITE_PMUD_LPCMP_LVL_SLOT_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x617), 0x3F, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_LPCMP_LVL_SLOT_2_TO_LPCMP_CONFIG_A_SLOT_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0xC0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* If the value is 0, the event will trigger if the measured value is below the configured comparator level. If the value is 1, the event occurs when the measured value is above the configured comparator level. */
#define GP_WB_READ_PMUD_LPCMP_COMPARE_VALUE_SLOT_2() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x617), 6)

#define GP_WB_GET_PMUD_LPCMP_COMPARE_VALUE_SLOT_2_FROM_LPCMP_CONFIG_A_SLOT_2(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_PMUD_LPCMP_COMPARE_VALUE_SLOT_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x617), 6, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_LPCMP_COMPARE_VALUE_SLOT_2_TO_LPCMP_CONFIG_A_SLOT_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* Enables the event on a comparator value match for slot 2 */
#define GP_WB_READ_PMUD_LPCMP_COMPARE_ENABLE_SLOT_2() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x617), 7)

#define GP_WB_GET_PMUD_LPCMP_COMPARE_ENABLE_SLOT_2_FROM_LPCMP_CONFIG_A_SLOT_2(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_PMUD_LPCMP_COMPARE_ENABLE_SLOT_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x617), 7, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_LPCMP_COMPARE_ENABLE_SLOT_2_TO_LPCMP_CONFIG_A_SLOT_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_LPCMP_CONFIG_A_SLOT_3() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x618))

#define GP_WB_WRITE_PMUD_LPCMP_CONFIG_A_SLOT_3(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x618), (val))

/* sets the comparator level for slot 3 */
#define GP_WB_READ_PMUD_LPCMP_LVL_SLOT_3() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x618)) & 0x3F)

#define GP_WB_GET_PMUD_LPCMP_LVL_SLOT_3_FROM_LPCMP_CONFIG_A_SLOT_3(tmp) \
        ((tmp) & 0x3F)

#define GP_WB_WRITE_PMUD_LPCMP_LVL_SLOT_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x618), 0x3F, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_LPCMP_LVL_SLOT_3_TO_LPCMP_CONFIG_A_SLOT_3(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0xC0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* If the value is 0, the event will trigger if the measured value is below the configured comparator level. If the value is 1, the event occurs when the measured value is above the configured comparator level. */
#define GP_WB_READ_PMUD_LPCMP_COMPARE_VALUE_SLOT_3() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x618), 6)

#define GP_WB_GET_PMUD_LPCMP_COMPARE_VALUE_SLOT_3_FROM_LPCMP_CONFIG_A_SLOT_3(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_PMUD_LPCMP_COMPARE_VALUE_SLOT_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x618), 6, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_LPCMP_COMPARE_VALUE_SLOT_3_TO_LPCMP_CONFIG_A_SLOT_3(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* Enables the event on a comparator value match for slot 3 */
#define GP_WB_READ_PMUD_LPCMP_COMPARE_ENABLE_SLOT_3() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x618), 7)

#define GP_WB_GET_PMUD_LPCMP_COMPARE_ENABLE_SLOT_3_FROM_LPCMP_CONFIG_A_SLOT_3(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_PMUD_LPCMP_COMPARE_ENABLE_SLOT_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x618), 7, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_LPCMP_COMPARE_ENABLE_SLOT_3_TO_LPCMP_CONFIG_A_SLOT_3(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_LPCMP_CONFIG_B_SLOT_0_1() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x619))

#define GP_WB_WRITE_PMUD_LPCMP_CONFIG_B_SLOT_0_1(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x619), (val))

/* Selects the anio channel to do the comparison on */
#define GP_WB_READ_PMUD_LPCMP_CHANNEL_SEL_SLOT_0() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x619)) & 0x07)

#define GP_WB_GET_PMUD_LPCMP_CHANNEL_SEL_SLOT_0_FROM_LPCMP_CONFIG_B_SLOT_0_1(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_PMUD_LPCMP_CHANNEL_SEL_SLOT_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x619), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_LPCMP_CHANNEL_SEL_SLOT_0_TO_LPCMP_CONFIG_B_SLOT_0_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x78; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Selects the anio channel to do the comparison on */
#define GP_WB_READ_PMUD_LPCMP_CHANNEL_SEL_SLOT_1() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x619)) >> 3) & 0x07)

#define GP_WB_GET_PMUD_LPCMP_CHANNEL_SEL_SLOT_1_FROM_LPCMP_CONFIG_B_SLOT_0_1(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_PMUD_LPCMP_CHANNEL_SEL_SLOT_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x619), 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_PMUD_LPCMP_CHANNEL_SEL_SLOT_1_TO_LPCMP_CONFIG_B_SLOT_0_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x47; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Enables the wakeup on a a comparator window match (when slot 0 and 1 match, the event will trigger) */
#define GP_WB_READ_PMUD_LPCMP_WINDOW_ENABLE_SLOT_0_AND_1() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x619), 6)

#define GP_WB_GET_PMUD_LPCMP_WINDOW_ENABLE_SLOT_0_AND_1_FROM_LPCMP_CONFIG_B_SLOT_0_1(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_PMUD_LPCMP_WINDOW_ENABLE_SLOT_0_AND_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x619), 6, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_LPCMP_WINDOW_ENABLE_SLOT_0_AND_1_TO_LPCMP_CONFIG_B_SLOT_0_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_LPCMP_CONFIG_B_SLOT_2_3() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x61a))

#define GP_WB_WRITE_PMUD_LPCMP_CONFIG_B_SLOT_2_3(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x61a), (val))

/* Selects the anio channel to do the comparison on */
#define GP_WB_READ_PMUD_LPCMP_CHANNEL_SEL_SLOT_2() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x61a)) & 0x07)

#define GP_WB_GET_PMUD_LPCMP_CHANNEL_SEL_SLOT_2_FROM_LPCMP_CONFIG_B_SLOT_2_3(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_PMUD_LPCMP_CHANNEL_SEL_SLOT_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x61a), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_LPCMP_CHANNEL_SEL_SLOT_2_TO_LPCMP_CONFIG_B_SLOT_2_3(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x78; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Selects the anio channel to do the comparison on */
#define GP_WB_READ_PMUD_LPCMP_CHANNEL_SEL_SLOT_3() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x61a)) >> 3) & 0x07)

#define GP_WB_GET_PMUD_LPCMP_CHANNEL_SEL_SLOT_3_FROM_LPCMP_CONFIG_B_SLOT_2_3(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_PMUD_LPCMP_CHANNEL_SEL_SLOT_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x61a), 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_PMUD_LPCMP_CHANNEL_SEL_SLOT_3_TO_LPCMP_CONFIG_B_SLOT_2_3(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x47; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Enables the wakeup on a a comparator window match (when slot 0 and 1 match, the event will trigger) */
#define GP_WB_READ_PMUD_LPCMP_WINDOW_ENABLE_SLOT_2_AND_3() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x61a), 6)

#define GP_WB_GET_PMUD_LPCMP_WINDOW_ENABLE_SLOT_2_AND_3_FROM_LPCMP_CONFIG_B_SLOT_2_3(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_PMUD_LPCMP_WINDOW_ENABLE_SLOT_2_AND_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x61a), 6, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_LPCMP_WINDOW_ENABLE_SLOT_2_AND_3_TO_LPCMP_CONFIG_B_SLOT_2_3(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_LPCMP_GENERAL_CONFIG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x61b))

#define GP_WB_WRITE_PMUD_LPCMP_GENERAL_CONFIG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x61b), (val))

/* sets the divide ratio for the lpcmparator clock. Divide factor is 2**lpcmp_clk_div_factor. Remark that max divide factor supported is 2**5. The base clock is 32KHZ. So 32 Khz downto 1 kHz is supported. Values bigger than 5 result into NO CLOCK */
#define GP_WB_READ_PMUD_LPCMP_CLK_DIV_FACTOR() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x61b)) & 0x07)

#define GP_WB_GET_PMUD_LPCMP_CLK_DIV_FACTOR_FROM_LPCMP_GENERAL_CONFIG(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_PMUD_LPCMP_CLK_DIV_FACTOR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x61b), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_LPCMP_CLK_DIV_FACTOR_TO_LPCMP_GENERAL_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x18; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* forces the analog lpcmp_pup to 1 even if no slots are enabled */
#define GP_WB_READ_PMUD_LPCMP_PUP_FORCE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x61b), 3)

#define GP_WB_GET_PMUD_LPCMP_PUP_FORCE_FROM_LPCMP_GENERAL_CONFIG(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_PMUD_LPCMP_PUP_FORCE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x61b), 3, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_LPCMP_PUP_FORCE_TO_LPCMP_GENERAL_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* forces on the channel mux pup, event if no slots are enabled */
#define GP_WB_READ_PMUD_LPCMP_CHANNEL_SEL_PUP_FORCE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x61b), 4)

#define GP_WB_GET_PMUD_LPCMP_CHANNEL_SEL_PUP_FORCE_FROM_LPCMP_GENERAL_CONFIG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_PMUD_LPCMP_CHANNEL_SEL_PUP_FORCE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x61b), 4, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_LPCMP_CHANNEL_SEL_PUP_FORCE_TO_LPCMP_GENERAL_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_WAKEUP_ON_RF_CONFIG_2() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x61d))

#define GP_WB_WRITE_PMUD_WAKEUP_ON_RF_CONFIG_2(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x61d), (val))

/* Wake_on_rf detector pup */
#define GP_WB_READ_PMUD_LPDET_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x61d), 0)

#define GP_WB_GET_PMUD_LPDET_PUP_FROM_WAKEUP_ON_RF_CONFIG_2(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_PMUD_LPDET_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x61d), 0, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_LPDET_PUP_TO_WAKEUP_ON_RF_CONFIG_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Sets the detector threshold level (0 means lowest threshold, 3 means highest threshold) */
#define GP_WB_READ_PMUD_LPDET_LVL() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x61d)) >> 1) & 0x03)

#define GP_WB_GET_PMUD_LPDET_LVL_FROM_WAKEUP_ON_RF_CONFIG_2(tmp) \
        (((tmp) >> 1) & 0x03)

#define GP_WB_WRITE_PMUD_LPDET_LVL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x61d), 0x06, (val) << 1); \
        } while (0)

#define GP_WB_SET_PMUD_LPDET_LVL_TO_WAKEUP_ON_RF_CONFIG_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x19; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* pup of the voltage doubler during sleep */
#define GP_WB_READ_PMUD_VDOUBLER_PUP_DURING_SLEEP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x61d), 3)

#define GP_WB_GET_PMUD_VDOUBLER_PUP_DURING_SLEEP_FROM_WAKEUP_ON_RF_CONFIG_2(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_PMUD_VDOUBLER_PUP_DURING_SLEEP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x61d), 3, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_VDOUBLER_PUP_DURING_SLEEP_TO_WAKEUP_ON_RF_CONFIG_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* When set to 1, the async status registers can be read out, if set to 0 these are masked off */
#define GP_WB_READ_PMUD_ENABLE_ASYNC_STATUS_READOUT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x61d), 4)

#define GP_WB_GET_PMUD_ENABLE_ASYNC_STATUS_READOUT_FROM_WAKEUP_ON_RF_CONFIG_2(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_PMUD_ENABLE_ASYNC_STATUS_READOUT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x61d), 4, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_ENABLE_ASYNC_STATUS_READOUT_TO_WAKEUP_ON_RF_CONFIG_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_WAKEUP_ON_RF_CONFIG_5() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x622))

#define GP_WB_WRITE_PMUD_WAKEUP_ON_RF_CONFIG_5(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x622), (val))

/* tune capacitance at ant1-side during sleep */
#define GP_WB_READ_PMUD_MATCH_ANT1_TUNE_DURING_SLEEP() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x622)) & 0x07)

#define GP_WB_GET_PMUD_MATCH_ANT1_TUNE_DURING_SLEEP_FROM_WAKEUP_ON_RF_CONFIG_5(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_PMUD_MATCH_ANT1_TUNE_DURING_SLEEP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x622), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_MATCH_ANT1_TUNE_DURING_SLEEP_TO_WAKEUP_ON_RF_CONFIG_5(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0xF8; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* tune capacitance at ant1-side during sleep */
#define GP_WB_READ_PMUD_MATCH_ANT2_TUNE_DURING_SLEEP() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x622)) >> 3) & 0x07)

#define GP_WB_GET_PMUD_MATCH_ANT2_TUNE_DURING_SLEEP_FROM_WAKEUP_ON_RF_CONFIG_5(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_PMUD_MATCH_ANT2_TUNE_DURING_SLEEP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x622), 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_PMUD_MATCH_ANT2_TUNE_DURING_SLEEP_TO_WAKEUP_ON_RF_CONFIG_5(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0xC7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* select antenna 2 to connect to tx or rx during sleep */
#define GP_WB_READ_PMUD_MATCH_ANT1_SELECT_DURING_SLEEP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x622), 6)

#define GP_WB_GET_PMUD_MATCH_ANT1_SELECT_DURING_SLEEP_FROM_WAKEUP_ON_RF_CONFIG_5(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_PMUD_MATCH_ANT1_SELECT_DURING_SLEEP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x622), 6, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_MATCH_ANT1_SELECT_DURING_SLEEP_TO_WAKEUP_ON_RF_CONFIG_5(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* select antenna 2 to connect to tx or rx during sleep */
#define GP_WB_READ_PMUD_MATCH_ANT2_SELECT_DURING_SLEEP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x622), 7)

#define GP_WB_GET_PMUD_MATCH_ANT2_SELECT_DURING_SLEEP_FROM_WAKEUP_ON_RF_CONFIG_5(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_PMUD_MATCH_ANT2_SELECT_DURING_SLEEP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x622), 7, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_MATCH_ANT2_SELECT_DURING_SLEEP_TO_WAKEUP_ON_RF_CONFIG_5(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* indicates what was the source of the por event */
#define GP_WB_READ_PMUD_POR_REASON() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x624)) & 0x0F)

/* indicates what was the reason for wakup */
#define GP_WB_READ_PMUD_WKUP_REASON() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x624)) >> 4) & 0x07)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_MISC_STATUS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x625))

/* 32MHz xtal rdy signal straight from analog */
#define GP_WB_READ_PMUD_CLK_32M_RDY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x625), 0)

#define GP_WB_GET_PMUD_CLK_32M_RDY_FROM_MISC_STATUS(tmp) \
        ((tmp) & 0x01)

/* 29MHz ringosc rdy signal straight from analog */
#define GP_WB_READ_PMUD_CLK_29M_RDY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x625), 1)

#define GP_WB_GET_PMUD_CLK_29M_RDY_FROM_MISC_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* Status of the lpcomparator events - needs enable_async_status_readout=1 for enabling readout */
#define GP_WB_READ_PMUD_COMP_EVENTS() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x625)) >> 2) & 0x0F)

#define GP_WB_GET_PMUD_COMP_EVENTS_FROM_MISC_STATUS(tmp) \
        (((tmp) >> 2) & 0x0F)



/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_WAKEUP_ON_RF_MISC() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x628))


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_PMU_VDDRAM_SEL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x629))

#define GP_WB_WRITE_PMUD_PMU_VDDRAM_SEL(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x629), (val))

/* disable retention of the system RAM from 0KB to 8KB */
#define GP_WB_READ_PMUD_PMU_VDDRAM_SEL_SYSRAM_0_8KB() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x629), 0)

#define GP_WB_GET_PMUD_PMU_VDDRAM_SEL_SYSRAM_0_8KB_FROM_PMU_VDDRAM_SEL(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_PMUD_PMU_VDDRAM_SEL_SYSRAM_0_8KB(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x629), 0, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_PMU_VDDRAM_SEL_SYSRAM_0_8KB_TO_PMU_VDDRAM_SEL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* disable retention of the system RAM from 8KB to 32KB */
#define GP_WB_READ_PMUD_PMU_VDDRAM_SEL_SYSRAM_8_32KB() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x629), 1)

#define GP_WB_GET_PMUD_PMU_VDDRAM_SEL_SYSRAM_8_32KB_FROM_PMU_VDDRAM_SEL(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_PMUD_PMU_VDDRAM_SEL_SYSRAM_8_32KB(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x629), 1, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_PMU_VDDRAM_SEL_SYSRAM_8_32KB_TO_PMU_VDDRAM_SEL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* disable retention of the uc RAM from 0KB to 32KB */
#define GP_WB_READ_PMUD_PMU_VDDRAM_SEL_UCRAM_0_32KB() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x629), 2)

#define GP_WB_GET_PMUD_PMU_VDDRAM_SEL_UCRAM_0_32KB_FROM_PMU_VDDRAM_SEL(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_PMUD_PMU_VDDRAM_SEL_UCRAM_0_32KB(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x629), 2, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_PMU_VDDRAM_SEL_UCRAM_0_32KB_TO_PMU_VDDRAM_SEL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* disable retention of the uc RAM above 32KB to 64 kB */
#define GP_WB_READ_PMUD_PMU_VDDRAM_SEL_UCRAM_32_64KB() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x629), 3)

#define GP_WB_GET_PMUD_PMU_VDDRAM_SEL_UCRAM_32_64KB_FROM_PMU_VDDRAM_SEL(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_PMUD_PMU_VDDRAM_SEL_UCRAM_32_64KB(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x629), 3, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_PMU_VDDRAM_SEL_UCRAM_32_64KB_TO_PMU_VDDRAM_SEL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* disable retention of the uc RAM above 64kB to 96 kB */
#define GP_WB_READ_PMUD_PMU_VDDRAM_SEL_UCRAM_64_96KB() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x629), 4)

#define GP_WB_GET_PMUD_PMU_VDDRAM_SEL_UCRAM_64_96KB_FROM_PMU_VDDRAM_SEL(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_PMUD_PMU_VDDRAM_SEL_UCRAM_64_96KB(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x629), 4, (val)); \
        } while (0)

#define GP_WB_SET_PMUD_PMU_VDDRAM_SEL_UCRAM_64_96KB_TO_PMU_VDDRAM_SEL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* set ldo resistance ladder reference. tweak the output voltage of the ldo */
#define GP_WB_READ_PMUD_XO_LDO_REFBITS() \
        (GP_WB_S8((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x62c)) & 0x1F), 5))

#define GP_WB_WRITE_PMUD_XO_LDO_REFBITS(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -16, 15); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x62c), 0x1F, (UInt8)((val))); \
        } while (0)

/* tunes the ram retention voltage (signed) */
#define GP_WB_READ_PMUD_PMU_VDDRAM_TUNE() \
        (GP_WB_S8(((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x62c)) >> 5) & 0x07), 3))

#define GP_WB_WRITE_PMUD_PMU_VDDRAM_TUNE(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x62c), 0xE0, (UInt8)((val) << 5)); \
        } while (0)

/* tunes the vref voltage (signed) */
#define GP_WB_READ_PMUD_PMU_VDDREF_TUNE() \
        (GP_WB_S8((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x62d)) & 0x0F), 4))

#define GP_WB_WRITE_PMUD_PMU_VDDREF_TUNE(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -8, 7); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x62d), 0x0F, (UInt8)((val))); \
        } while (0)

/* vmt tune value */
#define GP_WB_READ_PMUD_PMU_VMT_TUNE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x62d)) >> 4) & 0x0F)

#define GP_WB_WRITE_PMUD_PMU_VMT_TUNE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x62d), 0xF0, (val) << 4); \
        } while (0)

/* set ldo resistance ladder reference. tweak the output voltage of the ldo */
#define GP_WB_READ_PMUD_PU_DIG_LDO_REFBITS() \
        (GP_WB_S8((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x62e)) & 0x0F), 4))

#define GP_WB_WRITE_PMUD_PU_DIG_LDO_REFBITS(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -8, 7); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x62e), 0x0F, (UInt8)((val))); \
        } while (0)

/* set ldo resistance ladder reference. tweak the output voltage of the ldo */
#define GP_WB_READ_PMUD_PU_IO_LDO_REFBITS() \
        (GP_WB_S8(((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x62e)) >> 4) & 0x0F), 4))

#define GP_WB_WRITE_PMUD_PU_IO_LDO_REFBITS(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -8, 7); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x62e), 0xF0, (UInt8)((val) << 4)); \
        } while (0)

/* tunes the retention voltage (signed) */
#define GP_WB_READ_PMUD_PMU_VDDRET_TUNE() \
        (GP_WB_S8((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x62f)) & 0x07), 3))

#define GP_WB_WRITE_PMUD_PMU_VDDRET_TUNE(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x62f), 0x07, (UInt8)((val))); \
        } while (0)

/* set ldo resistance ladder reference. tweak the output voltage of the ldo */
#define GP_WB_READ_PMUD_PU_GLOBAL_LDO_REFBITS() \
        (GP_WB_S8(((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x62f)) >> 3) & 0x07), 3))

#define GP_WB_WRITE_PMUD_PU_GLOBAL_LDO_REFBITS(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -4, 3); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x62f), 0x38, (UInt8)((val) << 3)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PMUD_ANALOG_TUNING() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x630))

#define GP_WB_WRITE_PMUD_ANALOG_TUNING(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x630), (val))

/* bandgap: tune bandgap voltage (typical 0.6v) */
#define GP_WB_READ_PMUD_PMU_BG_TUNE() \
        (GP_WB_S8((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x630)) & 0x0F), 4))

#define GP_WB_GET_PMUD_PMU_BG_TUNE_FROM_ANALOG_TUNING(tmp) \
        (GP_WB_S8(((tmp) & 0x0F), 4))

#define GP_WB_WRITE_PMUD_PMU_BG_TUNE(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -8, 7); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x630), 0x0F, (UInt8)((val))); \
        } while (0)

#define GP_WB_SET_PMUD_PMU_BG_TUNE_TO_ANALOG_TUNING(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK_SIGNED(val, -8, 7); \
          (tmp) &= 0x70; \
          (tmp) |= (((Int8)(val)) & 0x0F); \
        } while (0)

/* bandgap: 5ua current tuning reference refamp: this tracks hr res : not calibrated? */
#define GP_WB_READ_PMUD_PMU_BG_BIAS_TUNE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x630)) >> 4) & 0x07)

#define GP_WB_GET_PMUD_PMU_BG_BIAS_TUNE_FROM_ANALOG_TUNING(tmp) \
        (((tmp) >> 4) & 0x07)

#define GP_WB_WRITE_PMUD_PMU_BG_BIAS_TUNE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x630), 0x70, (val) << 4); \
        } while (0)

#define GP_WB_SET_PMUD_PMU_BG_BIAS_TUNE_TO_ANALOG_TUNING(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* configures bias current of 32 khz crystal oscillator which control the swing of the 32 khz oscillator */
#define GP_WB_READ_PMUD_XT32K_CURRENT() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x634)) & 0x7F)

#define GP_WB_WRITE_PMUD_XT32K_CURRENT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x634), 0x7F, (val)); \
        } while (0)

/* bandgap noise filtereing */
#define GP_WB_READ_PMUD_PMU_BG_LPF() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x634), 7)

#define GP_WB_WRITE_PMUD_PMU_BG_LPF(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x634), 7, (val)); \
        } while (0)

/* tunes negative temperature coefficient resistive ladder */
#define GP_WB_READ_PMUD_PMU_RC64K_TUNEN() \
        (GP_WB_S8((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x635)) & 0x1F), 5))

#define GP_WB_WRITE_PMUD_PMU_RC64K_TUNEN(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -16, 15); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x635), 0x1F, (UInt8)((val))); \
        } while (0)

/* spare */
#define GP_WB_READ_PMUD_RCLJ_SPARE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x635)) >> 5) & 0x07)

#define GP_WB_WRITE_PMUD_RCLJ_SPARE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x635), 0xE0, (val) << 5); \
        } while (0)

/* tunes positive temperature coefficient resistive ladder */
#define GP_WB_READ_PMUD_PMU_RC64K_TUNEP() \
        (GP_WB_S8((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x636)) & 0x1F), 5))

#define GP_WB_WRITE_PMUD_PMU_RC64K_TUNEP(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -16, 15); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x636), 0x1F, (UInt8)((val))); \
        } while (0)

/* configures the drivestrength of the 32 mhz xo, which affects the rise and fall time of the sys_clk */
#define GP_WB_READ_PMUD_XO_BUF_STRENGTH() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x636)) >> 5) & 0x07)

#define GP_WB_WRITE_PMUD_XO_BUF_STRENGTH(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x636), 0xE0, (val) << 5); \
        } while (0)

/* 1.2v reference setting bits */
#define GP_WB_READ_PMUD_FLASH_REFBITS() \
        (GP_WB_S8((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x637)) & 0x0F), 4))

#define GP_WB_WRITE_PMUD_FLASH_REFBITS(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -8, 7); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x637), 0x0F, (UInt8)((val))); \
        } while (0)

/* course bank calibration for the 29 mhz ring oscillator */
#define GP_WB_READ_PMUD_XO_RING29M_COURSE_BANK() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x637)) >> 4) & 0x0F)

#define GP_WB_WRITE_PMUD_XO_RING29M_COURSE_BANK(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x637), 0xF0, (val) << 4); \
        } while (0)

/* fine bank calibration for the 29 mhz ring oscillator */
#define GP_WB_READ_PMUD_XO_RING29M_FINE_BANK() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x638)) & 0x0F)

#define GP_WB_WRITE_PMUD_XO_RING29M_FINE_BANK(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x638), 0x0F, (val)); \
        } while (0)

/* 2-complement agc level setting : [10,11,00,01]=[-2 -1 0 1] ; */
#define GP_WB_READ_PMUD_XO_AGC_LEVEL() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x638)) >> 4) & 0x03)

#define GP_WB_WRITE_PMUD_XO_AGC_LEVEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x638), 0x30, (val) << 4); \
        } while (0)

/* trim value for xtal oscillator caps */
#define GP_WB_READ_PMUD_XO_TRIMCAP() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x638)) >> 6) & 0x03)

#define GP_WB_WRITE_PMUD_XO_TRIMCAP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x638), 0xC0, (val) << 6); \
        } while (0)

/* disable lpr vref */
#define GP_WB_READ_PMUD_PMU_VDDREF_DISABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x639), 0)

#define GP_WB_WRITE_PMUD_PMU_VDDREF_DISABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x639), 0, (val)); \
        } while (0)

/* use lpr vref in standby */
#define GP_WB_READ_PMUD_PMU_VDDREF_IN_STANDBY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x639), 1)

#define GP_WB_WRITE_PMUD_PMU_VDDREF_IN_STANDBY(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x639), 1, (val)); \
        } while (0)

/* disable lpr process */
#define GP_WB_READ_PMUD_PMU_VDDRET_DISABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x639), 2)

#define GP_WB_WRITE_PMUD_PMU_VDDRET_DISABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x639), 2, (val)); \
        } while (0)

/* former pmu_vddret_in_active property, now reused for ljrc debug */
#define GP_WB_READ_PMUD_RC64KLJ_DEBUG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x639), 3)

#define GP_WB_WRITE_PMUD_RC64KLJ_DEBUG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x639), 3, (val)); \
        } while (0)

/* use 1khz vmt measurements */
#define GP_WB_READ_PMUD_PMU_VMT_1K() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x639), 4)

#define GP_WB_WRITE_PMUD_PMU_VMT_1K(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x639), 4, (val)); \
        } while (0)

/* set ldo in bleed mode */
#define GP_WB_READ_PMUD_PU_DIG_LDO_BLEED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x639), 5)

#define GP_WB_WRITE_PMUD_PU_DIG_LDO_BLEED(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x639), 5, (val)); \
        } while (0)

/* when set to 1 the vdddig will be actively discharged during sleep */
#define GP_WB_READ_PMUD_PU_DIG_LDO_DISCHARGE_EN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x639), 6)

#define GP_WB_WRITE_PMUD_PU_DIG_LDO_DISCHARGE_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x639), 6, (val)); \
        } while (0)

/* set to 1 to disable fixed bleed resistor (essiential for iddq) */
#define GP_WB_READ_PMUD_PU_DIG_LDO_IDDQ() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x639), 7)

#define GP_WB_WRITE_PMUD_PU_DIG_LDO_IDDQ(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x639), 7, (val)); \
        } while (0)

/* bypass the noise filter resistor (of the 0.6v bandgap reference) for speed up settling */
#define GP_WB_READ_PMUD_PU_DIG_LDO_RES_BYPASS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x63a), 0)

#define GP_WB_WRITE_PMUD_PU_DIG_LDO_RES_BYPASS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x63a), 0, (val)); \
        } while (0)

/* switched off the ldo in bleed mode of 100ua */
#define GP_WB_READ_PMUD_PU_GLOBAL_LDO_BLEED_OFF() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x63a), 1)

#define GP_WB_WRITE_PMUD_PU_GLOBAL_LDO_BLEED_OFF(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x63a), 1, (val)); \
        } while (0)

/* bypass the noise filter resistor (of the 0.6v bandgap reference) for speed up settling */
#define GP_WB_READ_PMUD_PU_GLOBAL_LDO_RES_BYPASS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x63a), 2)

#define GP_WB_WRITE_PMUD_PU_GLOBAL_LDO_RES_BYPASS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x63a), 2, (val)); \
        } while (0)

/* test feature for global ldo */
#define GP_WB_READ_PMUD_PU_GLOBAL_LDO_TEST_CUR_EN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x63a), 3)

#define GP_WB_WRITE_PMUD_PU_GLOBAL_LDO_TEST_CUR_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x63a), 3, (val)); \
        } while (0)

/* set ldo bleed mode off */
#define GP_WB_READ_PMUD_PU_IO_LDO_BLEED_OFF() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x63a), 4)

#define GP_WB_WRITE_PMUD_PU_IO_LDO_BLEED_OFF(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x63a), 4, (val)); \
        } while (0)

/* bypass the noise filter resistor (of the 0.6v bandgap reference) for speed up settling */
#define GP_WB_READ_PMUD_PU_IO_LDO_RES_BYPASS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x63a), 5)

#define GP_WB_WRITE_PMUD_PU_IO_LDO_RES_BYPASS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x63a), 5, (val)); \
        } while (0)

/* testmode: turn agc off */
#define GP_WB_READ_PMUD_XO_AGC_OFF() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x63a), 6)

#define GP_WB_WRITE_PMUD_XO_AGC_OFF(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x63a), 6, (val)); \
        } while (0)

/* enables the main 32 mhz clock buffer (so clock is route through coax to digital) */
#define GP_WB_READ_PMUD_XO_CLK_32M_DRIVE_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x63a), 7)

#define GP_WB_WRITE_PMUD_XO_CLK_32M_DRIVE_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x63a), 7, (val)); \
        } while (0)

/* set ldo bleed mode off */
#define GP_WB_READ_PMUD_XO_LDO_BLEED_OFF() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x63b), 0)

#define GP_WB_WRITE_PMUD_XO_LDO_BLEED_OFF(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x63b), 0, (val)); \
        } while (0)

/* bypass the noise filter resistor (of the 0.6v bandgap reference) for speed up settling */
#define GP_WB_READ_PMUD_XO_LDO_RES_BYPASS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x63b), 1)

#define GP_WB_WRITE_PMUD_XO_LDO_RES_BYPASS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x63b), 1, (val)); \
        } while (0)


/* selects 1 out of 8 t-switch pairs */
#define GP_WB_READ_PMUD_TESTBUS_SEL() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x63c)) & 0x07)

#define GP_WB_WRITE_PMUD_TESTBUS_SEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x63c), 0x07, (val)); \
        } while (0)

/* enables group of 8 t-switch pairs, for pmua, while vdddig can be disabled */
#define GP_WB_READ_PMUD_TESTBUS_PMU_EN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x63c), 3)

#define GP_WB_WRITE_PMUD_TESTBUS_PMU_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x63c), 3, (val)); \
        } while (0)

/* connects testbus of channel0 to testbuffer/mux, mainly digldo, mcb, xo, fll */
#define GP_WB_READ_PMUD_TESTBUS_PMU_SEL() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x63c), 4)

#define GP_WB_WRITE_PMUD_TESTBUS_PMU_SEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x63c), 4, (val)); \
        } while (0)

/***************************
 * layout: iob
 ***************************/

/* selects internal signal to see on dbg0 */
#define GP_WB_READ_IOB_DBG0_SEL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x700))

#define GP_WB_WRITE_IOB_DBG0_SEL(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x700), (val)); \
        } while (0)


/* selects internal signal to see on dbg1 */
#define GP_WB_READ_IOB_DBG1_SEL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x701))

#define GP_WB_WRITE_IOB_DBG1_SEL(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x701), (val)); \
        } while (0)


/* selects internal signal to see on dbg2 */
#define GP_WB_READ_IOB_DBG2_SEL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x702))

#define GP_WB_WRITE_IOB_DBG2_SEL(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x702), (val)); \
        } while (0)


/* selects internal signal to see on dbg3 */
#define GP_WB_READ_IOB_DBG3_SEL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x703))

#define GP_WB_WRITE_IOB_DBG3_SEL(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x703), (val)); \
        } while (0)


/* selects internal signal to see on dbg4 */
#define GP_WB_READ_IOB_DBG4_SEL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x704))

#define GP_WB_WRITE_IOB_DBG4_SEL(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x704), (val)); \
        } while (0)


/* selects internal signal to see on dbg5 */
#define GP_WB_READ_IOB_DBG5_SEL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x705))

#define GP_WB_WRITE_IOB_DBG5_SEL(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x705), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_GPIO_PIN_CONFIG_A_0() \
        GP_WB_READ_U48(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x708))

#define GP_WB_WRITE_IOB_GPIO_PIN_CONFIG_A_0(val) \
      GP_WB_WRITE_U48(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x708), (val))

/* pull up, pull down, buskeeper configuration */
#define GP_WB_READ_IOB_GPIO_0_CFG() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x708)) & 0x03)

#define GP_WB_GET_IOB_GPIO_0_CFG_FROM_GPIO_PIN_CONFIG_A_0(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_0_CFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x708), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_0_CFG_TO_GPIO_PIN_CONFIG_A_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3C3FFFFFFFFC; \
          (tmp) |= ((UInt64)(val)); \
        } while (0)

/* pull up, pull down, buskeeper configuration */
#define GP_WB_READ_IOB_GPIO_1_CFG() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x708)) >> 2) & 0x03)

#define GP_WB_GET_IOB_GPIO_1_CFG_FROM_GPIO_PIN_CONFIG_A_0(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_1_CFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x708), 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_1_CFG_TO_GPIO_PIN_CONFIG_A_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3C3FFFFFFFF3; \
          (tmp) |= (((UInt64)(val)) << 2); \
        } while (0)

/* pull up, pull down, buskeeper configuration */
#define GP_WB_READ_IOB_GPIO_2_CFG() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x708)) >> 4) & 0x03)

#define GP_WB_GET_IOB_GPIO_2_CFG_FROM_GPIO_PIN_CONFIG_A_0(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_2_CFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x708), 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_2_CFG_TO_GPIO_PIN_CONFIG_A_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3C3FFFFFFFCF; \
          (tmp) |= (((UInt64)(val)) << 4); \
        } while (0)

/* pull up, pull down, buskeeper configuration */
#define GP_WB_READ_IOB_GPIO_3_CFG() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x708)) >> 6) & 0x03)

#define GP_WB_GET_IOB_GPIO_3_CFG_FROM_GPIO_PIN_CONFIG_A_0(tmp) \
        (((tmp) >> 6) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_3_CFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x708), 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_3_CFG_TO_GPIO_PIN_CONFIG_A_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3C3FFFFFFF3F; \
          (tmp) |= (((UInt64)(val)) << 6); \
        } while (0)

/* pull up, pull down, buskeeper configuration */
#define GP_WB_READ_IOB_GPIO_4_CFG() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x709)) & 0x03)

#define GP_WB_GET_IOB_GPIO_4_CFG_FROM_GPIO_PIN_CONFIG_A_0(tmp) \
        (((tmp) >> 8) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_4_CFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x709), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_4_CFG_TO_GPIO_PIN_CONFIG_A_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3C3FFFFFFCFF; \
          (tmp) |= (((UInt64)(val)) << 8); \
        } while (0)

/* pull up, pull down, buskeeper configuration */
#define GP_WB_READ_IOB_GPIO_5_CFG() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x709)) >> 2) & 0x03)

#define GP_WB_GET_IOB_GPIO_5_CFG_FROM_GPIO_PIN_CONFIG_A_0(tmp) \
        (((tmp) >> 10) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_5_CFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x709), 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_5_CFG_TO_GPIO_PIN_CONFIG_A_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3C3FFFFFF3FF; \
          (tmp) |= (((UInt64)(val)) << 10); \
        } while (0)

/* pull up, pull down, buskeeper configuration */
#define GP_WB_READ_IOB_GPIO_6_CFG() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x709)) >> 4) & 0x03)

#define GP_WB_GET_IOB_GPIO_6_CFG_FROM_GPIO_PIN_CONFIG_A_0(tmp) \
        (((tmp) >> 12) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_6_CFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x709), 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_6_CFG_TO_GPIO_PIN_CONFIG_A_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3C3FFFFFCFFF; \
          (tmp) |= (((UInt64)(val)) << 12); \
        } while (0)

/* pull up, pull down, buskeeper configuration */
#define GP_WB_READ_IOB_GPIO_7_CFG() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x709)) >> 6) & 0x03)

#define GP_WB_GET_IOB_GPIO_7_CFG_FROM_GPIO_PIN_CONFIG_A_0(tmp) \
        (((tmp) >> 14) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_7_CFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x709), 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_7_CFG_TO_GPIO_PIN_CONFIG_A_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3C3FFFFF3FFF; \
          (tmp) |= (((UInt64)(val)) << 14); \
        } while (0)

/* pull up, pull down, buskeeper configuration */
#define GP_WB_READ_IOB_GPIO_8_CFG() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x70a)) & 0x03)

#define GP_WB_GET_IOB_GPIO_8_CFG_FROM_GPIO_PIN_CONFIG_A_0(tmp) \
        (((tmp) >> 16) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_8_CFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x70a), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_8_CFG_TO_GPIO_PIN_CONFIG_A_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3C3FFFFCFFFF; \
          (tmp) |= (((UInt64)(val)) << 16); \
        } while (0)

/* pull up, pull down, buskeeper configuration */
#define GP_WB_READ_IOB_GPIO_9_CFG() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x70a)) >> 2) & 0x03)

#define GP_WB_GET_IOB_GPIO_9_CFG_FROM_GPIO_PIN_CONFIG_A_0(tmp) \
        (((tmp) >> 18) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_9_CFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x70a), 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_9_CFG_TO_GPIO_PIN_CONFIG_A_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3C3FFFF3FFFF; \
          (tmp) |= (((UInt64)(val)) << 18); \
        } while (0)

/* pull up, pull down, buskeeper configuration */
#define GP_WB_READ_IOB_GPIO_10_CFG() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x70a)) >> 4) & 0x03)

#define GP_WB_GET_IOB_GPIO_10_CFG_FROM_GPIO_PIN_CONFIG_A_0(tmp) \
        (((tmp) >> 20) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_10_CFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x70a), 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_10_CFG_TO_GPIO_PIN_CONFIG_A_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3C3FFFCFFFFF; \
          (tmp) |= (((UInt64)(val)) << 20); \
        } while (0)

/* pull up, pull down, buskeeper configuration */
#define GP_WB_READ_IOB_GPIO_11_CFG() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x70a)) >> 6) & 0x03)

#define GP_WB_GET_IOB_GPIO_11_CFG_FROM_GPIO_PIN_CONFIG_A_0(tmp) \
        (((tmp) >> 22) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_11_CFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x70a), 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_11_CFG_TO_GPIO_PIN_CONFIG_A_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3C3FFF3FFFFF; \
          (tmp) |= (((UInt64)(val)) << 22); \
        } while (0)

/* pull up, pull down, buskeeper configuration */
#define GP_WB_READ_IOB_GPIO_12_CFG() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x70b)) & 0x03)

#define GP_WB_GET_IOB_GPIO_12_CFG_FROM_GPIO_PIN_CONFIG_A_0(tmp) \
        (((tmp) >> 24) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_12_CFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x70b), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_12_CFG_TO_GPIO_PIN_CONFIG_A_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3C3FFCFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 24); \
        } while (0)

/* pull up, pull down, buskeeper configuration */
#define GP_WB_READ_IOB_GPIO_13_CFG() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x70b)) >> 2) & 0x03)

#define GP_WB_GET_IOB_GPIO_13_CFG_FROM_GPIO_PIN_CONFIG_A_0(tmp) \
        (((tmp) >> 26) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_13_CFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x70b), 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_13_CFG_TO_GPIO_PIN_CONFIG_A_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3C3FF3FFFFFF; \
          (tmp) |= (((UInt64)(val)) << 26); \
        } while (0)

/* pull up, pull down, buskeeper configuration */
#define GP_WB_READ_IOB_GPIO_14_CFG() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x70b)) >> 4) & 0x03)

#define GP_WB_GET_IOB_GPIO_14_CFG_FROM_GPIO_PIN_CONFIG_A_0(tmp) \
        (((tmp) >> 28) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_14_CFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x70b), 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_14_CFG_TO_GPIO_PIN_CONFIG_A_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3C3FCFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 28); \
        } while (0)

/* pull up, pull down, buskeeper configuration */
#define GP_WB_READ_IOB_GPIO_15_CFG() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x70b)) >> 6) & 0x03)

#define GP_WB_GET_IOB_GPIO_15_CFG_FROM_GPIO_PIN_CONFIG_A_0(tmp) \
        (((tmp) >> 30) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_15_CFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x70b), 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_15_CFG_TO_GPIO_PIN_CONFIG_A_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3C3F3FFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 30); \
        } while (0)

/* pull up, pull down, buskeeper configuration */
#define GP_WB_READ_IOB_GPIO_16_CFG() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x70c)) & 0x03)

#define GP_WB_GET_IOB_GPIO_16_CFG_FROM_GPIO_PIN_CONFIG_A_0(tmp) \
        (((tmp) >> 32) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_16_CFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x70c), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_16_CFG_TO_GPIO_PIN_CONFIG_A_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3C3CFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 32); \
        } while (0)

/* pull up, pull down, buskeeper configuration */
#define GP_WB_READ_IOB_GPIO_17_CFG() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x70c)) >> 2) & 0x03)

#define GP_WB_GET_IOB_GPIO_17_CFG_FROM_GPIO_PIN_CONFIG_A_0(tmp) \
        (((tmp) >> 34) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_17_CFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x70c), 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_17_CFG_TO_GPIO_PIN_CONFIG_A_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3C33FFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 34); \
        } while (0)

/* pull up, pull down, buskeeper configuration */
#define GP_WB_READ_IOB_GPIO_18_CFG() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x70c)) >> 4) & 0x03)

#define GP_WB_GET_IOB_GPIO_18_CFG_FROM_GPIO_PIN_CONFIG_A_0(tmp) \
        (((tmp) >> 36) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_18_CFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x70c), 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_18_CFG_TO_GPIO_PIN_CONFIG_A_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3C0FFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 36); \
        } while (0)

/* pull up, pull down, buskeeper configuration */
#define GP_WB_READ_IOB_GPIO_21_CFG() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x70d)) >> 2) & 0x03)

#define GP_WB_GET_IOB_GPIO_21_CFG_FROM_GPIO_PIN_CONFIG_A_0(tmp) \
        (((tmp) >> 42) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_21_CFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x70d), 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_21_CFG_TO_GPIO_PIN_CONFIG_A_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x303FFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 42); \
        } while (0)

/* pull up, pull down, buskeeper configuration */
#define GP_WB_READ_IOB_GPIO_22_CFG() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x70d)) >> 4) & 0x03)

#define GP_WB_GET_IOB_GPIO_22_CFG_FROM_GPIO_PIN_CONFIG_A_0(tmp) \
        (((tmp) >> 44) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_22_CFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x70d), 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_22_CFG_TO_GPIO_PIN_CONFIG_A_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x0C3FFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 44); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_GPIO_PIN_CONFIG_B() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x710))

#define GP_WB_WRITE_IOB_GPIO_PIN_CONFIG_B(val) \
      GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x710), (val))

/* drive strength 00 = 4.5mA, 01 = 9mA, 10 = 13.5mA, 11 = 18mA */
#define GP_WB_READ_IOB_GPIO_0_3_DRIVE_STRENGTH() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x710)) & 0x03)

#define GP_WB_GET_IOB_GPIO_0_3_DRIVE_STRENGTH_FROM_GPIO_PIN_CONFIG_B(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_0_3_DRIVE_STRENGTH(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x710), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_0_3_DRIVE_STRENGTH_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x03FFFC; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Schmitt trigger enable */
#define GP_WB_READ_IOB_GPIO_0_3_SCHMITT_TRIGGER() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x710), 2)

#define GP_WB_GET_IOB_GPIO_0_3_SCHMITT_TRIGGER_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_0_3_SCHMITT_TRIGGER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x710), 2, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_0_3_SCHMITT_TRIGGER_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFFB; \
          (tmp) |= (((UInt32)(val)) << 2); \
        } while (0)

/* drive strength 00 = 4.5mA, 01 = 9mA, 10 = 13.5mA, 11 = 18mA */
#define GP_WB_READ_IOB_GPIO_4_7_DRIVE_STRENGTH() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x710)) >> 3) & 0x03)

#define GP_WB_GET_IOB_GPIO_4_7_DRIVE_STRENGTH_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 3) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_4_7_DRIVE_STRENGTH(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x710), 0x18, (val) << 3); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_4_7_DRIVE_STRENGTH_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x03FFE7; \
          (tmp) |= (((UInt32)(val)) << 3); \
        } while (0)

/* Schmitt trigger enable */
#define GP_WB_READ_IOB_GPIO_4_7_SCHMITT_TRIGGER() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x710), 5)

#define GP_WB_GET_IOB_GPIO_4_7_SCHMITT_TRIGGER_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_4_7_SCHMITT_TRIGGER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x710), 5, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_4_7_SCHMITT_TRIGGER_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFDF; \
          (tmp) |= (((UInt32)(val)) << 5); \
        } while (0)

/* drive strength 00 = 4.5mA, 01 = 9mA, 10 = 13.5mA, 11 = 18mA */
#define GP_WB_READ_IOB_GPIO_8_11_DRIVE_STRENGTH() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x710)) >> 6) & 0x03)

#define GP_WB_GET_IOB_GPIO_8_11_DRIVE_STRENGTH_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 6) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_8_11_DRIVE_STRENGTH(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x710), 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_8_11_DRIVE_STRENGTH_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x03FF3F; \
          (tmp) |= (((UInt32)(val)) << 6); \
        } while (0)

/* Schmitt trigger enable */
#define GP_WB_READ_IOB_GPIO_8_11_SCHMITT_TRIGGER() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x711), 0)

#define GP_WB_GET_IOB_GPIO_8_11_SCHMITT_TRIGGER_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_8_11_SCHMITT_TRIGGER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x711), 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_8_11_SCHMITT_TRIGGER_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FEFF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* drive strength 00 = 4.5mA, 01 = 9mA, 10 = 13.5mA, 11 = 18mA */
#define GP_WB_READ_IOB_GPIO_12_15_DRIVE_STRENGTH() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x711)) >> 1) & 0x03)

#define GP_WB_GET_IOB_GPIO_12_15_DRIVE_STRENGTH_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 9) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_12_15_DRIVE_STRENGTH(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x711), 0x06, (val) << 1); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_12_15_DRIVE_STRENGTH_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x03F9FF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* Schmitt trigger enable */
#define GP_WB_READ_IOB_GPIO_12_15_SCHMITT_TRIGGER() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x711), 3)

#define GP_WB_GET_IOB_GPIO_12_15_SCHMITT_TRIGGER_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_12_15_SCHMITT_TRIGGER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x711), 3, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_12_15_SCHMITT_TRIGGER_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03F7FF; \
          (tmp) |= (((UInt32)(val)) << 11); \
        } while (0)

/* drive strength 00 = 4.5mA, 01 = 9mA, 10 = 13.5mA, 11 = 18mA */
#define GP_WB_READ_IOB_GPIO_16_19_DRIVE_STRENGTH() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x711)) >> 4) & 0x03)

#define GP_WB_GET_IOB_GPIO_16_19_DRIVE_STRENGTH_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 12) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_16_19_DRIVE_STRENGTH(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x711), 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_16_19_DRIVE_STRENGTH_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x03CFFF; \
          (tmp) |= (((UInt32)(val)) << 12); \
        } while (0)

/* Schmitt trigger enable */
#define GP_WB_READ_IOB_GPIO_16_19_SCHMITT_TRIGGER() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x711), 6)

#define GP_WB_GET_IOB_GPIO_16_19_SCHMITT_TRIGGER_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_16_19_SCHMITT_TRIGGER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x711), 6, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_16_19_SCHMITT_TRIGGER_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03BFFF; \
          (tmp) |= (((UInt32)(val)) << 14); \
        } while (0)

/* Schmitt trigger enable */
#define GP_WB_READ_IOB_GPIO_20_23_SCHMITT_TRIGGER() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x711), 7)

#define GP_WB_GET_IOB_GPIO_20_23_SCHMITT_TRIGGER_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_20_23_SCHMITT_TRIGGER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x711), 7, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_20_23_SCHMITT_TRIGGER_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x037FFF; \
          (tmp) |= (((UInt32)(val)) << 15); \
        } while (0)

/* drive strength 00 = 4.5mA, 01 = 9mA, 10 = 13.5mA, 11 = 18mA */
#define GP_WB_READ_IOB_GPIO_20_23_DRIVE_STRENGTH() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x712))

#define GP_WB_GET_IOB_GPIO_20_23_DRIVE_STRENGTH_FROM_GPIO_PIN_CONFIG_B(tmp) \
        (((tmp) >> 16) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_20_23_DRIVE_STRENGTH(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x712), (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_20_23_DRIVE_STRENGTH_TO_GPIO_PIN_CONFIG_B(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x00FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_GPIO_PIN_CONFIG_C() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x714))

#define GP_WB_WRITE_IOB_GPIO_PIN_CONFIG_C(val) \
      GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x714), (val))

/* Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_0_PULSECFG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x714), 0)

#define GP_WB_GET_IOB_GPIO_0_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_0_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x714), 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_0_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FFFFE; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Enables a strong driver in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the strong driver is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_1_PULSECFG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x714), 1)

#define GP_WB_GET_IOB_GPIO_1_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_1_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x714), 1, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_1_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FFFFD; \
          (tmp) |= (((UInt32)(val)) << 1); \
        } while (0)

/* Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_2_PULSECFG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x714), 2)

#define GP_WB_GET_IOB_GPIO_2_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_2_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x714), 2, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_2_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FFFFB; \
          (tmp) |= (((UInt32)(val)) << 2); \
        } while (0)

/* Enables a strong driver in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the strong driver is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_3_PULSECFG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x714), 3)

#define GP_WB_GET_IOB_GPIO_3_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_3_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x714), 3, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_3_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FFFF7; \
          (tmp) |= (((UInt32)(val)) << 3); \
        } while (0)

/* Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_4_PULSECFG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x714), 4)

#define GP_WB_GET_IOB_GPIO_4_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_4_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x714), 4, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_4_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FFFEF; \
          (tmp) |= (((UInt32)(val)) << 4); \
        } while (0)

/* Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_5_PULSECFG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x714), 5)

#define GP_WB_GET_IOB_GPIO_5_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_5_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x714), 5, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_5_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FFFDF; \
          (tmp) |= (((UInt32)(val)) << 5); \
        } while (0)

/* Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_6_PULSECFG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x714), 6)

#define GP_WB_GET_IOB_GPIO_6_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_6_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x714), 6, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_6_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FFFBF; \
          (tmp) |= (((UInt32)(val)) << 6); \
        } while (0)

/* Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_7_PULSECFG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x714), 7)

#define GP_WB_GET_IOB_GPIO_7_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_7_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x714), 7, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_7_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FFF7F; \
          (tmp) |= (((UInt32)(val)) << 7); \
        } while (0)

/* Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_8_PULSECFG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x715), 0)

#define GP_WB_GET_IOB_GPIO_8_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_8_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x715), 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_8_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FFEFF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_9_PULSECFG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x715), 1)

#define GP_WB_GET_IOB_GPIO_9_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_9_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x715), 1, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_9_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FFDFF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_10_PULSECFG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x715), 2)

#define GP_WB_GET_IOB_GPIO_10_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_10_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x715), 2, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_10_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FFBFF; \
          (tmp) |= (((UInt32)(val)) << 10); \
        } while (0)

/* Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_11_PULSECFG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x715), 3)

#define GP_WB_GET_IOB_GPIO_11_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_11_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x715), 3, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_11_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FF7FF; \
          (tmp) |= (((UInt32)(val)) << 11); \
        } while (0)

/* Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_12_PULSECFG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x715), 4)

#define GP_WB_GET_IOB_GPIO_12_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_12_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x715), 4, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_12_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FEFFF; \
          (tmp) |= (((UInt32)(val)) << 12); \
        } while (0)

/* Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_13_PULSECFG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x715), 5)

#define GP_WB_GET_IOB_GPIO_13_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_13_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x715), 5, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_13_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FDFFF; \
          (tmp) |= (((UInt32)(val)) << 13); \
        } while (0)

/* Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_14_PULSECFG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x715), 6)

#define GP_WB_GET_IOB_GPIO_14_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_14_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x715), 6, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_14_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FBFFF; \
          (tmp) |= (((UInt32)(val)) << 14); \
        } while (0)

/* Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_15_PULSECFG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x715), 7)

#define GP_WB_GET_IOB_GPIO_15_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_15_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x715), 7, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_15_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F7FFF; \
          (tmp) |= (((UInt32)(val)) << 15); \
        } while (0)

/* Enables a strong driver in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the strong driver is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_16_PULSECFG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x716), 0)

#define GP_WB_GET_IOB_GPIO_16_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_16_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x716), 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_16_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1EFFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_17_PULSECFG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x716), 1)

#define GP_WB_GET_IOB_GPIO_17_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        (((tmp) >> 17) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_17_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x716), 1, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_17_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1DFFFF; \
          (tmp) |= (((UInt32)(val)) << 17); \
        } while (0)

/* Enables a strong driver in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the strong driver is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_18_PULSECFG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x716), 2)

#define GP_WB_GET_IOB_GPIO_18_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        (((tmp) >> 18) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_18_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x716), 2, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_18_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1BFFFF; \
          (tmp) |= (((UInt32)(val)) << 18); \
        } while (0)

/* Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_21_PULSECFG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x716), 3)

#define GP_WB_GET_IOB_GPIO_21_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        (((tmp) >> 19) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_21_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x716), 3, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_21_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x17FFFF; \
          (tmp) |= (((UInt32)(val)) << 19); \
        } while (0)

/* Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period) */
#define GP_WB_READ_IOB_GPIO_22_PULSECFG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x716), 4)

#define GP_WB_GET_IOB_GPIO_22_PULSECFG_FROM_GPIO_PIN_CONFIG_C(tmp) \
        (((tmp) >> 20) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_22_PULSECFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x716), 4, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_22_PULSECFG_TO_GPIO_PIN_CONFIG_C(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFFF; \
          (tmp) |= (((UInt32)(val)) << 20); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_GPIO_0_ALTERNATE_CFG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x717))

#define GP_WB_WRITE_IOB_GPIO_0_ALTERNATE_CFG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x717), (val))

#define GP_WB_READ_IOB_GPIO_0_ALTERNATE_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x717), 0)

#define GP_WB_GET_IOB_GPIO_0_ALTERNATE_ENABLE_FROM_GPIO_0_ALTERNATE_CFG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_0_ALTERNATE_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x717), 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_0_ALTERNATE_ENABLE_TO_GPIO_0_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_IOB_GPIO_0_ALTERNATE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x717)) >> 1) & 0x1F)

#define GP_WB_GET_IOB_GPIO_0_ALTERNATE_FROM_GPIO_0_ALTERNATE_CFG(tmp) \
        (((tmp) >> 1) & 0x1F)

#define GP_WB_WRITE_IOB_GPIO_0_ALTERNATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x717), 0x3E, (val) << 1); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_0_ALTERNATE_TO_GPIO_0_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_GPIO_1_ALTERNATE_CFG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x718))

#define GP_WB_WRITE_IOB_GPIO_1_ALTERNATE_CFG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x718), (val))

#define GP_WB_READ_IOB_GPIO_1_ALTERNATE_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x718), 0)

#define GP_WB_GET_IOB_GPIO_1_ALTERNATE_ENABLE_FROM_GPIO_1_ALTERNATE_CFG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_1_ALTERNATE_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x718), 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_1_ALTERNATE_ENABLE_TO_GPIO_1_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_IOB_GPIO_1_ALTERNATE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x718)) >> 1) & 0x1F)

#define GP_WB_GET_IOB_GPIO_1_ALTERNATE_FROM_GPIO_1_ALTERNATE_CFG(tmp) \
        (((tmp) >> 1) & 0x1F)

#define GP_WB_WRITE_IOB_GPIO_1_ALTERNATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x718), 0x3E, (val) << 1); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_1_ALTERNATE_TO_GPIO_1_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_GPIO_2_ALTERNATE_CFG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x719))

#define GP_WB_WRITE_IOB_GPIO_2_ALTERNATE_CFG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x719), (val))

#define GP_WB_READ_IOB_GPIO_2_ALTERNATE_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x719), 0)

#define GP_WB_GET_IOB_GPIO_2_ALTERNATE_ENABLE_FROM_GPIO_2_ALTERNATE_CFG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_2_ALTERNATE_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x719), 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_2_ALTERNATE_ENABLE_TO_GPIO_2_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_IOB_GPIO_2_ALTERNATE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x719)) >> 1) & 0x1F)

#define GP_WB_GET_IOB_GPIO_2_ALTERNATE_FROM_GPIO_2_ALTERNATE_CFG(tmp) \
        (((tmp) >> 1) & 0x1F)

#define GP_WB_WRITE_IOB_GPIO_2_ALTERNATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x719), 0x3E, (val) << 1); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_2_ALTERNATE_TO_GPIO_2_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_GPIO_3_ALTERNATE_CFG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71a))

#define GP_WB_WRITE_IOB_GPIO_3_ALTERNATE_CFG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71a), (val))

#define GP_WB_READ_IOB_GPIO_3_ALTERNATE_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71a), 0)

#define GP_WB_GET_IOB_GPIO_3_ALTERNATE_ENABLE_FROM_GPIO_3_ALTERNATE_CFG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_3_ALTERNATE_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71a), 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_3_ALTERNATE_ENABLE_TO_GPIO_3_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_IOB_GPIO_3_ALTERNATE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71a)) >> 1) & 0x1F)

#define GP_WB_GET_IOB_GPIO_3_ALTERNATE_FROM_GPIO_3_ALTERNATE_CFG(tmp) \
        (((tmp) >> 1) & 0x1F)

#define GP_WB_WRITE_IOB_GPIO_3_ALTERNATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71a), 0x3E, (val) << 1); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_3_ALTERNATE_TO_GPIO_3_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_GPIO_4_ALTERNATE_CFG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71b))

#define GP_WB_WRITE_IOB_GPIO_4_ALTERNATE_CFG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71b), (val))

#define GP_WB_READ_IOB_GPIO_4_ALTERNATE_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71b), 0)

#define GP_WB_GET_IOB_GPIO_4_ALTERNATE_ENABLE_FROM_GPIO_4_ALTERNATE_CFG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_4_ALTERNATE_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71b), 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_4_ALTERNATE_ENABLE_TO_GPIO_4_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_IOB_GPIO_4_ALTERNATE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71b)) >> 1) & 0x0F)

#define GP_WB_GET_IOB_GPIO_4_ALTERNATE_FROM_GPIO_4_ALTERNATE_CFG(tmp) \
        (((tmp) >> 1) & 0x0F)

#define GP_WB_WRITE_IOB_GPIO_4_ALTERNATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71b), 0x1E, (val) << 1); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_4_ALTERNATE_TO_GPIO_4_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_GPIO_5_ALTERNATE_CFG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71c))

#define GP_WB_WRITE_IOB_GPIO_5_ALTERNATE_CFG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71c), (val))

#define GP_WB_READ_IOB_GPIO_5_ALTERNATE_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71c), 0)

#define GP_WB_GET_IOB_GPIO_5_ALTERNATE_ENABLE_FROM_GPIO_5_ALTERNATE_CFG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_5_ALTERNATE_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71c), 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_5_ALTERNATE_ENABLE_TO_GPIO_5_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_IOB_GPIO_5_ALTERNATE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71c)) >> 1) & 0x0F)

#define GP_WB_GET_IOB_GPIO_5_ALTERNATE_FROM_GPIO_5_ALTERNATE_CFG(tmp) \
        (((tmp) >> 1) & 0x0F)

#define GP_WB_WRITE_IOB_GPIO_5_ALTERNATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71c), 0x1E, (val) << 1); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_5_ALTERNATE_TO_GPIO_5_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_GPIO_6_ALTERNATE_CFG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71d))

#define GP_WB_WRITE_IOB_GPIO_6_ALTERNATE_CFG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71d), (val))

#define GP_WB_READ_IOB_GPIO_6_ALTERNATE_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71d), 0)

#define GP_WB_GET_IOB_GPIO_6_ALTERNATE_ENABLE_FROM_GPIO_6_ALTERNATE_CFG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_6_ALTERNATE_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71d), 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_6_ALTERNATE_ENABLE_TO_GPIO_6_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_IOB_GPIO_6_ALTERNATE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71d)) >> 1) & 0x0F)

#define GP_WB_GET_IOB_GPIO_6_ALTERNATE_FROM_GPIO_6_ALTERNATE_CFG(tmp) \
        (((tmp) >> 1) & 0x0F)

#define GP_WB_WRITE_IOB_GPIO_6_ALTERNATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71d), 0x1E, (val) << 1); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_6_ALTERNATE_TO_GPIO_6_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_GPIO_7_ALTERNATE_CFG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71e))

#define GP_WB_WRITE_IOB_GPIO_7_ALTERNATE_CFG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71e), (val))

#define GP_WB_READ_IOB_GPIO_7_ALTERNATE_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71e), 0)

#define GP_WB_GET_IOB_GPIO_7_ALTERNATE_ENABLE_FROM_GPIO_7_ALTERNATE_CFG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_7_ALTERNATE_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71e), 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_7_ALTERNATE_ENABLE_TO_GPIO_7_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_IOB_GPIO_7_ALTERNATE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71e)) >> 1) & 0x0F)

#define GP_WB_GET_IOB_GPIO_7_ALTERNATE_FROM_GPIO_7_ALTERNATE_CFG(tmp) \
        (((tmp) >> 1) & 0x0F)

#define GP_WB_WRITE_IOB_GPIO_7_ALTERNATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71e), 0x1E, (val) << 1); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_7_ALTERNATE_TO_GPIO_7_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_GPIO_8_ALTERNATE_CFG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71f))

#define GP_WB_WRITE_IOB_GPIO_8_ALTERNATE_CFG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71f), (val))

#define GP_WB_READ_IOB_GPIO_8_ALTERNATE_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71f), 0)

#define GP_WB_GET_IOB_GPIO_8_ALTERNATE_ENABLE_FROM_GPIO_8_ALTERNATE_CFG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_8_ALTERNATE_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71f), 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_8_ALTERNATE_ENABLE_TO_GPIO_8_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_IOB_GPIO_8_ALTERNATE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71f)) >> 1) & 0x0F)

#define GP_WB_GET_IOB_GPIO_8_ALTERNATE_FROM_GPIO_8_ALTERNATE_CFG(tmp) \
        (((tmp) >> 1) & 0x0F)

#define GP_WB_WRITE_IOB_GPIO_8_ALTERNATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x71f), 0x1E, (val) << 1); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_8_ALTERNATE_TO_GPIO_8_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_GPIO_9_ALTERNATE_CFG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x720))

#define GP_WB_WRITE_IOB_GPIO_9_ALTERNATE_CFG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x720), (val))

#define GP_WB_READ_IOB_GPIO_9_ALTERNATE_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x720), 0)

#define GP_WB_GET_IOB_GPIO_9_ALTERNATE_ENABLE_FROM_GPIO_9_ALTERNATE_CFG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_9_ALTERNATE_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x720), 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_9_ALTERNATE_ENABLE_TO_GPIO_9_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_IOB_GPIO_9_ALTERNATE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x720)) >> 1) & 0x0F)

#define GP_WB_GET_IOB_GPIO_9_ALTERNATE_FROM_GPIO_9_ALTERNATE_CFG(tmp) \
        (((tmp) >> 1) & 0x0F)

#define GP_WB_WRITE_IOB_GPIO_9_ALTERNATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x720), 0x1E, (val) << 1); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_9_ALTERNATE_TO_GPIO_9_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_GPIO_10_ALTERNATE_CFG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x721))

#define GP_WB_WRITE_IOB_GPIO_10_ALTERNATE_CFG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x721), (val))

#define GP_WB_READ_IOB_GPIO_10_ALTERNATE_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x721), 0)

#define GP_WB_GET_IOB_GPIO_10_ALTERNATE_ENABLE_FROM_GPIO_10_ALTERNATE_CFG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_10_ALTERNATE_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x721), 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_10_ALTERNATE_ENABLE_TO_GPIO_10_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_IOB_GPIO_10_ALTERNATE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x721)) >> 1) & 0x1F)

#define GP_WB_GET_IOB_GPIO_10_ALTERNATE_FROM_GPIO_10_ALTERNATE_CFG(tmp) \
        (((tmp) >> 1) & 0x1F)

#define GP_WB_WRITE_IOB_GPIO_10_ALTERNATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x721), 0x3E, (val) << 1); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_10_ALTERNATE_TO_GPIO_10_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_GPIO_11_ALTERNATE_CFG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x722))

#define GP_WB_WRITE_IOB_GPIO_11_ALTERNATE_CFG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x722), (val))

#define GP_WB_READ_IOB_GPIO_11_ALTERNATE_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x722), 0)

#define GP_WB_GET_IOB_GPIO_11_ALTERNATE_ENABLE_FROM_GPIO_11_ALTERNATE_CFG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_11_ALTERNATE_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x722), 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_11_ALTERNATE_ENABLE_TO_GPIO_11_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_IOB_GPIO_11_ALTERNATE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x722)) >> 1) & 0x1F)

#define GP_WB_GET_IOB_GPIO_11_ALTERNATE_FROM_GPIO_11_ALTERNATE_CFG(tmp) \
        (((tmp) >> 1) & 0x1F)

#define GP_WB_WRITE_IOB_GPIO_11_ALTERNATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x722), 0x3E, (val) << 1); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_11_ALTERNATE_TO_GPIO_11_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_GPIO_12_ALTERNATE_CFG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x723))

#define GP_WB_WRITE_IOB_GPIO_12_ALTERNATE_CFG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x723), (val))

#define GP_WB_READ_IOB_GPIO_12_ALTERNATE_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x723), 0)

#define GP_WB_GET_IOB_GPIO_12_ALTERNATE_ENABLE_FROM_GPIO_12_ALTERNATE_CFG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_12_ALTERNATE_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x723), 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_12_ALTERNATE_ENABLE_TO_GPIO_12_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_IOB_GPIO_12_ALTERNATE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x723)) >> 1) & 0x1F)

#define GP_WB_GET_IOB_GPIO_12_ALTERNATE_FROM_GPIO_12_ALTERNATE_CFG(tmp) \
        (((tmp) >> 1) & 0x1F)

#define GP_WB_WRITE_IOB_GPIO_12_ALTERNATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x723), 0x3E, (val) << 1); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_12_ALTERNATE_TO_GPIO_12_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_GPIO_13_ALTERNATE_CFG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x724))

#define GP_WB_WRITE_IOB_GPIO_13_ALTERNATE_CFG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x724), (val))

#define GP_WB_READ_IOB_GPIO_13_ALTERNATE_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x724), 0)

#define GP_WB_GET_IOB_GPIO_13_ALTERNATE_ENABLE_FROM_GPIO_13_ALTERNATE_CFG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_13_ALTERNATE_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x724), 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_13_ALTERNATE_ENABLE_TO_GPIO_13_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_IOB_GPIO_13_ALTERNATE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x724)) >> 1) & 0x1F)

#define GP_WB_GET_IOB_GPIO_13_ALTERNATE_FROM_GPIO_13_ALTERNATE_CFG(tmp) \
        (((tmp) >> 1) & 0x1F)

#define GP_WB_WRITE_IOB_GPIO_13_ALTERNATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x724), 0x3E, (val) << 1); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_13_ALTERNATE_TO_GPIO_13_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_GPIO_14_ALTERNATE_CFG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x725))

#define GP_WB_WRITE_IOB_GPIO_14_ALTERNATE_CFG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x725), (val))

#define GP_WB_READ_IOB_GPIO_14_ALTERNATE_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x725), 0)

#define GP_WB_GET_IOB_GPIO_14_ALTERNATE_ENABLE_FROM_GPIO_14_ALTERNATE_CFG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_14_ALTERNATE_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x725), 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_14_ALTERNATE_ENABLE_TO_GPIO_14_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_IOB_GPIO_14_ALTERNATE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x725)) >> 1) & 0x1F)

#define GP_WB_GET_IOB_GPIO_14_ALTERNATE_FROM_GPIO_14_ALTERNATE_CFG(tmp) \
        (((tmp) >> 1) & 0x1F)

#define GP_WB_WRITE_IOB_GPIO_14_ALTERNATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x725), 0x3E, (val) << 1); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_14_ALTERNATE_TO_GPIO_14_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_GPIO_15_ALTERNATE_CFG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x726))

#define GP_WB_WRITE_IOB_GPIO_15_ALTERNATE_CFG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x726), (val))

#define GP_WB_READ_IOB_GPIO_15_ALTERNATE_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x726), 0)

#define GP_WB_GET_IOB_GPIO_15_ALTERNATE_ENABLE_FROM_GPIO_15_ALTERNATE_CFG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_15_ALTERNATE_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x726), 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_15_ALTERNATE_ENABLE_TO_GPIO_15_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_IOB_GPIO_15_ALTERNATE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x726)) >> 1) & 0x1F)

#define GP_WB_GET_IOB_GPIO_15_ALTERNATE_FROM_GPIO_15_ALTERNATE_CFG(tmp) \
        (((tmp) >> 1) & 0x1F)

#define GP_WB_WRITE_IOB_GPIO_15_ALTERNATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x726), 0x3E, (val) << 1); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_15_ALTERNATE_TO_GPIO_15_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_GPIO_16_ALTERNATE_CFG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x727))

#define GP_WB_WRITE_IOB_GPIO_16_ALTERNATE_CFG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x727), (val))

#define GP_WB_READ_IOB_GPIO_16_ALTERNATE_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x727), 0)

#define GP_WB_GET_IOB_GPIO_16_ALTERNATE_ENABLE_FROM_GPIO_16_ALTERNATE_CFG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_16_ALTERNATE_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x727), 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_16_ALTERNATE_ENABLE_TO_GPIO_16_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_IOB_GPIO_16_ALTERNATE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x727)) >> 1) & 0x1F)

#define GP_WB_GET_IOB_GPIO_16_ALTERNATE_FROM_GPIO_16_ALTERNATE_CFG(tmp) \
        (((tmp) >> 1) & 0x1F)

#define GP_WB_WRITE_IOB_GPIO_16_ALTERNATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x727), 0x3E, (val) << 1); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_16_ALTERNATE_TO_GPIO_16_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_GPIO_17_ALTERNATE_CFG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x728))

#define GP_WB_WRITE_IOB_GPIO_17_ALTERNATE_CFG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x728), (val))

#define GP_WB_READ_IOB_GPIO_17_ALTERNATE_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x728), 0)

#define GP_WB_GET_IOB_GPIO_17_ALTERNATE_ENABLE_FROM_GPIO_17_ALTERNATE_CFG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_17_ALTERNATE_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x728), 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_17_ALTERNATE_ENABLE_TO_GPIO_17_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_IOB_GPIO_17_ALTERNATE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x728)) >> 1) & 0x1F)

#define GP_WB_GET_IOB_GPIO_17_ALTERNATE_FROM_GPIO_17_ALTERNATE_CFG(tmp) \
        (((tmp) >> 1) & 0x1F)

#define GP_WB_WRITE_IOB_GPIO_17_ALTERNATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x728), 0x3E, (val) << 1); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_17_ALTERNATE_TO_GPIO_17_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_GPIO_18_ALTERNATE_CFG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x729))

#define GP_WB_WRITE_IOB_GPIO_18_ALTERNATE_CFG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x729), (val))

#define GP_WB_READ_IOB_GPIO_18_ALTERNATE_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x729), 0)

#define GP_WB_GET_IOB_GPIO_18_ALTERNATE_ENABLE_FROM_GPIO_18_ALTERNATE_CFG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_18_ALTERNATE_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x729), 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_18_ALTERNATE_ENABLE_TO_GPIO_18_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_IOB_GPIO_18_ALTERNATE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x729)) >> 1) & 0x1F)

#define GP_WB_GET_IOB_GPIO_18_ALTERNATE_FROM_GPIO_18_ALTERNATE_CFG(tmp) \
        (((tmp) >> 1) & 0x1F)

#define GP_WB_WRITE_IOB_GPIO_18_ALTERNATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x729), 0x3E, (val) << 1); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_18_ALTERNATE_TO_GPIO_18_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_GPIO_19_ALTERNATE_CFG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72a))

#define GP_WB_WRITE_IOB_GPIO_19_ALTERNATE_CFG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72a), (val))

#define GP_WB_READ_IOB_GPIO_19_ALTERNATE_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72a), 0)

#define GP_WB_GET_IOB_GPIO_19_ALTERNATE_ENABLE_FROM_GPIO_19_ALTERNATE_CFG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_19_ALTERNATE_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72a), 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_19_ALTERNATE_ENABLE_TO_GPIO_19_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_IOB_GPIO_19_ALTERNATE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72a)) >> 1) & 0x07)

#define GP_WB_GET_IOB_GPIO_19_ALTERNATE_FROM_GPIO_19_ALTERNATE_CFG(tmp) \
        (((tmp) >> 1) & 0x07)

#define GP_WB_WRITE_IOB_GPIO_19_ALTERNATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72a), 0x0E, (val) << 1); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_19_ALTERNATE_TO_GPIO_19_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_GPIO_20_ALTERNATE_CFG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72b))

#define GP_WB_WRITE_IOB_GPIO_20_ALTERNATE_CFG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72b), (val))

#define GP_WB_READ_IOB_GPIO_20_ALTERNATE_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72b), 0)

#define GP_WB_GET_IOB_GPIO_20_ALTERNATE_ENABLE_FROM_GPIO_20_ALTERNATE_CFG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_20_ALTERNATE_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72b), 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_20_ALTERNATE_ENABLE_TO_GPIO_20_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_IOB_GPIO_20_ALTERNATE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72b)) >> 1) & 0x03)

#define GP_WB_GET_IOB_GPIO_20_ALTERNATE_FROM_GPIO_20_ALTERNATE_CFG(tmp) \
        (((tmp) >> 1) & 0x03)

#define GP_WB_WRITE_IOB_GPIO_20_ALTERNATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72b), 0x06, (val) << 1); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_20_ALTERNATE_TO_GPIO_20_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_GPIO_21_ALTERNATE_CFG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72c))

#define GP_WB_WRITE_IOB_GPIO_21_ALTERNATE_CFG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72c), (val))

#define GP_WB_READ_IOB_GPIO_21_ALTERNATE_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72c), 0)

#define GP_WB_GET_IOB_GPIO_21_ALTERNATE_ENABLE_FROM_GPIO_21_ALTERNATE_CFG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_21_ALTERNATE_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72c), 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_21_ALTERNATE_ENABLE_TO_GPIO_21_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_IOB_GPIO_21_ALTERNATE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72c)) >> 1) & 0x0F)

#define GP_WB_GET_IOB_GPIO_21_ALTERNATE_FROM_GPIO_21_ALTERNATE_CFG(tmp) \
        (((tmp) >> 1) & 0x0F)

#define GP_WB_WRITE_IOB_GPIO_21_ALTERNATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72c), 0x1E, (val) << 1); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_21_ALTERNATE_TO_GPIO_21_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_GPIO_22_ALTERNATE_CFG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72d))

#define GP_WB_WRITE_IOB_GPIO_22_ALTERNATE_CFG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72d), (val))

#define GP_WB_READ_IOB_GPIO_22_ALTERNATE_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72d), 0)

#define GP_WB_GET_IOB_GPIO_22_ALTERNATE_ENABLE_FROM_GPIO_22_ALTERNATE_CFG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_22_ALTERNATE_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72d), 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_22_ALTERNATE_ENABLE_TO_GPIO_22_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_IOB_GPIO_22_ALTERNATE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72d)) >> 1) & 0x0F)

#define GP_WB_GET_IOB_GPIO_22_ALTERNATE_FROM_GPIO_22_ALTERNATE_CFG(tmp) \
        (((tmp) >> 1) & 0x0F)

#define GP_WB_WRITE_IOB_GPIO_22_ALTERNATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72d), 0x1E, (val) << 1); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_22_ALTERNATE_TO_GPIO_22_ALTERNATE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_GPIO_INPUT_BUFFER_ENABLE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72e))

#define GP_WB_WRITE_IOB_GPIO_INPUT_BUFFER_ENABLE(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72e), (val))

/* enables/disables the input buffer on gpio 17. Disabling the buffer supplies isolation for when the pad is used for something else. */
#define GP_WB_READ_IOB_GPIO_17_INPUT_BUFFER_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72e), 0)

#define GP_WB_GET_IOB_GPIO_17_INPUT_BUFFER_ENABLE_FROM_GPIO_INPUT_BUFFER_ENABLE(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_17_INPUT_BUFFER_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72e), 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_17_INPUT_BUFFER_ENABLE_TO_GPIO_INPUT_BUFFER_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* enables/disables the input buffer on gpio 18. Disabling the buffer supplies isolation for when the pad is used for something else. */
#define GP_WB_READ_IOB_GPIO_18_INPUT_BUFFER_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72e), 1)

#define GP_WB_GET_IOB_GPIO_18_INPUT_BUFFER_ENABLE_FROM_GPIO_INPUT_BUFFER_ENABLE(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_18_INPUT_BUFFER_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72e), 1, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_18_INPUT_BUFFER_ENABLE_TO_GPIO_INPUT_BUFFER_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* enables/disables the input buffer on gpio 19. Disabling the buffer supplies isolation for when the pad is used for something else. */
#define GP_WB_READ_IOB_GPIO_19_INPUT_BUFFER_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72e), 2)

#define GP_WB_GET_IOB_GPIO_19_INPUT_BUFFER_ENABLE_FROM_GPIO_INPUT_BUFFER_ENABLE(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_19_INPUT_BUFFER_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72e), 2, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_19_INPUT_BUFFER_ENABLE_TO_GPIO_INPUT_BUFFER_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* enables/disables the input buffer on gpio 20. Disabling the buffer supplies isolation for when the pad is used for something else. */
#define GP_WB_READ_IOB_GPIO_20_INPUT_BUFFER_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72e), 3)

#define GP_WB_GET_IOB_GPIO_20_INPUT_BUFFER_ENABLE_FROM_GPIO_INPUT_BUFFER_ENABLE(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_20_INPUT_BUFFER_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72e), 3, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_20_INPUT_BUFFER_ENABLE_TO_GPIO_INPUT_BUFFER_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* enables/disables the input buffer on gpio 21. Disabling the buffer supplies isolation for when the pad is used for something else. */
#define GP_WB_READ_IOB_GPIO_21_INPUT_BUFFER_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72e), 4)

#define GP_WB_GET_IOB_GPIO_21_INPUT_BUFFER_ENABLE_FROM_GPIO_INPUT_BUFFER_ENABLE(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_21_INPUT_BUFFER_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72e), 4, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_21_INPUT_BUFFER_ENABLE_TO_GPIO_INPUT_BUFFER_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* enables/disables the input buffer on gpio 22. Disabling the buffer supplies isolation for when the pad is used for something else. */
#define GP_WB_READ_IOB_GPIO_22_INPUT_BUFFER_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72e), 5)

#define GP_WB_GET_IOB_GPIO_22_INPUT_BUFFER_ENABLE_FROM_GPIO_INPUT_BUFFER_ENABLE(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_22_INPUT_BUFFER_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72e), 5, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_22_INPUT_BUFFER_ENABLE_TO_GPIO_INPUT_BUFFER_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_GPIO_MISC_CONFIG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72f))

#define GP_WB_WRITE_IOB_GPIO_MISC_CONFIG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72f), (val))

/* controls the iddq input of the gpios */
#define GP_WB_READ_IOB_GPIO_IDDQ() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72f), 0)

#define GP_WB_GET_IOB_GPIO_IDDQ_FROM_GPIO_MISC_CONFIG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IOB_GPIO_IDDQ(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x72f), 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_GPIO_IDDQ_TO_GPIO_MISC_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IOB_VILVIH_VOLVOH_SELECT() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x730))

#define GP_WB_WRITE_IOB_VILVIH_VOLVOH_SELECT(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x730), (val))

/* Select 40 pin vilvih mode */
#define GP_WB_READ_IOB_VILVIH_40_PIN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x730), 0)

#define GP_WB_GET_IOB_VILVIH_40_PIN_FROM_VILVIH_VOLVOH_SELECT(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IOB_VILVIH_40_PIN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x730), 0, (val)); \
        } while (0)

#define GP_WB_SET_IOB_VILVIH_40_PIN_TO_VILVIH_VOLVOH_SELECT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Select 40 pin volvoh mode */
#define GP_WB_READ_IOB_VOLVOH_40_PIN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x730), 1)

#define GP_WB_GET_IOB_VOLVOH_40_PIN_FROM_VILVIH_VOLVOH_SELECT(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_IOB_VOLVOH_40_PIN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x730), 1, (val)); \
        } while (0)

#define GP_WB_SET_IOB_VOLVOH_40_PIN_TO_VILVIH_VOLVOH_SELECT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Enables the rma interface for type 0 external flash */
#define GP_WB_READ_IOB_EXT_FLASH_RMA_0_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x730), 2)

#define GP_WB_GET_IOB_EXT_FLASH_RMA_0_ENABLE_FROM_VILVIH_VOLVOH_SELECT(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_IOB_EXT_FLASH_RMA_0_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x730), 2, (val)); \
        } while (0)

#define GP_WB_SET_IOB_EXT_FLASH_RMA_0_ENABLE_TO_VILVIH_VOLVOH_SELECT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Enables the rma interface for type 1 external flash */
#define GP_WB_READ_IOB_EXT_FLASH_RMA_1_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x730), 3)

#define GP_WB_GET_IOB_EXT_FLASH_RMA_1_ENABLE_FROM_VILVIH_VOLVOH_SELECT(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_IOB_EXT_FLASH_RMA_1_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x730), 3, (val)); \
        } while (0)

#define GP_WB_SET_IOB_EXT_FLASH_RMA_1_ENABLE_TO_VILVIH_VOLVOH_SELECT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* Reflects the values on the debug bus */
#define GP_WB_READ_IOB_DEBUG_STATUS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x731))

/***************************
 * layout: standby
 ***************************/

/* Version register */
#define GP_WB_READ_STANDBY_VERSION() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x800))


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_STBY_MODE_0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x802))

#define GP_WB_WRITE_STANDBY_STBY_MODE_0(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x802), (val))

/* SM CRC calculation enabled when 0x1 */
#define GP_WB_READ_STANDBY_CRC_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x802), 0)

#define GP_WB_GET_STANDBY_CRC_ENABLE_FROM_STBY_MODE_0(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_STANDBY_CRC_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x802), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CRC_ENABLE_TO_STBY_MODE_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* MW write enabled when 0x1 */
#define GP_WB_READ_STANDBY_MW_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x802), 1)

#define GP_WB_GET_STANDBY_MW_ENABLE_FROM_STBY_MODE_0(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_STANDBY_MW_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x802), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_MW_ENABLE_TO_STBY_MODE_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Field indicating that the wb backup needs to be done */
#define GP_WB_READ_STANDBY_WB_BACKUP_NEEDED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x802), 2)

#define GP_WB_GET_STANDBY_WB_BACKUP_NEEDED_FROM_STBY_MODE_0(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_STANDBY_WB_BACKUP_NEEDED(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x802), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WB_BACKUP_NEEDED_TO_STBY_MODE_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* When set the internal uController will be triggered through the NMI even when using vdddig on sleep mode */
#define GP_WB_READ_STANDBY_ALWAYS_TRIGGER_BACKUP_INT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x802), 3)

#define GP_WB_GET_STANDBY_ALWAYS_TRIGGER_BACKUP_INT_FROM_STBY_MODE_0(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_STANDBY_ALWAYS_TRIGGER_BACKUP_INT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x802), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_ALWAYS_TRIGGER_BACKUP_INT_TO_STBY_MODE_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Sets if the vlt_status needs to be triggered when vddb below threshold (=1) or when above threshold (=0) */
#define GP_WB_READ_STANDBY_VLT_STATUS_COMPARE_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x802), 4)

#define GP_WB_GET_STANDBY_VLT_STATUS_COMPARE_VALUE_FROM_STBY_MODE_0(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_STANDBY_VLT_STATUS_COMPARE_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x802), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_VLT_STATUS_COMPARE_VALUE_TO_STBY_MODE_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Browout level:1.8V+50mv*vddb_bodtune Determines level for BOD (aka vlt_status compare level) */
#define GP_WB_READ_STANDBY_VDDB_BODTUNE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x802)) >> 5) & 0x03)

#define GP_WB_GET_STANDBY_VDDB_BODTUNE_FROM_STBY_MODE_0(tmp) \
        (((tmp) >> 5) & 0x03)

#define GP_WB_WRITE_STANDBY_VDDB_BODTUNE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x802), 0x60, (val) << 5); \
        } while (0)

#define GP_WB_SET_STANDBY_VDDB_BODTUNE_TO_STBY_MODE_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x9F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* time reference is automatically halted before backup */
#define GP_WB_READ_STANDBY_AUTO_HALT_TIME_REFERENCE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x802), 7)

#define GP_WB_GET_STANDBY_AUTO_HALT_TIME_REFERENCE_FROM_STBY_MODE_0(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_STANDBY_AUTO_HALT_TIME_REFERENCE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x802), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_AUTO_HALT_TIME_REFERENCE_TO_STBY_MODE_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* CPU clock selection: 0x00 = 1 MHz, 0x01 = 2 MHz, 0x02 = 4 MHz, 0x03 = 8 MHz, 0x04 = 16 MHz */
#define GP_WB_READ_STANDBY_CLK_SELECT_CPU() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x803))

#define GP_WB_WRITE_STANDBY_CLK_SELECT_CPU(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x803), (val)); \
        } while (0)


#define GP_WB_WRITE_STANDBY_RST_PULSE(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x804), (val))

/* reset pulse for external CPU when 0x1 */
#define GP_WB_STANDBY_RESET_PULSE_CPU_SW() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x804), 0x01)

#define GP_WB_SET_STANDBY_RESET_PULSE_CPU_SW_TO_RST_PULSE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Resets the block_sync signal in M16 so that clock alignment can be started again */
#define GP_WB_STANDBY_RESET_BLOCK_SYNC() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x804), 0x02)

#define GP_WB_SET_STANDBY_RESET_BLOCK_SYNC_TO_RST_PULSE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_RESET_FUNC() \
        GP_WB_READ_U40(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x808))

#define GP_WB_WRITE_STANDBY_RESET_FUNC(val) \
      GP_WB_WRITE_U40(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x808), (val))

/* Resets the external CPU when '1' */
#define GP_WB_READ_STANDBY_RESET_CPU_SW() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x808), 0)

#define GP_WB_GET_STANDBY_RESET_CPU_SW_FROM_RESET_FUNC(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_CPU_SW(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x808), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_CPU_SW_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFFFFFFE; \
          (tmp) |= ((UInt64)(val)); \
        } while (0)

/* Resets the internal uc  when '1' */
#define GP_WB_READ_STANDBY_RESET_INT_UC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x808), 1)

#define GP_WB_GET_STANDBY_RESET_INT_UC_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_INT_UC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x808), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_INT_UC_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFFFFFFD; \
          (tmp) |= (((UInt64)(val)) << 1); \
        } while (0)

/* Reset the spi slave when '1' */
#define GP_WB_READ_STANDBY_RESET_EPI_SPI_S() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x808), 2)

#define GP_WB_GET_STANDBY_RESET_EPI_SPI_S_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_SPI_S(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x808), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_SPI_S_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFFFFFFB; \
          (tmp) |= (((UInt64)(val)) << 2); \
        } while (0)

/* Reset the i2c slave block when '1' */
#define GP_WB_READ_STANDBY_RESET_EPI_I2C_S() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x808), 3)

#define GP_WB_GET_STANDBY_RESET_EPI_I2C_S_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_I2C_S(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x808), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_I2C_S_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFFFFFF7; \
          (tmp) |= (((UInt64)(val)) << 3); \
        } while (0)

/* Resets the gpmicro processor */
#define GP_WB_READ_STANDBY_RESET_GPMICRO() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x808), 4)

#define GP_WB_GET_STANDBY_RESET_GPMICRO_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_GPMICRO(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x808), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_GPMICRO_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFFFFFEF; \
          (tmp) |= (((UInt64)(val)) << 4); \
        } while (0)

/* Reset the es timeref block when '1' */
#define GP_WB_READ_STANDBY_RESET_ES_TIMEREF() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x808), 5)

#define GP_WB_GET_STANDBY_RESET_ES_TIMEREF_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_ES_TIMEREF(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x808), 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_ES_TIMEREF_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFFFFFDF; \
          (tmp) |= (((UInt64)(val)) << 5); \
        } while (0)

/* Reset the es event block when '1' */
#define GP_WB_READ_STANDBY_RESET_ES_EVENT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x808), 6)

#define GP_WB_GET_STANDBY_RESET_ES_EVENT_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_ES_EVENT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x808), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_ES_EVENT_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFFFFFBF; \
          (tmp) |= (((UInt64)(val)) << 6); \
        } while (0)

/* Reset the gpio block when '1' */
#define GP_WB_READ_STANDBY_RESET_EPI_GPIO() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x808), 7)

#define GP_WB_GET_STANDBY_RESET_EPI_GPIO_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_GPIO(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x808), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_GPIO_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFFFFF7F; \
          (tmp) |= (((UInt64)(val)) << 7); \
        } while (0)

/* Reset the ssp block when '1' */
#define GP_WB_READ_STANDBY_RESET_EPI_SSP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x809), 0)

#define GP_WB_GET_STANDBY_RESET_EPI_SSP_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_SSP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x809), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_SSP_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFFFFEFF; \
          (tmp) |= (((UInt64)(val)) << 8); \
        } while (0)

/* Reset the security processor block when '1' */
#define GP_WB_READ_STANDBY_RESET_EPI_SEC_PROC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x809), 1)

#define GP_WB_GET_STANDBY_RESET_EPI_SEC_PROC_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_SEC_PROC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x809), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_SEC_PROC_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFFFFDFF; \
          (tmp) |= (((UInt64)(val)) << 9); \
        } while (0)

/* Reset the rpa accelerator block when '1' */
#define GP_WB_READ_STANDBY_RESET_EPI_RPA_ACC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x809), 2)

#define GP_WB_GET_STANDBY_RESET_EPI_RPA_ACC_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_RPA_ACC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x809), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_RPA_ACC_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFFFFBFF; \
          (tmp) |= (((UInt64)(val)) << 10); \
        } while (0)

/* Reset the uart block when '1' */
#define GP_WB_READ_STANDBY_RESET_EPI_UART_0() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x809), 3)

#define GP_WB_GET_STANDBY_RESET_EPI_UART_0_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_UART_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x809), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_UART_0_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFFFF7FF; \
          (tmp) |= (((UInt64)(val)) << 11); \
        } while (0)

/* Reset the uart block when '1' */
#define GP_WB_READ_STANDBY_RESET_EPI_UART_1() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x809), 4)

#define GP_WB_GET_STANDBY_RESET_EPI_UART_1_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_UART_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x809), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_UART_1_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFFFEFFF; \
          (tmp) |= (((UInt64)(val)) << 12); \
        } while (0)

/* Reset the spi master block when '1' */
#define GP_WB_READ_STANDBY_RESET_EPI_SPI_M() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x809), 6)

#define GP_WB_GET_STANDBY_RESET_EPI_SPI_M_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_SPI_M(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x809), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_SPI_M_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFFFBFFF; \
          (tmp) |= (((UInt64)(val)) << 14); \
        } while (0)

/* Reset the i2c master block when '1' */
#define GP_WB_READ_STANDBY_RESET_EPI_I2C_M() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x809), 7)

#define GP_WB_GET_STANDBY_RESET_EPI_I2C_M_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_I2C_M(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x809), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_I2C_M_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFFF7FFF; \
          (tmp) |= (((UInt64)(val)) << 15); \
        } while (0)

/* Reset the i2s master block when '1' */
#define GP_WB_READ_STANDBY_RESET_EPI_I2S_M() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80a), 0)

#define GP_WB_GET_STANDBY_RESET_EPI_I2S_M_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_I2S_M(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80a), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_I2S_M_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFFEFFFF; \
          (tmp) |= (((UInt64)(val)) << 16); \
        } while (0)

/* Reset for the IR peripheral */
#define GP_WB_READ_STANDBY_RESET_EPI_IR() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80a), 1)

#define GP_WB_GET_STANDBY_RESET_EPI_IR_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 17) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_IR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80a), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_IR_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFFDFFFF; \
          (tmp) |= (((UInt64)(val)) << 17); \
        } while (0)

/* Reset for the Led driver peripheral */
#define GP_WB_READ_STANDBY_RESET_EPI_LED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80a), 2)

#define GP_WB_GET_STANDBY_RESET_EPI_LED_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 18) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_LED(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80a), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_LED_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFFBFFFF; \
          (tmp) |= (((UInt64)(val)) << 18); \
        } while (0)

/* Reset for the adcif / rssi  peripheral */
#define GP_WB_READ_STANDBY_RESET_EPI_ADCIF() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80a), 3)

#define GP_WB_GET_STANDBY_RESET_EPI_ADCIF_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 19) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_ADCIF(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80a), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_ADCIF_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFF7FFFF; \
          (tmp) |= (((UInt64)(val)) << 19); \
        } while (0)

/* Reset for the inter processor communication peripheral */
#define GP_WB_READ_STANDBY_RESET_EPI_IPC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80a), 4)

#define GP_WB_GET_STANDBY_RESET_EPI_IPC_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 20) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_IPC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80a), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_IPC_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFEFFFFF; \
          (tmp) |= (((UInt64)(val)) << 20); \
        } while (0)

/* Reset for the dma peripheral */
#define GP_WB_READ_STANDBY_RESET_EPI_DMA_SCB() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80a), 5)

#define GP_WB_GET_STANDBY_RESET_EPI_DMA_SCB_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 21) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_DMA_SCB(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80a), 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_DMA_SCB_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFDFFFFF; \
          (tmp) |= (((UInt64)(val)) << 21); \
        } while (0)

/* Reset for the PWM peripheral */
#define GP_WB_READ_STANDBY_RESET_EPI_PWM() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80a), 6)

#define GP_WB_GET_STANDBY_RESET_EPI_PWM_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 22) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_PWM(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80a), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_PWM_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFFBFFFFF; \
          (tmp) |= (((UInt64)(val)) << 22); \
        } while (0)

/* Reset for the ASP peripheral */
#define GP_WB_READ_STANDBY_RESET_EPI_ASP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80a), 7)

#define GP_WB_GET_STANDBY_RESET_EPI_ASP_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 23) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_ASP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80a), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_ASP_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFF7FFFFF; \
          (tmp) |= (((UInt64)(val)) << 23); \
        } while (0)

/* Reset for the timer peripheral */
#define GP_WB_READ_STANDBY_RESET_EPI_TIMER() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80b), 0)

#define GP_WB_GET_STANDBY_RESET_EPI_TIMER_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 24) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_EPI_TIMER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80b), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_EPI_TIMER_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFEFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 24); \
        } while (0)

/* Reset the pseudo random generator block when '1' */
#define GP_WB_READ_STANDBY_RESET_PRG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80b), 1)

#define GP_WB_GET_STANDBY_RESET_PRG_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 25) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_PRG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80b), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_PRG_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFDFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 25); \
        } while (0)

/* Reset the phy when '1' */
#define GP_WB_READ_STANDBY_RESET_PHY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80b), 2)

#define GP_WB_GET_STANDBY_RESET_PHY_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 26) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_PHY(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80b), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_PHY_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFBFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 26); \
        } while (0)

/* Reset the phy when '1' */
#define GP_WB_READ_STANDBY_RESET_PHY_DYN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80b), 3)

#define GP_WB_GET_STANDBY_RESET_PHY_DYN_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 27) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_PHY_DYN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80b), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_PHY_DYN_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FF7FFFFFF; \
          (tmp) |= (((UInt64)(val)) << 27); \
        } while (0)

/* Reset the phy when '1' */
#define GP_WB_READ_STANDBY_RESET_PHY_DYN_64() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80b), 4)

#define GP_WB_GET_STANDBY_RESET_PHY_DYN_64_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 28) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_PHY_DYN_64(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80b), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_PHY_DYN_64_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FEFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 28); \
        } while (0)

/* Reset the convolution engine when '1' */
#define GP_WB_READ_STANDBY_RESET_PHY_CONV() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80b), 5)

#define GP_WB_GET_STANDBY_RESET_PHY_CONV_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 29) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_PHY_CONV(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80b), 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_PHY_CONV_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FDFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 29); \
        } while (0)

/* reset the rtm when '1' */
#define GP_WB_READ_STANDBY_RESET_RTM() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80b), 6)

#define GP_WB_GET_STANDBY_RESET_RTM_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 30) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_RTM(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80b), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_RTM_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FBFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 30); \
        } while (0)

/* reset the iob when '1' */
#define GP_WB_READ_STANDBY_RESET_IOB() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80b), 7)

#define GP_WB_GET_STANDBY_RESET_IOB_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 31) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_IOB(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80b), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_IOB_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F7FFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 31); \
        } while (0)

/* reset the standby memory and its peripheral blocks when '1' */
#define GP_WB_READ_STANDBY_RESET_MM_STBM() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80c), 0)

#define GP_WB_GET_STANDBY_RESET_MM_STBM_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 32) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_MM_STBM(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80c), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_MM_STBM_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0EFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 32); \
        } while (0)

/* reset the flash controller and peripheral blocks when '1' */
#define GP_WB_READ_STANDBY_RESET_MM_NVM() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80c), 1)

#define GP_WB_GET_STANDBY_RESET_MM_NVM_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 33) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_MM_NVM(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80c), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_MM_NVM_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0DFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 33); \
        } while (0)

/* reset the spi/i2c controller when '1' */
#define GP_WB_READ_STANDBY_RESET_MSI_CORE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80c), 2)

#define GP_WB_GET_STANDBY_RESET_MSI_CORE_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 34) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_MSI_CORE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80c), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_MSI_CORE_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0BFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 34); \
        } while (0)

/* reset the BBPLL synth (fract clock generator) when '1' */
#define GP_WB_READ_STANDBY_RESET_BBPLL_SYNTH() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80c), 3)

#define GP_WB_GET_STANDBY_RESET_BBPLL_SYNTH_FROM_RESET_FUNC(tmp) \
        (((tmp) >> 35) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_BBPLL_SYNTH(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x80c), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_BBPLL_SYNTH_TO_RESET_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 35); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_RESET_REGMAP() \
        GP_WB_READ_U40(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x810))

#define GP_WB_WRITE_STANDBY_RESET_REGMAP(val) \
      GP_WB_WRITE_U40(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x810), (val))

/* resets the iob regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_IOB() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x810), 0)

#define GP_WB_GET_STANDBY_RESET_REGMAP_IOB_FROM_RESET_REGMAP(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_IOB(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x810), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_IOB_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFFE; \
          (tmp) |= ((UInt64)(val)); \
        } while (0)

/* resets the stby controller regmap. This resets all registers in this regmap!! */
#define GP_WB_READ_STANDBY_RESET_REGMAP_STBC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x810), 1)

#define GP_WB_GET_STANDBY_RESET_REGMAP_STBC_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_STBC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x810), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_STBC_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFFD; \
          (tmp) |= (((UInt64)(val)) << 1); \
        } while (0)

/* Resets the internal uC regmap */
#define GP_WB_READ_STANDBY_RESET_REGMAP_INT_UC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x810), 2)

#define GP_WB_GET_STANDBY_RESET_REGMAP_INT_UC_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_INT_UC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x810), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_INT_UC_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFFB; \
          (tmp) |= (((UInt64)(val)) << 2); \
        } while (0)

/* Resets the gpmicro regmap */
#define GP_WB_READ_STANDBY_RESET_REGMAP_GPMICRO() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x810), 3)

#define GP_WB_GET_STANDBY_RESET_REGMAP_GPMICRO_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_GPMICRO(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x810), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_GPMICRO_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFF7; \
          (tmp) |= (((UInt64)(val)) << 3); \
        } while (0)

/* resets the es regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_ES() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x810), 4)

#define GP_WB_GET_STANDBY_RESET_REGMAP_ES_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_ES(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x810), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_ES_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFEF; \
          (tmp) |= (((UInt64)(val)) << 4); \
        } while (0)

/* resets the gpio regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_GPIO() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x810), 5)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_GPIO_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_GPIO(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x810), 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_GPIO_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFDF; \
          (tmp) |= (((UInt64)(val)) << 5); \
        } while (0)

/* resets the i2c master regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_I2C_M() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x810), 6)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_I2C_M_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_I2C_M(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x810), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_I2C_M_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFBF; \
          (tmp) |= (((UInt64)(val)) << 6); \
        } while (0)

/* resets the i2s master regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_I2S_M() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x810), 7)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_I2S_M_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_I2S_M(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x810), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_I2S_M_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFF7F; \
          (tmp) |= (((UInt64)(val)) << 7); \
        } while (0)

/* resets the ssp regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_SSP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x811), 0)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_SSP_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_SSP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x811), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_SSP_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFEFF; \
          (tmp) |= (((UInt64)(val)) << 8); \
        } while (0)

/* resets the security processor regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_SEC_PROC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x811), 1)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_SEC_PROC_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_SEC_PROC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x811), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_SEC_PROC_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFDFF; \
          (tmp) |= (((UInt64)(val)) << 9); \
        } while (0)

/* resets the rpa_acc regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_RPA_ACC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x811), 2)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_RPA_ACC_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_RPA_ACC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x811), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_RPA_ACC_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFBFF; \
          (tmp) |= (((UInt64)(val)) << 10); \
        } while (0)

/* resets the uart regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_UART_0() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x811), 3)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_UART_0_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_UART_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x811), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_UART_0_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFF7FF; \
          (tmp) |= (((UInt64)(val)) << 11); \
        } while (0)

/* resets the uart regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_UART_1() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x811), 4)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_UART_1_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_UART_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x811), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_UART_1_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFEFFF; \
          (tmp) |= (((UInt64)(val)) << 12); \
        } while (0)

/* resets the spi master regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_SPI_M() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x811), 6)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_SPI_M_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_SPI_M(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x811), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_SPI_M_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFBFFF; \
          (tmp) |= (((UInt64)(val)) << 14); \
        } while (0)

/* resets the epi ir block regmap */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_IR() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x811), 7)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_IR_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_IR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x811), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_IR_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFF7FFF; \
          (tmp) |= (((UInt64)(val)) << 15); \
        } while (0)

/* resets the epi led driver block regmap */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_LED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x812), 0)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_LED_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_LED(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x812), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_LED_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFEFFFF; \
          (tmp) |= (((UInt64)(val)) << 16); \
        } while (0)

/* resets the adcif block regmap */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_ADCIF() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x812), 1)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_ADCIF_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 17) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_ADCIF(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x812), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_ADCIF_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFDFFFF; \
          (tmp) |= (((UInt64)(val)) << 17); \
        } while (0)

/* resets the ipc block regmap */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_IPC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x812), 2)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_IPC_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 18) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_IPC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x812), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_IPC_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFBFFFF; \
          (tmp) |= (((UInt64)(val)) << 18); \
        } while (0)

/* resets the dma block regmap */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_DMA_SCB() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x812), 3)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_DMA_SCB_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 19) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_DMA_SCB(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x812), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_DMA_SCB_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFF7FFFF; \
          (tmp) |= (((UInt64)(val)) << 19); \
        } while (0)

/* resets the pwm block regmap */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_PWM() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x812), 4)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_PWM_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 20) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_PWM(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x812), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_PWM_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFEFFFFF; \
          (tmp) |= (((UInt64)(val)) << 20); \
        } while (0)

/* resets the asp block regmap */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_ASP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x812), 5)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_ASP_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 21) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_ASP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x812), 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_ASP_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFDFFFFF; \
          (tmp) |= (((UInt64)(val)) << 21); \
        } while (0)

/* resets the timer block regmap */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_TIMER() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x812), 6)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_TIMER_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 22) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_TIMER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x812), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_TIMER_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFBFFFFF; \
          (tmp) |= (((UInt64)(val)) << 22); \
        } while (0)

/* resets the prg regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_PRG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x812), 7)

#define GP_WB_GET_STANDBY_RESET_REGMAP_PRG_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 23) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_PRG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x812), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_PRG_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FF7FFFFF; \
          (tmp) |= (((UInt64)(val)) << 23); \
        } while (0)

/* resets the phy regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_PHY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x813), 0)

#define GP_WB_GET_STANDBY_RESET_REGMAP_PHY_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 24) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_PHY(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x813), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_PHY_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FEFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 24); \
        } while (0)

/* resets the rtm regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_RTM() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x813), 1)

#define GP_WB_GET_STANDBY_RESET_REGMAP_RTM_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 25) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_RTM(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x813), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_RTM_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FDFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 25); \
        } while (0)

/* resets the qta regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_RTM_QTA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x813), 2)

#define GP_WB_GET_STANDBY_RESET_REGMAP_RTM_QTA_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 26) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_RTM_QTA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x813), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_RTM_QTA_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FBFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 26); \
        } while (0)

/* resets the mm regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_MM() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x813), 3)

#define GP_WB_GET_STANDBY_RESET_REGMAP_MM_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 27) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_MM(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x813), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_MM_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01F7FFFFFF; \
          (tmp) |= (((UInt64)(val)) << 27); \
        } while (0)

/* resets the msi interrupt controller regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_MSI_INT_CTRL() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x813), 4)

#define GP_WB_GET_STANDBY_RESET_REGMAP_MSI_INT_CTRL_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 28) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_MSI_INT_CTRL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x813), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_MSI_INT_CTRL_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01EFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 28); \
        } while (0)

/* resets the msi core regmap when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_MSI_CORE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x813), 5)

#define GP_WB_GET_STANDBY_RESET_REGMAP_MSI_CORE_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 29) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_MSI_CORE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x813), 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_MSI_CORE_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01DFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 29); \
        } while (0)

/* resets the pbm admin regmap (and logic) when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_PBM_ADMIN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x813), 6)

#define GP_WB_GET_STANDBY_RESET_REGMAP_PBM_ADMIN_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 30) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_PBM_ADMIN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x813), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_PBM_ADMIN_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01BFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 30); \
        } while (0)

/* resets the spi slave regmap (and logic) when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_SPI_S() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x813), 7)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_SPI_S_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 31) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_SPI_S(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x813), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_SPI_S_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x017FFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 31); \
        } while (0)

/* resets the i2c slave regmap (and logic) when '1' */
#define GP_WB_READ_STANDBY_RESET_REGMAP_EPI_I2C_S() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x814), 0)

#define GP_WB_GET_STANDBY_RESET_REGMAP_EPI_I2C_S_FROM_RESET_REGMAP(tmp) \
        (((tmp) >> 32) & 0x01)

#define GP_WB_WRITE_STANDBY_RESET_REGMAP_EPI_I2C_S(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x814), (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RESET_REGMAP_EPI_I2C_S_TO_RESET_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x00FFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 32); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_CLK_ENABLE_FUNC() \
        GP_WB_READ_U40(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x818))

#define GP_WB_WRITE_STANDBY_CLK_ENABLE_FUNC(val) \
      GP_WB_WRITE_U40(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x818), (val))

/* Disables the clock to the external cpu when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_CPU() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x818), 0)

#define GP_WB_GET_STANDBY_CLK_ENA_CPU_FROM_CLK_ENABLE_FUNC(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_CPU(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x818), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_CPU_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFFFFFFE; \
          (tmp) |= ((UInt64)(val)); \
        } while (0)

/* Disables the clock to the internal uc when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_INT_UC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x818), 1)

#define GP_WB_GET_STANDBY_CLK_ENA_INT_UC_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_INT_UC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x818), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_INT_UC_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFFFFFFD; \
          (tmp) |= (((UInt64)(val)) << 1); \
        } while (0)

/* Disables the clock to the epi spi slave block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_SPI_S() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x818), 2)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_SPI_S_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_SPI_S(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x818), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_SPI_S_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFFFFFFB; \
          (tmp) |= (((UInt64)(val)) << 2); \
        } while (0)

/* Disables the clock to the epi i2c slave block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_I2C_S() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x818), 3)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_I2C_S_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_I2C_S(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x818), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_I2C_S_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFFFFFF7; \
          (tmp) |= (((UInt64)(val)) << 3); \
        } while (0)

/* Clk enable for the gpmicro processor */
#define GP_WB_READ_STANDBY_CLK_ENA_GPMICRO() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x818), 4)

#define GP_WB_GET_STANDBY_CLK_ENA_GPMICRO_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_GPMICRO(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x818), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_GPMICRO_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFFFFFEF; \
          (tmp) |= (((UInt64)(val)) << 4); \
        } while (0)

/* Disables the clock to the es timeref block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_ES_TIMEREF() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x818), 5)

#define GP_WB_GET_STANDBY_CLK_ENA_ES_TIMEREF_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_ES_TIMEREF(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x818), 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_ES_TIMEREF_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFFFFFDF; \
          (tmp) |= (((UInt64)(val)) << 5); \
        } while (0)

/* Disables the clock to the es event block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_ES_EVENT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x818), 6)

#define GP_WB_GET_STANDBY_CLK_ENA_ES_EVENT_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_ES_EVENT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x818), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_ES_EVENT_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFFFFFBF; \
          (tmp) |= (((UInt64)(val)) << 6); \
        } while (0)

/* Disables the clock to the epi gpio block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_GPIO() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x818), 7)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_GPIO_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_GPIO(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x818), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_GPIO_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFFFFF7F; \
          (tmp) |= (((UInt64)(val)) << 7); \
        } while (0)

/* Disables the clock to the epi ssp block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_SSP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x819), 0)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_SSP_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_SSP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x819), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_SSP_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFFFFEFF; \
          (tmp) |= (((UInt64)(val)) << 8); \
        } while (0)

/* Disables the clock to the epi security processor block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_SEC_PROC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x819), 1)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_SEC_PROC_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_SEC_PROC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x819), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_SEC_PROC_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFFFFDFF; \
          (tmp) |= (((UInt64)(val)) << 9); \
        } while (0)

/* Disables the clock to the epi rpa acc block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_RPA_ACC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x819), 2)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_RPA_ACC_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_RPA_ACC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x819), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_RPA_ACC_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFFFFBFF; \
          (tmp) |= (((UInt64)(val)) << 10); \
        } while (0)

/* Disables the clock to the epi uart block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_UART_0() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x819), 3)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_UART_0_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_UART_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x819), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_UART_0_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFFFF7FF; \
          (tmp) |= (((UInt64)(val)) << 11); \
        } while (0)

/* Disables the clock to the epi uart block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_UART_1() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x819), 4)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_UART_1_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_UART_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x819), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_UART_1_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFFFEFFF; \
          (tmp) |= (((UInt64)(val)) << 12); \
        } while (0)

/* Disables the clock to the epi ir block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_IR() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x819), 6)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_IR_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_IR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x819), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_IR_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFFFBFFF; \
          (tmp) |= (((UInt64)(val)) << 14); \
        } while (0)

/* Disables the clock to the epi led block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_LED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x819), 7)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_LED_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_LED(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x819), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_LED_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFFF7FFF; \
          (tmp) |= (((UInt64)(val)) << 15); \
        } while (0)

/* Disables the clock to the epi spi master block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_SPI_M() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81a), 0)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_SPI_M_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_SPI_M(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81a), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_SPI_M_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFFEFFFF; \
          (tmp) |= (((UInt64)(val)) << 16); \
        } while (0)

/* Disables the clock to the i2c master block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_I2C_M() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81a), 1)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_I2C_M_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 17) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_I2C_M(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81a), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_I2C_M_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFFDFFFF; \
          (tmp) |= (((UInt64)(val)) << 17); \
        } while (0)

/* Disables the clock to the i2s master block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_I2S_M() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81a), 2)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_I2S_M_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 18) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_I2S_M(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81a), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_I2S_M_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFFBFFFF; \
          (tmp) |= (((UInt64)(val)) << 18); \
        } while (0)

/* Disables the clock to the adcif block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_ADCIF() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81a), 3)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_ADCIF_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 19) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_ADCIF(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81a), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_ADCIF_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFF7FFFF; \
          (tmp) |= (((UInt64)(val)) << 19); \
        } while (0)

/* Disables the clock to the ipc block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_IPC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81a), 4)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_IPC_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 20) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_IPC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81a), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_IPC_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFEFFFFF; \
          (tmp) |= (((UInt64)(val)) << 20); \
        } while (0)

/* Disables the clock to the dma block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_DMA_SCB() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81a), 5)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_DMA_SCB_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 21) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_DMA_SCB(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81a), 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_DMA_SCB_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFDFFFFF; \
          (tmp) |= (((UInt64)(val)) << 21); \
        } while (0)

/* Disables the clock to the pwm block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_PWM() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81a), 6)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_PWM_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 22) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_PWM(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81a), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_PWM_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFBFFFFF; \
          (tmp) |= (((UInt64)(val)) << 22); \
        } while (0)

/* Disables the clock to the asp block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_ASP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81a), 7)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_ASP_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 23) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_ASP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81a), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_ASP_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FF7FFFFF; \
          (tmp) |= (((UInt64)(val)) << 23); \
        } while (0)

/* Disables the clock to the timer block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_EPI_TIMER() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81b), 0)

#define GP_WB_GET_STANDBY_CLK_ENA_EPI_TIMER_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 24) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_EPI_TIMER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81b), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_EPI_TIMER_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FEFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 24); \
        } while (0)

/* Disables the clock to the pseudo random generator block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_PRG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81b), 1)

#define GP_WB_GET_STANDBY_CLK_ENA_PRG_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 25) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_PRG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81b), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_PRG_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FDFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 25); \
        } while (0)

/* Disables the clock to the phy block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_PHY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81b), 2)

#define GP_WB_GET_STANDBY_CLK_ENA_PHY_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 26) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_PHY(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81b), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_PHY_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FBFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 26); \
        } while (0)

/* Disables the clock to the phy block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_PHY_DYN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81b), 3)

#define GP_WB_GET_STANDBY_CLK_ENA_PHY_DYN_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 27) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_PHY_DYN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81b), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_PHY_DYN_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03F7FFFFFF; \
          (tmp) |= (((UInt64)(val)) << 27); \
        } while (0)

/* Disables the clock to the phy block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_PHY_DYN_64() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81b), 4)

#define GP_WB_GET_STANDBY_CLK_ENA_PHY_DYN_64_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 28) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_PHY_DYN_64(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81b), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_PHY_DYN_64_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03EFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 28); \
        } while (0)

/* Disables the clock to the convolution engine block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_PHY_CONV() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81b), 5)

#define GP_WB_GET_STANDBY_CLK_ENA_PHY_CONV_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 29) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_PHY_CONV(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81b), 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_PHY_CONV_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03DFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 29); \
        } while (0)

/* Disables the clock to the rtm block when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_RTM() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81b), 6)

#define GP_WB_GET_STANDBY_CLK_ENA_RTM_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 30) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_RTM(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81b), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_RTM_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03BFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 30); \
        } while (0)

/* Disables the clock to the standby memory and its peripheral blocks when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_MM_STBM() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81b), 7)

#define GP_WB_GET_STANDBY_CLK_ENA_MM_STBM_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 31) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_MM_STBM(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81b), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_MM_STBM_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x037FFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 31); \
        } while (0)

/* Disables the clock to  the flash controller and peripheral blocks when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_MM_NVM() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81c), 0)

#define GP_WB_GET_STANDBY_CLK_ENA_MM_NVM_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 32) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_MM_NVM(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81c), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_MM_NVM_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02FFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 32); \
        } while (0)

/* Disables the clock to  the spi/i2c controller when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_MSI_CORE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81c), 1)

#define GP_WB_GET_STANDBY_CLK_ENA_MSI_CORE_FROM_CLK_ENABLE_FUNC(tmp) \
        (((tmp) >> 33) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_MSI_CORE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x81c), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_MSI_CORE_TO_CLK_ENABLE_FUNC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 33); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_CLK_ENABLE_REGMAP() \
        GP_WB_READ_U40(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x820))

#define GP_WB_WRITE_STANDBY_CLK_ENABLE_REGMAP(val) \
      GP_WB_WRITE_U40(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x820), (val))

/* Disables the clock to the iob regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_IOB() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x820), 0)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_IOB_FROM_CLK_ENABLE_REGMAP(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_IOB(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x820), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_IOB_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFFE; \
          (tmp) |= ((UInt64)(val)); \
        } while (0)

/* Disables the clock to PMUD regmap (the always on power domain) when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_PMUD() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x820), 1)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_PMUD_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_PMUD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x820), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_PMUD_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFFD; \
          (tmp) |= (((UInt64)(val)) << 1); \
        } while (0)

/* clk enable for the internal uc regmap */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_INT_UC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x820), 2)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_INT_UC_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_INT_UC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x820), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_INT_UC_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFFB; \
          (tmp) |= (((UInt64)(val)) << 2); \
        } while (0)

/* clk enable for the gpmicro processor regmap */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_GPMICRO() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x820), 3)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_GPMICRO_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_GPMICRO(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x820), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_GPMICRO_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFF7; \
          (tmp) |= (((UInt64)(val)) << 3); \
        } while (0)

/* Disables the clock to the es regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_ES() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x820), 4)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_ES_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_ES(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x820), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_ES_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFEF; \
          (tmp) |= (((UInt64)(val)) << 4); \
        } while (0)

/* Disables the clock to the gpio regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_GPIO() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x820), 5)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_GPIO_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_GPIO(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x820), 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_GPIO_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFDF; \
          (tmp) |= (((UInt64)(val)) << 5); \
        } while (0)

/* Disables the clock to the i2c mastrer regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_I2C_M() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x820), 6)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_I2C_M_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_I2C_M(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x820), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_I2C_M_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFBF; \
          (tmp) |= (((UInt64)(val)) << 6); \
        } while (0)

/* Disables the clock to the i2c mastrer regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_I2S_M() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x820), 7)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_I2S_M_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_I2S_M(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x820), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_I2S_M_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFF7F; \
          (tmp) |= (((UInt64)(val)) << 7); \
        } while (0)

/* Disables the clock to the ssp regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_SSP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x821), 0)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_SSP_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_SSP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x821), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_SSP_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFEFF; \
          (tmp) |= (((UInt64)(val)) << 8); \
        } while (0)

/* Disables the clock to the security processor regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_SEC_PROC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x821), 1)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_SEC_PROC_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_SEC_PROC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x821), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_SEC_PROC_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFDFF; \
          (tmp) |= (((UInt64)(val)) << 9); \
        } while (0)

/* Disables the clock to the rpa_acc regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_RPA_ACC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x821), 2)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_RPA_ACC_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_RPA_ACC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x821), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_RPA_ACC_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFBFF; \
          (tmp) |= (((UInt64)(val)) << 10); \
        } while (0)

/* Disables the clock to the uart regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_UART_0() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x821), 3)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_UART_0_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_UART_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x821), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_UART_0_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFF7FF; \
          (tmp) |= (((UInt64)(val)) << 11); \
        } while (0)

/* Disables the clock to the uart regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_UART_1() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x821), 4)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_UART_1_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_UART_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x821), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_UART_1_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFEFFF; \
          (tmp) |= (((UInt64)(val)) << 12); \
        } while (0)

/* Disables the clock to the spi master regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_SPI_M() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x821), 6)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_SPI_M_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_SPI_M(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x821), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_SPI_M_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFBFFF; \
          (tmp) |= (((UInt64)(val)) << 14); \
        } while (0)

/* Disables the clock to the ir regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_IR() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x821), 7)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_IR_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_IR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x821), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_IR_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFF7FFF; \
          (tmp) |= (((UInt64)(val)) << 15); \
        } while (0)

/* Disables the clock to the led regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_LED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x822), 0)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_LED_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_LED(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x822), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_LED_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFEFFFF; \
          (tmp) |= (((UInt64)(val)) << 16); \
        } while (0)

/* Disables the clock to the ipc regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_IPC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x822), 1)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_IPC_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 17) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_IPC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x822), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_IPC_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFDFFFF; \
          (tmp) |= (((UInt64)(val)) << 17); \
        } while (0)

/* Disables the clock to the adcif regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_ADCIF() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x822), 2)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_ADCIF_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 18) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_ADCIF(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x822), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_ADCIF_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFBFFFF; \
          (tmp) |= (((UInt64)(val)) << 18); \
        } while (0)

/* Disables the clock to the dma regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_DMA_SCB() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x822), 3)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_DMA_SCB_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 19) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_DMA_SCB(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x822), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_DMA_SCB_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFF7FFFF; \
          (tmp) |= (((UInt64)(val)) << 19); \
        } while (0)

/* Disables the clock to the pwm regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_PWM() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x822), 4)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_PWM_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 20) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_PWM(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x822), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_PWM_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFEFFFFF; \
          (tmp) |= (((UInt64)(val)) << 20); \
        } while (0)

/* Disables the clock to the asp regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_ASP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x822), 5)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_ASP_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 21) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_ASP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x822), 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_ASP_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFDFFFFF; \
          (tmp) |= (((UInt64)(val)) << 21); \
        } while (0)

/* Disables the clock to the timer regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_TIMER() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x822), 6)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_TIMER_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 22) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_TIMER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x822), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_TIMER_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFBFFFFF; \
          (tmp) |= (((UInt64)(val)) << 22); \
        } while (0)

/* Disables the clock to the prg regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_PRG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x822), 7)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_PRG_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 23) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_PRG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x822), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_PRG_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FF7FFFFF; \
          (tmp) |= (((UInt64)(val)) << 23); \
        } while (0)

/* Disables the clock to the phy regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_PHY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x823), 0)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_PHY_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 24) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_PHY(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x823), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_PHY_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FEFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 24); \
        } while (0)

/* Disables the clock to the rtm regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_RTM() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x823), 1)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_RTM_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 25) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_RTM(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x823), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_RTM_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FDFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 25); \
        } while (0)

/* Disables the clock to the qta regmap (and logic) when  '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_RTM_QTA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x823), 2)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_RTM_QTA_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 26) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_RTM_QTA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x823), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_RTM_QTA_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FBFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 26); \
        } while (0)

/* Disables the clock to the mm regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_MM() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x823), 3)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_MM_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 27) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_MM(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x823), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_MM_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01F7FFFFFF; \
          (tmp) |= (((UInt64)(val)) << 27); \
        } while (0)

/* Disables the clock to the msi interrupt controller regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_MSI_INT_CTRL() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x823), 4)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_MSI_INT_CTRL_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 28) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_MSI_INT_CTRL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x823), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_MSI_INT_CTRL_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01EFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 28); \
        } while (0)

/* Disables the clock to the msi core regmap when '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_MSI_CORE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x823), 5)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_MSI_CORE_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 29) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_MSI_CORE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x823), 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_MSI_CORE_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01DFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 29); \
        } while (0)

/* Disables the clock to the pbm admin regmap (and logic) when  '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_PBM_ADMIN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x823), 6)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_PBM_ADMIN_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 30) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_PBM_ADMIN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x823), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_PBM_ADMIN_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01BFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 30); \
        } while (0)

/* Disables the clock to the pbm admin regmap (and logic) when  '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_SPI_S() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x823), 7)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_SPI_S_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 31) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_SPI_S(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x823), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_SPI_S_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x017FFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 31); \
        } while (0)

/* Disables the clock to the pbm admin regmap (and logic) when  '0' */
#define GP_WB_READ_STANDBY_CLK_ENA_REGMAP_EPI_I2C_S() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x824), 0)

#define GP_WB_GET_STANDBY_CLK_ENA_REGMAP_EPI_I2C_S_FROM_CLK_ENABLE_REGMAP(tmp) \
        (((tmp) >> 32) & 0x01)

#define GP_WB_WRITE_STANDBY_CLK_ENA_REGMAP_EPI_I2C_S(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x824), (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_CLK_ENA_REGMAP_EPI_I2C_S_TO_CLK_ENABLE_REGMAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x00FFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 32); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_CLK_CONTROL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x825))

#define GP_WB_WRITE_STANDBY_CLK_CONTROL(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x825), (val))

/* Sets the prescaler to obtain the desired clock speed for the uccore prescaler group */
#define GP_WB_READ_STANDBY_PRESCALE_UCCORE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x825), 0)

#define GP_WB_GET_STANDBY_PRESCALE_UCCORE_FROM_CLK_CONTROL(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_STANDBY_PRESCALE_UCCORE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x825), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_PRESCALE_UCCORE_TO_CLK_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When set the fast clock source will be the main clock source even if the uccore speed does not require the high speed */
#define GP_WB_READ_STANDBY_ALWAYS_USE_FAST_CLOCK_AS_SOURCE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x825), 1)

#define GP_WB_GET_STANDBY_ALWAYS_USE_FAST_CLOCK_AS_SOURCE_FROM_CLK_CONTROL(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_STANDBY_ALWAYS_USE_FAST_CLOCK_AS_SOURCE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x825), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_ALWAYS_USE_FAST_CLOCK_AS_SOURCE_TO_CLK_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* configures the bbpll phase (0-5) that is used to sync the main clocks */
#define GP_WB_READ_STANDBY_SYNC_PHASE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x825)) >> 2) & 0x07)

#define GP_WB_GET_STANDBY_SYNC_PHASE_FROM_CLK_CONTROL(tmp) \
        (((tmp) >> 2) & 0x07)

#define GP_WB_WRITE_STANDBY_SYNC_PHASE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x825), 0x1C, (val) << 2); \
        } while (0)

#define GP_WB_SET_STANDBY_SYNC_PHASE_TO_CLK_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


#define GP_WB_WRITE_STANDBY_SNAPSHOT_CTRL(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x826), (val))

/* Sample retention when 0x1 */
#define GP_WB_STANDBY_SAMPLE_RET() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x826), 0x01)

#define GP_WB_SET_STANDBY_SAMPLE_RET_TO_SNAPSHOT_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* preload retention when 0x1 */
#define GP_WB_STANDBY_PRELOAD_RET() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x826), 0x02)

#define GP_WB_SET_STANDBY_PRELOAD_RET_TO_SNAPSHOT_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* halt time reference 0x1 */
#define GP_WB_STANDBY_HALT_TIME_REFERENCE() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x826), 0x04)

#define GP_WB_SET_STANDBY_HALT_TIME_REFERENCE_TO_SNAPSHOT_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_POWERUP_AND_ISOLATION_CTRL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x827))

#define GP_WB_WRITE_STANDBY_POWERUP_AND_ISOLATION_CTRL(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x827), (val))

/* This is the main clock enable of the chip. It needs to be put to 1 in order to enable the main functionality. When 0 only regmaps/uc/rams and flash have a clock */
#define GP_WB_READ_STANDBY_ENABLE_MAIN_CLOCKS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x827), 0)

#define GP_WB_GET_STANDBY_ENABLE_MAIN_CLOCKS_FROM_POWERUP_AND_ISOLATION_CTRL(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_STANDBY_ENABLE_MAIN_CLOCKS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x827), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_ENABLE_MAIN_CLOCKS_TO_POWERUP_AND_ISOLATION_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Needs to be explicitely set by SW, when chip is ready to drive ioring */
#define GP_WB_READ_STANDBY_ACTIVATE_IORING() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x827), 1)

#define GP_WB_GET_STANDBY_ACTIVATE_IORING_FROM_POWERUP_AND_ISOLATION_CTRL(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_STANDBY_ACTIVATE_IORING(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x827), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_ACTIVATE_IORING_TO_POWERUP_AND_ISOLATION_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Isolate radio from digital logic when 0x1, actual signal is low active */
#define GP_WB_READ_STANDBY_RADIO_ISOLATE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x827), 2)

#define GP_WB_GET_STANDBY_RADIO_ISOLATE_FROM_POWERUP_AND_ISOLATION_CTRL(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_STANDBY_RADIO_ISOLATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x827), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RADIO_ISOLATE_TO_POWERUP_AND_ISOLATION_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* enables all ldo's in the analog domain. Needs to be set to 1 to enable radio activity */
#define GP_WB_READ_STANDBY_MASTER_LDO_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x827), 3)

#define GP_WB_GET_STANDBY_MASTER_LDO_PUP_FROM_POWERUP_AND_ISOLATION_CTRL(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_STANDBY_MASTER_LDO_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x827), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_MASTER_LDO_PUP_TO_POWERUP_AND_ISOLATION_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_SOFT_POR_BY_EVENTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x828))

#define GP_WB_WRITE_STANDBY_SOFT_POR_BY_EVENTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x828), (val))

/* Enable soft_por_by_bbpll when frequency out of range */
#define GP_WB_READ_STANDBY_SOFT_POR_BY_BBPLL_FOOR_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x828), 0)

#define GP_WB_GET_STANDBY_SOFT_POR_BY_BBPLL_FOOR_ENA_FROM_SOFT_POR_BY_EVENTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_STANDBY_SOFT_POR_BY_BBPLL_FOOR_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x828), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_SOFT_POR_BY_BBPLL_FOOR_ENA_TO_SOFT_POR_BY_EVENTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Enable soft_por_by_bbpll when phase out of lock */
#define GP_WB_READ_STANDBY_SOFT_POR_BY_BBPLL_POOL_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x828), 1)

#define GP_WB_GET_STANDBY_SOFT_POR_BY_BBPLL_POOL_ENA_FROM_SOFT_POR_BY_EVENTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_STANDBY_SOFT_POR_BY_BBPLL_POOL_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x828), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_SOFT_POR_BY_BBPLL_POOL_ENA_TO_SOFT_POR_BY_EVENTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Enable soft_por when the bod triggers */
#define GP_WB_READ_STANDBY_SOFT_POR_BY_BOD() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x828), 2)

#define GP_WB_GET_STANDBY_SOFT_POR_BY_BOD_FROM_SOFT_POR_BY_EVENTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_STANDBY_SOFT_POR_BY_BOD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x828), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_SOFT_POR_BY_BOD_TO_SOFT_POR_BY_EVENTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* Threshold for Ready to go to standby check. Number of 16 MHz clock cycles all need to be ready before going to standby. 0 = ready signals overlap for duration of one 16 MHz clock cycle */
#define GP_WB_READ_STANDBY_RTGTS_THRESHOLD() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x829))

#define GP_WB_WRITE_STANDBY_RTGTS_THRESHOLD(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x829), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_RTGTS_SW_0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82a))

#define GP_WB_WRITE_STANDBY_RTGTS_SW_0(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82a), (val))

/* Ready to go to standby overrule for es interrup from SW */
#define GP_WB_READ_STANDBY_RTGTS_SW_ES_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82a), 0)

#define GP_WB_GET_STANDBY_RTGTS_SW_ES_INTERRUPT_FROM_RTGTS_SW_0(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_STANDBY_RTGTS_SW_ES_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82a), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RTGTS_SW_ES_INTERRUPT_TO_RTGTS_SW_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Ready to go to standby overrule for es event handler from SW */
#define GP_WB_READ_STANDBY_RTGTS_SW_ES_EVENT_HANDLER() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82a)) >> 1) & 0x3F)

#define GP_WB_GET_STANDBY_RTGTS_SW_ES_EVENT_HANDLER_FROM_RTGTS_SW_0(tmp) \
        (((tmp) >> 1) & 0x3F)

#define GP_WB_WRITE_STANDBY_RTGTS_SW_ES_EVENT_HANDLER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82a), 0x7E, (val) << 1); \
        } while (0)

#define GP_WB_SET_STANDBY_RTGTS_SW_ES_EVENT_HANDLER_TO_RTGTS_SW_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_RTGTS_SW_1() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82b))

#define GP_WB_WRITE_STANDBY_RTGTS_SW_1(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82b), (val))

/* Ready to go to standby overrule for es timereference from SW */
#define GP_WB_READ_STANDBY_RTGTS_SW_ES_TIME_REFERENCE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82b)) & 0x7F)

#define GP_WB_GET_STANDBY_RTGTS_SW_ES_TIME_REFERENCE_FROM_RTGTS_SW_1(tmp) \
        ((tmp) & 0x7F)

#define GP_WB_WRITE_STANDBY_RTGTS_SW_ES_TIME_REFERENCE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82b), 0x7F, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RTGTS_SW_ES_TIME_REFERENCE_TO_RTGTS_SW_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          (tmp) &= 0x80; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Ready to go to standby overrule for the led driver from SW */
#define GP_WB_READ_STANDBY_RTGTS_SW_LED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82b), 7)

#define GP_WB_GET_STANDBY_RTGTS_SW_LED_FROM_RTGTS_SW_1(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_STANDBY_RTGTS_SW_LED(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82b), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RTGTS_SW_LED_TO_RTGTS_SW_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_RTGTS_SW_2() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82c))

#define GP_WB_WRITE_STANDBY_RTGTS_SW_2(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82c), (val))

/* Ready to go to standby overrule for dps from SW */
#define GP_WB_READ_STANDBY_RTGTS_SW_DPS() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82c)) & 0x03)

#define GP_WB_GET_STANDBY_RTGTS_SW_DPS_FROM_RTGTS_SW_2(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_STANDBY_RTGTS_SW_DPS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82c), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RTGTS_SW_DPS_TO_RTGTS_SW_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0xF8; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Ready to go to standby overrule for msi peripherals from SW */
#define GP_WB_READ_STANDBY_RTGTS_SW_MSI_PERIP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82c), 3)

#define GP_WB_GET_STANDBY_RTGTS_SW_MSI_PERIP_FROM_RTGTS_SW_2(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_STANDBY_RTGTS_SW_MSI_PERIP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82c), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RTGTS_SW_MSI_PERIP_TO_RTGTS_SW_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF3; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Ready to go to standby overrule for pending masked interrupts */
#define GP_WB_READ_STANDBY_RTGTS_SW_INTERRUPTS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82c), 4)

#define GP_WB_GET_STANDBY_RTGTS_SW_INTERRUPTS_FROM_RTGTS_SW_2(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_STANDBY_RTGTS_SW_INTERRUPTS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82c), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RTGTS_SW_INTERRUPTS_TO_RTGTS_SW_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEB; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Ready to go to standby overrule for the internal UC from SW */
#define GP_WB_READ_STANDBY_RTGTS_SW_INTUC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82c), 6)

#define GP_WB_GET_STANDBY_RTGTS_SW_INTUC_FROM_RTGTS_SW_2(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_STANDBY_RTGTS_SW_INTUC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82c), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RTGTS_SW_INTUC_TO_RTGTS_SW_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBB; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* Ready to go to standby overrule for the gpmicro processor from SW */
#define GP_WB_READ_STANDBY_RTGTS_SW_GPMICRO() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82c), 7)

#define GP_WB_GET_STANDBY_RTGTS_SW_GPMICRO_FROM_RTGTS_SW_2(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_STANDBY_RTGTS_SW_GPMICRO(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82c), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RTGTS_SW_GPMICRO_TO_RTGTS_SW_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7B; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_RTGTS_SW_3() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82d))

#define GP_WB_WRITE_STANDBY_RTGTS_SW_3(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82d), (val))

/* Ready to go to standby overrule for spi slave selected */
#define GP_WB_READ_STANDBY_RTGTS_SW_SPI_SL() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82d), 0)

#define GP_WB_GET_STANDBY_RTGTS_SW_SPI_SL_FROM_RTGTS_SW_3(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_STANDBY_RTGTS_SW_SPI_SL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82d), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RTGTS_SW_SPI_SL_TO_RTGTS_SW_3(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Ready to go to standby overrule for i2c slave selected */
#define GP_WB_READ_STANDBY_RTGTS_SW_I2C_SL() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82d), 1)

#define GP_WB_GET_STANDBY_RTGTS_SW_I2C_SL_FROM_RTGTS_SW_3(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_STANDBY_RTGTS_SW_I2C_SL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82d), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RTGTS_SW_I2C_SL_TO_RTGTS_SW_3(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Ready to go to standby overrule for gpio from SW */
#define GP_WB_READ_STANDBY_RTGTS_SW_GPIO() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82d), 2)

#define GP_WB_GET_STANDBY_RTGTS_SW_GPIO_FROM_RTGTS_SW_3(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_STANDBY_RTGTS_SW_GPIO(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82d), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RTGTS_SW_GPIO_TO_RTGTS_SW_3(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Ready to go to standby overrule for uart TX busy */
#define GP_WB_READ_STANDBY_RTGTS_SW_UART() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82d), 3)

#define GP_WB_GET_STANDBY_RTGTS_SW_UART_FROM_RTGTS_SW_3(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_STANDBY_RTGTS_SW_UART(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82d), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_RTGTS_SW_UART_TO_RTGTS_SW_3(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* SW ready to go to standby */
#define GP_WB_READ_STANDBY_RTGTS_SW() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82e), 0)

#define GP_WB_WRITE_STANDBY_RTGTS_SW(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82e), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_NVM_DPDOWN_CONFIG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82f))

#define GP_WB_WRITE_STANDBY_NVM_DPDOWN_CONFIG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82f), (val))

/* This bit indicates if we want to wait until the NVM macro is in its deep power down state, before actually going to standby (Putting this to 0 speeds up going to sleep) */
#define GP_WB_READ_STANDBY_WAIT_FOR_NVM_DPDOWN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82f), 0)

#define GP_WB_GET_STANDBY_WAIT_FOR_NVM_DPDOWN_FROM_NVM_DPDOWN_CONFIG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_STANDBY_WAIT_FOR_NVM_DPDOWN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82f), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WAIT_FOR_NVM_DPDOWN_TO_NVM_DPDOWN_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* This bit indicates if we want to enable the NVM (so in fact enable the read voltage and make sure the nvm state machine is in read mode) while the chip is in the active state */
#define GP_WB_READ_STANDBY_KEEP_NVM_ON_DURING_ACTIVE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82f), 1)

#define GP_WB_GET_STANDBY_KEEP_NVM_ON_DURING_ACTIVE_FROM_NVM_DPDOWN_CONFIG(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_STANDBY_KEEP_NVM_ON_DURING_ACTIVE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82f), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_KEEP_NVM_ON_DURING_ACTIVE_TO_NVM_DPDOWN_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* When set, write access to nvm will be prevented when the VDD is below BOD level. Default enabled and not retained, so needs to be explicitely disabled for NVM writing below BOD level */
#define GP_WB_READ_STANDBY_DISABLE_NVM_WRITE_UNDER_BOD() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82f), 2)

#define GP_WB_GET_STANDBY_DISABLE_NVM_WRITE_UNDER_BOD_FROM_NVM_DPDOWN_CONFIG(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_STANDBY_DISABLE_NVM_WRITE_UNDER_BOD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x82f), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_DISABLE_NVM_WRITE_UNDER_BOD_TO_NVM_DPDOWN_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x830))

/* Status of ready to go to standby for es interrupt */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_ES_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x830), 0)

#define GP_WB_GET_STANDBY_RTGTS_STATUS_ES_INTERRUPT_FROM_RTGTS_STATUS_0(tmp) \
        ((tmp) & 0x01)

/* Status of ready to go to standby for es event handler */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_ES_EVENT_HANDLER() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x830)) >> 1) & 0x3F)

#define GP_WB_GET_STANDBY_RTGTS_STATUS_ES_EVENT_HANDLER_FROM_RTGTS_STATUS_0(tmp) \
        (((tmp) >> 1) & 0x3F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_1() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x831))

/* Status of ready to go to standby for es time reference */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_ES_TIME_REFERENCE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x831)) & 0x7F)

#define GP_WB_GET_STANDBY_RTGTS_STATUS_ES_TIME_REFERENCE_FROM_RTGTS_STATUS_1(tmp) \
        ((tmp) & 0x7F)

/* Status of ready to go to standby for the led driver */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_LED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x831), 7)

#define GP_WB_GET_STANDBY_RTGTS_STATUS_LED_FROM_RTGTS_STATUS_1(tmp) \
        (((tmp) >> 7) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_2() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x832))

/* Status of ready to go to standby for dps */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_DPS() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x832)) & 0x03)

#define GP_WB_GET_STANDBY_RTGTS_STATUS_DPS_FROM_RTGTS_STATUS_2(tmp) \
        ((tmp) & 0x03)

/* Status of ready to go to standby for msi peripherals */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_MSI_PERIP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x832), 3)

#define GP_WB_GET_STANDBY_RTGTS_STATUS_MSI_PERIP_FROM_RTGTS_STATUS_2(tmp) \
        (((tmp) >> 3) & 0x01)

/* Status of ready to go to standby for interrupts peripheral */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_INTERRUPTS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x832), 4)

#define GP_WB_GET_STANDBY_RTGTS_STATUS_INTERRUPTS_FROM_RTGTS_STATUS_2(tmp) \
        (((tmp) >> 4) & 0x01)

/* Status of ready to go to standby for internal uc */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_INTUC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x832), 6)

#define GP_WB_GET_STANDBY_RTGTS_STATUS_INTUC_FROM_RTGTS_STATUS_2(tmp) \
        (((tmp) >> 6) & 0x01)

/* Status of ready to go to standby for gpmicro processor */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_GPMICRO() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x832), 7)

#define GP_WB_GET_STANDBY_RTGTS_STATUS_GPMICRO_FROM_RTGTS_STATUS_2(tmp) \
        (((tmp) >> 7) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_3() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x833))

/* Status of ready to go to standby for spi slave selected */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_SPI_SL() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x833), 0)

#define GP_WB_GET_STANDBY_RTGTS_STATUS_SPI_SL_FROM_RTGTS_STATUS_3(tmp) \
        ((tmp) & 0x01)

/* Status of ready to go to standby for i2c slave selected */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_I2C_SL() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x833), 1)

#define GP_WB_GET_STANDBY_RTGTS_STATUS_I2C_SL_FROM_RTGTS_STATUS_3(tmp) \
        (((tmp) >> 1) & 0x01)

/* Status of ready to go to standby for gpio */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_GPIO() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x833), 2)

#define GP_WB_GET_STANDBY_RTGTS_STATUS_GPIO_FROM_RTGTS_STATUS_3(tmp) \
        (((tmp) >> 2) & 0x01)

/* Status of ready to go to standby for uart TX busy */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_UART_0() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x833), 3)

#define GP_WB_GET_STANDBY_RTGTS_STATUS_UART_0_FROM_RTGTS_STATUS_3(tmp) \
        (((tmp) >> 3) & 0x01)

/* Status of ready to go to standby for uart TX busy */
#define GP_WB_READ_STANDBY_RTGTS_STATUS_UART_1() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x833), 4)

#define GP_WB_GET_STANDBY_RTGTS_STATUS_UART_1_FROM_RTGTS_STATUS_3(tmp) \
        (((tmp) >> 4) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_UNMASKED_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x834))

/* Interrupt event power on reset detected, set to 0x1 when detected */
#define GP_WB_READ_STANDBY_UNMASKED_PORD_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x834), 0)

#define GP_WB_GET_STANDBY_UNMASKED_PORD_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* Interrupt event Active state, set to 0x1 when detected */
#define GP_WB_READ_STANDBY_UNMASKED_ACTIVE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x834), 1)

#define GP_WB_GET_STANDBY_UNMASKED_ACTIVE_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* interrupt event when vlt_status = vlt_compare_value brown out */
#define GP_WB_READ_STANDBY_UNMASKED_VLT_STATUS_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x834), 2)

#define GP_WB_GET_STANDBY_UNMASKED_VLT_STATUS_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)


#define GP_WB_WRITE_STANDBY_CLR_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x835), (val))

/* Interrupt event clear power on reset detected by writing 0x1 */
#define GP_WB_STANDBY_CLR_PORD_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x835), 0x01)

#define GP_WB_SET_STANDBY_CLR_PORD_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Interrupt event clear Active state by writing 0x1 */
#define GP_WB_STANDBY_CLR_ACTIVE_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x835), 0x02)

#define GP_WB_SET_STANDBY_CLR_ACTIVE_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* vlt_status clear by writing 0x1 */
#define GP_WB_STANDBY_CLR_VLT_STATUS_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x835), 0x04)

#define GP_WB_SET_STANDBY_CLR_VLT_STATUS_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* clears the unmaskable backup/restore interrupt for backup condition */
#define GP_WB_STANDBY_CLR_BACKUP_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x835), 0x08)

#define GP_WB_SET_STANDBY_CLR_BACKUP_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_STANDBY_STATUS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x836))

/* State (for debug only) */
#define GP_WB_READ_STANDBY_STANDBY_CONTROLLER_STATE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x836)) & 0x03)

#define GP_WB_GET_STANDBY_STANDBY_CONTROLLER_STATE_FROM_STANDBY_STATUS(tmp) \
        ((tmp) & 0x03)

/* Is 1 when vddb is below vlt threshold (which is 1.8V fixed at this time) */
#define GP_WB_READ_STANDBY_VLT_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x836), 2)

#define GP_WB_GET_STANDBY_VLT_STATUS_FROM_STANDBY_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_LICENSE_ITF() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x838))

#define GP_WB_WRITE_STANDBY_LICENSE_ITF(val) \
      GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x838), (val))

/* sets the nvm size (use type for encoding) */
#define GP_WB_READ_STANDBY_NVM_SIZE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x838)) & 0x07)

#define GP_WB_GET_STANDBY_NVM_SIZE_FROM_LICENSE_ITF(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_STANDBY_NVM_SIZE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x838), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_NVM_SIZE_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0xFFFFFFF8; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Protect read access to lower part (first 128 bytes) of Security Section ROM (last 256 bytes) => Bootloader will apply this in User, Bare Access and Debug Mode, such that keys are only accessible in ROM Sec Boot */
#define GP_WB_READ_STANDBY_READ_PROTECT_ROM_SECURITY_LOWER() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x838), 3)

#define GP_WB_GET_STANDBY_READ_PROTECT_ROM_SECURITY_LOWER_FROM_LICENSE_ITF(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_STANDBY_READ_PROTECT_ROM_SECURITY_LOWER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x838), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_READ_PROTECT_ROM_SECURITY_LOWER_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFF7; \
          (tmp) |= (((UInt32)(val)) << 3); \
        } while (0)

/* Write lock info page 0 (Qorvo Area) in user, bare access and debug mode (NVR sector 0). Blocks the erasing of the whole NVR (chip erase) and of the NVR sector 0 (sector erase) when set. */
#define GP_WB_READ_STANDBY_WRITE_LOCK_INF_PAGE_0() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x838), 4)

#define GP_WB_GET_STANDBY_WRITE_LOCK_INF_PAGE_0_FROM_LICENSE_ITF(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_INF_PAGE_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x838), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_INF_PAGE_0_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFEF; \
          (tmp) |= (((UInt32)(val)) << 4); \
        } while (0)

/* Write lock info page 1 (Customer Area) in user, bare access and debug mode (NVR sector 0). Lock has no impact on erase operations. */
#define GP_WB_READ_STANDBY_WRITE_LOCK_INF_PAGE_1() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x838), 5)

#define GP_WB_GET_STANDBY_WRITE_LOCK_INF_PAGE_1_FROM_LICENSE_ITF(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_INF_PAGE_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x838), 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_INF_PAGE_1_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFDF; \
          (tmp) |= (((UInt32)(val)) << 5); \
        } while (0)

/* Write lock info page 2 (Device Attestation A) in user, bare access and debug mode (NVR sector 1). Blocks the erasing of NVR sector 1 (sector erase) when set. */
#define GP_WB_READ_STANDBY_WRITE_LOCK_INF_PAGE_2() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x838), 6)

#define GP_WB_GET_STANDBY_WRITE_LOCK_INF_PAGE_2_FROM_LICENSE_ITF(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_INF_PAGE_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x838), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_INF_PAGE_2_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFBF; \
          (tmp) |= (((UInt32)(val)) << 6); \
        } while (0)

/* Write lock info page 3 (Device Attestation B)  in user, bare access and debug mode (NVR sector 1). Lock has no impact on erase operations. */
#define GP_WB_READ_STANDBY_WRITE_LOCK_INF_PAGE_3() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x838), 7)

#define GP_WB_GET_STANDBY_WRITE_LOCK_INF_PAGE_3_FROM_LICENSE_ITF(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_INF_PAGE_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x838), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_INF_PAGE_3_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFF7F; \
          (tmp) |= (((UInt32)(val)) << 7); \
        } while (0)

/* Disables the spi slave interface */
#define GP_WB_READ_STANDBY_DISABLE_SPI() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x839), 0)

#define GP_WB_GET_STANDBY_DISABLE_SPI_FROM_LICENSE_ITF(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_STANDBY_DISABLE_SPI(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x839), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_DISABLE_SPI_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFEFF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* Disables the i2c slave interface */
#define GP_WB_READ_STANDBY_DISABLE_I2C() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x839), 1)

#define GP_WB_GET_STANDBY_DISABLE_I2C_FROM_LICENSE_ITF(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_STANDBY_DISABLE_I2C(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x839), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_DISABLE_I2C_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFDFF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* Disables the spi master interface */
#define GP_WB_READ_STANDBY_DISABLE_SPI_M() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x839), 2)

#define GP_WB_GET_STANDBY_DISABLE_SPI_M_FROM_LICENSE_ITF(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_STANDBY_DISABLE_SPI_M(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x839), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_DISABLE_SPI_M_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFBFF; \
          (tmp) |= (((UInt32)(val)) << 10); \
        } while (0)

/* Disables the i2c master interface */
#define GP_WB_READ_STANDBY_DISABLE_I2C_M() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x839), 3)

#define GP_WB_GET_STANDBY_DISABLE_I2C_M_FROM_LICENSE_ITF(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_STANDBY_DISABLE_I2C_M(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x839), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_DISABLE_I2C_M_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFF7FF; \
          (tmp) |= (((UInt32)(val)) << 11); \
        } while (0)

/* Disables the ir block */
#define GP_WB_READ_STANDBY_DISABLE_IR() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x839), 4)

#define GP_WB_GET_STANDBY_DISABLE_IR_FROM_LICENSE_ITF(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_STANDBY_DISABLE_IR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x839), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_DISABLE_IR_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFEFFF; \
          (tmp) |= (((UInt32)(val)) << 12); \
        } while (0)

/* Disables the adc block */
#define GP_WB_READ_STANDBY_DISABLE_ADC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x839), 6)

#define GP_WB_GET_STANDBY_DISABLE_ADC_FROM_LICENSE_ITF(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_STANDBY_DISABLE_ADC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x839), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_DISABLE_ADC_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFBFFF; \
          (tmp) |= (((UInt32)(val)) << 14); \
        } while (0)

/* Protect read access to upper part (last 128 bytes) of Security Section ROM (last 256 bytes) => Bootloader will apply this in User, Bare Access and Debug Mode, such that keys are only accessible in ROM Sec Boot */
#define GP_WB_READ_STANDBY_READ_PROTECT_ROM_SECURITY_UPPER() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x839), 7)

#define GP_WB_GET_STANDBY_READ_PROTECT_ROM_SECURITY_UPPER_FROM_LICENSE_ITF(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_STANDBY_READ_PROTECT_ROM_SECURITY_UPPER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x839), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_READ_PROTECT_ROM_SECURITY_UPPER_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFF7FFF; \
          (tmp) |= (((UInt32)(val)) << 15); \
        } while (0)

/* Disables the i2s master interface */
#define GP_WB_READ_STANDBY_DISABLE_I2S_M() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83a), 0)

#define GP_WB_GET_STANDBY_DISABLE_I2S_M_FROM_LICENSE_ITF(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_STANDBY_DISABLE_I2S_M(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83a), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_DISABLE_I2S_M_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFEFFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* Disables the PWM block */
#define GP_WB_READ_STANDBY_DISABLE_PWM() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83a), 1)

#define GP_WB_GET_STANDBY_DISABLE_PWM_FROM_LICENSE_ITF(tmp) \
        (((tmp) >> 17) & 0x01)

#define GP_WB_WRITE_STANDBY_DISABLE_PWM(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83a), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_DISABLE_PWM_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFDFFFF; \
          (tmp) |= (((UInt32)(val)) << 17); \
        } while (0)

/* Disables the asp block */
#define GP_WB_READ_STANDBY_DISABLE_ASP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83a), 2)

#define GP_WB_GET_STANDBY_DISABLE_ASP_FROM_LICENSE_ITF(tmp) \
        (((tmp) >> 18) & 0x01)

#define GP_WB_WRITE_STANDBY_DISABLE_ASP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83a), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_DISABLE_ASP_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFBFFFF; \
          (tmp) |= (((UInt32)(val)) << 18); \
        } while (0)

/* Disables the direct security processor interface */
#define GP_WB_READ_STANDBY_DISABLE_SECPROC_MRI() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83a), 3)

#define GP_WB_GET_STANDBY_DISABLE_SECPROC_MRI_FROM_LICENSE_ITF(tmp) \
        (((tmp) >> 19) & 0x01)

#define GP_WB_WRITE_STANDBY_DISABLE_SECPROC_MRI(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83a), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_DISABLE_SECPROC_MRI_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFF7FFFF; \
          (tmp) |= (((UInt32)(val)) << 19); \
        } while (0)

/* Disables the concurrent listening feature */
#define GP_WB_READ_STANDBY_DISABLE_CONCURRENT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83a), 4)

#define GP_WB_GET_STANDBY_DISABLE_CONCURRENT_FROM_LICENSE_ITF(tmp) \
        (((tmp) >> 20) & 0x01)

#define GP_WB_WRITE_STANDBY_DISABLE_CONCURRENT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83a), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_DISABLE_CONCURRENT_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFEFFFFF; \
          (tmp) |= (((UInt32)(val)) << 20); \
        } while (0)

/* Disables the BLE high data rate */
#define GP_WB_READ_STANDBY_DISABLE_BLE_HDR() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83a), 5)

#define GP_WB_GET_STANDBY_DISABLE_BLE_HDR_FROM_LICENSE_ITF(tmp) \
        (((tmp) >> 21) & 0x01)

#define GP_WB_WRITE_STANDBY_DISABLE_BLE_HDR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83a), 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_DISABLE_BLE_HDR_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFDFFFFF; \
          (tmp) |= (((UInt32)(val)) << 21); \
        } while (0)

/* Disables the 802.15.4 functionality */
#define GP_WB_READ_STANDBY_DISABLE_802154() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83a), 6)

#define GP_WB_GET_STANDBY_DISABLE_802154_FROM_LICENSE_ITF(tmp) \
        (((tmp) >> 22) & 0x01)

#define GP_WB_WRITE_STANDBY_DISABLE_802154(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83a), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_DISABLE_802154_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFBFFFFF; \
          (tmp) |= (((UInt32)(val)) << 22); \
        } while (0)

/* Disables the BLE functionality */
#define GP_WB_READ_STANDBY_DISABLE_BLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83a), 7)

#define GP_WB_GET_STANDBY_DISABLE_BLE_FROM_LICENSE_ITF(tmp) \
        (((tmp) >> 23) & 0x01)

#define GP_WB_WRITE_STANDBY_DISABLE_BLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83a), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_DISABLE_BLE_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7FFFFF; \
          (tmp) |= (((UInt32)(val)) << 23); \
        } while (0)

/* Disables listening to multiple channels. But keeps attenuator diversity through slot hopping alive */
#define GP_WB_READ_STANDBY_DISABLE_MULTI_CHANNEL() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83b), 0)

#define GP_WB_GET_STANDBY_DISABLE_MULTI_CHANNEL_FROM_LICENSE_ITF(tmp) \
        (((tmp) >> 24) & 0x01)

#define GP_WB_WRITE_STANDBY_DISABLE_MULTI_CHANNEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83b), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_DISABLE_MULTI_CHANNEL_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFEFFFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)

/* Disables the attenuator diversity feature */
#define GP_WB_READ_STANDBY_DISABLE_ATTENUATOR_DIV() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83b), 1)

#define GP_WB_GET_STANDBY_DISABLE_ATTENUATOR_DIV_FROM_LICENSE_ITF(tmp) \
        (((tmp) >> 25) & 0x01)

#define GP_WB_WRITE_STANDBY_DISABLE_ATTENUATOR_DIV(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83b), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_DISABLE_ATTENUATOR_DIV_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFDFFFFFF; \
          (tmp) |= (((UInt32)(val)) << 25); \
        } while (0)

/* Locks the number of supported pans to what is set by the cm restore */
#define GP_WB_READ_STANDBY_LOCK_MULTI_PAN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83b), 2)

#define GP_WB_GET_STANDBY_LOCK_MULTI_PAN_FROM_LICENSE_ITF(tmp) \
        (((tmp) >> 26) & 0x01)

#define GP_WB_WRITE_STANDBY_LOCK_MULTI_PAN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83b), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_LOCK_MULTI_PAN_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFBFFFFFF; \
          (tmp) |= (((UInt32)(val)) << 26); \
        } while (0)

/* Protect read access to upper part of NVR page 0 (0x140 and above) => Bootloader will apply this in User, Bare Access and Debug Mode (e.g. for symmetric keys that do not need to be accessible to MCU, but are used directly by AES engine) */
#define GP_WB_READ_STANDBY_READ_PROTECT_INF_PAGE_0_UPPER() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83b), 3)

#define GP_WB_GET_STANDBY_READ_PROTECT_INF_PAGE_0_UPPER_FROM_LICENSE_ITF(tmp) \
        (((tmp) >> 27) & 0x01)

#define GP_WB_WRITE_STANDBY_READ_PROTECT_INF_PAGE_0_UPPER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83b), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_READ_PROTECT_INF_PAGE_0_UPPER_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 27); \
        } while (0)

/* Protect read access to upper part of NVR page 0 (0x200 to 0x27F) => Bootloader will apply this in Bare Access and Debug Mode, NOT IN USER MODE (for private keys that need to be accessible to MCU) */
#define GP_WB_READ_STANDBY_READ_PROTECT_INF_PAGE_1_LOWER() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83b), 4)

#define GP_WB_GET_STANDBY_READ_PROTECT_INF_PAGE_1_LOWER_FROM_LICENSE_ITF(tmp) \
        (((tmp) >> 28) & 0x01)

#define GP_WB_WRITE_STANDBY_READ_PROTECT_INF_PAGE_1_LOWER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83b), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_READ_PROTECT_INF_PAGE_1_LOWER_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEFFFFFFF; \
          (tmp) |= (((UInt32)(val)) << 28); \
        } while (0)

/* Blocks all write access to nvr_cfg by forcing flash lck_cfg bit */
#define GP_WB_READ_STANDBY_LOCK_NVR_CFG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83b), 5)

#define GP_WB_GET_STANDBY_LOCK_NVR_CFG_FROM_LICENSE_ITF(tmp) \
        (((tmp) >> 29) & 0x01)

#define GP_WB_WRITE_STANDBY_LOCK_NVR_CFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83b), 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_LOCK_NVR_CFG_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDFFFFFFF; \
          (tmp) |= (((UInt32)(val)) << 29); \
        } while (0)

/* Blocks all access to flash testmodes */
#define GP_WB_READ_STANDBY_LOCK_FLASH_TM() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83b), 6)

#define GP_WB_GET_STANDBY_LOCK_FLASH_TM_FROM_LICENSE_ITF(tmp) \
        (((tmp) >> 30) & 0x01)

#define GP_WB_WRITE_STANDBY_LOCK_FLASH_TM(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83b), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_LOCK_FLASH_TM_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBFFFFFFF; \
          (tmp) |= (((UInt32)(val)) << 30); \
        } while (0)

/* locks the interface to the license (when triggered, no more license updates can happen) */
#define GP_WB_READ_STANDBY_LOCK_LICENSE_ITF() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83b), 7)

#define GP_WB_GET_STANDBY_LOCK_LICENSE_ITF_FROM_LICENSE_ITF(tmp) \
        (((tmp) >> 31) & 0x01)

#define GP_WB_WRITE_STANDBY_LOCK_LICENSE_ITF(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83b), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_LOCK_LICENSE_ITF_TO_LICENSE_ITF(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7FFFFFFF; \
          (tmp) |= (((UInt32)(val)) << 31); \
        } while (0)


/* flash sector word address that needs to be remapped. This sector will be remapped to redundancy sector 0 */
#define GP_WB_READ_STANDBY_NVM_SECTOR_REMAP_ENTRY_0_INP_ADDR() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83c))

#define GP_WB_WRITE_STANDBY_NVM_SECTOR_REMAP_ENTRY_0_INP_ADDR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83c), (val)); \
        } while (0)


/* flash sector word address that needs to be remapped. This sector will be remapped to redundancy sector 1 */
#define GP_WB_READ_STANDBY_NVM_SECTOR_REMAP_ENTRY_1_INP_ADDR() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83e))

#define GP_WB_WRITE_STANDBY_NVM_SECTOR_REMAP_ENTRY_1_INP_ADDR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x83e), (val)); \
        } while (0)


/* flash sector word address that needs to be remapped. This sector will be remapped to redundancy sector 2 */
#define GP_WB_READ_STANDBY_NVM_SECTOR_REMAP_ENTRY_2_INP_ADDR() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x840))

#define GP_WB_WRITE_STANDBY_NVM_SECTOR_REMAP_ENTRY_2_INP_ADDR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x840), (val)); \
        } while (0)


/* flash sector word address that needs to be remapped. This sector will be remapped to redundancy sector 3 */
#define GP_WB_READ_STANDBY_NVM_SECTOR_REMAP_ENTRY_3_INP_ADDR() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x842))

#define GP_WB_WRITE_STANDBY_NVM_SECTOR_REMAP_ENTRY_3_INP_ADDR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x842), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_NVM_BLOCK_REMAP_ENTRIES() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x844))

#define GP_WB_WRITE_STANDBY_NVM_BLOCK_REMAP_ENTRIES(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x844), (val))

/* Does the logical to physical mapping of the first 256kB of logical addresses */
#define GP_WB_READ_STANDBY_NVM_BLOCK_REMAP_ENTRY_0() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x844)) & 0x03)

#define GP_WB_GET_STANDBY_NVM_BLOCK_REMAP_ENTRY_0_FROM_NVM_BLOCK_REMAP_ENTRIES(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_STANDBY_NVM_BLOCK_REMAP_ENTRY_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x844), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_NVM_BLOCK_REMAP_ENTRY_0_TO_NVM_BLOCK_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0xFC; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Does the logical to physical mapping of the second 256kB of logical addresses */
#define GP_WB_READ_STANDBY_NVM_BLOCK_REMAP_ENTRY_1() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x844)) >> 2) & 0x03)

#define GP_WB_GET_STANDBY_NVM_BLOCK_REMAP_ENTRY_1_FROM_NVM_BLOCK_REMAP_ENTRIES(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_STANDBY_NVM_BLOCK_REMAP_ENTRY_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x844), 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_STANDBY_NVM_BLOCK_REMAP_ENTRY_1_TO_NVM_BLOCK_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0xF3; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Does the logical to physical mapping of the third 256kB of logical addresses */
#define GP_WB_READ_STANDBY_NVM_BLOCK_REMAP_ENTRY_2() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x844)) >> 4) & 0x03)

#define GP_WB_GET_STANDBY_NVM_BLOCK_REMAP_ENTRY_2_FROM_NVM_BLOCK_REMAP_ENTRIES(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_STANDBY_NVM_BLOCK_REMAP_ENTRY_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x844), 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_STANDBY_NVM_BLOCK_REMAP_ENTRY_2_TO_NVM_BLOCK_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0xCF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Does the logical to physical mapping of the fourth 256kB of logical addresses */
#define GP_WB_READ_STANDBY_NVM_BLOCK_REMAP_ENTRY_3() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x844)) >> 6) & 0x03)

#define GP_WB_GET_STANDBY_NVM_BLOCK_REMAP_ENTRY_3_FROM_NVM_BLOCK_REMAP_ENTRIES(tmp) \
        (((tmp) >> 6) & 0x03)

#define GP_WB_WRITE_STANDBY_NVM_BLOCK_REMAP_ENTRY_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x844), 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_STANDBY_NVM_BLOCK_REMAP_ENTRY_3_TO_NVM_BLOCK_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_LOCK_NVM_REMAP_ENTRIES() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x846))

#define GP_WB_WRITE_STANDBY_LOCK_NVM_REMAP_ENTRIES(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x846), (val))

/* Locks the sector remap entry, and makes it valid. Setting this property to true, will also lock the the prop itself */
#define GP_WB_READ_STANDBY_LOCK_NVM_SECTOR_REMAP_ENTRY_0() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x846), 0)

#define GP_WB_GET_STANDBY_LOCK_NVM_SECTOR_REMAP_ENTRY_0_FROM_LOCK_NVM_REMAP_ENTRIES(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_STANDBY_LOCK_NVM_SECTOR_REMAP_ENTRY_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x846), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_LOCK_NVM_SECTOR_REMAP_ENTRY_0_TO_LOCK_NVM_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FE; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Locks the sector remap entry, and makes it valid. Setting this property to true, will also lock the the prop itself */
#define GP_WB_READ_STANDBY_LOCK_NVM_SECTOR_REMAP_ENTRY_1() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x846), 1)

#define GP_WB_GET_STANDBY_LOCK_NVM_SECTOR_REMAP_ENTRY_1_FROM_LOCK_NVM_REMAP_ENTRIES(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_STANDBY_LOCK_NVM_SECTOR_REMAP_ENTRY_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x846), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_LOCK_NVM_SECTOR_REMAP_ENTRY_1_TO_LOCK_NVM_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FD; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

/* Locks the sector remap entry, and makes it valid. Setting this property to true, will also lock the the prop itself */
#define GP_WB_READ_STANDBY_LOCK_NVM_SECTOR_REMAP_ENTRY_2() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x846), 2)

#define GP_WB_GET_STANDBY_LOCK_NVM_SECTOR_REMAP_ENTRY_2_FROM_LOCK_NVM_REMAP_ENTRIES(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_STANDBY_LOCK_NVM_SECTOR_REMAP_ENTRY_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x846), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_LOCK_NVM_SECTOR_REMAP_ENTRY_2_TO_LOCK_NVM_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FB; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* Locks the sector remap entry, and makes it valid. Setting this property to true, will also lock the the prop itself */
#define GP_WB_READ_STANDBY_LOCK_NVM_SECTOR_REMAP_ENTRY_3() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x846), 3)

#define GP_WB_GET_STANDBY_LOCK_NVM_SECTOR_REMAP_ENTRY_3_FROM_LOCK_NVM_REMAP_ENTRIES(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_STANDBY_LOCK_NVM_SECTOR_REMAP_ENTRY_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x846), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_LOCK_NVM_SECTOR_REMAP_ENTRY_3_TO_LOCK_NVM_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03F7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

/* locks the block remapping fields (including this lock field itself) */
#define GP_WB_READ_STANDBY_LOCK_NVM_BLOCK_REMAP_ENTRIES() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x846), 4)

#define GP_WB_GET_STANDBY_LOCK_NVM_BLOCK_REMAP_ENTRIES_FROM_LOCK_NVM_REMAP_ENTRIES(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_STANDBY_LOCK_NVM_BLOCK_REMAP_ENTRIES(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x846), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_LOCK_NVM_BLOCK_REMAP_ENTRIES_TO_LOCK_NVM_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03EF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* Write locks the first redundancy sector (including this lock field itself) */
#define GP_WB_READ_STANDBY_LOCK_NVM_REDUNDANCY_0() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x846), 5)

#define GP_WB_GET_STANDBY_LOCK_NVM_REDUNDANCY_0_FROM_LOCK_NVM_REMAP_ENTRIES(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_STANDBY_LOCK_NVM_REDUNDANCY_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x846), 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_LOCK_NVM_REDUNDANCY_0_TO_LOCK_NVM_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03DF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

/* Write locks the second redundancy sector(including this lock field itself) */
#define GP_WB_READ_STANDBY_LOCK_NVM_REDUNDANCY_1() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x846), 6)

#define GP_WB_GET_STANDBY_LOCK_NVM_REDUNDANCY_1_FROM_LOCK_NVM_REMAP_ENTRIES(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_STANDBY_LOCK_NVM_REDUNDANCY_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x846), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_LOCK_NVM_REDUNDANCY_1_TO_LOCK_NVM_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03BF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

/* Write locks the third redundancy sector (including this lock field itself) */
#define GP_WB_READ_STANDBY_LOCK_NVM_REDUNDANCY_2() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x846), 7)

#define GP_WB_GET_STANDBY_LOCK_NVM_REDUNDANCY_2_FROM_LOCK_NVM_REMAP_ENTRIES(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_STANDBY_LOCK_NVM_REDUNDANCY_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x846), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_LOCK_NVM_REDUNDANCY_2_TO_LOCK_NVM_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x037F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* Write locks the fourth redundancy sector(inclsuding this lock field itself) */
#define GP_WB_READ_STANDBY_LOCK_NVM_REDUNDANCY_3() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x847), 0)

#define GP_WB_GET_STANDBY_LOCK_NVM_REDUNDANCY_3_FROM_LOCK_NVM_REMAP_ENTRIES(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_STANDBY_LOCK_NVM_REDUNDANCY_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x847), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_LOCK_NVM_REDUNDANCY_3_TO_LOCK_NVM_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* blocks the fact that the uController can use a 2MByte shifted fixed view of the flash for code execution */
#define GP_WB_READ_STANDBY_BLOCK_ALTERNATE_CODE_FLASH_VIEW() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x847), 1)

#define GP_WB_GET_STANDBY_BLOCK_ALTERNATE_CODE_FLASH_VIEW_FROM_LOCK_NVM_REMAP_ENTRIES(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_STANDBY_BLOCK_ALTERNATE_CODE_FLASH_VIEW(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x847), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_BLOCK_ALTERNATE_CODE_FLASH_VIEW_TO_LOCK_NVM_REMAP_ENTRIES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE() \
        GP_WB_READ_U64(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x848))

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE(val) \
      GP_WB_WRITE_U64(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x848), (val))

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 0 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_0() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x848), 0)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_0_FROM_WRITE_LOCK_FINE(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x848), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_0_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFFFFFE; \
          (tmp) |= ((UInt64)(val)); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 2 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_1() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x848), 1)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_1_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x848), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_1_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFFFFFD; \
          (tmp) |= (((UInt64)(val)) << 1); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 4 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_2() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x848), 2)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_2_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x848), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_2_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFFFFFB; \
          (tmp) |= (((UInt64)(val)) << 2); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 6 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_3() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x848), 3)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_3_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x848), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_3_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFFFFF7; \
          (tmp) |= (((UInt64)(val)) << 3); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 8 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_4() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x848), 4)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_4_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x848), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_4_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFFFFEF; \
          (tmp) |= (((UInt64)(val)) << 4); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 10 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_5() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x848), 5)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_5_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x848), 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_5_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFFFFDF; \
          (tmp) |= (((UInt64)(val)) << 5); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 12 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_6() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x848), 6)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_6_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_6(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x848), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_6_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFFFFBF; \
          (tmp) |= (((UInt64)(val)) << 6); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 14 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_7() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x848), 7)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_7_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_7(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x848), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_7_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFFFF7F; \
          (tmp) |= (((UInt64)(val)) << 7); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 16 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_8() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x849), 0)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_8_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_8(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x849), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_8_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFFFEFF; \
          (tmp) |= (((UInt64)(val)) << 8); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 18 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_9() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x849), 1)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_9_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_9(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x849), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_9_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFFFDFF; \
          (tmp) |= (((UInt64)(val)) << 9); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 20 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_10() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x849), 2)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_10_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_10(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x849), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_10_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFFFBFF; \
          (tmp) |= (((UInt64)(val)) << 10); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 22 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_11() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x849), 3)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_11_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_11(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x849), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_11_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFFF7FF; \
          (tmp) |= (((UInt64)(val)) << 11); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 24 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_12() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x849), 4)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_12_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_12(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x849), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_12_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFFEFFF; \
          (tmp) |= (((UInt64)(val)) << 12); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 26 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_13() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x849), 5)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_13_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_13(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x849), 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_13_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFFDFFF; \
          (tmp) |= (((UInt64)(val)) << 13); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 28 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_14() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x849), 6)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_14_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_14(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x849), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_14_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFFBFFF; \
          (tmp) |= (((UInt64)(val)) << 14); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 30 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_15() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x849), 7)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_15_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_15(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x849), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_15_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFF7FFF; \
          (tmp) |= (((UInt64)(val)) << 15); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 256 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_16() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84a), 0)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_16_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_16(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84a), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_16_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFEFFFF; \
          (tmp) |= (((UInt64)(val)) << 16); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 258 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_17() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84a), 1)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_17_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 17) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_17(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84a), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_17_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFDFFFF; \
          (tmp) |= (((UInt64)(val)) << 17); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 260 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_18() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84a), 2)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_18_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 18) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_18(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84a), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_18_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFBFFFF; \
          (tmp) |= (((UInt64)(val)) << 18); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 262 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_19() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84a), 3)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_19_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 19) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_19(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84a), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_19_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFF7FFFF; \
          (tmp) |= (((UInt64)(val)) << 19); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 264 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_20() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84a), 4)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_20_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 20) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_20(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84a), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_20_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFEFFFFF; \
          (tmp) |= (((UInt64)(val)) << 20); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 266 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_21() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84a), 5)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_21_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 21) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_21(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84a), 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_21_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFDFFFFF; \
          (tmp) |= (((UInt64)(val)) << 21); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 268 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_22() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84a), 6)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_22_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 22) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_22(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84a), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_22_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFBFFFFF; \
          (tmp) |= (((UInt64)(val)) << 22); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 270 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_23() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84a), 7)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_23_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 23) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_23(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84a), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_23_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFF7FFFFF; \
          (tmp) |= (((UInt64)(val)) << 23); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 272 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_24() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84b), 0)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_24_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 24) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_24(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84b), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_24_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFEFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 24); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 274 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_25() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84b), 1)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_25_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 25) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_25(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84b), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_25_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFDFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 25); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 276 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_26() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84b), 2)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_26_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 26) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_26(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84b), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_26_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFBFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 26); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 278 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_27() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84b), 3)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_27_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 27) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_27(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84b), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_27_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFF7FFFFFF; \
          (tmp) |= (((UInt64)(val)) << 27); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 280 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_28() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84b), 4)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_28_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 28) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_28(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84b), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_28_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFEFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 28); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 282 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_29() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84b), 5)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_29_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 29) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_29(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84b), 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_29_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFDFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 29); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 284 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_30() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84b), 6)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_30_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 30) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_30(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84b), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_30_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFBFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 30); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 286 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_31() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84b), 7)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_31_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 31) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_31(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84b), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_31_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFF7FFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 31); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 512 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_32() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84c), 0)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_32_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 32) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_32(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84c), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_32_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFEFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 32); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 514 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_33() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84c), 1)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_33_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 33) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_33(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84c), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_33_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFDFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 33); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 516 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_34() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84c), 2)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_34_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 34) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_34(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84c), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_34_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFBFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 34); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 518 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_35() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84c), 3)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_35_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 35) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_35(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84c), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_35_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFF7FFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 35); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 520 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_36() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84c), 4)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_36_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 36) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_36(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84c), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_36_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFEFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 36); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 522 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_37() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84c), 5)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_37_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 37) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_37(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84c), 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_37_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFDFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 37); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 524 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_38() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84c), 6)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_38_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 38) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_38(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84c), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_38_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFBFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 38); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 526 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_39() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84c), 7)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_39_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 39) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_39(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84c), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_39_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFF7FFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 39); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 528 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_40() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84d), 0)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_40_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 40) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_40(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84d), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_40_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFEFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 40); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 530 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_41() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84d), 1)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_41_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 41) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_41(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84d), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_41_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFDFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 41); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 532 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_42() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84d), 2)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_42_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 42) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_42(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84d), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_42_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFBFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 42); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 534 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_43() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84d), 3)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_43_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 43) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_43(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84d), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_43_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFF7FFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 43); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 536 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_44() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84d), 4)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_44_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 44) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_44(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84d), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_44_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFEFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 44); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 538 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_45() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84d), 5)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_45_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 45) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_45(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84d), 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_45_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFDFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 45); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 540 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_46() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84d), 6)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_46_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 46) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_46(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84d), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_46_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFBFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 46); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 542 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_47() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84d), 7)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_47_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 47) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_47(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84d), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_47_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFF7FFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 47); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 768 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_48() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84e), 0)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_48_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 48) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_48(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84e), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_48_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFEFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 48); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 770 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_49() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84e), 1)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_49_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 49) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_49(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84e), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_49_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFDFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 49); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 772 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_50() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84e), 2)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_50_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 50) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_50(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84e), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_50_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFBFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 50); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 774 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_51() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84e), 3)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_51_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 51) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_51(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84e), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_51_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFF7FFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 51); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 776 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_52() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84e), 4)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_52_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 52) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_52(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84e), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_52_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFEFFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 52); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 778 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_53() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84e), 5)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_53_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 53) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_53(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84e), 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_53_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFDFFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 53); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 780 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_54() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84e), 6)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_54_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 54) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_54(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84e), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_54_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFBFFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 54); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 782 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_55() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84e), 7)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_55_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 55) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_55(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84e), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_55_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7FFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 55); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 784 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_56() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84f), 0)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_56_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 56) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_56(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84f), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_56_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFEFFFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 56); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 786 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_57() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84f), 1)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_57_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 57) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_57(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84f), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_57_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFDFFFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 57); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 788 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_58() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84f), 2)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_58_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 58) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_58(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84f), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_58_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFBFFFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 58); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 790 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_59() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84f), 3)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_59_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 59) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_59(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84f), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_59_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7FFFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 59); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 792 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_60() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84f), 4)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_60_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 60) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_60(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84f), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_60_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEFFFFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 60); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 794 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_61() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84f), 5)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_61_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 61) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_61(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84f), 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_61_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDFFFFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 61); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 796 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_62() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84f), 6)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_62_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 62) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_62(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84f), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_62_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBFFFFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 62); \
        } while (0)

/* Each bit write locks a 2 kBytes section of the flash. Section can not be unlocked, once locked. flash address Offset is 798 kByte */
#define GP_WB_READ_STANDBY_WRITE_LOCK_FINE_63() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84f), 7)

#define GP_WB_GET_STANDBY_WRITE_LOCK_FINE_63_FROM_WRITE_LOCK_FINE(tmp) \
        (((tmp) >> 63) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_FINE_63(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x84f), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_FINE_63_TO_WRITE_LOCK_FINE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7FFFFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 63); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_WRITE_LOCK_COARSE() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x850))

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_COARSE(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x850), (val))

/* write locks the flash section 32kB  to  64kB. Section can not be unlocked, once locked */
#define GP_WB_READ_STANDBY_WRITE_LOCK_COARSE_LOW_0() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x850), 0)

#define GP_WB_GET_STANDBY_WRITE_LOCK_COARSE_LOW_0_FROM_WRITE_LOCK_COARSE(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_COARSE_LOW_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x850), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_COARSE_LOW_0_TO_WRITE_LOCK_COARSE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFE; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* write locks the flash section 64kB  to 128kB. Section can not be unlocked, once locked */
#define GP_WB_READ_STANDBY_WRITE_LOCK_COARSE_MID_0() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x850), 1)

#define GP_WB_GET_STANDBY_WRITE_LOCK_COARSE_MID_0_FROM_WRITE_LOCK_COARSE(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_COARSE_MID_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x850), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_COARSE_MID_0_TO_WRITE_LOCK_COARSE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFD; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

/* write locks the flash section 128kB to 256kB. Section can not be unlocked, once locked */
#define GP_WB_READ_STANDBY_WRITE_LOCK_COARSE_HIGH_0() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x850), 2)

#define GP_WB_GET_STANDBY_WRITE_LOCK_COARSE_HIGH_0_FROM_WRITE_LOCK_COARSE(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_COARSE_HIGH_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x850), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_COARSE_HIGH_0_TO_WRITE_LOCK_COARSE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFB; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* write locks the flash section 288kB to 320kB. Section can not be unlocked, once locked */
#define GP_WB_READ_STANDBY_WRITE_LOCK_COARSE_LOW_1() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x850), 3)

#define GP_WB_GET_STANDBY_WRITE_LOCK_COARSE_LOW_1_FROM_WRITE_LOCK_COARSE(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_COARSE_LOW_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x850), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_COARSE_LOW_1_TO_WRITE_LOCK_COARSE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FF7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

/* write locks the flash section 320kB to 384kB. Section can not be unlocked, once locked */
#define GP_WB_READ_STANDBY_WRITE_LOCK_COARSE_MID_1() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x850), 4)

#define GP_WB_GET_STANDBY_WRITE_LOCK_COARSE_MID_1_FROM_WRITE_LOCK_COARSE(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_COARSE_MID_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x850), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_COARSE_MID_1_TO_WRITE_LOCK_COARSE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FEF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* write locks the flash section 384kB to 512kB. Section can not be unlocked, once locked */
#define GP_WB_READ_STANDBY_WRITE_LOCK_COARSE_HIGH_1() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x850), 5)

#define GP_WB_GET_STANDBY_WRITE_LOCK_COARSE_HIGH_1_FROM_WRITE_LOCK_COARSE(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_COARSE_HIGH_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x850), 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_COARSE_HIGH_1_TO_WRITE_LOCK_COARSE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FDF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

/* write locks the flash section 544kB to 576kB. Section can not be unlocked, once locked */
#define GP_WB_READ_STANDBY_WRITE_LOCK_COARSE_LOW_2() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x850), 6)

#define GP_WB_GET_STANDBY_WRITE_LOCK_COARSE_LOW_2_FROM_WRITE_LOCK_COARSE(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_COARSE_LOW_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x850), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_COARSE_LOW_2_TO_WRITE_LOCK_COARSE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FBF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

/* write locks the flash section 576kB to 640kB. Section can not be unlocked, once locked */
#define GP_WB_READ_STANDBY_WRITE_LOCK_COARSE_MID_2() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x850), 7)

#define GP_WB_GET_STANDBY_WRITE_LOCK_COARSE_MID_2_FROM_WRITE_LOCK_COARSE(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_COARSE_MID_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x850), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_COARSE_MID_2_TO_WRITE_LOCK_COARSE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* write locks the flash section 640kB to 768kB. Section can not be unlocked, once locked */
#define GP_WB_READ_STANDBY_WRITE_LOCK_COARSE_HIGH_2() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x851), 0)

#define GP_WB_GET_STANDBY_WRITE_LOCK_COARSE_HIGH_2_FROM_WRITE_LOCK_COARSE(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_COARSE_HIGH_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x851), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_COARSE_HIGH_2_TO_WRITE_LOCK_COARSE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0EFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* write locks the flash section 800kB to 832kB. Section can not be unlocked, once locked */
#define GP_WB_READ_STANDBY_WRITE_LOCK_COARSE_LOW_3() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x851), 1)

#define GP_WB_GET_STANDBY_WRITE_LOCK_COARSE_LOW_3_FROM_WRITE_LOCK_COARSE(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_COARSE_LOW_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x851), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_COARSE_LOW_3_TO_WRITE_LOCK_COARSE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0DFF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)

/* write locks the flash section 832kB to 896kB. Section can not be unlocked, once locked */
#define GP_WB_READ_STANDBY_WRITE_LOCK_COARSE_MID_3() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x851), 2)

#define GP_WB_GET_STANDBY_WRITE_LOCK_COARSE_MID_3_FROM_WRITE_LOCK_COARSE(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_COARSE_MID_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x851), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_COARSE_MID_3_TO_WRITE_LOCK_COARSE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0BFF; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)

/* write locks the flash section 896kB to 1024kB. Section can not be unlocked, once locked */
#define GP_WB_READ_STANDBY_WRITE_LOCK_COARSE_HIGH_3() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x851), 3)

#define GP_WB_GET_STANDBY_WRITE_LOCK_COARSE_HIGH_3_FROM_WRITE_LOCK_COARSE(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_STANDBY_WRITE_LOCK_COARSE_HIGH_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x851), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_WRITE_LOCK_COARSE_HIGH_3_TO_WRITE_LOCK_COARSE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FF; \
          (tmp) |= (((UInt16)(val)) << 11); \
        } while (0)


/* locks the the rom patching functionality */
#define GP_WB_READ_STANDBY_LOCK_ROM_PATCH_ENTRIES() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x852), 0)

#define GP_WB_WRITE_STANDBY_LOCK_ROM_PATCH_ENTRIES(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x852), (val)); \
        } while (0)


/* When set to 1 all write access to the flash is blocked */
#define GP_WB_READ_STANDBY_FLASH_GLOBAL_WRITE_LOCK() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x853), 0)

#define GP_WB_WRITE_STANDBY_FLASH_GLOBAL_WRITE_LOCK(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x853), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_TEST_BLOCK_ENA() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x854))

#define GP_WB_WRITE_STANDBY_TEST_BLOCK_ENA(val) \
      GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x854), (val))

/* Select bias lnablock block to measure */
#define GP_WB_READ_STANDBY_TEST_BLOCK_LNAMIX_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x854), 0)

#define GP_WB_GET_STANDBY_TEST_BLOCK_LNAMIX_ENA_FROM_TEST_BLOCK_ENA(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_STANDBY_TEST_BLOCK_LNAMIX_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x854), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_TEST_BLOCK_LNAMIX_ENA_TO_TEST_BLOCK_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFE; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Select bpf block to measure */
#define GP_WB_READ_STANDBY_TEST_BLOCK_BPF_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x854), 1)

#define GP_WB_GET_STANDBY_TEST_BLOCK_BPF_ENA_FROM_TEST_BLOCK_ENA(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_STANDBY_TEST_BLOCK_BPF_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x854), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_TEST_BLOCK_BPF_ENA_TO_TEST_BLOCK_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFD; \
          (tmp) |= (((UInt32)(val)) << 1); \
        } while (0)

/* Select limiter block to measure */
#define GP_WB_READ_STANDBY_TEST_BLOCK_LIMITER_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x854), 2)

#define GP_WB_GET_STANDBY_TEST_BLOCK_LIMITER_ENA_FROM_TEST_BLOCK_ENA(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_STANDBY_TEST_BLOCK_LIMITER_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x854), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_TEST_BLOCK_LIMITER_ENA_TO_TEST_BLOCK_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFFB; \
          (tmp) |= (((UInt32)(val)) << 2); \
        } while (0)

/* Select bias sx block to measure */
#define GP_WB_READ_STANDBY_TEST_BLOCK_SX_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x854), 3)

#define GP_WB_GET_STANDBY_TEST_BLOCK_SX_ENA_FROM_TEST_BLOCK_ENA(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_STANDBY_TEST_BLOCK_SX_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x854), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_TEST_BLOCK_SX_ENA_TO_TEST_BLOCK_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFF7; \
          (tmp) |= (((UInt32)(val)) << 3); \
        } while (0)

/* Select block fll to measure */
#define GP_WB_READ_STANDBY_TEST_BLOCK_FLL_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x854), 4)

#define GP_WB_GET_STANDBY_TEST_BLOCK_FLL_ENA_FROM_TEST_BLOCK_ENA(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_STANDBY_TEST_BLOCK_FLL_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x854), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_TEST_BLOCK_FLL_ENA_TO_TEST_BLOCK_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFEF; \
          (tmp) |= (((UInt32)(val)) << 4); \
        } while (0)

/* Select block tx to measure */
#define GP_WB_READ_STANDBY_TEST_BLOCK_TX_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x854), 5)

#define GP_WB_GET_STANDBY_TEST_BLOCK_TX_ENA_FROM_TEST_BLOCK_ENA(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_STANDBY_TEST_BLOCK_TX_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x854), 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_TEST_BLOCK_TX_ENA_TO_TEST_BLOCK_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFDF; \
          (tmp) |= (((UInt32)(val)) << 5); \
        } while (0)

/* Select block IF  to measure */
#define GP_WB_READ_STANDBY_TEST_BLOCK_IF_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x854), 6)

#define GP_WB_GET_STANDBY_TEST_BLOCK_IF_ENA_FROM_TEST_BLOCK_ENA(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_STANDBY_TEST_BLOCK_IF_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x854), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_TEST_BLOCK_IF_ENA_TO_TEST_BLOCK_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FFBF; \
          (tmp) |= (((UInt32)(val)) << 6); \
        } while (0)

/* Select block xo to measure */
#define GP_WB_READ_STANDBY_TEST_BLOCK_XO_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x854), 7)

#define GP_WB_GET_STANDBY_TEST_BLOCK_XO_ENA_FROM_TEST_BLOCK_ENA(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_STANDBY_TEST_BLOCK_XO_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x854), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_TEST_BLOCK_XO_ENA_TO_TEST_BLOCK_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FF7F; \
          (tmp) |= (((UInt32)(val)) << 7); \
        } while (0)

/* Select block BBPLL to measure */
#define GP_WB_READ_STANDBY_TEST_BLOCK_BBPLL_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x855), 0)

#define GP_WB_GET_STANDBY_TEST_BLOCK_BBPLL_ENA_FROM_TEST_BLOCK_ENA(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_STANDBY_TEST_BLOCK_BBPLL_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x855), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_TEST_BLOCK_BBPLL_ENA_TO_TEST_BLOCK_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FEFF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* Select process monitor block to measure */
#define GP_WB_READ_STANDBY_TEST_BLOCK_PROCESS_MONITOR_ENA() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x855)) >> 1) & 0x0F)

#define GP_WB_GET_STANDBY_TEST_BLOCK_PROCESS_MONITOR_ENA_FROM_TEST_BLOCK_ENA(tmp) \
        (((tmp) >> 9) & 0x0F)

#define GP_WB_WRITE_STANDBY_TEST_BLOCK_PROCESS_MONITOR_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x855), 0x1E, (val) << 1); \
        } while (0)

#define GP_WB_SET_STANDBY_TEST_BLOCK_PROCESS_MONITOR_ENA_TO_TEST_BLOCK_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x07E1FF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* Select power unit block to measure */
#define GP_WB_READ_STANDBY_TEST_BLOCK_PWR_UNIT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x855), 5)

#define GP_WB_GET_STANDBY_TEST_BLOCK_PWR_UNIT_FROM_TEST_BLOCK_ENA(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_STANDBY_TEST_BLOCK_PWR_UNIT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x855), 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_TEST_BLOCK_PWR_UNIT_TO_TEST_BLOCK_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07DFFF; \
          (tmp) |= (((UInt32)(val)) << 13); \
        } while (0)

/* Select adc rssi block to measure */
#define GP_WB_READ_STANDBY_TEST_BLOCK_ADC_RSSI() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x855), 6)

#define GP_WB_GET_STANDBY_TEST_BLOCK_ADC_RSSI_FROM_TEST_BLOCK_ENA(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_STANDBY_TEST_BLOCK_ADC_RSSI(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x855), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_TEST_BLOCK_ADC_RSSI_TO_TEST_BLOCK_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07BFFF; \
          (tmp) |= (((UInt32)(val)) << 14); \
        } while (0)

/* Not used */
#define GP_WB_READ_STANDBY_TEST_BLOCK_RESERVED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x855), 7)

#define GP_WB_GET_STANDBY_TEST_BLOCK_RESERVED_FROM_TEST_BLOCK_ENA(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_STANDBY_TEST_BLOCK_RESERVED(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x855), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_TEST_BLOCK_RESERVED_TO_TEST_BLOCK_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x077FFF; \
          (tmp) |= (((UInt32)(val)) << 15); \
        } while (0)

/* Select gp adc1 block to measure */
#define GP_WB_READ_STANDBY_TEST_BLOCK_GP_ADC1() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x856), 0)

#define GP_WB_GET_STANDBY_TEST_BLOCK_GP_ADC1_FROM_TEST_BLOCK_ENA(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_STANDBY_TEST_BLOCK_GP_ADC1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x856), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_TEST_BLOCK_GP_ADC1_TO_TEST_BLOCK_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* Select gp adc2 block to measure */
#define GP_WB_READ_STANDBY_TEST_BLOCK_GP_ADC2() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x856), 1)

#define GP_WB_GET_STANDBY_TEST_BLOCK_GP_ADC2_FROM_TEST_BLOCK_ENA(tmp) \
        (((tmp) >> 17) & 0x01)

#define GP_WB_WRITE_STANDBY_TEST_BLOCK_GP_ADC2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x856), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_TEST_BLOCK_GP_ADC2_TO_TEST_BLOCK_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05FFFF; \
          (tmp) |= (((UInt32)(val)) << 17); \
        } while (0)

/* Select the 32KHz xo block to measure */
#define GP_WB_READ_STANDBY_TEST_BLOCK_32K_XO() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x856), 2)

#define GP_WB_GET_STANDBY_TEST_BLOCK_32K_XO_FROM_TEST_BLOCK_ENA(tmp) \
        (((tmp) >> 18) & 0x01)

#define GP_WB_WRITE_STANDBY_TEST_BLOCK_32K_XO(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x856), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_TEST_BLOCK_32K_XO_TO_TEST_BLOCK_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFFF; \
          (tmp) |= (((UInt32)(val)) << 18); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_STANDBY_FORCE_ON() \
        GP_WB_READ_U48(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x858))

#define GP_WB_WRITE_STANDBY_FORCE_ON(val) \
      GP_WB_WRITE_U48(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x858), (val))

/* All fons force on both func and regmap clocks */
#define GP_WB_READ_STANDBY_FON_CLK_INT_UC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x858), 0)

#define GP_WB_GET_STANDBY_FON_CLK_INT_UC_FROM_FORCE_ON(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_INT_UC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x858), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_INT_UC_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFFFFE; \
          (tmp) |= ((UInt64)(val)); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_GPMICRO() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x858), 1)

#define GP_WB_GET_STANDBY_FON_CLK_GPMICRO_FROM_FORCE_ON(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_GPMICRO(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x858), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_GPMICRO_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFFFFD; \
          (tmp) |= (((UInt64)(val)) << 1); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_STBC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x858), 2)

#define GP_WB_GET_STANDBY_FON_CLK_STBC_FROM_FORCE_ON(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_STBC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x858), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_STBC_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFFFFB; \
          (tmp) |= (((UInt64)(val)) << 2); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_RTM() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x858), 3)

#define GP_WB_GET_STANDBY_FON_CLK_RTM_FROM_FORCE_ON(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_RTM(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x858), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_RTM_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFFFF7; \
          (tmp) |= (((UInt64)(val)) << 3); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_ES_TIMEREF() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x858), 4)

#define GP_WB_GET_STANDBY_FON_CLK_ES_TIMEREF_FROM_FORCE_ON(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_ES_TIMEREF(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x858), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_ES_TIMEREF_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFFFEF; \
          (tmp) |= (((UInt64)(val)) << 4); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_ES_EVENT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x858), 5)

#define GP_WB_GET_STANDBY_FON_CLK_ES_EVENT_FROM_FORCE_ON(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_ES_EVENT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x858), 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_ES_EVENT_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFFFDF; \
          (tmp) |= (((UInt64)(val)) << 5); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_GPIO() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x858), 6)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_GPIO_FROM_FORCE_ON(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_GPIO(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x858), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_GPIO_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFFFBF; \
          (tmp) |= (((UInt64)(val)) << 6); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_SSP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x858), 7)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_SSP_FROM_FORCE_ON(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_SSP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x858), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_SSP_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFFF7F; \
          (tmp) |= (((UInt64)(val)) << 7); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_SEC_PROC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x859), 0)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_SEC_PROC_FROM_FORCE_ON(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_SEC_PROC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x859), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_SEC_PROC_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFFEFF; \
          (tmp) |= (((UInt64)(val)) << 8); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_RPA_ACC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x859), 1)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_RPA_ACC_FROM_FORCE_ON(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_RPA_ACC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x859), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_RPA_ACC_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFFDFF; \
          (tmp) |= (((UInt64)(val)) << 9); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_IPC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x859), 2)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_IPC_FROM_FORCE_ON(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_IPC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x859), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_IPC_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFFBFF; \
          (tmp) |= (((UInt64)(val)) << 10); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_IR() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x859), 3)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_IR_FROM_FORCE_ON(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_IR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x859), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_IR_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFF7FF; \
          (tmp) |= (((UInt64)(val)) << 11); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_LED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x859), 4)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_LED_FROM_FORCE_ON(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_LED(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x859), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_LED_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFEFFF; \
          (tmp) |= (((UInt64)(val)) << 12); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_ADCIF() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x859), 5)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_ADCIF_FROM_FORCE_ON(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_ADCIF(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x859), 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_ADCIF_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFDFFF; \
          (tmp) |= (((UInt64)(val)) << 13); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_UART_0() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x859), 7)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_UART_0_FROM_FORCE_ON(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_UART_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x859), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_UART_0_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFF7FFF; \
          (tmp) |= (((UInt64)(val)) << 15); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_UART_1() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85a), 0)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_UART_1_FROM_FORCE_ON(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_UART_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85a), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_UART_1_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFEFFFF; \
          (tmp) |= (((UInt64)(val)) << 16); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_SPI_M() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85a), 1)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_SPI_M_FROM_FORCE_ON(tmp) \
        (((tmp) >> 17) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_SPI_M(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85a), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_SPI_M_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFDFFFF; \
          (tmp) |= (((UInt64)(val)) << 17); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_I2C_M() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85a), 2)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_I2C_M_FROM_FORCE_ON(tmp) \
        (((tmp) >> 18) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_I2C_M(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85a), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_I2C_M_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFBFFFF; \
          (tmp) |= (((UInt64)(val)) << 18); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_I2S_M() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85a), 3)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_I2S_M_FROM_FORCE_ON(tmp) \
        (((tmp) >> 19) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_I2S_M(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85a), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_I2S_M_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFF7FFFF; \
          (tmp) |= (((UInt64)(val)) << 19); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_WATCHDOG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85a), 4)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_WATCHDOG_FROM_FORCE_ON(tmp) \
        (((tmp) >> 20) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_WATCHDOG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85a), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_WATCHDOG_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFEFFFFF; \
          (tmp) |= (((UInt64)(val)) << 20); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_SPI_S() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85a), 5)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_SPI_S_FROM_FORCE_ON(tmp) \
        (((tmp) >> 21) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_SPI_S(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85a), 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_SPI_S_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFDFFFFF; \
          (tmp) |= (((UInt64)(val)) << 21); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_I2C_S() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85a), 6)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_I2C_S_FROM_FORCE_ON(tmp) \
        (((tmp) >> 22) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_I2C_S(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85a), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_I2C_S_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFBFFFFF; \
          (tmp) |= (((UInt64)(val)) << 22); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_DMA_SCB() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85a), 7)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_DMA_SCB_FROM_FORCE_ON(tmp) \
        (((tmp) >> 23) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_DMA_SCB(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85a), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_DMA_SCB_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFF7FFFFF; \
          (tmp) |= (((UInt64)(val)) << 23); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_PWM() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85b), 0)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_PWM_FROM_FORCE_ON(tmp) \
        (((tmp) >> 24) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_PWM(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85b), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_PWM_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFEFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 24); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_ASP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85b), 1)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_ASP_FROM_FORCE_ON(tmp) \
        (((tmp) >> 25) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_ASP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85b), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_ASP_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFDFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 25); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_EPI_TIMER() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85b), 2)

#define GP_WB_GET_STANDBY_FON_CLK_EPI_TIMER_FROM_FORCE_ON(tmp) \
        (((tmp) >> 26) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_EPI_TIMER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85b), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_EPI_TIMER_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFBFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 26); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_PRG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85b), 3)

#define GP_WB_GET_STANDBY_FON_CLK_PRG_FROM_FORCE_ON(tmp) \
        (((tmp) >> 27) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_PRG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85b), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_PRG_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFF7FFFFFF; \
          (tmp) |= (((UInt64)(val)) << 27); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_PHY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85b), 4)

#define GP_WB_GET_STANDBY_FON_CLK_PHY_FROM_FORCE_ON(tmp) \
        (((tmp) >> 28) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_PHY(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85b), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_PHY_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFEFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 28); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_PHY_DYN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85b), 5)

#define GP_WB_GET_STANDBY_FON_CLK_PHY_DYN_FROM_FORCE_ON(tmp) \
        (((tmp) >> 29) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_PHY_DYN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85b), 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_PHY_DYN_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFDFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 29); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_PHY_DYN_64() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85b), 6)

#define GP_WB_GET_STANDBY_FON_CLK_PHY_DYN_64_FROM_FORCE_ON(tmp) \
        (((tmp) >> 30) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_PHY_DYN_64(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85b), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_PHY_DYN_64_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFBFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 30); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_PHY_CONV() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85b), 7)

#define GP_WB_GET_STANDBY_FON_CLK_PHY_CONV_FROM_FORCE_ON(tmp) \
        (((tmp) >> 31) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_PHY_CONV(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85b), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_PHY_CONV_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FF7FFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 31); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_MM_STBM() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85c), 0)

#define GP_WB_GET_STANDBY_FON_CLK_MM_STBM_FROM_FORCE_ON(tmp) \
        (((tmp) >> 32) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_MM_STBM(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85c), 0, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_MM_STBM_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FEFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 32); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_MM_NVM() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85c), 1)

#define GP_WB_GET_STANDBY_FON_CLK_MM_NVM_FROM_FORCE_ON(tmp) \
        (((tmp) >> 33) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_MM_NVM(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85c), 1, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_MM_NVM_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FDFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 33); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_MSI_CORE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85c), 2)

#define GP_WB_GET_STANDBY_FON_CLK_MSI_CORE_FROM_FORCE_ON(tmp) \
        (((tmp) >> 34) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_MSI_CORE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85c), 2, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_MSI_CORE_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FBFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 34); \
        } while (0)

/* forces on the clock to the iob regmap when '1' */
#define GP_WB_READ_STANDBY_FON_CLK_IOB() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85c), 3)

#define GP_WB_GET_STANDBY_FON_CLK_IOB_FROM_FORCE_ON(tmp) \
        (((tmp) >> 35) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_IOB(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85c), 3, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_IOB_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01F7FFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 35); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_REGMAP_PMUD() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85c), 4)

#define GP_WB_GET_STANDBY_FON_CLK_REGMAP_PMUD_FROM_FORCE_ON(tmp) \
        (((tmp) >> 36) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_REGMAP_PMUD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85c), 4, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_REGMAP_PMUD_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01EFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 36); \
        } while (0)

/* forces on the clock to the qta regmap (and logic) when  '1' */
#define GP_WB_READ_STANDBY_FON_CLK_REGMAP_RTM_QTA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85c), 5)

#define GP_WB_GET_STANDBY_FON_CLK_REGMAP_RTM_QTA_FROM_FORCE_ON(tmp) \
        (((tmp) >> 37) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_REGMAP_RTM_QTA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85c), 5, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_REGMAP_RTM_QTA_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01DFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 37); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_REGMAP_MM() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85c), 6)

#define GP_WB_GET_STANDBY_FON_CLK_REGMAP_MM_FROM_FORCE_ON(tmp) \
        (((tmp) >> 38) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_REGMAP_MM(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85c), 6, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_REGMAP_MM_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01BFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 38); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_REGMAP_MSI_INT_CTRL() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85c), 7)

#define GP_WB_GET_STANDBY_FON_CLK_REGMAP_MSI_INT_CTRL_FROM_FORCE_ON(tmp) \
        (((tmp) >> 39) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_REGMAP_MSI_INT_CTRL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85c), 7, (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_REGMAP_MSI_INT_CTRL_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x017FFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 39); \
        } while (0)

#define GP_WB_READ_STANDBY_FON_CLK_REGMAP_PBM_ADMIN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85d), 0)

#define GP_WB_GET_STANDBY_FON_CLK_REGMAP_PBM_ADMIN_FROM_FORCE_ON(tmp) \
        (((tmp) >> 40) & 0x01)

#define GP_WB_WRITE_STANDBY_FON_CLK_REGMAP_PBM_ADMIN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85d), (val)); \
        } while (0)

#define GP_WB_SET_STANDBY_FON_CLK_REGMAP_PBM_ADMIN_TO_FORCE_ON(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x00FFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 40); \
        } while (0)


/* enabled bypass of the testbuffer */
#define GP_WB_READ_STANDBY_TESTBUS_ANIO_CONNECT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85e), 0)

#define GP_WB_WRITE_STANDBY_TESTBUS_ANIO_CONNECT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85e), 0, (val)); \
        } while (0)

/* enables the testbus buffer connected any of the 3 channels */
#define GP_WB_READ_STANDBY_TESTBUS_BUF_N_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85e), 1)

#define GP_WB_WRITE_STANDBY_TESTBUS_BUF_N_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85e), 1, (val)); \
        } while (0)

/* enables the testbus buffer connected any of the 3 channels */
#define GP_WB_READ_STANDBY_TESTBUS_BUF_P_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85e), 2)

#define GP_WB_WRITE_STANDBY_TESTBUS_BUF_P_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85e), 2, (val)); \
        } while (0)

/* connects testbus of channel0 to testbuffer/mux, mainly sx, tx */
#define GP_WB_READ_STANDBY_TESTBUS_CH0_SEL() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85e), 3)

#define GP_WB_WRITE_STANDBY_TESTBUS_CH0_SEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85e), 3, (val)); \
        } while (0)

/* connects testbus of channel0 to testbuffer/mux, mainly rx, bpf, lim */
#define GP_WB_READ_STANDBY_TESTBUS_CH1_SEL() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85e), 4)

#define GP_WB_WRITE_STANDBY_TESTBUS_CH1_SEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85e), 4, (val)); \
        } while (0)

/* connects testbus of channel0 to testbuffer/mux, mainly digldo, mcb, xo, fll */
#define GP_WB_READ_STANDBY_TESTBUS_CH2_SEL() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85e), 5)

#define GP_WB_WRITE_STANDBY_TESTBUS_CH2_SEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85e), 5, (val)); \
        } while (0)


/* spare bits. connects to ana_top */
#define GP_WB_READ_STANDBY_SPARE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85f)) & 0x07)

#define GP_WB_WRITE_STANDBY_SPARE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85f), 0x07, (val)); \
        } while (0)

/* ring oscillator enable */
#define GP_WB_READ_STANDBY_RINGOSC_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85f), 3)

#define GP_WB_WRITE_STANDBY_RINGOSC_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85f), 3, (val)); \
        } while (0)

/* determines if the rvt or hvt oscillator is used */
#define GP_WB_READ_STANDBY_RINGOSC_RVT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85f), 4)

#define GP_WB_WRITE_STANDBY_RINGOSC_RVT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x85f), 4, (val)); \
        } while (0)

/***************************
 * layout: es
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ES_TIME_REFERENCE_SETTING() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x900))

#define GP_WB_WRITE_ES_TIME_REFERENCE_SETTING(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x900), (val))

/* Enable Sample Conversion By GPIO Extern */
#define GP_WB_READ_ES_ENABLE_SAMPLE_CONVERSION_BY_GPIO_EXTERN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x900), 0)

#define GP_WB_GET_ES_ENABLE_SAMPLE_CONVERSION_BY_GPIO_EXTERN_FROM_TIME_REFERENCE_SETTING(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_ES_ENABLE_SAMPLE_CONVERSION_BY_GPIO_EXTERN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x900), 0, (val)); \
        } while (0)

#define GP_WB_SET_ES_ENABLE_SAMPLE_CONVERSION_BY_GPIO_EXTERN_TO_TIME_REFERENCE_SETTING(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFE; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Select what edge of oscillator benchmark clk is jitter free */
#define GP_WB_READ_ES_CLK_OSB_STABLE_ON_FALLING_EDGE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x900), 1)

#define GP_WB_GET_ES_CLK_OSB_STABLE_ON_FALLING_EDGE_FROM_TIME_REFERENCE_SETTING(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_ES_CLK_OSB_STABLE_ON_FALLING_EDGE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x900), 1, (val)); \
        } while (0)

#define GP_WB_SET_ES_CLK_OSB_STABLE_ON_FALLING_EDGE_TO_TIME_REFERENCE_SETTING(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFD; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

/* Select on which edge of standby clock the gray counter is stable */
#define GP_WB_READ_ES_GRAY_COUNTER_STABLE_ON_FALLING_EDGE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x900), 2)

#define GP_WB_GET_ES_GRAY_COUNTER_STABLE_ON_FALLING_EDGE_FROM_TIME_REFERENCE_SETTING(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_ES_GRAY_COUNTER_STABLE_ON_FALLING_EDGE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x900), 2, (val)); \
        } while (0)

#define GP_WB_SET_ES_GRAY_COUNTER_STABLE_ON_FALLING_EDGE_TO_TIME_REFERENCE_SETTING(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFB; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* Disable Automatic Reference Point Update */
#define GP_WB_READ_ES_DISABLE_AUTOMATIC_REFERENCE_POINT_UPDATE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x900), 3)

#define GP_WB_GET_ES_DISABLE_AUTOMATIC_REFERENCE_POINT_UPDATE_FROM_TIME_REFERENCE_SETTING(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_ES_DISABLE_AUTOMATIC_REFERENCE_POINT_UPDATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x900), 3, (val)); \
        } while (0)

#define GP_WB_SET_ES_DISABLE_AUTOMATIC_REFERENCE_POINT_UPDATE_TO_TIME_REFERENCE_SETTING(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFF7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

/* Reconversion on updates */
#define GP_WB_READ_ES_RECONVERSION_ON_UPDATES() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x900), 4)

#define GP_WB_GET_ES_RECONVERSION_ON_UPDATES_FROM_TIME_REFERENCE_SETTING(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_ES_RECONVERSION_ON_UPDATES(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x900), 4, (val)); \
        } while (0)

#define GP_WB_SET_ES_RECONVERSION_ON_UPDATES_TO_TIME_REFERENCE_SETTING(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFEF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* Disable Extrapolation */
#define GP_WB_READ_ES_DISABLE_EXTRAPOLATION() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x900), 5)

#define GP_WB_GET_ES_DISABLE_EXTRAPOLATION_FROM_TIME_REFERENCE_SETTING(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_ES_DISABLE_EXTRAPOLATION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x900), 5, (val)); \
        } while (0)

#define GP_WB_SET_ES_DISABLE_EXTRAPOLATION_TO_TIME_REFERENCE_SETTING(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFDF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

/* Disable Conversion */
#define GP_WB_READ_ES_DISABLE_CONVERSION() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x900), 6)

#define GP_WB_GET_ES_DISABLE_CONVERSION_FROM_TIME_REFERENCE_SETTING(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_ES_DISABLE_CONVERSION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x900), 6, (val)); \
        } while (0)

#define GP_WB_SET_ES_DISABLE_CONVERSION_TO_TIME_REFERENCE_SETTING(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFBF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

/* Fast Sync On Start */
#define GP_WB_READ_ES_FAST_SYNC_ON_START() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x900), 7)

#define GP_WB_GET_ES_FAST_SYNC_ON_START_FROM_TIME_REFERENCE_SETTING(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ES_FAST_SYNC_ON_START(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x900), 7, (val)); \
        } while (0)

#define GP_WB_SET_ES_FAST_SYNC_ON_START_TO_TIME_REFERENCE_SETTING(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* Enable Oscillator Benchmark */
#define GP_WB_READ_ES_ENABLE_OSCILLATOR_BENCHMARK() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x901), 0)

#define GP_WB_GET_ES_ENABLE_OSCILLATOR_BENCHMARK_FROM_TIME_REFERENCE_SETTING(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_ES_ENABLE_OSCILLATOR_BENCHMARK(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x901), 0, (val)); \
        } while (0)

#define GP_WB_SET_ES_ENABLE_OSCILLATOR_BENCHMARK_TO_TIME_REFERENCE_SETTING(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFEFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* Auto trigger oscillator benchmark when oscillator benchmark is not valid */
#define GP_WB_READ_ES_AUTO_TRIGGER_OSCILLATOR_BENCHMARK_WHEN_NOT_VALID() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x901), 1)

#define GP_WB_GET_ES_AUTO_TRIGGER_OSCILLATOR_BENCHMARK_WHEN_NOT_VALID_FROM_TIME_REFERENCE_SETTING(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_ES_AUTO_TRIGGER_OSCILLATOR_BENCHMARK_WHEN_NOT_VALID(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x901), 1, (val)); \
        } while (0)

#define GP_WB_SET_ES_AUTO_TRIGGER_OSCILLATOR_BENCHMARK_WHEN_NOT_VALID_TO_TIME_REFERENCE_SETTING(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFDFF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)

#define GP_WB_READ_ES_KEEP_AWAKE_DURING_OSCILLATOR_BENCHMARK_MEASUREMENT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x901), 2)

#define GP_WB_GET_ES_KEEP_AWAKE_DURING_OSCILLATOR_BENCHMARK_MEASUREMENT_FROM_TIME_REFERENCE_SETTING(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_ES_KEEP_AWAKE_DURING_OSCILLATOR_BENCHMARK_MEASUREMENT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x901), 2, (val)); \
        } while (0)

#define GP_WB_SET_ES_KEEP_AWAKE_DURING_OSCILLATOR_BENCHMARK_MEASUREMENT_TO_TIME_REFERENCE_SETTING(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFBFF; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)

#define GP_WB_READ_ES_LOCK_OSCILLATOR_BENCHMARK() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x901), 3)

#define GP_WB_GET_ES_LOCK_OSCILLATOR_BENCHMARK_FROM_TIME_REFERENCE_SETTING(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_ES_LOCK_OSCILLATOR_BENCHMARK(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x901), 3, (val)); \
        } while (0)

#define GP_WB_SET_ES_LOCK_OSCILLATOR_BENCHMARK_TO_TIME_REFERENCE_SETTING(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7FF; \
          (tmp) |= (((UInt16)(val)) << 11); \
        } while (0)

/* determines what clock to use for the oscillator benchmark test */
#define GP_WB_READ_ES_OSCILLATOR_BENCHMARK_CLK_SRC() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x901)) >> 4) & 0x07)

#define GP_WB_GET_ES_OSCILLATOR_BENCHMARK_CLK_SRC_FROM_TIME_REFERENCE_SETTING(tmp) \
        (((tmp) >> 12) & 0x07)

#define GP_WB_WRITE_ES_OSCILLATOR_BENCHMARK_CLK_SRC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x901), 0x70, (val) << 4); \
        } while (0)

#define GP_WB_SET_ES_OSCILLATOR_BENCHMARK_CLK_SRC_TO_TIME_REFERENCE_SETTING(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x8FFF; \
          (tmp) |= (((UInt16)(val)) << 12); \
        } while (0)

/* only convert when needed, automatically disabling the conversion, only enable when symbol counter is not initialized or when a calibration (e.g. realignment) is to be executed */
#define GP_WB_READ_ES_ONLY_CONVERT_WHEN_NEEDED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x901), 7)

#define GP_WB_GET_ES_ONLY_CONVERT_WHEN_NEEDED_FROM_TIME_REFERENCE_SETTING(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_ES_ONLY_CONVERT_WHEN_NEEDED(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x901), 7, (val)); \
        } while (0)

#define GP_WB_SET_ES_ONLY_CONVERT_WHEN_NEEDED_TO_TIME_REFERENCE_SETTING(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7FFF; \
          (tmp) |= (((UInt16)(val)) << 15); \
        } while (0)


/* The number of ticks (+1) of the low power oscillator that is used by the oscillator benchmark to measure the number of 32MHz ticks over */
#define GP_WB_READ_ES_OSCILLATOR_BENCHMARK_LP_TICKS_THRESHOLD() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x902))

#define GP_WB_WRITE_ES_OSCILLATOR_BENCHMARK_LP_TICKS_THRESHOLD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x902), (val)); \
        } while (0)


/* The minimum number of oscillator ticks expected during a 1 slow clock period */
#define GP_WB_READ_ES_OSCILLATOR_BENCHMARK_SUB_COUNTER_MIN() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x904))

#define GP_WB_WRITE_ES_OSCILLATOR_BENCHMARK_SUB_COUNTER_MIN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x904), (val)); \
        } while (0)


/* The maximum number of oscillator ticks expected during a 1 slow clock period */
#define GP_WB_READ_ES_OSCILLATOR_BENCHMARK_SUB_COUNTER_MAX() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x906))

#define GP_WB_WRITE_ES_OSCILLATOR_BENCHMARK_SUB_COUNTER_MAX(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x906), (val)); \
        } while (0)


#define GP_WB_WRITE_ES_TIME_REFERENCE_CONTROL(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x908), (val))

/* Apply Simple Calibration */
#define GP_WB_ES_APPLY_EXTERNAL_SIMPLE_CALIBRATION() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x908), 0x01)

#define GP_WB_SET_ES_APPLY_EXTERNAL_SIMPLE_CALIBRATION_TO_TIME_REFERENCE_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FE; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Apply Advanced Calibration */
#define GP_WB_ES_APPLY_EXTERNAL_ADVANCED_CALIBRATION() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x908), 0x02)

#define GP_WB_SET_ES_APPLY_EXTERNAL_ADVANCED_CALIBRATION_TO_TIME_REFERENCE_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FD; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

/* Apply Zero Calibration */
#define GP_WB_ES_APPLY_EXTERNAL_ZERO_CALIBRATION() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x908), 0x04)

#define GP_WB_SET_ES_APPLY_EXTERNAL_ZERO_CALIBRATION_TO_TIME_REFERENCE_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FB; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* Sample Calibration */
#define GP_WB_ES_SAMPLE_CALIBRATION() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x908), 0x08)

#define GP_WB_SET_ES_SAMPLE_CALIBRATION_TO_TIME_REFERENCE_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01F7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

/* Sample Conversion */
#define GP_WB_ES_SAMPLE_CONVERSION() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x908), 0x10)

#define GP_WB_SET_ES_SAMPLE_CONVERSION_TO_TIME_REFERENCE_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01EF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* Trigger Fast Sync */
#define GP_WB_ES_TRIGGER_FAST_SYNC() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x908), 0x20)

#define GP_WB_SET_ES_TRIGGER_FAST_SYNC_TO_TIME_REFERENCE_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01DF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

/* Trigger Oscillator Benchmark */
#define GP_WB_ES_TRIGGER_OSCILLATOR_BENCHMARK() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x908), 0x40)

#define GP_WB_SET_ES_TRIGGER_OSCILLATOR_BENCHMARK_TO_TIME_REFERENCE_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01BF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

/* Apply Startup Symbol Time */
#define GP_WB_ES_APPLY_STARTUP_SYMBOL_TIME() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x908), 0x80)

#define GP_WB_SET_ES_APPLY_STARTUP_SYMBOL_TIME_TO_TIME_REFERENCE_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x017F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* Apply Realignment Calibration */
#define GP_WB_ES_APPLY_EXTERNAL_REALIGNMENT_CALIBRATION() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x909), 0x01)

#define GP_WB_SET_ES_APPLY_EXTERNAL_REALIGNMENT_CALIBRATION_TO_TIME_REFERENCE_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x00FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ES_TIME_REFERENCE_STATE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x90a))

/* Apply Simple Calibration Busy */
#define GP_WB_READ_ES_APPLY_EXTERNAL_SIMPLE_CALIBRATION_BUSY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x90a), 0)

#define GP_WB_GET_ES_APPLY_EXTERNAL_SIMPLE_CALIBRATION_BUSY_FROM_TIME_REFERENCE_STATE(tmp) \
        ((tmp) & 0x01)

/* Apply Advanced Calibration Busy */
#define GP_WB_READ_ES_APPLY_EXTERNAL_ADVANCED_CALIBRATION_BUSY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x90a), 1)

#define GP_WB_GET_ES_APPLY_EXTERNAL_ADVANCED_CALIBRATION_BUSY_FROM_TIME_REFERENCE_STATE(tmp) \
        (((tmp) >> 1) & 0x01)

/* Apply Zero Calibration Busy */
#define GP_WB_READ_ES_APPLY_EXTERNAL_ZERO_CALIBRATION_BUSY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x90a), 2)

#define GP_WB_GET_ES_APPLY_EXTERNAL_ZERO_CALIBRATION_BUSY_FROM_TIME_REFERENCE_STATE(tmp) \
        (((tmp) >> 2) & 0x01)

/* Symbol Counter Updated Since Last Calibration */
#define GP_WB_READ_ES_SYMBOL_COUNTER_UPDATED_SINCE_LAST_CALIBRATION() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x90a), 3)

#define GP_WB_GET_ES_SYMBOL_COUNTER_UPDATED_SINCE_LAST_CALIBRATION_FROM_TIME_REFERENCE_STATE(tmp) \
        (((tmp) >> 3) & 0x01)

/* Reconversion busy */
#define GP_WB_READ_ES_RECONVERSION_BUSY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x90a), 4)

#define GP_WB_GET_ES_RECONVERSION_BUSY_FROM_TIME_REFERENCE_STATE(tmp) \
        (((tmp) >> 4) & 0x01)

/* Init Event Scheduler Busy */
#define GP_WB_READ_ES_INIT_TIME_REFERENCE_BUSY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x90a), 5)

#define GP_WB_GET_ES_INIT_TIME_REFERENCE_BUSY_FROM_TIME_REFERENCE_STATE(tmp) \
        (((tmp) >> 5) & 0x01)

/* Fast Sync Busy */
#define GP_WB_READ_ES_FAST_SYNC_BUSY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x90a), 6)

#define GP_WB_GET_ES_FAST_SYNC_BUSY_FROM_TIME_REFERENCE_STATE(tmp) \
        (((tmp) >> 6) & 0x01)

/* Apply Realignment Calibration Bus */
#define GP_WB_READ_ES_APPLY_EXTERNAL_REALIGNMENT_CALIBRATION_BUSY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x90a), 7)

#define GP_WB_GET_ES_APPLY_EXTERNAL_REALIGNMENT_CALIBRATION_BUSY_FROM_TIME_REFERENCE_STATE(tmp) \
        (((tmp) >> 7) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ES_TIME_REFERENCE_STATE2() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x90b))

/* Oscillator benchmark state */
#define GP_WB_READ_ES_OSCILLATOR_BENCHMARK_STATE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x90b)) & 0x03)

#define GP_WB_GET_ES_OSCILLATOR_BENCHMARK_STATE_FROM_TIME_REFERENCE_STATE2(tmp) \
        ((tmp) & 0x03)

/* Oscillator benchmark result valid */
#define GP_WB_READ_ES_OSCILLATOR_BENCHMARK_RESULT_VALID() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x90b), 2)

#define GP_WB_GET_ES_OSCILLATOR_BENCHMARK_RESULT_VALID_FROM_TIME_REFERENCE_STATE2(tmp) \
        (((tmp) >> 2) & 0x01)

/* status indicationg that during a measurement period, the number of ticks for 1 slow period was below the allowed min value */
#define GP_WB_READ_ES_OSCILLATOR_BENCHMARK_SUB_COUNTER_TOO_LOW() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x90b), 3)

#define GP_WB_GET_ES_OSCILLATOR_BENCHMARK_SUB_COUNTER_TOO_LOW_FROM_TIME_REFERENCE_STATE2(tmp) \
        (((tmp) >> 3) & 0x01)

/* status indicationg that during a measurement period, the number of ticks for 1 slow period was above the allowed max value */
#define GP_WB_READ_ES_OSCILLATOR_BENCHMARK_SUB_COUNTER_TOO_HIGH() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x90b), 4)

#define GP_WB_GET_ES_OSCILLATOR_BENCHMARK_SUB_COUNTER_TOO_HIGH_FROM_TIME_REFERENCE_STATE2(tmp) \
        (((tmp) >> 4) & 0x01)


/* Auto Sample Symbol Counter */
#define GP_WB_READ_ES_AUTO_SAMPLED_SYMBOL_COUNTER() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x90c))


/* Second auto samppled symbol counter, dedicated for second processor in the sybsystem */
#define GP_WB_READ_ES_AUTO_SAMPLED_SYMBOL_COUNTER_ALTERNATE() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x910))


/* Binary gray counter */
#define GP_WB_READ_ES_BINARY_GRAY_COUNTER() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x914))

#define GP_WB_WRITE_ES_BINARY_GRAY_COUNTER(val) do { \
          GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x914), (val)); \
        } while (0)


/* Symbol counter */
#define GP_WB_READ_ES_SYMBOL_COUNTER() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x918))

#define GP_WB_WRITE_ES_SYMBOL_COUNTER(val) do { \
          GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x918), (val)); \
        } while (0)


/* Number of 32MHz ticks seen by the oscillator benchmark */
#define GP_WB_READ_ES_OSCILLATOR_BENCHMARK_COUNTER() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x91c))


/* Number of low power oscillator ticks seen by the oscillator benchmark */
#define GP_WB_READ_ES_OSCILLATOR_BENCHMARK_LP_TICKS_SEEN() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x920))


/* Number of low power oscillator ticks seen by the oscillator during 1 tick of the slow clock */
#define GP_WB_READ_ES_OSCILLATOR_BENCHMARK_SUB_COUNTER_RESULT() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x922))


/* Startup symbol time. Resolution is 1 us */
#define GP_WB_READ_ES_STARTUP_SYMBOL_TIME() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x924))

#define GP_WB_WRITE_ES_STARTUP_SYMBOL_TIME(val) do { \
          GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x924), (val)); \
        } while (0)


/* Startup long symbol time. Resolution is 1 us */
#define GP_WB_READ_ES_LONG_STARTUP_SYMBOL_TIME() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x928))

#define GP_WB_WRITE_ES_LONG_STARTUP_SYMBOL_TIME(val) do { \
          GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x928), (val)); \
        } while (0)


/* Binary gray counter reference */
#define GP_WB_READ_ES_BINARY_GRAY_COUNTER_REFERENCE() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x92c))

#define GP_WB_WRITE_ES_BINARY_GRAY_COUNTER_REFERENCE(val) do { \
          GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x92c), (val)); \
        } while (0)


/* Symbol counter reference */
#define GP_WB_READ_ES_SYMBOL_COUNTER_REFERENCE() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x930))

#define GP_WB_WRITE_ES_SYMBOL_COUNTER_REFERENCE(val) do { \
          GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x930), (val)); \
        } while (0)


/* Calibration factor */
#define GP_WB_READ_ES_CALIBRATION_FACTOR() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x934))

#define GP_WB_WRITE_ES_CALIBRATION_FACTOR(val) do { \
          GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x934), (val)); \
        } while (0)


/* Phase compensation */
#define GP_WB_READ_ES_PHASE_COMPENSATION() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x938))

#define GP_WB_WRITE_ES_PHASE_COMPENSATION(val) do { \
          GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x938), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ES_TIME_REFERENCE_ENABLE_CLK_BY_UC() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x93c))

#define GP_WB_WRITE_ES_TIME_REFERENCE_ENABLE_CLK_BY_UC(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x93c), (val))

/* Enable clk time reference base a by uC */
#define GP_WB_READ_ES_ENABLE_CLK_TIME_REFERENCE_BASE_A_BY_UC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x93c), 0)

#define GP_WB_GET_ES_ENABLE_CLK_TIME_REFERENCE_BASE_A_BY_UC_FROM_TIME_REFERENCE_ENABLE_CLK_BY_UC(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_ES_ENABLE_CLK_TIME_REFERENCE_BASE_A_BY_UC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x93c), 0, (val)); \
        } while (0)

#define GP_WB_SET_ES_ENABLE_CLK_TIME_REFERENCE_BASE_A_BY_UC_TO_TIME_REFERENCE_ENABLE_CLK_BY_UC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Enable clk time reference base b by uC */
#define GP_WB_READ_ES_ENABLE_CLK_TIME_REFERENCE_BASE_B_BY_UC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x93c), 1)

#define GP_WB_GET_ES_ENABLE_CLK_TIME_REFERENCE_BASE_B_BY_UC_FROM_TIME_REFERENCE_ENABLE_CLK_BY_UC(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_ES_ENABLE_CLK_TIME_REFERENCE_BASE_B_BY_UC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x93c), 1, (val)); \
        } while (0)

#define GP_WB_SET_ES_ENABLE_CLK_TIME_REFERENCE_BASE_B_BY_UC_TO_TIME_REFERENCE_ENABLE_CLK_BY_UC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Enable clk time reference io by uC */
#define GP_WB_READ_ES_ENABLE_CLK_TIME_REFERENCE_IO_BY_UC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x93c), 2)

#define GP_WB_GET_ES_ENABLE_CLK_TIME_REFERENCE_IO_BY_UC_FROM_TIME_REFERENCE_ENABLE_CLK_BY_UC(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_ES_ENABLE_CLK_TIME_REFERENCE_IO_BY_UC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x93c), 2, (val)); \
        } while (0)

#define GP_WB_SET_ES_ENABLE_CLK_TIME_REFERENCE_IO_BY_UC_TO_TIME_REFERENCE_ENABLE_CLK_BY_UC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Enable clk time reference oscillator benchmark by uC */
#define GP_WB_READ_ES_ENABLE_CLK_TIME_REFERENCE_OSCILLATOR_BENCHMARK_BY_UC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x93c), 3)

#define GP_WB_GET_ES_ENABLE_CLK_TIME_REFERENCE_OSCILLATOR_BENCHMARK_BY_UC_FROM_TIME_REFERENCE_ENABLE_CLK_BY_UC(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_ES_ENABLE_CLK_TIME_REFERENCE_OSCILLATOR_BENCHMARK_BY_UC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x93c), 3, (val)); \
        } while (0)

#define GP_WB_SET_ES_ENABLE_CLK_TIME_REFERENCE_OSCILLATOR_BENCHMARK_BY_UC_TO_TIME_REFERENCE_ENABLE_CLK_BY_UC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ES_VALID_EVENTS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x93e))

/* Valid Events */
#define GP_WB_READ_ES_VALID_EVENTS_0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x93e))

#define GP_WB_GET_ES_VALID_EVENTS_0_FROM_VALID_EVENTS(tmp) \
        ((tmp) & 0xFF)

/* Valid Events */
#define GP_WB_READ_ES_VALID_EVENTS_1() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x93f))

#define GP_WB_GET_ES_VALID_EVENTS_1_FROM_VALID_EVENTS(tmp) \
        (((tmp) >> 8) & 0xFF)


#define GP_WB_WRITE_ES_SET_VALID_EVENTS(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x940), (val))

/* Valid Events */
#define GP_WB_WRITE_ES_SET_VALID_EVENTS_0(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x940), (val)); \
        } while (0)

#define GP_WB_SET_ES_SET_VALID_EVENTS_0_TO_SET_VALID_EVENTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          (tmp) &= 0xFF00; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Valid Events */
#define GP_WB_WRITE_ES_SET_VALID_EVENTS_1(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x941), (val)); \
        } while (0)

#define GP_WB_SET_ES_SET_VALID_EVENTS_1_TO_SET_VALID_EVENTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          (tmp) &= 0x00FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)


#define GP_WB_WRITE_ES_CLR_VALID_EVENTS(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x942), (val))

/* Valid Events */
#define GP_WB_WRITE_ES_CLR_VALID_EVENTS_0(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x942), (val)); \
        } while (0)

#define GP_WB_SET_ES_CLR_VALID_EVENTS_0_TO_CLR_VALID_EVENTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          (tmp) &= 0xFF00; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Valid Events */
#define GP_WB_WRITE_ES_CLR_VALID_EVENTS_1(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x943), (val)); \
        } while (0)

#define GP_WB_SET_ES_CLR_VALID_EVENTS_1_TO_CLR_VALID_EVENTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          (tmp) &= 0x00FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)


/* Buffer time */
#define GP_WB_READ_ES_BUFFER_TIME() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x944))

#define GP_WB_WRITE_ES_BUFFER_TIME(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x944), (val)); \
        } while (0)


/* Priotiry time */
#define GP_WB_READ_ES_PRIORITY_TIME() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x946))

#define GP_WB_WRITE_ES_PRIORITY_TIME(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x946), (val)); \
        } while (0)


/* Guard Time Selector */
#define GP_WB_READ_ES_GUARD_TIME_SEL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x948))

#define GP_WB_WRITE_ES_GUARD_TIME_SEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x948), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ES_EVENT_HANDLER_SETTING() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x949))

#define GP_WB_WRITE_ES_EVENT_HANDLER_SETTING(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x949), (val))

/* Overwrite execution time on final execution */
#define GP_WB_READ_ES_OVERWRITE_EXECUTION_TIME_ON_FINAL_EXECUTION() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x949), 0)

#define GP_WB_GET_ES_OVERWRITE_EXECUTION_TIME_ON_FINAL_EXECUTION_FROM_EVENT_HANDLER_SETTING(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_ES_OVERWRITE_EXECUTION_TIME_ON_FINAL_EXECUTION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x949), 0, (val)); \
        } while (0)

#define GP_WB_SET_ES_OVERWRITE_EXECUTION_TIME_ON_FINAL_EXECUTION_TO_EVENT_HANDLER_SETTING(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Freeze relative event countdown */
#define GP_WB_READ_ES_RELATIVE_EVENT_FREEZE_COUNTDOWN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x949), 1)

#define GP_WB_GET_ES_RELATIVE_EVENT_FREEZE_COUNTDOWN_FROM_EVENT_HANDLER_SETTING(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_ES_RELATIVE_EVENT_FREEZE_COUNTDOWN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x949), 1, (val)); \
        } while (0)

#define GP_WB_SET_ES_RELATIVE_EVENT_FREEZE_COUNTDOWN_TO_EVENT_HANDLER_SETTING(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* External event valid */
#define GP_WB_READ_ES_EXTERNAL_EVENT_VALID() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x949), 2)

#define GP_WB_GET_ES_EXTERNAL_EVENT_VALID_FROM_EVENT_HANDLER_SETTING(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_ES_EXTERNAL_EVENT_VALID(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x949), 2, (val)); \
        } while (0)

#define GP_WB_SET_ES_EXTERNAL_EVENT_VALID_TO_EVENT_HANDLER_SETTING(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Comparator event valid */
#define GP_WB_READ_ES_COMP_EVENT_VALID() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x949)) >> 3) & 0x0F)

#define GP_WB_GET_ES_COMP_EVENT_VALID_FROM_EVENT_HANDLER_SETTING(tmp) \
        (((tmp) >> 3) & 0x0F)

#define GP_WB_WRITE_ES_COMP_EVENT_VALID(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x949), 0x78, (val) << 3); \
        } while (0)

#define GP_WB_SET_ES_COMP_EVENT_VALID_TO_EVENT_HANDLER_SETTING(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x87; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* External event type */
#define GP_WB_READ_ES_EXTERNAL_EVENT_TYPE_TO_BE_EXECUTED() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x94a))

#define GP_WB_WRITE_ES_EXTERNAL_EVENT_TYPE_TO_BE_EXECUTED(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x94a), (val)); \
        } while (0)


/* Custom data of external event */
#define GP_WB_READ_ES_EXTERNAL_EVENT_CUSTOM_DATA() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x94c))

#define GP_WB_WRITE_ES_EXTERNAL_EVENT_CUSTOM_DATA(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x94c), (val)); \
        } while (0)


#define GP_WB_WRITE_ES_EVENT_HANDLER_CONTROL(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x94e), (val))

/* Reevaluate events */
#define GP_WB_ES_REEVALUATE_EVENTS() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x94e), 0x01)

#define GP_WB_SET_ES_REEVALUATE_EVENTS_TO_EVENT_HANDLER_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Start relative event countdown */
#define GP_WB_ES_RELATIVE_EVENT_EXECUTE() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x94e), 0x02)

#define GP_WB_SET_ES_RELATIVE_EVENT_EXECUTE_TO_EVENT_HANDLER_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Cancel relative event */
#define GP_WB_ES_RELATIVE_EVENT_CANCEL() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x94e), 0x04)

#define GP_WB_SET_ES_RELATIVE_EVENT_CANCEL_TO_EVENT_HANDLER_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* Relative event type */
#define GP_WB_READ_ES_RELATIVE_EVENT_TYPE_TO_BE_EXECUTED() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x94f))

#define GP_WB_WRITE_ES_RELATIVE_EVENT_TYPE_TO_BE_EXECUTED(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x94f), (val)); \
        } while (0)


/* Custom data of relative event */
#define GP_WB_READ_ES_RELATIVE_EVENT_CUSTOM_DATA() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x950))

#define GP_WB_WRITE_ES_RELATIVE_EVENT_CUSTOM_DATA(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x950), (val)); \
        } while (0)


/* Comparator event type */
#define GP_WB_READ_ES_COMP_EVENT_TYPE_TO_BE_EXECUTED() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x952))

#define GP_WB_WRITE_ES_COMP_EVENT_TYPE_TO_BE_EXECUTED(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x952), (val)); \
        } while (0)


/* Custom data of comparator event */
#define GP_WB_READ_ES_COMP_EVENT_CUSTOM_DATA() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x954))

#define GP_WB_WRITE_ES_COMP_EVENT_CUSTOM_DATA(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x954), (val)); \
        } while (0)




/* Time delay (in multiples of 16 us) after which the event wil be executed */
#define GP_WB_READ_ES_RELATIVE_EVENT_TIME_DELAY() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x95a))

#define GP_WB_WRITE_ES_RELATIVE_EVENT_TIME_DELAY(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x95a), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ES_RELATIVE_EVENT_STATUS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x95b))

/* Relative event count down */
#define GP_WB_READ_ES_RELATIVE_EVENT_COUNTDOWN() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x95b)) & 0x7F)

#define GP_WB_GET_ES_RELATIVE_EVENT_COUNTDOWN_FROM_RELATIVE_EVENT_STATUS(tmp) \
        ((tmp) & 0x7F)

/* Relative event pending */
#define GP_WB_READ_ES_RELATIVE_EVENT_PENDING() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x95b), 7)

#define GP_WB_GET_ES_RELATIVE_EVENT_PENDING_FROM_RELATIVE_EVENT_STATUS(tmp) \
        (((tmp) >> 7) & 0x01)


/* Dither seed */
#define GP_WB_READ_ES_DITHER_SEED() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x95c))

#define GP_WB_WRITE_ES_DITHER_SEED(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x95c), (val)); \
        } while (0)


/* Dither backoff exponent mask */
#define GP_WB_READ_ES_DITHER_BACKOFF_EXPONENT_MASK() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x95e))

#define GP_WB_WRITE_ES_DITHER_BACKOFF_EXPONENT_MASK(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x95e), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ES_EVENT_HANDLER_STATE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x95f))

/* Current Event Number */
#define GP_WB_READ_ES_CURRENT_EVENT_NUMBER() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x95f)) & 0x0F)

#define GP_WB_GET_ES_CURRENT_EVENT_NUMBER_FROM_EVENT_HANDLER_STATE(tmp) \
        ((tmp) & 0x0F)

/* Current Event Pending */
#define GP_WB_READ_ES_CURRENT_EVENT_PENDING() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x95f), 4)

#define GP_WB_GET_ES_CURRENT_EVENT_PENDING_FROM_EVENT_HANDLER_STATE(tmp) \
        (((tmp) >> 4) & 0x01)

/* Current Event Being Executed */
#define GP_WB_READ_ES_CURRENT_EVENT_BEING_EXECUTED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x95f), 5)

#define GP_WB_GET_ES_CURRENT_EVENT_BEING_EXECUTED_FROM_EVENT_HANDLER_STATE(tmp) \
        (((tmp) >> 5) & 0x01)

/* Next Event Search Busy */
#define GP_WB_READ_ES_NEXT_EVENT_SEARCH_BUSY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x95f), 6)

#define GP_WB_GET_ES_NEXT_EVENT_SEARCH_BUSY_FROM_EVENT_HANDLER_STATE(tmp) \
        (((tmp) >> 6) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ES_EVENT_HANDLER_ENABLE_CLK_BY_UC() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x960))

#define GP_WB_WRITE_ES_EVENT_HANDLER_ENABLE_CLK_BY_UC(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x960), (val))

/* Enable clk event handler base a by uC */
#define GP_WB_READ_ES_ENABLE_CLK_EVENT_HANDLER_BASE_A_BY_UC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x960), 0)

#define GP_WB_GET_ES_ENABLE_CLK_EVENT_HANDLER_BASE_A_BY_UC_FROM_EVENT_HANDLER_ENABLE_CLK_BY_UC(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_ES_ENABLE_CLK_EVENT_HANDLER_BASE_A_BY_UC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x960), 0, (val)); \
        } while (0)

#define GP_WB_SET_ES_ENABLE_CLK_EVENT_HANDLER_BASE_A_BY_UC_TO_EVENT_HANDLER_ENABLE_CLK_BY_UC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Enable clk event handler base b by uC */
#define GP_WB_READ_ES_ENABLE_CLK_EVENT_HANDLER_BASE_B_BY_UC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x960), 1)

#define GP_WB_GET_ES_ENABLE_CLK_EVENT_HANDLER_BASE_B_BY_UC_FROM_EVENT_HANDLER_ENABLE_CLK_BY_UC(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_ES_ENABLE_CLK_EVENT_HANDLER_BASE_B_BY_UC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x960), 1, (val)); \
        } while (0)

#define GP_WB_SET_ES_ENABLE_CLK_EVENT_HANDLER_BASE_B_BY_UC_TO_EVENT_HANDLER_ENABLE_CLK_BY_UC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Enable clk event handler external event by uC */
#define GP_WB_READ_ES_ENABLE_CLK_EVENT_HANDLER_EXTERNAL_EVENT_BY_UC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x960), 2)

#define GP_WB_GET_ES_ENABLE_CLK_EVENT_HANDLER_EXTERNAL_EVENT_BY_UC_FROM_EVENT_HANDLER_ENABLE_CLK_BY_UC(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_ES_ENABLE_CLK_EVENT_HANDLER_EXTERNAL_EVENT_BY_UC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x960), 2, (val)); \
        } while (0)

#define GP_WB_SET_ES_ENABLE_CLK_EVENT_HANDLER_EXTERNAL_EVENT_BY_UC_TO_EVENT_HANDLER_ENABLE_CLK_BY_UC(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* event state of the external pins when last external pin event occurred */
#define GP_WB_READ_ES_LAST_EXTERNAL_PIN_EVENT_STATE() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x964))


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ES_UNMASKED_INTERRUPTS() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x968))

/* Unmasked Event Interrupts */
#define GP_WB_READ_ES_UNMASKED_EVENT_INTERRUPTS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x968))

#define GP_WB_GET_ES_UNMASKED_EVENT_INTERRUPTS_FROM_UNMASKED_INTERRUPTS(tmp) \
        ((tmp) & 0xFFFF)

/* Unmasked comparator event interrupts */
#define GP_WB_READ_ES_UNMASKED_COMP_EVENT_INTERRUPTS() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x96a)) & 0x0F)

#define GP_WB_GET_ES_UNMASKED_COMP_EVENT_INTERRUPTS_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0x0F)

#define GP_WB_READ_ES_UNMASKED_SYMBOL_COUNTER_VALID_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x96a), 5)

#define GP_WB_GET_ES_UNMASKED_SYMBOL_COUNTER_VALID_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 21) & 0x01)

/* Unmasked Oscillator Benchmark Done Interrupt */
#define GP_WB_READ_ES_UNMASKED_OSCILLATOR_BENCHMARK_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x96a), 6)

#define GP_WB_GET_ES_UNMASKED_OSCILLATOR_BENCHMARK_DONE_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 22) & 0x01)

/* Unmasked Oscillator Benchmark Done Interrupt */
#define GP_WB_READ_ES_UNMASKED_OSCILLATOR_BENCHMARK_SUB_MEAS_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x96a), 7)

#define GP_WB_GET_ES_UNMASKED_OSCILLATOR_BENCHMARK_SUB_MEAS_DONE_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 23) & 0x01)

/* Unmasked Relative Event Interrupt */
#define GP_WB_READ_ES_UNMASKED_RELATIVE_EVENT_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x96b), 0)

#define GP_WB_GET_ES_UNMASKED_RELATIVE_EVENT_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 24) & 0x01)

/* Unmasked External Event Interrupt */
#define GP_WB_READ_ES_UNMASKED_EXTERNAL_EVENT_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x96b), 1)

#define GP_WB_GET_ES_UNMASKED_EXTERNAL_EVENT_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 25) & 0x01)


#define GP_WB_WRITE_ES_CLR_INTERRUPTS(val) \
      GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x96c), (val))

/* Clear Event Interrupts */
#define GP_WB_WRITE_ES_CLR_EVENT_INTERRUPTS(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x96c), (val)); \
        } while (0)

#define GP_WB_SET_ES_CLR_EVENT_INTERRUPTS_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x07FF0000; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Clear comparator Event Interrupt */
#define GP_WB_WRITE_ES_CLR_COMP_EVENT_INTERRUPTS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x96e), (val)); \
        } while (0)

#define GP_WB_SET_ES_CLR_COMP_EVENT_INTERRUPTS_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x07F0FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* Clear symbol counter interrupt */
#define GP_WB_ES_CLR_SYMBOL_COUNTER_VALID_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x96e), 0x20)

#define GP_WB_SET_ES_CLR_SYMBOL_COUNTER_VALID_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07DFFFFF; \
          (tmp) |= (((UInt32)(val)) << 21); \
        } while (0)

/* Unmasked Oscillator Benchmark Done Interrupt */
#define GP_WB_ES_CLR_OSCILLATOR_BENCHMARK_DONE_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x96e), 0x40)

#define GP_WB_SET_ES_CLR_OSCILLATOR_BENCHMARK_DONE_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07BFFFFF; \
          (tmp) |= (((UInt32)(val)) << 22); \
        } while (0)

/* Unmasked Oscillator Benchmark sub measurement Done Interrupt */
#define GP_WB_ES_CLR_OSCILLATOR_BENCHMARK_SUB_MEAS_DONE_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x96e), 0x80)

#define GP_WB_SET_ES_CLR_OSCILLATOR_BENCHMARK_SUB_MEAS_DONE_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x077FFFFF; \
          (tmp) |= (((UInt32)(val)) << 23); \
        } while (0)

/* Clear Relative Event Interrupt */
#define GP_WB_ES_CLR_RELATIVE_EVENT_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x96f), 0x01)

#define GP_WB_SET_ES_CLR_RELATIVE_EVENT_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)

/* Clear External Event Interrupt */
#define GP_WB_ES_CLR_EXTERNAL_EVENT_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x96f), 0x02)

#define GP_WB_SET_ES_CLR_EXTERNAL_EVENT_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 25); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ES_RETENTION_UNMASKED_INTERRUPTS() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x970))

#define GP_WB_WRITE_ES_RETENTION_UNMASKED_INTERRUPTS(val) \
      GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x970), (val))

/* Retention unmasked event Interrupts */
#define GP_WB_READ_ES_RETENTION_UNMASKED_EVENT_INTERRUPTS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x970))

#define GP_WB_GET_ES_RETENTION_UNMASKED_EVENT_INTERRUPTS_FROM_RETENTION_UNMASKED_INTERRUPTS(tmp) \
        ((tmp) & 0xFFFF)

#define GP_WB_WRITE_ES_RETENTION_UNMASKED_EVENT_INTERRUPTS(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x970), (val)); \
        } while (0)

#define GP_WB_SET_ES_RETENTION_UNMASKED_EVENT_INTERRUPTS_TO_RETENTION_UNMASKED_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x03FF0000; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Retention unmasked Comp Event Interrupts */
#define GP_WB_READ_ES_RETENTION_UNMASKED_COMP_EVENT_INTERRUPTS() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x972)) & 0x0F)

#define GP_WB_GET_ES_RETENTION_UNMASKED_COMP_EVENT_INTERRUPTS_FROM_RETENTION_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0x0F)

#define GP_WB_WRITE_ES_RETENTION_UNMASKED_COMP_EVENT_INTERRUPTS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x972), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_ES_RETENTION_UNMASKED_COMP_EVENT_INTERRUPTS_TO_RETENTION_UNMASKED_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x03F0FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* Retention unmasked symbol counter interrupt */
#define GP_WB_READ_ES_RETENTION_UNMASKED_SYMBOL_COUNTER_VALID_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x972), 5)

#define GP_WB_GET_ES_RETENTION_UNMASKED_SYMBOL_COUNTER_VALID_INTERRUPT_FROM_RETENTION_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 21) & 0x01)

#define GP_WB_WRITE_ES_RETENTION_UNMASKED_SYMBOL_COUNTER_VALID_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x972), 5, (val)); \
        } while (0)

#define GP_WB_SET_ES_RETENTION_UNMASKED_SYMBOL_COUNTER_VALID_INTERRUPT_TO_RETENTION_UNMASKED_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03DFFFFF; \
          (tmp) |= (((UInt32)(val)) << 21); \
        } while (0)

/* Unmasked Oscillator Benchmark Done Interrupt */
#define GP_WB_READ_ES_RETENTION_UNMASKED_OSCILLATOR_BENCHMARK_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x972), 6)

#define GP_WB_GET_ES_RETENTION_UNMASKED_OSCILLATOR_BENCHMARK_DONE_INTERRUPT_FROM_RETENTION_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 22) & 0x01)

#define GP_WB_WRITE_ES_RETENTION_UNMASKED_OSCILLATOR_BENCHMARK_DONE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x972), 6, (val)); \
        } while (0)

#define GP_WB_SET_ES_RETENTION_UNMASKED_OSCILLATOR_BENCHMARK_DONE_INTERRUPT_TO_RETENTION_UNMASKED_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03BFFFFF; \
          (tmp) |= (((UInt32)(val)) << 22); \
        } while (0)

/* Unmasked Oscillator Benchmark sub measurement Done Interrupt */
#define GP_WB_READ_ES_RETENTION_UNMASKED_OSCILLATOR_BENCHMARK_SUB_MEAS_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x972), 7)

#define GP_WB_GET_ES_RETENTION_UNMASKED_OSCILLATOR_BENCHMARK_SUB_MEAS_DONE_INTERRUPT_FROM_RETENTION_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 23) & 0x01)

#define GP_WB_WRITE_ES_RETENTION_UNMASKED_OSCILLATOR_BENCHMARK_SUB_MEAS_DONE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x972), 7, (val)); \
        } while (0)

#define GP_WB_SET_ES_RETENTION_UNMASKED_OSCILLATOR_BENCHMARK_SUB_MEAS_DONE_INTERRUPT_TO_RETENTION_UNMASKED_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x037FFFFF; \
          (tmp) |= (((UInt32)(val)) << 23); \
        } while (0)

/* Retention unmasked Relative Event Interrupt */
#define GP_WB_READ_ES_RETENTION_UNMASKED_RELATIVE_EVENT_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x973), 0)

#define GP_WB_GET_ES_RETENTION_UNMASKED_RELATIVE_EVENT_INTERRUPT_FROM_RETENTION_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 24) & 0x01)

#define GP_WB_WRITE_ES_RETENTION_UNMASKED_RELATIVE_EVENT_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x973), 0, (val)); \
        } while (0)

#define GP_WB_SET_ES_RETENTION_UNMASKED_RELATIVE_EVENT_INTERRUPT_TO_RETENTION_UNMASKED_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)

/* Retention unmasked External Event Interrupt */
#define GP_WB_READ_ES_RETENTION_UNMASKED_EXTERNAL_EVENT_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x973), 1)

#define GP_WB_GET_ES_RETENTION_UNMASKED_EXTERNAL_EVENT_INTERRUPT_FROM_RETENTION_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 25) & 0x01)

#define GP_WB_WRITE_ES_RETENTION_UNMASKED_EXTERNAL_EVENT_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x973), 1, (val)); \
        } while (0)

#define GP_WB_SET_ES_RETENTION_UNMASKED_EXTERNAL_EVENT_INTERRUPT_TO_RETENTION_UNMASKED_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 25); \
        } while (0)


/* Calibration factor adjustment */
#define GP_WB_READ_ES_CALIBRATION_FACTOR_ADJUSTMENT() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x974))

#define GP_WB_WRITE_ES_CALIBRATION_FACTOR_ADJUSTMENT(val) do { \
          GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x974), (val)); \
        } while (0)

/***************************
 * layout: msi
 ***************************/

/* Semaphore 0 */
#define GP_WB_READ_MSI_SEMAPHORE_0() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xa00), 0)

#define GP_WB_WRITE_MSI_SEMAPHORE_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xa00), (val)); \
        } while (0)


/* Semaphore 1 */
#define GP_WB_READ_MSI_SEMAPHORE_1() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xa01), 0)

#define GP_WB_WRITE_MSI_SEMAPHORE_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xa01), (val)); \
        } while (0)


/* Semaphore 2 */
#define GP_WB_READ_MSI_SEMAPHORE_2() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xa02), 0)

#define GP_WB_WRITE_MSI_SEMAPHORE_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xa02), (val)); \
        } while (0)


/* Semaphore 3 */
#define GP_WB_READ_MSI_SEMAPHORE_3() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xa03), 0)

#define GP_WB_WRITE_MSI_SEMAPHORE_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xa03), (val)); \
        } while (0)


/* see enum definition */
#define GP_WB_READ_MSI_SERIAL_ITF_SELECT() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xa04))

#define GP_WB_WRITE_MSI_SERIAL_ITF_SELECT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xa04), (val)); \
        } while (0)

/***************************
 * layout: int_ctrl
 ***************************/

/* This bit enables the external interrupts */
#define GP_WB_READ_INT_CTRL_GLOBAL_INTERRUPTS_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb00), 0)

#define GP_WB_WRITE_INT_CTRL_GLOBAL_INTERRUPTS_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb00), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_UNMASKED_INTERRUPTS() \
        GP_WB_READ_U40(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb04))

/* unmasked I2C master interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_I2CM_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb04), 0)

#define GP_WB_GET_INT_CTRL_UNMASKED_I2CM_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* unmasked standby controller interrupt (internal and external are the same) */
#define GP_WB_READ_INT_CTRL_UNMASKED_STBC_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb04), 2)

#define GP_WB_GET_INT_CTRL_UNMASKED_STBC_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* unmasked IR driver interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_IR_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb04), 3)

#define GP_WB_GET_INT_CTRL_UNMASKED_IR_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

/* unmasked RPA accelerator interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_RPA_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb04), 4)

#define GP_WB_GET_INT_CTRL_UNMASKED_RPA_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

/* unmasked qta interrupt (same for internal and external) */
#define GP_WB_READ_INT_CTRL_UNMASKED_QTA_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb04), 5)

#define GP_WB_GET_INT_CTRL_UNMASKED_QTA_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

/* unmasked watchdog interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_WATCHDOG_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb04), 6)

#define GP_WB_GET_INT_CTRL_UNMASKED_WATCHDOG_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 6) & 0x01)

/* unmasked ES interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_ES_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb04), 7)

#define GP_WB_GET_INT_CTRL_UNMASKED_ES_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 7) & 0x01)

/* unmasked UART interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_UART_1_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb05), 0)

#define GP_WB_GET_INT_CTRL_UNMASKED_UART_1_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x01)

/* unmasked UART interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_UART_0_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb05), 1)

#define GP_WB_GET_INT_CTRL_UNMASKED_UART_0_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 9) & 0x01)

/* unmasked parfcs filter interrupt (same for internal and external) */
#define GP_WB_READ_INT_CTRL_UNMASKED_PARFCS_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb05), 2)

#define GP_WB_GET_INT_CTRL_UNMASKED_PARFCS_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 10) & 0x01)

/* unmasked RCI interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_RCI_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb05), 3)

#define GP_WB_GET_INT_CTRL_UNMASKED_RCI_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 11) & 0x01)

/* unmasked ADC interface interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_ADCIF_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb05), 4)

#define GP_WB_GET_INT_CTRL_UNMASKED_ADCIF_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 12) & 0x01)

/* unmasked ASP interface interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_ASP_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb05), 5)

#define GP_WB_GET_INT_CTRL_UNMASKED_ASP_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 13) & 0x01)

/* unmasked security processor interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_SSP_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb05), 6)

#define GP_WB_GET_INT_CTRL_UNMASKED_SSP_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 14) & 0x01)

/* unmasked I2S master interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_I2SM_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb05), 7)

#define GP_WB_GET_INT_CTRL_UNMASKED_I2SM_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 15) & 0x01)

/* unmasked Phy interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_PHY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb06), 0)

#define GP_WB_GET_INT_CTRL_UNMASKED_PHY_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0x01)

/* unmasked Security Processor interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_SECPROC_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb06), 1)

#define GP_WB_GET_INT_CTRL_UNMASKED_SECPROC_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 17) & 0x01)

/* unmasked SPI Master interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_SPIM_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb06), 2)

#define GP_WB_GET_INT_CTRL_UNMASKED_SPIM_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 18) & 0x01)

/* unmasked gpmicro interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_GPMICRO_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb06), 3)

#define GP_WB_GET_INT_CTRL_UNMASKED_GPMICRO_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 19) & 0x01)

/* unmasked BBPLL interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_BBPLL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb06), 4)

#define GP_WB_GET_INT_CTRL_UNMASKED_BBPLL_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 20) & 0x01)

/* unmasked SPI Slave interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_SPISL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb06), 5)

#define GP_WB_GET_INT_CTRL_UNMASKED_SPISL_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 21) & 0x01)

/* unmasked DMA SCB engine interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_DMAS_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb06), 6)

#define GP_WB_GET_INT_CTRL_UNMASKED_DMAS_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 22) & 0x01)

/* unmasked gpio external interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_GPIO_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb06), 7)

#define GP_WB_GET_INT_CTRL_UNMASKED_GPIO_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 23) & 0x01)

/* unmasked trc interrupt (same for internal and external) */
#define GP_WB_READ_INT_CTRL_UNMASKED_TRC_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb07), 0)

#define GP_WB_GET_INT_CTRL_UNMASKED_TRC_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 24) & 0x01)

/* unmasked parble filter interrupt (same for internal and external) */
#define GP_WB_READ_INT_CTRL_UNMASKED_PARBLE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb07), 1)

#define GP_WB_GET_INT_CTRL_UNMASKED_PARBLE_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 25) & 0x01)

/* unmasked timer interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_TIMERS_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb07), 2)

#define GP_WB_GET_INT_CTRL_UNMASKED_TIMERS_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 26) & 0x01)

/* unmasked mri interrupt (internal and external are the same) */
#define GP_WB_READ_INT_CTRL_UNMASKED_MRI_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb07), 3)

#define GP_WB_GET_INT_CTRL_UNMASKED_MRI_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 27) & 0x01)

/* unmasked I2C Slave interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_I2CSL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb07), 4)

#define GP_WB_GET_INT_CTRL_UNMASKED_I2CSL_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 28) & 0x01)

/* unmasked PWM interrupt */
#define GP_WB_READ_INT_CTRL_UNMASKED_PWMS_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb07), 5)

#define GP_WB_GET_INT_CTRL_UNMASKED_PWMS_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 29) & 0x01)

/* unmasked inter process communication interrupt (... 2 gpm) */
#define GP_WB_READ_INT_CTRL_UNMASKED_IPCX2GPM_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb07), 6)

#define GP_WB_GET_INT_CTRL_UNMASKED_IPCX2GPM_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 30) & 0x01)

/* unmasked inter process communication interrupt (ext 2 ...) */
#define GP_WB_READ_INT_CTRL_UNMASKED_IPCEXT2X_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb07), 7)

#define GP_WB_GET_INT_CTRL_UNMASKED_IPCEXT2X_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 31) & 0x01)

/* unmasked inter process communication interrupt (... 2 int) */
#define GP_WB_READ_INT_CTRL_UNMASKED_IPCX2INT_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb08), 0)

#define GP_WB_GET_INT_CTRL_UNMASKED_IPCX2INT_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 32) & 0x01)

/* unmasked inter process communication interrupt (... 2 ext) */
#define GP_WB_READ_INT_CTRL_UNMASKED_IPCX2EXT_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb08), 1)

#define GP_WB_GET_INT_CTRL_UNMASKED_IPCX2EXT_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 33) & 0x01)

/* unmasked inter process communication interrupt (gpm 2 ...) */
#define GP_WB_READ_INT_CTRL_UNMASKED_IPCGPM2X_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb08), 2)

#define GP_WB_GET_INT_CTRL_UNMASKED_IPCGPM2X_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 34) & 0x01)

/* unmasked inter process communication interrupt (int 2 ...) */
#define GP_WB_READ_INT_CTRL_UNMASKED_IPCINT2X_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb08), 3)

#define GP_WB_GET_INT_CTRL_UNMASKED_IPCINT2X_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 35) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_INTERRUPTS() \
        GP_WB_READ_U40(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb0c))

/* masked external I2C master interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_I2CM_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb0c), 0)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_I2CM_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* masked external standby controller interrupt (internal and external are the same) */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_STBC_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb0c), 2)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_STBC_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* masked external IR driver interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_IR_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb0c), 3)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_IR_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

/* masked external RPA accelerator interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_RPA_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb0c), 4)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_RPA_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

/* masked external qta interrupt (same for internal and external) */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_QTA_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb0c), 5)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_QTA_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

/* masked external watchdog interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_WATCHDOG_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb0c), 6)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_WATCHDOG_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 6) & 0x01)

/* masked external ES interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_ES_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb0c), 7)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_ES_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 7) & 0x01)

/* masked external UART interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_UART_1_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb0d), 0)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_UART_1_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x01)

/* masked external UART interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_UART_0_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb0d), 1)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_UART_0_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 9) & 0x01)

/* masked external parfcs filter interrupt (same for internal and external) */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_PARFCS_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb0d), 2)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_PARFCS_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 10) & 0x01)

/* masked external RCI interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_RCI_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb0d), 3)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_RCI_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 11) & 0x01)

/* masked external ADC interface interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_ADCIF_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb0d), 4)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_ADCIF_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 12) & 0x01)

/* masked external ASP interface interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_ASP_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb0d), 5)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_ASP_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 13) & 0x01)

/* masked external security processor interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_SSP_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb0d), 6)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_SSP_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 14) & 0x01)

/* masked external I2S master interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_I2SM_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb0d), 7)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_I2SM_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 15) & 0x01)

/* masked external Phy interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_PHY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb0e), 0)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_PHY_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0x01)

/* masked external Security Processor interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_SECPROC_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb0e), 1)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_SECPROC_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 17) & 0x01)

/* masked external SPI Master interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_SPIM_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb0e), 2)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_SPIM_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 18) & 0x01)

/* masked external gpmicro interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_GPMICRO_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb0e), 3)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_GPMICRO_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 19) & 0x01)

/* masked external BBPLL interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_BBPLL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb0e), 4)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_BBPLL_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 20) & 0x01)

/* masked external SPI Slave interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_SPISL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb0e), 5)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_SPISL_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 21) & 0x01)

/* masked external DMA SCB engine interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_DMAS_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb0e), 6)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_DMAS_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 22) & 0x01)

/* masked external gpio external interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_GPIO_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb0e), 7)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_GPIO_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 23) & 0x01)

/* masked external trc interrupt (same for internal and external) */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_TRC_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb0f), 0)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_TRC_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 24) & 0x01)

/* masked external parble filter interrupt (same for internal and external) */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_PARBLE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb0f), 1)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_PARBLE_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 25) & 0x01)

/* masked external timer interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_TIMERS_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb0f), 2)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_TIMERS_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 26) & 0x01)

/* masked external mri interrupt (internal and external are the same) */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_MRI_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb0f), 3)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_MRI_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 27) & 0x01)

/* masked external I2C Slave interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_I2CSL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb0f), 4)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_I2CSL_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 28) & 0x01)

/* masked external PWM interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_PWMS_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb0f), 5)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_PWMS_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 29) & 0x01)

/* masked external inter process communication interrupt (... 2 ext) */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_IPCX2EXT_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb0f), 6)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_IPCX2EXT_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 30) & 0x01)

/* masked external inter process communication interrupt (gpm 2 ...) */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_IPCGPM2X_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb0f), 7)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_IPCGPM2X_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 31) & 0x01)

/* masked external inter process communication interrupt (int 2 ...) */
#define GP_WB_READ_INT_CTRL_MASKED_EXT_IPCINT2X_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb10), 0)

#define GP_WB_GET_INT_CTRL_MASKED_EXT_IPCINT2X_INTERRUPT_FROM_MASKED_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 32) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_EXT_INTERRUPTS() \
        GP_WB_READ_U40(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb14))

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_INTERRUPTS(val) \
      GP_WB_WRITE_U40(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb14), (val))

/* mask external I2C master interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_I2CM_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb14), 0)

#define GP_WB_GET_INT_CTRL_MASK_EXT_I2CM_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_I2CM_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb14), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_I2CM_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFFE; \
          (tmp) |= ((UInt64)(val)); \
        } while (0)

/* mask external standby controller interrupt (internal and external are the same) */
#define GP_WB_READ_INT_CTRL_MASK_EXT_STBC_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb14), 2)

#define GP_WB_GET_INT_CTRL_MASK_EXT_STBC_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_STBC_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb14), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_STBC_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFFB; \
          (tmp) |= (((UInt64)(val)) << 2); \
        } while (0)

/* mask external IR driver interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_IR_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb14), 3)

#define GP_WB_GET_INT_CTRL_MASK_EXT_IR_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_IR_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb14), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_IR_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFF7; \
          (tmp) |= (((UInt64)(val)) << 3); \
        } while (0)

/* mask external RPA accelerator interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_RPA_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb14), 4)

#define GP_WB_GET_INT_CTRL_MASK_EXT_RPA_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_RPA_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb14), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_RPA_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFEF; \
          (tmp) |= (((UInt64)(val)) << 4); \
        } while (0)

/* mask external qta interrupt (same for internal and external) */
#define GP_WB_READ_INT_CTRL_MASK_EXT_QTA_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb14), 5)

#define GP_WB_GET_INT_CTRL_MASK_EXT_QTA_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_QTA_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb14), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_QTA_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFDF; \
          (tmp) |= (((UInt64)(val)) << 5); \
        } while (0)

/* mask external watchdog interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_WATCHDOG_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb14), 6)

#define GP_WB_GET_INT_CTRL_MASK_EXT_WATCHDOG_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_WATCHDOG_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb14), 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_WATCHDOG_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFBF; \
          (tmp) |= (((UInt64)(val)) << 6); \
        } while (0)

/* mask external ES interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_ES_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb14), 7)

#define GP_WB_GET_INT_CTRL_MASK_EXT_ES_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_ES_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb14), 7, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_ES_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFF7F; \
          (tmp) |= (((UInt64)(val)) << 7); \
        } while (0)

/* mask external UART interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_UART_1_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb15), 0)

#define GP_WB_GET_INT_CTRL_MASK_EXT_UART_1_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_UART_1_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb15), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_UART_1_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFEFF; \
          (tmp) |= (((UInt64)(val)) << 8); \
        } while (0)

/* mask external UART interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_UART_0_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb15), 1)

#define GP_WB_GET_INT_CTRL_MASK_EXT_UART_0_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_UART_0_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb15), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_UART_0_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFDFF; \
          (tmp) |= (((UInt64)(val)) << 9); \
        } while (0)

/* mask external parfcs filter interrupt (same for internal and external) */
#define GP_WB_READ_INT_CTRL_MASK_EXT_PARFCS_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb15), 2)

#define GP_WB_GET_INT_CTRL_MASK_EXT_PARFCS_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_PARFCS_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb15), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_PARFCS_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFBFF; \
          (tmp) |= (((UInt64)(val)) << 10); \
        } while (0)

/* mask external RCI interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_RCI_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb15), 3)

#define GP_WB_GET_INT_CTRL_MASK_EXT_RCI_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_RCI_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb15), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_RCI_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFF7FF; \
          (tmp) |= (((UInt64)(val)) << 11); \
        } while (0)

/* mask external ADC interface interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_ADCIF_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb15), 4)

#define GP_WB_GET_INT_CTRL_MASK_EXT_ADCIF_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_ADCIF_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb15), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_ADCIF_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFEFFF; \
          (tmp) |= (((UInt64)(val)) << 12); \
        } while (0)

/* mask external ASP interface interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_ASP_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb15), 5)

#define GP_WB_GET_INT_CTRL_MASK_EXT_ASP_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_ASP_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb15), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_ASP_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFDFFF; \
          (tmp) |= (((UInt64)(val)) << 13); \
        } while (0)

/* mask external security processor interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_SSP_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb15), 6)

#define GP_WB_GET_INT_CTRL_MASK_EXT_SSP_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_SSP_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb15), 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_SSP_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFBFFF; \
          (tmp) |= (((UInt64)(val)) << 14); \
        } while (0)

/* mask external I2S master interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_I2SM_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb15), 7)

#define GP_WB_GET_INT_CTRL_MASK_EXT_I2SM_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_I2SM_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb15), 7, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_I2SM_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFF7FFF; \
          (tmp) |= (((UInt64)(val)) << 15); \
        } while (0)

/* mask external Phy interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_PHY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb16), 0)

#define GP_WB_GET_INT_CTRL_MASK_EXT_PHY_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_PHY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb16), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_PHY_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFEFFFF; \
          (tmp) |= (((UInt64)(val)) << 16); \
        } while (0)

/* mask external Security Processor interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_SECPROC_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb16), 1)

#define GP_WB_GET_INT_CTRL_MASK_EXT_SECPROC_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 17) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_SECPROC_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb16), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_SECPROC_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFDFFFF; \
          (tmp) |= (((UInt64)(val)) << 17); \
        } while (0)

/* mask external SPI Master interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_SPIM_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb16), 2)

#define GP_WB_GET_INT_CTRL_MASK_EXT_SPIM_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 18) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_SPIM_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb16), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_SPIM_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFBFFFF; \
          (tmp) |= (((UInt64)(val)) << 18); \
        } while (0)

/* mask external gpmicro interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_GPMICRO_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb16), 3)

#define GP_WB_GET_INT_CTRL_MASK_EXT_GPMICRO_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 19) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_GPMICRO_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb16), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_GPMICRO_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFF7FFFF; \
          (tmp) |= (((UInt64)(val)) << 19); \
        } while (0)

/* mask external BBPLL interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_BBPLL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb16), 4)

#define GP_WB_GET_INT_CTRL_MASK_EXT_BBPLL_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 20) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_BBPLL_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb16), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_BBPLL_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFEFFFFF; \
          (tmp) |= (((UInt64)(val)) << 20); \
        } while (0)

/* mask external SPI Slave interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_SPISL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb16), 5)

#define GP_WB_GET_INT_CTRL_MASK_EXT_SPISL_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 21) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_SPISL_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb16), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_SPISL_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFDFFFFF; \
          (tmp) |= (((UInt64)(val)) << 21); \
        } while (0)

/* mask external DMA SCB engine interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_DMAS_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb16), 6)

#define GP_WB_GET_INT_CTRL_MASK_EXT_DMAS_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 22) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_DMAS_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb16), 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_DMAS_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFBFFFFF; \
          (tmp) |= (((UInt64)(val)) << 22); \
        } while (0)

/* mask external gpio external interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_GPIO_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb16), 7)

#define GP_WB_GET_INT_CTRL_MASK_EXT_GPIO_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 23) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_GPIO_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb16), 7, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_GPIO_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FF7FFFFF; \
          (tmp) |= (((UInt64)(val)) << 23); \
        } while (0)

/* mask external trc interrupt (same for internal and external) */
#define GP_WB_READ_INT_CTRL_MASK_EXT_TRC_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb17), 0)

#define GP_WB_GET_INT_CTRL_MASK_EXT_TRC_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 24) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_TRC_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb17), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_TRC_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FEFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 24); \
        } while (0)

/* mask external parble filter interrupt (same for internal and external) */
#define GP_WB_READ_INT_CTRL_MASK_EXT_PARBLE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb17), 1)

#define GP_WB_GET_INT_CTRL_MASK_EXT_PARBLE_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 25) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_PARBLE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb17), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_PARBLE_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FDFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 25); \
        } while (0)

/* mask external timer interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_TIMERS_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb17), 2)

#define GP_WB_GET_INT_CTRL_MASK_EXT_TIMERS_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 26) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_TIMERS_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb17), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_TIMERS_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FBFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 26); \
        } while (0)

/* mask external mri interrupt (internal and external are the same) */
#define GP_WB_READ_INT_CTRL_MASK_EXT_MRI_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb17), 3)

#define GP_WB_GET_INT_CTRL_MASK_EXT_MRI_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 27) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_MRI_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb17), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_MRI_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01F7FFFFFF; \
          (tmp) |= (((UInt64)(val)) << 27); \
        } while (0)

/* mask external I2C Slave interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_I2CSL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb17), 4)

#define GP_WB_GET_INT_CTRL_MASK_EXT_I2CSL_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 28) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_I2CSL_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb17), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_I2CSL_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01EFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 28); \
        } while (0)

/* mask external PWM interrupt */
#define GP_WB_READ_INT_CTRL_MASK_EXT_PWMS_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb17), 5)

#define GP_WB_GET_INT_CTRL_MASK_EXT_PWMS_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 29) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_PWMS_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb17), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_PWMS_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01DFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 29); \
        } while (0)

/* mask external inter process communication interrupt (... 2 ext) */
#define GP_WB_READ_INT_CTRL_MASK_EXT_IPCX2EXT_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb17), 6)

#define GP_WB_GET_INT_CTRL_MASK_EXT_IPCX2EXT_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 30) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_IPCX2EXT_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb17), 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_IPCX2EXT_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01BFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 30); \
        } while (0)

/* mask external inter process communication interrupt (gpm 2 ...) */
#define GP_WB_READ_INT_CTRL_MASK_EXT_IPCGPM2X_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb17), 7)

#define GP_WB_GET_INT_CTRL_MASK_EXT_IPCGPM2X_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 31) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_IPCGPM2X_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb17), 7, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_IPCGPM2X_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x017FFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 31); \
        } while (0)

/* mask external inter process communication interrupt (int 2 ...) */
#define GP_WB_READ_INT_CTRL_MASK_EXT_IPCINT2X_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb18), 0)

#define GP_WB_GET_INT_CTRL_MASK_EXT_IPCINT2X_INTERRUPT_FROM_MASK_EXT_INTERRUPTS(tmp) \
        (((tmp) >> 32) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_EXT_IPCINT2X_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb18), (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_EXT_IPCINT2X_INTERRUPT_TO_MASK_EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x00FFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 32); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_INT_INTERRUPTS() \
        GP_WB_READ_U40(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb1c))

/* masked internal I2C master interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_I2CM_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb1c), 0)

#define GP_WB_GET_INT_CTRL_MASKED_INT_I2CM_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* masked internal standby controller interrupt (internal and external are the same) */
#define GP_WB_READ_INT_CTRL_MASKED_INT_STBC_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb1c), 2)

#define GP_WB_GET_INT_CTRL_MASKED_INT_STBC_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* masked internal IR driver interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_IR_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb1c), 3)

#define GP_WB_GET_INT_CTRL_MASKED_INT_IR_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

/* masked internal RPA accelerator interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_RPA_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb1c), 4)

#define GP_WB_GET_INT_CTRL_MASKED_INT_RPA_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

/* masked internal qta interrupt (same for internal and external) */
#define GP_WB_READ_INT_CTRL_MASKED_INT_QTA_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb1c), 5)

#define GP_WB_GET_INT_CTRL_MASKED_INT_QTA_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

/* masked internal watchdog interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_WATCHDOG_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb1c), 6)

#define GP_WB_GET_INT_CTRL_MASKED_INT_WATCHDOG_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 6) & 0x01)

/* masked internal ES interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_ES_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb1c), 7)

#define GP_WB_GET_INT_CTRL_MASKED_INT_ES_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 7) & 0x01)

/* masked internal UART interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_UART_1_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb1d), 0)

#define GP_WB_GET_INT_CTRL_MASKED_INT_UART_1_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x01)

/* masked internal UART interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_UART_0_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb1d), 1)

#define GP_WB_GET_INT_CTRL_MASKED_INT_UART_0_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 9) & 0x01)

/* masked internal parfcs filter interrupt (same for internal and external) */
#define GP_WB_READ_INT_CTRL_MASKED_INT_PARFCS_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb1d), 2)

#define GP_WB_GET_INT_CTRL_MASKED_INT_PARFCS_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 10) & 0x01)

/* masked internal RCI interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_RCI_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb1d), 3)

#define GP_WB_GET_INT_CTRL_MASKED_INT_RCI_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 11) & 0x01)

/* masked internal ADC interface interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_ADCIF_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb1d), 4)

#define GP_WB_GET_INT_CTRL_MASKED_INT_ADCIF_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 12) & 0x01)

/* masked internal ASP interface interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_ASP_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb1d), 5)

#define GP_WB_GET_INT_CTRL_MASKED_INT_ASP_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 13) & 0x01)

/* masked internal security processor interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_SSP_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb1d), 6)

#define GP_WB_GET_INT_CTRL_MASKED_INT_SSP_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 14) & 0x01)

/* masked internal I2S master interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_I2SM_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb1d), 7)

#define GP_WB_GET_INT_CTRL_MASKED_INT_I2SM_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 15) & 0x01)

/* masked internal Phy interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_PHY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb1e), 0)

#define GP_WB_GET_INT_CTRL_MASKED_INT_PHY_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0x01)

/* masked internal Security Processor interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_SECPROC_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb1e), 1)

#define GP_WB_GET_INT_CTRL_MASKED_INT_SECPROC_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 17) & 0x01)

/* masked internal SPI Master interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_SPIM_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb1e), 2)

#define GP_WB_GET_INT_CTRL_MASKED_INT_SPIM_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 18) & 0x01)

/* masked internal gpmicro interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_GPMICRO_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb1e), 3)

#define GP_WB_GET_INT_CTRL_MASKED_INT_GPMICRO_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 19) & 0x01)

/* masked internal BBPLL interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_BBPLL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb1e), 4)

#define GP_WB_GET_INT_CTRL_MASKED_INT_BBPLL_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 20) & 0x01)

/* masked internal SPI Slave interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_SPISL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb1e), 5)

#define GP_WB_GET_INT_CTRL_MASKED_INT_SPISL_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 21) & 0x01)

/* masked internal DMA SCB engine interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_DMAS_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb1e), 6)

#define GP_WB_GET_INT_CTRL_MASKED_INT_DMAS_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 22) & 0x01)

/* masked internal gpio external interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_GPIO_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb1e), 7)

#define GP_WB_GET_INT_CTRL_MASKED_INT_GPIO_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 23) & 0x01)

/* masked internal trc interrupt (same for internal and external) */
#define GP_WB_READ_INT_CTRL_MASKED_INT_TRC_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb1f), 0)

#define GP_WB_GET_INT_CTRL_MASKED_INT_TRC_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 24) & 0x01)

/* masked internal parble filter interrupt (same for internal and external) */
#define GP_WB_READ_INT_CTRL_MASKED_INT_PARBLE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb1f), 1)

#define GP_WB_GET_INT_CTRL_MASKED_INT_PARBLE_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 25) & 0x01)

/* masked internal timer interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_TIMERS_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb1f), 2)

#define GP_WB_GET_INT_CTRL_MASKED_INT_TIMERS_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 26) & 0x01)

/* masked internal mri interrupt (internal and external are the same) */
#define GP_WB_READ_INT_CTRL_MASKED_INT_MRI_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb1f), 3)

#define GP_WB_GET_INT_CTRL_MASKED_INT_MRI_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 27) & 0x01)

/* masked internal I2C Slave interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_I2CSL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb1f), 4)

#define GP_WB_GET_INT_CTRL_MASKED_INT_I2CSL_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 28) & 0x01)

/* masked internal PWM interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_INT_PWMS_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb1f), 5)

#define GP_WB_GET_INT_CTRL_MASKED_INT_PWMS_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 29) & 0x01)

/* masked internal inter process communication interrupt (ext 2 ...) */
#define GP_WB_READ_INT_CTRL_MASKED_INT_IPCEXT2X_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb1f), 6)

#define GP_WB_GET_INT_CTRL_MASKED_INT_IPCEXT2X_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 30) & 0x01)

/* masked internal inter process communication interrupt (... 2 int) */
#define GP_WB_READ_INT_CTRL_MASKED_INT_IPCX2INT_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb1f), 7)

#define GP_WB_GET_INT_CTRL_MASKED_INT_IPCX2INT_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 31) & 0x01)

/* masked internal inter process communication interrupt (gpm 2 ...) */
#define GP_WB_READ_INT_CTRL_MASKED_INT_IPCGPM2X_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb20), 0)

#define GP_WB_GET_INT_CTRL_MASKED_INT_IPCGPM2X_INTERRUPT_FROM_MASKED_INT_INTERRUPTS(tmp) \
        (((tmp) >> 32) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_INT_INTERRUPTS() \
        GP_WB_READ_U40(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb24))

#define GP_WB_WRITE_INT_CTRL_MASK_INT_INTERRUPTS(val) \
      GP_WB_WRITE_U40(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb24), (val))

/* mask internal I2C master interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_I2CM_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb24), 0)

#define GP_WB_GET_INT_CTRL_MASK_INT_I2CM_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_I2CM_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb24), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_I2CM_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFFE; \
          (tmp) |= ((UInt64)(val)); \
        } while (0)

/* mask internal standby controller interrupt (internal and external are the same) */
#define GP_WB_READ_INT_CTRL_MASK_INT_STBC_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb24), 2)

#define GP_WB_GET_INT_CTRL_MASK_INT_STBC_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_STBC_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb24), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_STBC_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFFB; \
          (tmp) |= (((UInt64)(val)) << 2); \
        } while (0)

/* mask internal IR driver interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_IR_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb24), 3)

#define GP_WB_GET_INT_CTRL_MASK_INT_IR_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_IR_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb24), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_IR_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFF7; \
          (tmp) |= (((UInt64)(val)) << 3); \
        } while (0)

/* mask internal RPA accelerator interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_RPA_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb24), 4)

#define GP_WB_GET_INT_CTRL_MASK_INT_RPA_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_RPA_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb24), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_RPA_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFEF; \
          (tmp) |= (((UInt64)(val)) << 4); \
        } while (0)

/* mask internal qta interrupt (same for internal and external) */
#define GP_WB_READ_INT_CTRL_MASK_INT_QTA_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb24), 5)

#define GP_WB_GET_INT_CTRL_MASK_INT_QTA_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_QTA_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb24), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_QTA_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFDF; \
          (tmp) |= (((UInt64)(val)) << 5); \
        } while (0)

/* mask internal watchdog interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_WATCHDOG_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb24), 6)

#define GP_WB_GET_INT_CTRL_MASK_INT_WATCHDOG_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_WATCHDOG_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb24), 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_WATCHDOG_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFFBF; \
          (tmp) |= (((UInt64)(val)) << 6); \
        } while (0)

/* mask internal ES interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_ES_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb24), 7)

#define GP_WB_GET_INT_CTRL_MASK_INT_ES_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_ES_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb24), 7, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_ES_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFF7F; \
          (tmp) |= (((UInt64)(val)) << 7); \
        } while (0)

/* mask internal UART interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_UART_1_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb25), 0)

#define GP_WB_GET_INT_CTRL_MASK_INT_UART_1_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_UART_1_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb25), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_UART_1_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFEFF; \
          (tmp) |= (((UInt64)(val)) << 8); \
        } while (0)

/* mask internal UART interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_UART_0_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb25), 1)

#define GP_WB_GET_INT_CTRL_MASK_INT_UART_0_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_UART_0_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb25), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_UART_0_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFDFF; \
          (tmp) |= (((UInt64)(val)) << 9); \
        } while (0)

/* mask internal parfcs filter interrupt (same for internal and external) */
#define GP_WB_READ_INT_CTRL_MASK_INT_PARFCS_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb25), 2)

#define GP_WB_GET_INT_CTRL_MASK_INT_PARFCS_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_PARFCS_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb25), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_PARFCS_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFBFF; \
          (tmp) |= (((UInt64)(val)) << 10); \
        } while (0)

/* mask internal RCI interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_RCI_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb25), 3)

#define GP_WB_GET_INT_CTRL_MASK_INT_RCI_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_RCI_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb25), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_RCI_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFF7FF; \
          (tmp) |= (((UInt64)(val)) << 11); \
        } while (0)

/* mask internal ADC interface interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_ADCIF_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb25), 4)

#define GP_WB_GET_INT_CTRL_MASK_INT_ADCIF_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_ADCIF_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb25), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_ADCIF_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFEFFF; \
          (tmp) |= (((UInt64)(val)) << 12); \
        } while (0)

/* mask internal ASP interface interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_ASP_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb25), 5)

#define GP_WB_GET_INT_CTRL_MASK_INT_ASP_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_ASP_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb25), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_ASP_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFDFFF; \
          (tmp) |= (((UInt64)(val)) << 13); \
        } while (0)

/* mask internal security processor interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_SSP_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb25), 6)

#define GP_WB_GET_INT_CTRL_MASK_INT_SSP_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_SSP_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb25), 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_SSP_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFBFFF; \
          (tmp) |= (((UInt64)(val)) << 14); \
        } while (0)

/* mask internal I2S master interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_I2SM_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb25), 7)

#define GP_WB_GET_INT_CTRL_MASK_INT_I2SM_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_I2SM_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb25), 7, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_I2SM_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFF7FFF; \
          (tmp) |= (((UInt64)(val)) << 15); \
        } while (0)

/* mask internal Phy interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_PHY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb26), 0)

#define GP_WB_GET_INT_CTRL_MASK_INT_PHY_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_PHY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb26), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_PHY_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFEFFFF; \
          (tmp) |= (((UInt64)(val)) << 16); \
        } while (0)

/* mask internal Security Processor interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_SECPROC_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb26), 1)

#define GP_WB_GET_INT_CTRL_MASK_INT_SECPROC_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 17) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_SECPROC_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb26), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_SECPROC_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFDFFFF; \
          (tmp) |= (((UInt64)(val)) << 17); \
        } while (0)

/* mask internal SPI Master interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_SPIM_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb26), 2)

#define GP_WB_GET_INT_CTRL_MASK_INT_SPIM_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 18) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_SPIM_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb26), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_SPIM_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFBFFFF; \
          (tmp) |= (((UInt64)(val)) << 18); \
        } while (0)

/* mask internal gpmicro interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_GPMICRO_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb26), 3)

#define GP_WB_GET_INT_CTRL_MASK_INT_GPMICRO_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 19) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_GPMICRO_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb26), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_GPMICRO_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFF7FFFF; \
          (tmp) |= (((UInt64)(val)) << 19); \
        } while (0)

/* mask internal BBPLL interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_BBPLL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb26), 4)

#define GP_WB_GET_INT_CTRL_MASK_INT_BBPLL_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 20) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_BBPLL_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb26), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_BBPLL_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFEFFFFF; \
          (tmp) |= (((UInt64)(val)) << 20); \
        } while (0)

/* mask internal SPI Slave interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_SPISL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb26), 5)

#define GP_WB_GET_INT_CTRL_MASK_INT_SPISL_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 21) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_SPISL_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb26), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_SPISL_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFDFFFFF; \
          (tmp) |= (((UInt64)(val)) << 21); \
        } while (0)

/* mask internal DMA SCB engine interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_DMAS_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb26), 6)

#define GP_WB_GET_INT_CTRL_MASK_INT_DMAS_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 22) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_DMAS_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb26), 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_DMAS_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFBFFFFF; \
          (tmp) |= (((UInt64)(val)) << 22); \
        } while (0)

/* mask internal gpio external interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_GPIO_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb26), 7)

#define GP_WB_GET_INT_CTRL_MASK_INT_GPIO_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 23) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_GPIO_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb26), 7, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_GPIO_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FF7FFFFF; \
          (tmp) |= (((UInt64)(val)) << 23); \
        } while (0)

/* mask internal trc interrupt (same for internal and external) */
#define GP_WB_READ_INT_CTRL_MASK_INT_TRC_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb27), 0)

#define GP_WB_GET_INT_CTRL_MASK_INT_TRC_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 24) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_TRC_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb27), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_TRC_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FEFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 24); \
        } while (0)

/* mask internal parble filter interrupt (same for internal and external) */
#define GP_WB_READ_INT_CTRL_MASK_INT_PARBLE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb27), 1)

#define GP_WB_GET_INT_CTRL_MASK_INT_PARBLE_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 25) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_PARBLE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb27), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_PARBLE_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FDFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 25); \
        } while (0)

/* mask internal timer interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_TIMERS_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb27), 2)

#define GP_WB_GET_INT_CTRL_MASK_INT_TIMERS_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 26) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_TIMERS_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb27), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_TIMERS_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FBFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 26); \
        } while (0)

/* mask internal mri interrupt (internal and external are the same) */
#define GP_WB_READ_INT_CTRL_MASK_INT_MRI_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb27), 3)

#define GP_WB_GET_INT_CTRL_MASK_INT_MRI_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 27) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_MRI_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb27), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_MRI_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01F7FFFFFF; \
          (tmp) |= (((UInt64)(val)) << 27); \
        } while (0)

/* mask internal I2C Slave interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_I2CSL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb27), 4)

#define GP_WB_GET_INT_CTRL_MASK_INT_I2CSL_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 28) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_I2CSL_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb27), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_I2CSL_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01EFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 28); \
        } while (0)

/* mask internal PWM interrupt */
#define GP_WB_READ_INT_CTRL_MASK_INT_PWMS_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb27), 5)

#define GP_WB_GET_INT_CTRL_MASK_INT_PWMS_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 29) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_PWMS_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb27), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_PWMS_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01DFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 29); \
        } while (0)

/* mask internal inter process communication interrupt (ext 2 ...) */
#define GP_WB_READ_INT_CTRL_MASK_INT_IPCEXT2X_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb27), 6)

#define GP_WB_GET_INT_CTRL_MASK_INT_IPCEXT2X_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 30) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_IPCEXT2X_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb27), 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_IPCEXT2X_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01BFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 30); \
        } while (0)

/* mask internal inter process communication interrupt (... 2 int) */
#define GP_WB_READ_INT_CTRL_MASK_INT_IPCX2INT_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb27), 7)

#define GP_WB_GET_INT_CTRL_MASK_INT_IPCX2INT_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 31) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_IPCX2INT_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb27), 7, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_IPCX2INT_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x017FFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 31); \
        } while (0)

/* mask internal inter process communication interrupt (gpm 2 ...) */
#define GP_WB_READ_INT_CTRL_MASK_INT_IPCGPM2X_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb28), 0)

#define GP_WB_GET_INT_CTRL_MASK_INT_IPCGPM2X_INTERRUPT_FROM_MASK_INT_INTERRUPTS(tmp) \
        (((tmp) >> 32) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_INT_IPCGPM2X_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb28), (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_INT_IPCGPM2X_INTERRUPT_TO_MASK_INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x00FFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 32); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_UNMASKED_GPM_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb29))

/* unmasked trc interrupt for gpmicro */
#define GP_WB_READ_INT_CTRL_UNMASKED_GPM_TRC_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb29), 0)

#define GP_WB_GET_INT_CTRL_UNMASKED_GPM_TRC_INTERRUPT_FROM_UNMASKED_GPM_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* unmasked Phy interrupt for gpmicro */
#define GP_WB_READ_INT_CTRL_UNMASKED_GPM_PHY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb29), 1)

#define GP_WB_GET_INT_CTRL_UNMASKED_GPM_PHY_INTERRUPT_FROM_UNMASKED_GPM_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* unmasked ES interrupt for gpmicro */
#define GP_WB_READ_INT_CTRL_UNMASKED_GPM_ES_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb29), 2)

#define GP_WB_GET_INT_CTRL_UNMASKED_GPM_ES_INTERRUPT_FROM_UNMASKED_GPM_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_GPM_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2a))

/* masked trc interrupt for gpmicro */
#define GP_WB_READ_INT_CTRL_MASKED_GPM_TRC_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2a), 0)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_TRC_INTERRUPT_FROM_MASKED_GPM_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* masked parble filter interrupt for gpmicro */
#define GP_WB_READ_INT_CTRL_MASKED_GPM_PARBLE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2a), 1)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_PARBLE_INTERRUPT_FROM_MASKED_GPM_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* masked RPA accelerator interrupt for gpmicro */
#define GP_WB_READ_INT_CTRL_MASKED_GPM_RPA_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2a), 2)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_RPA_INTERRUPT_FROM_MASKED_GPM_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* masked parfcs filter interrupt for gpmicro */
#define GP_WB_READ_INT_CTRL_MASKED_GPM_PARFCS_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2a), 3)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_PARFCS_INTERRUPT_FROM_MASKED_GPM_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

/* masked Phy interrupt for gpmicro */
#define GP_WB_READ_INT_CTRL_MASKED_GPM_PHY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2a), 4)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_PHY_INTERRUPT_FROM_MASKED_GPM_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

/* masked ES interrupt for gpmicro */
#define GP_WB_READ_INT_CTRL_MASKED_GPM_ES_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2a), 5)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_ES_INTERRUPT_FROM_MASKED_GPM_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

/* masked inter process communication interrupt (... 2 gpm) for gpmicro */
#define GP_WB_READ_INT_CTRL_MASKED_GPM_IPCX2GPM_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2a), 6)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_IPCX2GPM_INTERRUPT_FROM_MASKED_GPM_INTERRUPTS(tmp) \
        (((tmp) >> 6) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_GPM_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2b))

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2b), (val))

/* mask trc interrupt for gpmicro */
#define GP_WB_READ_INT_CTRL_MASK_GPM_TRC_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2b), 0)

#define GP_WB_GET_INT_CTRL_MASK_GPM_TRC_INTERRUPT_FROM_MASK_GPM_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_TRC_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2b), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_TRC_INTERRUPT_TO_MASK_GPM_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* mask parble filter interrupt for gpmicro */
#define GP_WB_READ_INT_CTRL_MASK_GPM_PARBLE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2b), 1)

#define GP_WB_GET_INT_CTRL_MASK_GPM_PARBLE_INTERRUPT_FROM_MASK_GPM_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_PARBLE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2b), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_PARBLE_INTERRUPT_TO_MASK_GPM_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* mask RPA accelerator interrupt for gpmicro */
#define GP_WB_READ_INT_CTRL_MASK_GPM_RPA_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2b), 2)

#define GP_WB_GET_INT_CTRL_MASK_GPM_RPA_INTERRUPT_FROM_MASK_GPM_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_RPA_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2b), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_RPA_INTERRUPT_TO_MASK_GPM_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* mask parfcs filter interrupt for gpmicro */
#define GP_WB_READ_INT_CTRL_MASK_GPM_PARFCS_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2b), 3)

#define GP_WB_GET_INT_CTRL_MASK_GPM_PARFCS_INTERRUPT_FROM_MASK_GPM_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_PARFCS_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2b), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_PARFCS_INTERRUPT_TO_MASK_GPM_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x77; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* mask Phy interrupt for gpmicro */
#define GP_WB_READ_INT_CTRL_MASK_GPM_PHY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2b), 4)

#define GP_WB_GET_INT_CTRL_MASK_GPM_PHY_INTERRUPT_FROM_MASK_GPM_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_PHY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2b), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_PHY_INTERRUPT_TO_MASK_GPM_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x6F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* mask ES interrupt for gpmicro */
#define GP_WB_READ_INT_CTRL_MASK_GPM_ES_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2b), 5)

#define GP_WB_GET_INT_CTRL_MASK_GPM_ES_INTERRUPT_FROM_MASK_GPM_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_ES_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2b), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_ES_INTERRUPT_TO_MASK_GPM_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x5F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* mask inter process communication interrupt (... 2 gpm) for gpmicro */
#define GP_WB_READ_INT_CTRL_MASK_GPM_IPCX2GPM_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2b), 6)

#define GP_WB_GET_INT_CTRL_MASK_GPM_IPCX2GPM_INTERRUPT_FROM_MASK_GPM_INTERRUPTS(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_IPCX2GPM_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2b), 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_IPCX2GPM_INTERRUPT_TO_MASK_GPM_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_GPM_ES_INTERRUPTS() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2c))

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_ES_INTERRUPTS(val) \
      GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2c), (val))

/* masks the Event Interrupts */
#define GP_WB_READ_INT_CTRL_MASK_GPM_ES_EVENT_INTERRUPTS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2c))

#define GP_WB_GET_INT_CTRL_MASK_GPM_ES_EVENT_INTERRUPTS_FROM_MASK_GPM_ES_INTERRUPTS(tmp) \
        ((tmp) & 0xFFFF)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_ES_EVENT_INTERRUPTS(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2c), (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_ES_EVENT_INTERRUPTS_TO_MASK_GPM_ES_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x03FF0000; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* masks the Comparator Event interrupts */
#define GP_WB_READ_INT_CTRL_MASK_GPM_ES_COMP_EVENT_INTERRUPTS() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2e)) & 0x0F)

#define GP_WB_GET_INT_CTRL_MASK_GPM_ES_COMP_EVENT_INTERRUPTS_FROM_MASK_GPM_ES_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0x0F)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_ES_COMP_EVENT_INTERRUPTS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2e), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_ES_COMP_EVENT_INTERRUPTS_TO_MASK_GPM_ES_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x03F0FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* masks the es symbol counter interrupt */
#define GP_WB_READ_INT_CTRL_MASK_GPM_ES_SYMBOL_COUNTER_VALID_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2e), 5)

#define GP_WB_GET_INT_CTRL_MASK_GPM_ES_SYMBOL_COUNTER_VALID_INTERRUPT_FROM_MASK_GPM_ES_INTERRUPTS(tmp) \
        (((tmp) >> 21) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_ES_SYMBOL_COUNTER_VALID_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2e), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_ES_SYMBOL_COUNTER_VALID_INTERRUPT_TO_MASK_GPM_ES_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03DFFFFF; \
          (tmp) |= (((UInt32)(val)) << 21); \
        } while (0)

/* masks the es oscillator benchmark interrupt */
#define GP_WB_READ_INT_CTRL_MASK_GPM_ES_OSCILLATOR_BENCHMARK_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2e), 6)

#define GP_WB_GET_INT_CTRL_MASK_GPM_ES_OSCILLATOR_BENCHMARK_DONE_INTERRUPT_FROM_MASK_GPM_ES_INTERRUPTS(tmp) \
        (((tmp) >> 22) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_ES_OSCILLATOR_BENCHMARK_DONE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2e), 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_ES_OSCILLATOR_BENCHMARK_DONE_INTERRUPT_TO_MASK_GPM_ES_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03BFFFFF; \
          (tmp) |= (((UInt32)(val)) << 22); \
        } while (0)

/* masks the es oscillator benchmark sub measurement done interrupt */
#define GP_WB_READ_INT_CTRL_MASK_GPM_ES_OSCILLATOR_BENCHMARK_SUB_MEAS_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2e), 7)

#define GP_WB_GET_INT_CTRL_MASK_GPM_ES_OSCILLATOR_BENCHMARK_SUB_MEAS_DONE_INTERRUPT_FROM_MASK_GPM_ES_INTERRUPTS(tmp) \
        (((tmp) >> 23) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_ES_OSCILLATOR_BENCHMARK_SUB_MEAS_DONE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2e), 7, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_ES_OSCILLATOR_BENCHMARK_SUB_MEAS_DONE_INTERRUPT_TO_MASK_GPM_ES_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x037FFFFF; \
          (tmp) |= (((UInt32)(val)) << 23); \
        } while (0)

/* masks the es Relative Event Interrupt */
#define GP_WB_READ_INT_CTRL_MASK_GPM_ES_RELATIVE_EVENT_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2f), 0)

#define GP_WB_GET_INT_CTRL_MASK_GPM_ES_RELATIVE_EVENT_INTERRUPT_FROM_MASK_GPM_ES_INTERRUPTS(tmp) \
        (((tmp) >> 24) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_ES_RELATIVE_EVENT_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2f), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_ES_RELATIVE_EVENT_INTERRUPT_TO_MASK_GPM_ES_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)

/* masks the External Event Interrupt */
#define GP_WB_READ_INT_CTRL_MASK_GPM_ES_EXTERNAL_EVENT_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2f), 1)

#define GP_WB_GET_INT_CTRL_MASK_GPM_ES_EXTERNAL_EVENT_INTERRUPT_FROM_MASK_GPM_ES_INTERRUPTS(tmp) \
        (((tmp) >> 25) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_ES_EXTERNAL_EVENT_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb2f), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_ES_EXTERNAL_EVENT_INTERRUPT_TO_MASK_GPM_ES_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 25); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_GPM_PHY_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb30))

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_PHY_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb30), (val))

/* masks the interrupt for the fll rx out of range event */
#define GP_WB_READ_INT_CTRL_MASK_GPM_PHY_FLL_RX_OUT_OF_RANGE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb30), 0)

#define GP_WB_GET_INT_CTRL_MASK_GPM_PHY_FLL_RX_OUT_OF_RANGE_INTERRUPT_FROM_MASK_GPM_PHY_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_PHY_FLL_RX_OUT_OF_RANGE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb30), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_PHY_FLL_RX_OUT_OF_RANGE_INTERRUPT_TO_MASK_GPM_PHY_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* masks the interrupt for the fll tx out of range event */
#define GP_WB_READ_INT_CTRL_MASK_GPM_PHY_FLL_TX_OUT_OF_RANGE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb30), 1)

#define GP_WB_GET_INT_CTRL_MASK_GPM_PHY_FLL_TX_OUT_OF_RANGE_INTERRUPT_FROM_MASK_GPM_PHY_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_PHY_FLL_TX_OUT_OF_RANGE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb30), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_PHY_FLL_TX_OUT_OF_RANGE_INTERRUPT_TO_MASK_GPM_PHY_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* masks the interrupt for the fll tx_out of lock event */
#define GP_WB_READ_INT_CTRL_MASK_GPM_PHY_FLL_TX_OUT_OF_LOCK_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb30), 2)

#define GP_WB_GET_INT_CTRL_MASK_GPM_PHY_FLL_TX_OUT_OF_LOCK_INTERRUPT_FROM_MASK_GPM_PHY_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_PHY_FLL_TX_OUT_OF_LOCK_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb30), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_PHY_FLL_TX_OUT_OF_LOCK_INTERRUPT_TO_MASK_GPM_PHY_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* masks the interrupt for the fll fp out of range event */
#define GP_WB_READ_INT_CTRL_MASK_GPM_PHY_FLL_FE_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb30), 3)

#define GP_WB_GET_INT_CTRL_MASK_GPM_PHY_FLL_FE_DONE_INTERRUPT_FROM_MASK_GPM_PHY_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_PHY_FLL_FE_DONE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb30), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_PHY_FLL_FE_DONE_INTERRUPT_TO_MASK_GPM_PHY_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* masks the interrupt for the fll fp out of range event */
#define GP_WB_READ_INT_CTRL_MASK_GPM_PHY_FLL_CAL_START_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb30), 4)

#define GP_WB_GET_INT_CTRL_MASK_GPM_PHY_FLL_CAL_START_INTERRUPT_FROM_MASK_GPM_PHY_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_PHY_FLL_CAL_START_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb30), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_PHY_FLL_CAL_START_INTERRUPT_TO_MASK_GPM_PHY_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* masks the interrupt for rx_mode changes */
#define GP_WB_READ_INT_CTRL_MASK_GPM_PHY_RX_MODE_CHANGE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb30), 5)

#define GP_WB_GET_INT_CTRL_MASK_GPM_PHY_RX_MODE_CHANGE_INTERRUPT_FROM_MASK_GPM_PHY_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_PHY_RX_MODE_CHANGE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb30), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_PHY_RX_MODE_CHANGE_INTERRUPT_TO_MASK_GPM_PHY_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_GPM_TRC_INTERRUPTS() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb34))

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_TRC_INTERRUPTS(val) \
      GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb34), (val))

#define GP_WB_READ_INT_CTRL_MASK_GPM_TRC_PBM_FULL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb34), 0)

#define GP_WB_GET_INT_CTRL_MASK_GPM_TRC_PBM_FULL_INTERRUPT_FROM_MASK_GPM_TRC_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_TRC_PBM_FULL_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb34), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_TRC_PBM_FULL_INTERRUPT_TO_MASK_GPM_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F3F3E; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_GPM_TRC_TX_STARTED_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb34), 1)

#define GP_WB_GET_INT_CTRL_MASK_GPM_TRC_TX_STARTED_INTERRUPT_FROM_MASK_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_TRC_TX_STARTED_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb34), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_TRC_TX_STARTED_INTERRUPT_TO_MASK_GPM_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F3F3D; \
          (tmp) |= (((UInt32)(val)) << 1); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_GPM_TRC_TX_ACK_STARTED_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb34), 2)

#define GP_WB_GET_INT_CTRL_MASK_GPM_TRC_TX_ACK_STARTED_INTERRUPT_FROM_MASK_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_TRC_TX_ACK_STARTED_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb34), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_TRC_TX_ACK_STARTED_INTERRUPT_TO_MASK_GPM_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F3F3B; \
          (tmp) |= (((UInt32)(val)) << 2); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_GPM_TRC_PHY_TRANSITION_NOT_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb34), 3)

#define GP_WB_GET_INT_CTRL_MASK_GPM_TRC_PHY_TRANSITION_NOT_DONE_INTERRUPT_FROM_MASK_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_TRC_PHY_TRANSITION_NOT_DONE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb34), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_TRC_PHY_TRANSITION_NOT_DONE_INTERRUPT_TO_MASK_GPM_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F3F37; \
          (tmp) |= (((UInt32)(val)) << 3); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_GPM_TRC_TX_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb34), 4)

#define GP_WB_GET_INT_CTRL_MASK_GPM_TRC_TX_DONE_INTERRUPT_FROM_MASK_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_TRC_TX_DONE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb34), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_TRC_TX_DONE_INTERRUPT_TO_MASK_GPM_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F3F2F; \
          (tmp) |= (((UInt32)(val)) << 4); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_GPM_TRC_MSG_REQ_WHILE_BUSY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb34), 5)

#define GP_WB_GET_INT_CTRL_MASK_GPM_TRC_MSG_REQ_WHILE_BUSY_INTERRUPT_FROM_MASK_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_TRC_MSG_REQ_WHILE_BUSY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb34), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_TRC_MSG_REQ_WHILE_BUSY_INTERRUPT_TO_MASK_GPM_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F3F1F; \
          (tmp) |= (((UInt32)(val)) << 5); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_GPM_TRC_CAL_DONE_INTERRUPTS() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb35)) & 0x3F)

#define GP_WB_GET_INT_CTRL_MASK_GPM_TRC_CAL_DONE_INTERRUPTS_FROM_MASK_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x3F)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_TRC_CAL_DONE_INTERRUPTS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb35), 0x3F, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_TRC_CAL_DONE_INTERRUPTS_TO_MASK_GPM_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0x3F003F; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_GPM_TRC_CAL_DONE_CH0_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb35), 0)

#define GP_WB_GET_INT_CTRL_MASK_GPM_TRC_CAL_DONE_CH0_INTERRUPT_FROM_MASK_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_TRC_CAL_DONE_CH0_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb35), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_TRC_CAL_DONE_CH0_INTERRUPT_TO_MASK_GPM_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F3E3F; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_GPM_TRC_CAL_DONE_CH1_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb35), 1)

#define GP_WB_GET_INT_CTRL_MASK_GPM_TRC_CAL_DONE_CH1_INTERRUPT_FROM_MASK_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_TRC_CAL_DONE_CH1_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb35), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_TRC_CAL_DONE_CH1_INTERRUPT_TO_MASK_GPM_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F3D3F; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_GPM_TRC_CAL_DONE_CH2_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb35), 2)

#define GP_WB_GET_INT_CTRL_MASK_GPM_TRC_CAL_DONE_CH2_INTERRUPT_FROM_MASK_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_TRC_CAL_DONE_CH2_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb35), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_TRC_CAL_DONE_CH2_INTERRUPT_TO_MASK_GPM_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F3B3F; \
          (tmp) |= (((UInt32)(val)) << 10); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_GPM_TRC_CAL_DONE_CH3_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb35), 3)

#define GP_WB_GET_INT_CTRL_MASK_GPM_TRC_CAL_DONE_CH3_INTERRUPT_FROM_MASK_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_TRC_CAL_DONE_CH3_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb35), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_TRC_CAL_DONE_CH3_INTERRUPT_TO_MASK_GPM_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F373F; \
          (tmp) |= (((UInt32)(val)) << 11); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_GPM_TRC_CAL_DONE_CH4_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb35), 4)

#define GP_WB_GET_INT_CTRL_MASK_GPM_TRC_CAL_DONE_CH4_INTERRUPT_FROM_MASK_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_TRC_CAL_DONE_CH4_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb35), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_TRC_CAL_DONE_CH4_INTERRUPT_TO_MASK_GPM_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F2F3F; \
          (tmp) |= (((UInt32)(val)) << 12); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_GPM_TRC_CAL_DONE_CH5_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb35), 5)

#define GP_WB_GET_INT_CTRL_MASK_GPM_TRC_CAL_DONE_CH5_INTERRUPT_FROM_MASK_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_TRC_CAL_DONE_CH5_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb35), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_TRC_CAL_DONE_CH5_INTERRUPT_TO_MASK_GPM_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F1F3F; \
          (tmp) |= (((UInt32)(val)) << 13); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_GPM_TRC_RX_WINDOW_DONE_INTERRUPTS() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb36)) & 0x3F)

#define GP_WB_GET_INT_CTRL_MASK_GPM_TRC_RX_WINDOW_DONE_INTERRUPTS_FROM_MASK_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0x3F)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_TRC_RX_WINDOW_DONE_INTERRUPTS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb36), 0x3F, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_TRC_RX_WINDOW_DONE_INTERRUPTS_TO_MASK_GPM_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0x003F3F; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_GPM_TRC_RX_WINDOW_DONE_CH0_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb36), 0)

#define GP_WB_GET_INT_CTRL_MASK_GPM_TRC_RX_WINDOW_DONE_CH0_INTERRUPT_FROM_MASK_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_TRC_RX_WINDOW_DONE_CH0_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb36), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_TRC_RX_WINDOW_DONE_CH0_INTERRUPT_TO_MASK_GPM_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E3F3F; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_GPM_TRC_RX_WINDOW_DONE_CH1_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb36), 1)

#define GP_WB_GET_INT_CTRL_MASK_GPM_TRC_RX_WINDOW_DONE_CH1_INTERRUPT_FROM_MASK_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 17) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_TRC_RX_WINDOW_DONE_CH1_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb36), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_TRC_RX_WINDOW_DONE_CH1_INTERRUPT_TO_MASK_GPM_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3D3F3F; \
          (tmp) |= (((UInt32)(val)) << 17); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_GPM_TRC_RX_WINDOW_DONE_CH2_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb36), 2)

#define GP_WB_GET_INT_CTRL_MASK_GPM_TRC_RX_WINDOW_DONE_CH2_INTERRUPT_FROM_MASK_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 18) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_TRC_RX_WINDOW_DONE_CH2_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb36), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_TRC_RX_WINDOW_DONE_CH2_INTERRUPT_TO_MASK_GPM_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3B3F3F; \
          (tmp) |= (((UInt32)(val)) << 18); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_GPM_TRC_RX_WINDOW_DONE_CH3_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb36), 3)

#define GP_WB_GET_INT_CTRL_MASK_GPM_TRC_RX_WINDOW_DONE_CH3_INTERRUPT_FROM_MASK_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 19) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_TRC_RX_WINDOW_DONE_CH3_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb36), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_TRC_RX_WINDOW_DONE_CH3_INTERRUPT_TO_MASK_GPM_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x373F3F; \
          (tmp) |= (((UInt32)(val)) << 19); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_GPM_TRC_RX_WINDOW_DONE_CH4_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb36), 4)

#define GP_WB_GET_INT_CTRL_MASK_GPM_TRC_RX_WINDOW_DONE_CH4_INTERRUPT_FROM_MASK_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 20) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_TRC_RX_WINDOW_DONE_CH4_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb36), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_TRC_RX_WINDOW_DONE_CH4_INTERRUPT_TO_MASK_GPM_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F3F3F; \
          (tmp) |= (((UInt32)(val)) << 20); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_GPM_TRC_RX_WINDOW_DONE_CH5_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb36), 5)

#define GP_WB_GET_INT_CTRL_MASK_GPM_TRC_RX_WINDOW_DONE_CH5_INTERRUPT_FROM_MASK_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 21) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPM_TRC_RX_WINDOW_DONE_CH5_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb36), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPM_TRC_RX_WINDOW_DONE_CH5_INTERRUPT_TO_MASK_GPM_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F3F3F; \
          (tmp) |= (((UInt32)(val)) << 21); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_ES_INTERRUPTS() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb38))

#define GP_WB_WRITE_INT_CTRL_MASK_ES_INTERRUPTS(val) \
      GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb38), (val))

/* masks the Event Interrupts */
#define GP_WB_READ_INT_CTRL_MASK_ES_EVENT_INTERRUPTS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb38))

#define GP_WB_GET_INT_CTRL_MASK_ES_EVENT_INTERRUPTS_FROM_MASK_ES_INTERRUPTS(tmp) \
        ((tmp) & 0xFFFF)

#define GP_WB_WRITE_INT_CTRL_MASK_ES_EVENT_INTERRUPTS(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb38), (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_ES_EVENT_INTERRUPTS_TO_MASK_ES_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x03FF0000; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* masks the Comparator Event interrupts */
#define GP_WB_READ_INT_CTRL_MASK_ES_COMP_EVENT_INTERRUPTS() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3a)) & 0x0F)

#define GP_WB_GET_INT_CTRL_MASK_ES_COMP_EVENT_INTERRUPTS_FROM_MASK_ES_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0x0F)

#define GP_WB_WRITE_INT_CTRL_MASK_ES_COMP_EVENT_INTERRUPTS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3a), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_ES_COMP_EVENT_INTERRUPTS_TO_MASK_ES_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x03F0FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* masks the es symbol counter interrupt */
#define GP_WB_READ_INT_CTRL_MASK_ES_SYMBOL_COUNTER_VALID_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3a), 5)

#define GP_WB_GET_INT_CTRL_MASK_ES_SYMBOL_COUNTER_VALID_INTERRUPT_FROM_MASK_ES_INTERRUPTS(tmp) \
        (((tmp) >> 21) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_ES_SYMBOL_COUNTER_VALID_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3a), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_ES_SYMBOL_COUNTER_VALID_INTERRUPT_TO_MASK_ES_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03DFFFFF; \
          (tmp) |= (((UInt32)(val)) << 21); \
        } while (0)

/* masks the es oscillator benchmark interrupt */
#define GP_WB_READ_INT_CTRL_MASK_ES_OSCILLATOR_BENCHMARK_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3a), 6)

#define GP_WB_GET_INT_CTRL_MASK_ES_OSCILLATOR_BENCHMARK_DONE_INTERRUPT_FROM_MASK_ES_INTERRUPTS(tmp) \
        (((tmp) >> 22) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_ES_OSCILLATOR_BENCHMARK_DONE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3a), 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_ES_OSCILLATOR_BENCHMARK_DONE_INTERRUPT_TO_MASK_ES_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03BFFFFF; \
          (tmp) |= (((UInt32)(val)) << 22); \
        } while (0)

/* masks the es oscillator benchmark sub meas done interrupt */
#define GP_WB_READ_INT_CTRL_MASK_ES_OSCILLATOR_BENCHMARK_SUB_MEAS_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3a), 7)

#define GP_WB_GET_INT_CTRL_MASK_ES_OSCILLATOR_BENCHMARK_SUB_MEAS_DONE_INTERRUPT_FROM_MASK_ES_INTERRUPTS(tmp) \
        (((tmp) >> 23) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_ES_OSCILLATOR_BENCHMARK_SUB_MEAS_DONE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3a), 7, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_ES_OSCILLATOR_BENCHMARK_SUB_MEAS_DONE_INTERRUPT_TO_MASK_ES_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x037FFFFF; \
          (tmp) |= (((UInt32)(val)) << 23); \
        } while (0)

/* masks the es Relative Event Interrupt */
#define GP_WB_READ_INT_CTRL_MASK_ES_RELATIVE_EVENT_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3b), 0)

#define GP_WB_GET_INT_CTRL_MASK_ES_RELATIVE_EVENT_INTERRUPT_FROM_MASK_ES_INTERRUPTS(tmp) \
        (((tmp) >> 24) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_ES_RELATIVE_EVENT_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3b), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_ES_RELATIVE_EVENT_INTERRUPT_TO_MASK_ES_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)

/* masks the External Event Interrupt */
#define GP_WB_READ_INT_CTRL_MASK_ES_EXTERNAL_EVENT_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3b), 1)

#define GP_WB_GET_INT_CTRL_MASK_ES_EXTERNAL_EVENT_INTERRUPT_FROM_MASK_ES_INTERRUPTS(tmp) \
        (((tmp) >> 25) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_ES_EXTERNAL_EVENT_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3b), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_ES_EXTERNAL_EVENT_INTERRUPT_TO_MASK_ES_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 25); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_DMAS_INTERRUPTS() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3c))

#define GP_WB_WRITE_INT_CTRL_MASK_DMAS_INTERRUPTS(val) \
      GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3c), (val))

#define GP_WB_READ_INT_CTRL_MASK_DMAS_BUFFER_ALMOST_COMPLETE_0_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3c), 0)

#define GP_WB_GET_INT_CTRL_MASK_DMAS_BUFFER_ALMOST_COMPLETE_0_INTERRUPT_FROM_MASK_DMAS_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_DMAS_BUFFER_ALMOST_COMPLETE_0_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3c), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_DMAS_BUFFER_ALMOST_COMPLETE_0_INTERRUPT_TO_MASK_DMAS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFE; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_DMAS_BUFFER_ALMOST_COMPLETE_1_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3c), 1)

#define GP_WB_GET_INT_CTRL_MASK_DMAS_BUFFER_ALMOST_COMPLETE_1_INTERRUPT_FROM_MASK_DMAS_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_DMAS_BUFFER_ALMOST_COMPLETE_1_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3c), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_DMAS_BUFFER_ALMOST_COMPLETE_1_INTERRUPT_TO_MASK_DMAS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFD; \
          (tmp) |= (((UInt32)(val)) << 1); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_DMAS_BUFFER_ALMOST_COMPLETE_2_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3c), 2)

#define GP_WB_GET_INT_CTRL_MASK_DMAS_BUFFER_ALMOST_COMPLETE_2_INTERRUPT_FROM_MASK_DMAS_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_DMAS_BUFFER_ALMOST_COMPLETE_2_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3c), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_DMAS_BUFFER_ALMOST_COMPLETE_2_INTERRUPT_TO_MASK_DMAS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFB; \
          (tmp) |= (((UInt32)(val)) << 2); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_DMAS_BUFFER_ALMOST_COMPLETE_3_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3c), 3)

#define GP_WB_GET_INT_CTRL_MASK_DMAS_BUFFER_ALMOST_COMPLETE_3_INTERRUPT_FROM_MASK_DMAS_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_DMAS_BUFFER_ALMOST_COMPLETE_3_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3c), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_DMAS_BUFFER_ALMOST_COMPLETE_3_INTERRUPT_TO_MASK_DMAS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFF7; \
          (tmp) |= (((UInt32)(val)) << 3); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_DMAS_BUFFER_ALMOST_COMPLETE_4_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3c), 4)

#define GP_WB_GET_INT_CTRL_MASK_DMAS_BUFFER_ALMOST_COMPLETE_4_INTERRUPT_FROM_MASK_DMAS_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_DMAS_BUFFER_ALMOST_COMPLETE_4_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3c), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_DMAS_BUFFER_ALMOST_COMPLETE_4_INTERRUPT_TO_MASK_DMAS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFEF; \
          (tmp) |= (((UInt32)(val)) << 4); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_DMAS_BUFFER_ALMOST_COMPLETE_5_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3c), 5)

#define GP_WB_GET_INT_CTRL_MASK_DMAS_BUFFER_ALMOST_COMPLETE_5_INTERRUPT_FROM_MASK_DMAS_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_DMAS_BUFFER_ALMOST_COMPLETE_5_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3c), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_DMAS_BUFFER_ALMOST_COMPLETE_5_INTERRUPT_TO_MASK_DMAS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFDF; \
          (tmp) |= (((UInt32)(val)) << 5); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_DMAS_BUFFER_ALMOST_COMPLETE_6_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3c), 6)

#define GP_WB_GET_INT_CTRL_MASK_DMAS_BUFFER_ALMOST_COMPLETE_6_INTERRUPT_FROM_MASK_DMAS_INTERRUPTS(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_DMAS_BUFFER_ALMOST_COMPLETE_6_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3c), 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_DMAS_BUFFER_ALMOST_COMPLETE_6_INTERRUPT_TO_MASK_DMAS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFBF; \
          (tmp) |= (((UInt32)(val)) << 6); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_DMAS_BUFFER_ALMOST_COMPLETE_7_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3c), 7)

#define GP_WB_GET_INT_CTRL_MASK_DMAS_BUFFER_ALMOST_COMPLETE_7_INTERRUPT_FROM_MASK_DMAS_INTERRUPTS(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_DMAS_BUFFER_ALMOST_COMPLETE_7_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3c), 7, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_DMAS_BUFFER_ALMOST_COMPLETE_7_INTERRUPT_TO_MASK_DMAS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FF7F; \
          (tmp) |= (((UInt32)(val)) << 7); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_DMAS_BUFFER_COMPLETE_0_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3d), 0)

#define GP_WB_GET_INT_CTRL_MASK_DMAS_BUFFER_COMPLETE_0_INTERRUPT_FROM_MASK_DMAS_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_DMAS_BUFFER_COMPLETE_0_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3d), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_DMAS_BUFFER_COMPLETE_0_INTERRUPT_TO_MASK_DMAS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FEFF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_DMAS_BUFFER_COMPLETE_1_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3d), 1)

#define GP_WB_GET_INT_CTRL_MASK_DMAS_BUFFER_COMPLETE_1_INTERRUPT_FROM_MASK_DMAS_INTERRUPTS(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_DMAS_BUFFER_COMPLETE_1_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3d), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_DMAS_BUFFER_COMPLETE_1_INTERRUPT_TO_MASK_DMAS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FDFF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_DMAS_BUFFER_COMPLETE_2_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3d), 2)

#define GP_WB_GET_INT_CTRL_MASK_DMAS_BUFFER_COMPLETE_2_INTERRUPT_FROM_MASK_DMAS_INTERRUPTS(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_DMAS_BUFFER_COMPLETE_2_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3d), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_DMAS_BUFFER_COMPLETE_2_INTERRUPT_TO_MASK_DMAS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FBFF; \
          (tmp) |= (((UInt32)(val)) << 10); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_DMAS_BUFFER_COMPLETE_3_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3d), 3)

#define GP_WB_GET_INT_CTRL_MASK_DMAS_BUFFER_COMPLETE_3_INTERRUPT_FROM_MASK_DMAS_INTERRUPTS(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_DMAS_BUFFER_COMPLETE_3_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3d), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_DMAS_BUFFER_COMPLETE_3_INTERRUPT_TO_MASK_DMAS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01F7FF; \
          (tmp) |= (((UInt32)(val)) << 11); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_DMAS_BUFFER_COMPLETE_4_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3d), 4)

#define GP_WB_GET_INT_CTRL_MASK_DMAS_BUFFER_COMPLETE_4_INTERRUPT_FROM_MASK_DMAS_INTERRUPTS(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_DMAS_BUFFER_COMPLETE_4_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3d), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_DMAS_BUFFER_COMPLETE_4_INTERRUPT_TO_MASK_DMAS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01EFFF; \
          (tmp) |= (((UInt32)(val)) << 12); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_DMAS_BUFFER_COMPLETE_5_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3d), 5)

#define GP_WB_GET_INT_CTRL_MASK_DMAS_BUFFER_COMPLETE_5_INTERRUPT_FROM_MASK_DMAS_INTERRUPTS(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_DMAS_BUFFER_COMPLETE_5_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3d), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_DMAS_BUFFER_COMPLETE_5_INTERRUPT_TO_MASK_DMAS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01DFFF; \
          (tmp) |= (((UInt32)(val)) << 13); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_DMAS_BUFFER_COMPLETE_6_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3d), 6)

#define GP_WB_GET_INT_CTRL_MASK_DMAS_BUFFER_COMPLETE_6_INTERRUPT_FROM_MASK_DMAS_INTERRUPTS(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_DMAS_BUFFER_COMPLETE_6_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3d), 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_DMAS_BUFFER_COMPLETE_6_INTERRUPT_TO_MASK_DMAS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01BFFF; \
          (tmp) |= (((UInt32)(val)) << 14); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_DMAS_BUFFER_COMPLETE_7_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3d), 7)

#define GP_WB_GET_INT_CTRL_MASK_DMAS_BUFFER_COMPLETE_7_INTERRUPT_FROM_MASK_DMAS_INTERRUPTS(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_DMAS_BUFFER_COMPLETE_7_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3d), 7, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_DMAS_BUFFER_COMPLETE_7_INTERRUPT_TO_MASK_DMAS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x017FFF; \
          (tmp) |= (((UInt32)(val)) << 15); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_DMAS_CPY_ERR_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3e), 0)

#define GP_WB_GET_INT_CTRL_MASK_DMAS_CPY_ERR_INTERRUPT_FROM_MASK_DMAS_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_DMAS_CPY_ERR_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3e), (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_DMAS_CPY_ERR_INTERRUPT_TO_MASK_DMAS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x00FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_QTA_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3f))

#define GP_WB_WRITE_INT_CTRL_MASK_QTA_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3f), (val))

#define GP_WB_READ_INT_CTRL_MASK_QTA_SCH0_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3f), 0)

#define GP_WB_GET_INT_CTRL_MASK_QTA_SCH0_EMPTY_INTERRUPT_FROM_MASK_QTA_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_QTA_SCH0_EMPTY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3f), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_QTA_SCH0_EMPTY_INTERRUPT_TO_MASK_QTA_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_QTA_SCH1_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3f), 1)

#define GP_WB_GET_INT_CTRL_MASK_QTA_SCH1_EMPTY_INTERRUPT_FROM_MASK_QTA_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_QTA_SCH1_EMPTY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3f), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_QTA_SCH1_EMPTY_INTERRUPT_TO_MASK_QTA_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_QTA_SCH2_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3f), 2)

#define GP_WB_GET_INT_CTRL_MASK_QTA_SCH2_EMPTY_INTERRUPT_FROM_MASK_QTA_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_QTA_SCH2_EMPTY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3f), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_QTA_SCH2_EMPTY_INTERRUPT_TO_MASK_QTA_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_QTA_SCH3_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3f), 3)

#define GP_WB_GET_INT_CTRL_MASK_QTA_SCH3_EMPTY_INTERRUPT_FROM_MASK_QTA_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_QTA_SCH3_EMPTY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3f), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_QTA_SCH3_EMPTY_INTERRUPT_TO_MASK_QTA_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_QTA_QUEUE_FULL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3f), 4)

#define GP_WB_GET_INT_CTRL_MASK_QTA_QUEUE_FULL_INTERRUPT_FROM_MASK_QTA_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_QTA_QUEUE_FULL_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb3f), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_QTA_QUEUE_FULL_INTERRUPT_TO_MASK_QTA_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_TRC_INTERRUPTS() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb40))

#define GP_WB_WRITE_INT_CTRL_MASK_TRC_INTERRUPTS(val) \
      GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb40), (val))

#define GP_WB_READ_INT_CTRL_MASK_TRC_PBM_FULL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb40), 0)

#define GP_WB_GET_INT_CTRL_MASK_TRC_PBM_FULL_INTERRUPT_FROM_MASK_TRC_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TRC_PBM_FULL_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb40), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TRC_PBM_FULL_INTERRUPT_TO_MASK_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F3F3E; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_TRC_TX_STARTED_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb40), 1)

#define GP_WB_GET_INT_CTRL_MASK_TRC_TX_STARTED_INTERRUPT_FROM_MASK_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TRC_TX_STARTED_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb40), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TRC_TX_STARTED_INTERRUPT_TO_MASK_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F3F3D; \
          (tmp) |= (((UInt32)(val)) << 1); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_TRC_TX_ACK_STARTED_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb40), 2)

#define GP_WB_GET_INT_CTRL_MASK_TRC_TX_ACK_STARTED_INTERRUPT_FROM_MASK_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TRC_TX_ACK_STARTED_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb40), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TRC_TX_ACK_STARTED_INTERRUPT_TO_MASK_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F3F3B; \
          (tmp) |= (((UInt32)(val)) << 2); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_TRC_PHY_TRANSITION_NOT_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb40), 3)

#define GP_WB_GET_INT_CTRL_MASK_TRC_PHY_TRANSITION_NOT_DONE_INTERRUPT_FROM_MASK_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TRC_PHY_TRANSITION_NOT_DONE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb40), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TRC_PHY_TRANSITION_NOT_DONE_INTERRUPT_TO_MASK_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F3F37; \
          (tmp) |= (((UInt32)(val)) << 3); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_TRC_TX_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb40), 4)

#define GP_WB_GET_INT_CTRL_MASK_TRC_TX_DONE_INTERRUPT_FROM_MASK_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TRC_TX_DONE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb40), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TRC_TX_DONE_INTERRUPT_TO_MASK_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F3F2F; \
          (tmp) |= (((UInt32)(val)) << 4); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_TRC_MSG_REQ_WHILE_BUSY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb40), 5)

#define GP_WB_GET_INT_CTRL_MASK_TRC_MSG_REQ_WHILE_BUSY_INTERRUPT_FROM_MASK_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TRC_MSG_REQ_WHILE_BUSY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb40), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TRC_MSG_REQ_WHILE_BUSY_INTERRUPT_TO_MASK_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F3F1F; \
          (tmp) |= (((UInt32)(val)) << 5); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_TRC_CAL_DONE_INTERRUPTS() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb41)) & 0x3F)

#define GP_WB_GET_INT_CTRL_MASK_TRC_CAL_DONE_INTERRUPTS_FROM_MASK_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x3F)

#define GP_WB_WRITE_INT_CTRL_MASK_TRC_CAL_DONE_INTERRUPTS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb41), 0x3F, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TRC_CAL_DONE_INTERRUPTS_TO_MASK_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0x3F003F; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_TRC_CAL_DONE_CH0_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb41), 0)

#define GP_WB_GET_INT_CTRL_MASK_TRC_CAL_DONE_CH0_INTERRUPT_FROM_MASK_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TRC_CAL_DONE_CH0_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb41), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TRC_CAL_DONE_CH0_INTERRUPT_TO_MASK_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F3E3F; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_TRC_CAL_DONE_CH1_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb41), 1)

#define GP_WB_GET_INT_CTRL_MASK_TRC_CAL_DONE_CH1_INTERRUPT_FROM_MASK_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TRC_CAL_DONE_CH1_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb41), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TRC_CAL_DONE_CH1_INTERRUPT_TO_MASK_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F3D3F; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_TRC_CAL_DONE_CH2_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb41), 2)

#define GP_WB_GET_INT_CTRL_MASK_TRC_CAL_DONE_CH2_INTERRUPT_FROM_MASK_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TRC_CAL_DONE_CH2_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb41), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TRC_CAL_DONE_CH2_INTERRUPT_TO_MASK_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F3B3F; \
          (tmp) |= (((UInt32)(val)) << 10); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_TRC_CAL_DONE_CH3_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb41), 3)

#define GP_WB_GET_INT_CTRL_MASK_TRC_CAL_DONE_CH3_INTERRUPT_FROM_MASK_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TRC_CAL_DONE_CH3_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb41), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TRC_CAL_DONE_CH3_INTERRUPT_TO_MASK_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F373F; \
          (tmp) |= (((UInt32)(val)) << 11); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_TRC_CAL_DONE_CH4_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb41), 4)

#define GP_WB_GET_INT_CTRL_MASK_TRC_CAL_DONE_CH4_INTERRUPT_FROM_MASK_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TRC_CAL_DONE_CH4_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb41), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TRC_CAL_DONE_CH4_INTERRUPT_TO_MASK_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F2F3F; \
          (tmp) |= (((UInt32)(val)) << 12); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_TRC_CAL_DONE_CH5_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb41), 5)

#define GP_WB_GET_INT_CTRL_MASK_TRC_CAL_DONE_CH5_INTERRUPT_FROM_MASK_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TRC_CAL_DONE_CH5_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb41), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TRC_CAL_DONE_CH5_INTERRUPT_TO_MASK_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F1F3F; \
          (tmp) |= (((UInt32)(val)) << 13); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_TRC_RX_WINDOW_DONE_INTERRUPTS() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb42)) & 0x3F)

#define GP_WB_GET_INT_CTRL_MASK_TRC_RX_WINDOW_DONE_INTERRUPTS_FROM_MASK_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0x3F)

#define GP_WB_WRITE_INT_CTRL_MASK_TRC_RX_WINDOW_DONE_INTERRUPTS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb42), 0x3F, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TRC_RX_WINDOW_DONE_INTERRUPTS_TO_MASK_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0x003F3F; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_TRC_RX_WINDOW_DONE_CH0_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb42), 0)

#define GP_WB_GET_INT_CTRL_MASK_TRC_RX_WINDOW_DONE_CH0_INTERRUPT_FROM_MASK_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TRC_RX_WINDOW_DONE_CH0_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb42), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TRC_RX_WINDOW_DONE_CH0_INTERRUPT_TO_MASK_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E3F3F; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_TRC_RX_WINDOW_DONE_CH1_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb42), 1)

#define GP_WB_GET_INT_CTRL_MASK_TRC_RX_WINDOW_DONE_CH1_INTERRUPT_FROM_MASK_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 17) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TRC_RX_WINDOW_DONE_CH1_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb42), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TRC_RX_WINDOW_DONE_CH1_INTERRUPT_TO_MASK_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3D3F3F; \
          (tmp) |= (((UInt32)(val)) << 17); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_TRC_RX_WINDOW_DONE_CH2_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb42), 2)

#define GP_WB_GET_INT_CTRL_MASK_TRC_RX_WINDOW_DONE_CH2_INTERRUPT_FROM_MASK_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 18) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TRC_RX_WINDOW_DONE_CH2_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb42), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TRC_RX_WINDOW_DONE_CH2_INTERRUPT_TO_MASK_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3B3F3F; \
          (tmp) |= (((UInt32)(val)) << 18); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_TRC_RX_WINDOW_DONE_CH3_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb42), 3)

#define GP_WB_GET_INT_CTRL_MASK_TRC_RX_WINDOW_DONE_CH3_INTERRUPT_FROM_MASK_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 19) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TRC_RX_WINDOW_DONE_CH3_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb42), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TRC_RX_WINDOW_DONE_CH3_INTERRUPT_TO_MASK_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x373F3F; \
          (tmp) |= (((UInt32)(val)) << 19); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_TRC_RX_WINDOW_DONE_CH4_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb42), 4)

#define GP_WB_GET_INT_CTRL_MASK_TRC_RX_WINDOW_DONE_CH4_INTERRUPT_FROM_MASK_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 20) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TRC_RX_WINDOW_DONE_CH4_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb42), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TRC_RX_WINDOW_DONE_CH4_INTERRUPT_TO_MASK_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F3F3F; \
          (tmp) |= (((UInt32)(val)) << 20); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_TRC_RX_WINDOW_DONE_CH5_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb42), 5)

#define GP_WB_GET_INT_CTRL_MASK_TRC_RX_WINDOW_DONE_CH5_INTERRUPT_FROM_MASK_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 21) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TRC_RX_WINDOW_DONE_CH5_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb42), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TRC_RX_WINDOW_DONE_CH5_INTERRUPT_TO_MASK_TRC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F3F3F; \
          (tmp) |= (((UInt32)(val)) << 21); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_PARBLE_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb43))

#define GP_WB_WRITE_INT_CTRL_MASK_PARBLE_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb43), (val))

/* triggering an interrupt when n bytes were received */
#define GP_WB_READ_INT_CTRL_MASK_PARBLE_LEVEL_TRIGGER_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb43), 0)

#define GP_WB_GET_INT_CTRL_MASK_PARBLE_LEVEL_TRIGGER_INTERRUPT_FROM_MASK_PARBLE_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PARBLE_LEVEL_TRIGGER_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb43), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PARBLE_LEVEL_TRIGGER_INTERRUPT_TO_MASK_PARBLE_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_PARBLE_PACKET_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb43), 1)

#define GP_WB_GET_INT_CTRL_MASK_PARBLE_PACKET_DONE_INTERRUPT_FROM_MASK_PARBLE_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PARBLE_PACKET_DONE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb43), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PARBLE_PACKET_DONE_INTERRUPT_TO_MASK_PARBLE_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_STBC_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb44))

#define GP_WB_WRITE_INT_CTRL_MASK_STBC_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb44), (val))

/* masks the standby controller event power on reset detected interrupt */
#define GP_WB_READ_INT_CTRL_MASK_STBC_PORD_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb44), 0)

#define GP_WB_GET_INT_CTRL_MASK_STBC_PORD_INTERRUPT_FROM_MASK_STBC_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_STBC_PORD_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb44), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_STBC_PORD_INTERRUPT_TO_MASK_STBC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* masks the standby controller Active state interrupt */
#define GP_WB_READ_INT_CTRL_MASK_STBC_ACTIVE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb44), 1)

#define GP_WB_GET_INT_CTRL_MASK_STBC_ACTIVE_INTERRUPT_FROM_MASK_STBC_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_STBC_ACTIVE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb44), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_STBC_ACTIVE_INTERRUPT_TO_MASK_STBC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* masks the standby controller vlt_status interrupt */
#define GP_WB_READ_INT_CTRL_MASK_STBC_VLT_STATUS_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb44), 2)

#define GP_WB_GET_INT_CTRL_MASK_STBC_VLT_STATUS_INTERRUPT_FROM_MASK_STBC_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_STBC_VLT_STATUS_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb44), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_STBC_VLT_STATUS_INTERRUPT_TO_MASK_STBC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_I2CM_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb45))

#define GP_WB_WRITE_INT_CTRL_MASK_I2CM_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb45), (val))

/* masks the I2C master done interrupt */
#define GP_WB_READ_INT_CTRL_MASK_I2CM_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb45), 0)

#define GP_WB_GET_INT_CTRL_MASK_I2CM_DONE_INTERRUPT_FROM_MASK_I2CM_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_I2CM_DONE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb45), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_I2CM_DONE_INTERRUPT_TO_MASK_I2CM_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* masks the I2C master arbitration lost interrupt */
#define GP_WB_READ_INT_CTRL_MASK_I2CM_ARB_LOST_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb45), 1)

#define GP_WB_GET_INT_CTRL_MASK_I2CM_ARB_LOST_INTERRUPT_FROM_MASK_I2CM_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_I2CM_ARB_LOST_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb45), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_I2CM_ARB_LOST_INTERRUPT_TO_MASK_I2CM_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* masks the I2C master clock synchronization slave wait interrupt */
#define GP_WB_READ_INT_CTRL_MASK_I2CM_CLK_SYNC_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb45), 2)

#define GP_WB_GET_INT_CTRL_MASK_I2CM_CLK_SYNC_INTERRUPT_FROM_MASK_I2CM_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_I2CM_CLK_SYNC_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb45), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_I2CM_CLK_SYNC_INTERRUPT_TO_MASK_I2CM_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_RCI_INTERRUPTS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb46))

#define GP_WB_WRITE_INT_CTRL_MASK_RCI_INTERRUPTS(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb46), (val))

#define GP_WB_READ_INT_CTRL_MASK_RCI_DATA_IND_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb46), 0)

#define GP_WB_GET_INT_CTRL_MASK_RCI_DATA_IND_INTERRUPT_FROM_MASK_RCI_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_RCI_DATA_IND_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb46), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_RCI_DATA_IND_INTERRUPT_TO_MASK_RCI_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FE; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_RCI_DATA_CNF_0_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb46), 1)

#define GP_WB_GET_INT_CTRL_MASK_RCI_DATA_CNF_0_INTERRUPT_FROM_MASK_RCI_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_RCI_DATA_CNF_0_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb46), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_RCI_DATA_CNF_0_INTERRUPT_TO_MASK_RCI_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FD; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_RCI_DATA_CNF_INTERRUPTS() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb46)) >> 1) & 0x0F)

#define GP_WB_GET_INT_CTRL_MASK_RCI_DATA_CNF_INTERRUPTS_FROM_MASK_RCI_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x0F)

#define GP_WB_WRITE_INT_CTRL_MASK_RCI_DATA_CNF_INTERRUPTS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb46), 0x1E, (val) << 1); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_RCI_DATA_CNF_INTERRUPTS_TO_MASK_RCI_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x03E1; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_RCI_DATA_CNF_1_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb46), 2)

#define GP_WB_GET_INT_CTRL_MASK_RCI_DATA_CNF_1_INTERRUPT_FROM_MASK_RCI_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_RCI_DATA_CNF_1_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb46), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_RCI_DATA_CNF_1_INTERRUPT_TO_MASK_RCI_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FB; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_RCI_DATA_CNF_2_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb46), 3)

#define GP_WB_GET_INT_CTRL_MASK_RCI_DATA_CNF_2_INTERRUPT_FROM_MASK_RCI_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_RCI_DATA_CNF_2_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb46), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_RCI_DATA_CNF_2_INTERRUPT_TO_MASK_RCI_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03F7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_RCI_DATA_CNF_3_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb46), 4)

#define GP_WB_GET_INT_CTRL_MASK_RCI_DATA_CNF_3_INTERRUPT_FROM_MASK_RCI_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_RCI_DATA_CNF_3_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb46), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_RCI_DATA_CNF_3_INTERRUPT_TO_MASK_RCI_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03EF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_RCI_BLE_DATA_IND_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb46), 5)

#define GP_WB_GET_INT_CTRL_MASK_RCI_BLE_DATA_IND_INTERRUPT_FROM_MASK_RCI_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_RCI_BLE_DATA_IND_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb46), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_RCI_BLE_DATA_IND_INTERRUPT_TO_MASK_RCI_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03DF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_RCI_BLE_ADV_IND_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb46), 6)

#define GP_WB_GET_INT_CTRL_MASK_RCI_BLE_ADV_IND_INTERRUPT_FROM_MASK_RCI_INTERRUPTS(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_RCI_BLE_ADV_IND_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb46), 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_RCI_BLE_ADV_IND_INTERRUPT_TO_MASK_RCI_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03BF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_RCI_BLE_CONN_REQ_IND_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb46), 7)

#define GP_WB_GET_INT_CTRL_MASK_RCI_BLE_CONN_REQ_IND_INTERRUPT_FROM_MASK_RCI_INTERRUPTS(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_RCI_BLE_CONN_REQ_IND_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb46), 7, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_RCI_BLE_CONN_REQ_IND_INTERRUPT_TO_MASK_RCI_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x037F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_RCI_BLE_CONN_RSP_IND_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb47), 0)

#define GP_WB_GET_INT_CTRL_MASK_RCI_BLE_CONN_RSP_IND_INTERRUPT_FROM_MASK_RCI_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_RCI_BLE_CONN_RSP_IND_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb47), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_RCI_BLE_CONN_RSP_IND_INTERRUPT_TO_MASK_RCI_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_RCI_BLE_DATA_CNF_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb47), 1)

#define GP_WB_GET_INT_CTRL_MASK_RCI_BLE_DATA_CNF_INTERRUPT_FROM_MASK_RCI_INTERRUPTS(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_RCI_BLE_DATA_CNF_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb47), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_RCI_BLE_DATA_CNF_INTERRUPT_TO_MASK_RCI_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_PHY_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb48))

#define GP_WB_WRITE_INT_CTRL_MASK_PHY_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb48), (val))

/* masks the interrupt for the fll rx out of range event */
#define GP_WB_READ_INT_CTRL_MASK_PHY_FLL_RX_OUT_OF_RANGE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb48), 0)

#define GP_WB_GET_INT_CTRL_MASK_PHY_FLL_RX_OUT_OF_RANGE_INTERRUPT_FROM_MASK_PHY_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PHY_FLL_RX_OUT_OF_RANGE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb48), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PHY_FLL_RX_OUT_OF_RANGE_INTERRUPT_TO_MASK_PHY_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* masks the interrupt for the fll tx out of range event */
#define GP_WB_READ_INT_CTRL_MASK_PHY_FLL_TX_OUT_OF_RANGE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb48), 1)

#define GP_WB_GET_INT_CTRL_MASK_PHY_FLL_TX_OUT_OF_RANGE_INTERRUPT_FROM_MASK_PHY_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PHY_FLL_TX_OUT_OF_RANGE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb48), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PHY_FLL_TX_OUT_OF_RANGE_INTERRUPT_TO_MASK_PHY_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* masks the interrupt for the fll tx_out of lock event */
#define GP_WB_READ_INT_CTRL_MASK_PHY_FLL_TX_OUT_OF_LOCK_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb48), 2)

#define GP_WB_GET_INT_CTRL_MASK_PHY_FLL_TX_OUT_OF_LOCK_INTERRUPT_FROM_MASK_PHY_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PHY_FLL_TX_OUT_OF_LOCK_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb48), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PHY_FLL_TX_OUT_OF_LOCK_INTERRUPT_TO_MASK_PHY_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* masks the interrupt for the fll fp out of range event */
#define GP_WB_READ_INT_CTRL_MASK_PHY_FLL_FE_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb48), 3)

#define GP_WB_GET_INT_CTRL_MASK_PHY_FLL_FE_DONE_INTERRUPT_FROM_MASK_PHY_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PHY_FLL_FE_DONE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb48), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PHY_FLL_FE_DONE_INTERRUPT_TO_MASK_PHY_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* masks the interrupt for the fll fp out of range event */
#define GP_WB_READ_INT_CTRL_MASK_PHY_FLL_CAL_START_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb48), 4)

#define GP_WB_GET_INT_CTRL_MASK_PHY_FLL_CAL_START_INTERRUPT_FROM_MASK_PHY_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PHY_FLL_CAL_START_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb48), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PHY_FLL_CAL_START_INTERRUPT_TO_MASK_PHY_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* masks the interrupt for rx_mode changes */
#define GP_WB_READ_INT_CTRL_MASK_PHY_RX_MODE_CHANGE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb48), 5)

#define GP_WB_GET_INT_CTRL_MASK_PHY_RX_MODE_CHANGE_INTERRUPT_FROM_MASK_PHY_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PHY_RX_MODE_CHANGE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb48), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PHY_RX_MODE_CHANGE_INTERRUPT_TO_MASK_PHY_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_GPIO_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb49))

#define GP_WB_WRITE_INT_CTRL_MASK_GPIO_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb49), (val))

/* masks the gpio interrupts for exti 0 of the selected port */
#define GP_WB_READ_INT_CTRL_MASK_GPIO_EXTI0_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb49), 0)

#define GP_WB_GET_INT_CTRL_MASK_GPIO_EXTI0_INTERRUPT_FROM_MASK_GPIO_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPIO_EXTI0_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb49), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPIO_EXTI0_INTERRUPT_TO_MASK_GPIO_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* masks the gpio interrupts for exti 1 of the selected port */
#define GP_WB_READ_INT_CTRL_MASK_GPIO_EXTI1_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb49), 1)

#define GP_WB_GET_INT_CTRL_MASK_GPIO_EXTI1_INTERRUPT_FROM_MASK_GPIO_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPIO_EXTI1_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb49), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPIO_EXTI1_INTERRUPT_TO_MASK_GPIO_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* masks the gpio interrupts for exti 2 of the selected port */
#define GP_WB_READ_INT_CTRL_MASK_GPIO_EXTI2_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb49), 2)

#define GP_WB_GET_INT_CTRL_MASK_GPIO_EXTI2_INTERRUPT_FROM_MASK_GPIO_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPIO_EXTI2_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb49), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPIO_EXTI2_INTERRUPT_TO_MASK_GPIO_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* masks the gpio interrupts for exti 3 of the selected port */
#define GP_WB_READ_INT_CTRL_MASK_GPIO_EXTI3_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb49), 3)

#define GP_WB_GET_INT_CTRL_MASK_GPIO_EXTI3_INTERRUPT_FROM_MASK_GPIO_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPIO_EXTI3_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb49), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPIO_EXTI3_INTERRUPT_TO_MASK_GPIO_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* masks the gpio interrupts for exti 4 of the selected port */
#define GP_WB_READ_INT_CTRL_MASK_GPIO_EXTI4_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb49), 4)

#define GP_WB_GET_INT_CTRL_MASK_GPIO_EXTI4_INTERRUPT_FROM_MASK_GPIO_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPIO_EXTI4_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb49), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPIO_EXTI4_INTERRUPT_TO_MASK_GPIO_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* masks the gpio interrupts for exti 5 of the selected port */
#define GP_WB_READ_INT_CTRL_MASK_GPIO_EXTI5_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb49), 5)

#define GP_WB_GET_INT_CTRL_MASK_GPIO_EXTI5_INTERRUPT_FROM_MASK_GPIO_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPIO_EXTI5_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb49), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPIO_EXTI5_INTERRUPT_TO_MASK_GPIO_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* masks the gpio interrupts for exti 6 of the selected port */
#define GP_WB_READ_INT_CTRL_MASK_GPIO_EXTI6_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb49), 6)

#define GP_WB_GET_INT_CTRL_MASK_GPIO_EXTI6_INTERRUPT_FROM_MASK_GPIO_INTERRUPTS(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPIO_EXTI6_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb49), 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPIO_EXTI6_INTERRUPT_TO_MASK_GPIO_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* masks the gpio interrupts for exti 7 of the selected port */
#define GP_WB_READ_INT_CTRL_MASK_GPIO_EXTI7_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb49), 7)

#define GP_WB_GET_INT_CTRL_MASK_GPIO_EXTI7_INTERRUPT_FROM_MASK_GPIO_INTERRUPTS(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPIO_EXTI7_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb49), 7, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPIO_EXTI7_INTERRUPT_TO_MASK_GPIO_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_SPIM_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4a))

#define GP_WB_WRITE_INT_CTRL_MASK_SPIM_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4a), (val))

/* masks the SPI master transfer not busy interrupt */
#define GP_WB_READ_INT_CTRL_MASK_SPIM_NOT_BUSY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4a), 0)

#define GP_WB_GET_INT_CTRL_MASK_SPIM_NOT_BUSY_INTERRUPT_FROM_MASK_SPIM_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_SPIM_NOT_BUSY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4a), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_SPIM_NOT_BUSY_INTERRUPT_TO_MASK_SPIM_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* masks the SPI master TX buffer empty interrupt */
#define GP_WB_READ_INT_CTRL_MASK_SPIM_TX_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4a), 1)

#define GP_WB_GET_INT_CTRL_MASK_SPIM_TX_NOT_FULL_INTERRUPT_FROM_MASK_SPIM_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_SPIM_TX_NOT_FULL_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4a), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_SPIM_TX_NOT_FULL_INTERRUPT_TO_MASK_SPIM_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* masks the SPI master RX buffer not empty interrupt */
#define GP_WB_READ_INT_CTRL_MASK_SPIM_RX_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4a), 2)

#define GP_WB_GET_INT_CTRL_MASK_SPIM_RX_NOT_EMPTY_INTERRUPT_FROM_MASK_SPIM_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_SPIM_RX_NOT_EMPTY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4a), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_SPIM_RX_NOT_EMPTY_INTERRUPT_TO_MASK_SPIM_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* masks the SPI master RX buffer overrun interrupt */
#define GP_WB_READ_INT_CTRL_MASK_SPIM_RX_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4a), 3)

#define GP_WB_GET_INT_CTRL_MASK_SPIM_RX_OVERRUN_INTERRUPT_FROM_MASK_SPIM_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_SPIM_RX_OVERRUN_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4a), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_SPIM_RX_OVERRUN_INTERRUPT_TO_MASK_SPIM_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_SPISL_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4b))

#define GP_WB_WRITE_INT_CTRL_MASK_SPISL_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4b), (val))

/* masks the SPI slave TX buffer empty interrupt */
#define GP_WB_READ_INT_CTRL_MASK_SPISL_TX_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4b), 0)

#define GP_WB_GET_INT_CTRL_MASK_SPISL_TX_NOT_FULL_INTERRUPT_FROM_MASK_SPISL_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_SPISL_TX_NOT_FULL_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4b), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_SPISL_TX_NOT_FULL_INTERRUPT_TO_MASK_SPISL_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* masks the SPI slave RX buffer not empty interrupt */
#define GP_WB_READ_INT_CTRL_MASK_SPISL_RX_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4b), 1)

#define GP_WB_GET_INT_CTRL_MASK_SPISL_RX_NOT_EMPTY_INTERRUPT_FROM_MASK_SPISL_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_SPISL_RX_NOT_EMPTY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4b), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_SPISL_RX_NOT_EMPTY_INTERRUPT_TO_MASK_SPISL_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* masks the SPI slave TX buffer underrun interrupt */
#define GP_WB_READ_INT_CTRL_MASK_SPISL_TX_UNDERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4b), 2)

#define GP_WB_GET_INT_CTRL_MASK_SPISL_TX_UNDERRUN_INTERRUPT_FROM_MASK_SPISL_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_SPISL_TX_UNDERRUN_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4b), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_SPISL_TX_UNDERRUN_INTERRUPT_TO_MASK_SPISL_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* masks the SPI slave RX buffer overrun interrupt */
#define GP_WB_READ_INT_CTRL_MASK_SPISL_RX_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4b), 3)

#define GP_WB_GET_INT_CTRL_MASK_SPISL_RX_OVERRUN_INTERRUPT_FROM_MASK_SPISL_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_SPISL_RX_OVERRUN_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4b), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_SPISL_RX_OVERRUN_INTERRUPT_TO_MASK_SPISL_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* masks the SPI slave TX empty interrupt */
#define GP_WB_READ_INT_CTRL_MASK_SPISL_TX_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4b), 4)

#define GP_WB_GET_INT_CTRL_MASK_SPISL_TX_EMPTY_INTERRUPT_FROM_MASK_SPISL_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_SPISL_TX_EMPTY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4b), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_SPISL_TX_EMPTY_INTERRUPT_TO_MASK_SPISL_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_IPCGPM2X_INTERRUPTS() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4c))

#define GP_WB_WRITE_INT_CTRL_MASK_IPCGPM2X_INTERRUPTS(val) \
      GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4c), (val))

/* masks the inter processor communication source interrupt (gpm 2 ...) */
#define GP_WB_READ_INT_CTRL_MASK_IPCGPM2X_FLAG_A_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4c), 0)

#define GP_WB_GET_INT_CTRL_MASK_IPCGPM2X_FLAG_A_INTERRUPT_FROM_MASK_IPCGPM2X_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCGPM2X_FLAG_A_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4c), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCGPM2X_FLAG_A_INTERRUPT_TO_MASK_IPCGPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFE; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* masks the inter processor communication source interrupt (gpm 2 ...) */
#define GP_WB_READ_INT_CTRL_MASK_IPCGPM2X_FLAG_B_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4c), 1)

#define GP_WB_GET_INT_CTRL_MASK_IPCGPM2X_FLAG_B_INTERRUPT_FROM_MASK_IPCGPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCGPM2X_FLAG_B_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4c), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCGPM2X_FLAG_B_INTERRUPT_TO_MASK_IPCGPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFD; \
          (tmp) |= (((UInt32)(val)) << 1); \
        } while (0)

/* masks the inter processor communication source interrupt (gpm 2 ...) */
#define GP_WB_READ_INT_CTRL_MASK_IPCGPM2X_FLAG_C_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4c), 2)

#define GP_WB_GET_INT_CTRL_MASK_IPCGPM2X_FLAG_C_INTERRUPT_FROM_MASK_IPCGPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCGPM2X_FLAG_C_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4c), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCGPM2X_FLAG_C_INTERRUPT_TO_MASK_IPCGPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFB; \
          (tmp) |= (((UInt32)(val)) << 2); \
        } while (0)

/* masks the inter processor communication source interrupt (gpm 2 ...) */
#define GP_WB_READ_INT_CTRL_MASK_IPCGPM2X_FLAG_D_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4c), 3)

#define GP_WB_GET_INT_CTRL_MASK_IPCGPM2X_FLAG_D_INTERRUPT_FROM_MASK_IPCGPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCGPM2X_FLAG_D_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4c), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCGPM2X_FLAG_D_INTERRUPT_TO_MASK_IPCGPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFF7; \
          (tmp) |= (((UInt32)(val)) << 3); \
        } while (0)

/* Indicates that an internal cmd is processed */
#define GP_WB_READ_INT_CTRL_MASK_IPCGPM2X_CMD_PROCESSED_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4c), 4)

#define GP_WB_GET_INT_CTRL_MASK_IPCGPM2X_CMD_PROCESSED_INTERRUPT_FROM_MASK_IPCGPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCGPM2X_CMD_PROCESSED_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4c), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCGPM2X_CMD_PROCESSED_INTERRUPT_TO_MASK_IPCGPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFEF; \
          (tmp) |= (((UInt32)(val)) << 4); \
        } while (0)

/* masks the gpmicro error interrupt */
#define GP_WB_READ_INT_CTRL_MASK_IPCGPM2X_ERROR_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4c), 5)

#define GP_WB_GET_INT_CTRL_MASK_IPCGPM2X_ERROR_INTERRUPT_FROM_MASK_IPCGPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCGPM2X_ERROR_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4c), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCGPM2X_ERROR_INTERRUPT_TO_MASK_IPCGPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFDF; \
          (tmp) |= (((UInt32)(val)) << 5); \
        } while (0)

/* masks the gpmicro unexpected condition interrupt */
#define GP_WB_READ_INT_CTRL_MASK_IPCGPM2X_UNEXPECTED_COND_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4c), 6)

#define GP_WB_GET_INT_CTRL_MASK_IPCGPM2X_UNEXPECTED_COND_INTERRUPT_FROM_MASK_IPCGPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCGPM2X_UNEXPECTED_COND_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4c), 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCGPM2X_UNEXPECTED_COND_INTERRUPT_TO_MASK_IPCGPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFBF; \
          (tmp) |= (((UInt32)(val)) << 6); \
        } while (0)

/* masks the gpmicro status interrupt */
#define GP_WB_READ_INT_CTRL_MASK_IPCGPM2X_STAT_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4c), 7)

#define GP_WB_GET_INT_CTRL_MASK_IPCGPM2X_STAT_INTERRUPT_FROM_MASK_IPCGPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCGPM2X_STAT_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4c), 7, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCGPM2X_STAT_INTERRUPT_TO_MASK_IPCGPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FF7F; \
          (tmp) |= (((UInt32)(val)) << 7); \
        } while (0)

/* Indicates a frame is sent during an advertising event */
#define GP_WB_READ_INT_CTRL_MASK_IPCGPM2X_ADV_TX_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4d), 0)

#define GP_WB_GET_INT_CTRL_MASK_IPCGPM2X_ADV_TX_INTERRUPT_FROM_MASK_IPCGPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCGPM2X_ADV_TX_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4d), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCGPM2X_ADV_TX_INTERRUPT_TO_MASK_IPCGPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FEFF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* Indicates a scan request has been received */
#define GP_WB_READ_INT_CTRL_MASK_IPCGPM2X_SCAN_REQ_RX_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4d), 1)

#define GP_WB_GET_INT_CTRL_MASK_IPCGPM2X_SCAN_REQ_RX_INTERRUPT_FROM_MASK_IPCGPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCGPM2X_SCAN_REQ_RX_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4d), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCGPM2X_SCAN_REQ_RX_INTERRUPT_TO_MASK_IPCGPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FDFF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* Indicates a scan response is sent */
#define GP_WB_READ_INT_CTRL_MASK_IPCGPM2X_SCAN_RSP_TX_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4d), 2)

#define GP_WB_GET_INT_CTRL_MASK_IPCGPM2X_SCAN_RSP_TX_INTERRUPT_FROM_MASK_IPCGPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCGPM2X_SCAN_RSP_TX_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4d), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCGPM2X_SCAN_RSP_TX_INTERRUPT_TO_MASK_IPCGPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FBFF; \
          (tmp) |= (((UInt32)(val)) << 10); \
        } while (0)

/* Indicates that a SCAN_REQ frame is sent */
#define GP_WB_READ_INT_CTRL_MASK_IPCGPM2X_SCAN_REQ_TX_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4d), 3)

#define GP_WB_GET_INT_CTRL_MASK_IPCGPM2X_SCAN_REQ_TX_INTERRUPT_FROM_MASK_IPCGPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCGPM2X_SCAN_REQ_TX_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4d), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCGPM2X_SCAN_REQ_TX_INTERRUPT_TO_MASK_IPCGPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01F7FF; \
          (tmp) |= (((UInt32)(val)) << 11); \
        } while (0)

/* Indicates that a CONN_REQ frame is sent */
#define GP_WB_READ_INT_CTRL_MASK_IPCGPM2X_CONN_REQ_TX_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4d), 4)

#define GP_WB_GET_INT_CTRL_MASK_IPCGPM2X_CONN_REQ_TX_INTERRUPT_FROM_MASK_IPCGPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCGPM2X_CONN_REQ_TX_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4d), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCGPM2X_CONN_REQ_TX_INTERRUPT_TO_MASK_IPCGPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01EFFF; \
          (tmp) |= (((UInt32)(val)) << 12); \
        } while (0)

/* Indicates that a subevent has been processed */
#define GP_WB_READ_INT_CTRL_MASK_IPCGPM2X_SUBEV_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4d), 5)

#define GP_WB_GET_INT_CTRL_MASK_IPCGPM2X_SUBEV_DONE_INTERRUPT_FROM_MASK_IPCGPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCGPM2X_SUBEV_DONE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4d), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCGPM2X_SUBEV_DONE_INTERRUPT_TO_MASK_IPCGPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01DFFF; \
          (tmp) |= (((UInt32)(val)) << 13); \
        } while (0)

/* Indicates that a ble event has been processed */
#define GP_WB_READ_INT_CTRL_MASK_IPCGPM2X_EVENT_PROCESSED_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4d), 6)

#define GP_WB_GET_INT_CTRL_MASK_IPCGPM2X_EVENT_PROCESSED_INTERRUPT_FROM_MASK_IPCGPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCGPM2X_EVENT_PROCESSED_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4d), 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCGPM2X_EVENT_PROCESSED_INTERRUPT_TO_MASK_IPCGPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01BFFF; \
          (tmp) |= (((UInt32)(val)) << 14); \
        } while (0)

/* Indicates that a connection ble event has reached its last_sch_event_cnt (if enabled) */
#define GP_WB_READ_INT_CTRL_MASK_IPCGPM2X_LAST_CONN_EVENT_CNT_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4d), 7)

#define GP_WB_GET_INT_CTRL_MASK_IPCGPM2X_LAST_CONN_EVENT_CNT_INTERRUPT_FROM_MASK_IPCGPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCGPM2X_LAST_CONN_EVENT_CNT_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4d), 7, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCGPM2X_LAST_CONN_EVENT_CNT_INTERRUPT_TO_MASK_IPCGPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x017FFF; \
          (tmp) |= (((UInt32)(val)) << 15); \
        } while (0)

/* Indicates that a ble event has been skipped */
#define GP_WB_READ_INT_CTRL_MASK_IPCGPM2X_EVENT_SKIPPED_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4e), 0)

#define GP_WB_GET_INT_CTRL_MASK_IPCGPM2X_EVENT_SKIPPED_INTERRUPT_FROM_MASK_IPCGPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCGPM2X_EVENT_SKIPPED_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4e), (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCGPM2X_EVENT_SKIPPED_INTERRUPT_TO_MASK_IPCGPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x00FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_IPCX2GPM_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4f))

#define GP_WB_WRITE_INT_CTRL_MASK_IPCX2GPM_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4f), (val))

#define GP_WB_READ_INT_CTRL_MASK_IPCX2GPM_FLAG_A_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4f), 0)

#define GP_WB_GET_INT_CTRL_MASK_IPCX2GPM_FLAG_A_INTERRUPT_FROM_MASK_IPCX2GPM_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCX2GPM_FLAG_A_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4f), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCX2GPM_FLAG_A_INTERRUPT_TO_MASK_IPCX2GPM_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_IPCX2GPM_FLAG_B_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4f), 1)

#define GP_WB_GET_INT_CTRL_MASK_IPCX2GPM_FLAG_B_INTERRUPT_FROM_MASK_IPCX2GPM_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCX2GPM_FLAG_B_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4f), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCX2GPM_FLAG_B_INTERRUPT_TO_MASK_IPCX2GPM_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_IPCX2GPM_FLAG_C_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4f), 2)

#define GP_WB_GET_INT_CTRL_MASK_IPCX2GPM_FLAG_C_INTERRUPT_FROM_MASK_IPCX2GPM_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCX2GPM_FLAG_C_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4f), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCX2GPM_FLAG_C_INTERRUPT_TO_MASK_IPCX2GPM_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_IPCX2GPM_FLAG_D_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4f), 3)

#define GP_WB_GET_INT_CTRL_MASK_IPCX2GPM_FLAG_D_INTERRUPT_FROM_MASK_IPCX2GPM_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCX2GPM_FLAG_D_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4f), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCX2GPM_FLAG_D_INTERRUPT_TO_MASK_IPCX2GPM_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Indicates that a cmd is available to be processed */
#define GP_WB_READ_INT_CTRL_MASK_IPCX2GPM_CMD_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4f), 4)

#define GP_WB_GET_INT_CTRL_MASK_IPCX2GPM_CMD_INTERRUPT_FROM_MASK_IPCX2GPM_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCX2GPM_CMD_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb4f), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCX2GPM_CMD_INTERRUPT_TO_MASK_IPCX2GPM_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_IPCINT2X_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb50))

#define GP_WB_WRITE_INT_CTRL_MASK_IPCINT2X_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb50), (val))

/* masks the inter processor communication source interrupt (int 2 ...) */
#define GP_WB_READ_INT_CTRL_MASK_IPCINT2X_FLAG_A_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb50), 0)

#define GP_WB_GET_INT_CTRL_MASK_IPCINT2X_FLAG_A_INTERRUPT_FROM_MASK_IPCINT2X_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCINT2X_FLAG_A_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb50), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCINT2X_FLAG_A_INTERRUPT_TO_MASK_IPCINT2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* masks the inter processor communication source interrupt (int 2 ...) */
#define GP_WB_READ_INT_CTRL_MASK_IPCINT2X_FLAG_B_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb50), 1)

#define GP_WB_GET_INT_CTRL_MASK_IPCINT2X_FLAG_B_INTERRUPT_FROM_MASK_IPCINT2X_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCINT2X_FLAG_B_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb50), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCINT2X_FLAG_B_INTERRUPT_TO_MASK_IPCINT2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* masks the inter processor communication source interrupt (int 2 ...) */
#define GP_WB_READ_INT_CTRL_MASK_IPCINT2X_FLAG_C_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb50), 2)

#define GP_WB_GET_INT_CTRL_MASK_IPCINT2X_FLAG_C_INTERRUPT_FROM_MASK_IPCINT2X_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCINT2X_FLAG_C_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb50), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCINT2X_FLAG_C_INTERRUPT_TO_MASK_IPCINT2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* masks the inter processor communication source interrupt (int 2 ...) */
#define GP_WB_READ_INT_CTRL_MASK_IPCINT2X_FLAG_D_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb50), 3)

#define GP_WB_GET_INT_CTRL_MASK_IPCINT2X_FLAG_D_INTERRUPT_FROM_MASK_IPCINT2X_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCINT2X_FLAG_D_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb50), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCINT2X_FLAG_D_INTERRUPT_TO_MASK_IPCINT2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_IPCX2INT_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb51))

#define GP_WB_WRITE_INT_CTRL_MASK_IPCX2INT_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb51), (val))

/* masks the inter processor communication source interrupt (... 2 int) */
#define GP_WB_READ_INT_CTRL_MASK_IPCX2INT_FLAG_A_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb51), 0)

#define GP_WB_GET_INT_CTRL_MASK_IPCX2INT_FLAG_A_INTERRUPT_FROM_MASK_IPCX2INT_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCX2INT_FLAG_A_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb51), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCX2INT_FLAG_A_INTERRUPT_TO_MASK_IPCX2INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* masks the inter processor communication source interrupt (... 2 int) */
#define GP_WB_READ_INT_CTRL_MASK_IPCX2INT_FLAG_B_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb51), 1)

#define GP_WB_GET_INT_CTRL_MASK_IPCX2INT_FLAG_B_INTERRUPT_FROM_MASK_IPCX2INT_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCX2INT_FLAG_B_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb51), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCX2INT_FLAG_B_INTERRUPT_TO_MASK_IPCX2INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* masks the inter processor communication source interrupt (... 2 int) */
#define GP_WB_READ_INT_CTRL_MASK_IPCX2INT_FLAG_C_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb51), 2)

#define GP_WB_GET_INT_CTRL_MASK_IPCX2INT_FLAG_C_INTERRUPT_FROM_MASK_IPCX2INT_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCX2INT_FLAG_C_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb51), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCX2INT_FLAG_C_INTERRUPT_TO_MASK_IPCX2INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* masks the inter processor communication source interrupt (... 2 int) */
#define GP_WB_READ_INT_CTRL_MASK_IPCX2INT_FLAG_D_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb51), 3)

#define GP_WB_GET_INT_CTRL_MASK_IPCX2INT_FLAG_D_INTERRUPT_FROM_MASK_IPCX2INT_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCX2INT_FLAG_D_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb51), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCX2INT_FLAG_D_INTERRUPT_TO_MASK_IPCX2INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_IPCEXT2X_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb52))

#define GP_WB_WRITE_INT_CTRL_MASK_IPCEXT2X_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb52), (val))

/* masks the inter processor communication source interrupt (ext 2 ...) */
#define GP_WB_READ_INT_CTRL_MASK_IPCEXT2X_FLAG_A_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb52), 0)

#define GP_WB_GET_INT_CTRL_MASK_IPCEXT2X_FLAG_A_INTERRUPT_FROM_MASK_IPCEXT2X_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCEXT2X_FLAG_A_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb52), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCEXT2X_FLAG_A_INTERRUPT_TO_MASK_IPCEXT2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* masks the inter processor communication source interrupt (ext 2 ...) */
#define GP_WB_READ_INT_CTRL_MASK_IPCEXT2X_FLAG_B_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb52), 1)

#define GP_WB_GET_INT_CTRL_MASK_IPCEXT2X_FLAG_B_INTERRUPT_FROM_MASK_IPCEXT2X_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCEXT2X_FLAG_B_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb52), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCEXT2X_FLAG_B_INTERRUPT_TO_MASK_IPCEXT2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* masks the inter processor communication source interrupt (ext 2 ...) */
#define GP_WB_READ_INT_CTRL_MASK_IPCEXT2X_FLAG_C_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb52), 2)

#define GP_WB_GET_INT_CTRL_MASK_IPCEXT2X_FLAG_C_INTERRUPT_FROM_MASK_IPCEXT2X_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCEXT2X_FLAG_C_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb52), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCEXT2X_FLAG_C_INTERRUPT_TO_MASK_IPCEXT2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* masks the inter processor communication source interrupt (ext 2 ...) */
#define GP_WB_READ_INT_CTRL_MASK_IPCEXT2X_FLAG_D_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb52), 3)

#define GP_WB_GET_INT_CTRL_MASK_IPCEXT2X_FLAG_D_INTERRUPT_FROM_MASK_IPCEXT2X_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCEXT2X_FLAG_D_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb52), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCEXT2X_FLAG_D_INTERRUPT_TO_MASK_IPCEXT2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_IPCX2EXT_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb53))

#define GP_WB_WRITE_INT_CTRL_MASK_IPCX2EXT_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb53), (val))

/* masks the inter processor communication source interrupt (... 2 ext) */
#define GP_WB_READ_INT_CTRL_MASK_IPCX2EXT_FLAG_A_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb53), 0)

#define GP_WB_GET_INT_CTRL_MASK_IPCX2EXT_FLAG_A_INTERRUPT_FROM_MASK_IPCX2EXT_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCX2EXT_FLAG_A_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb53), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCX2EXT_FLAG_A_INTERRUPT_TO_MASK_IPCX2EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* masks the inter processor communication source interrupt (... 2 ext) */
#define GP_WB_READ_INT_CTRL_MASK_IPCX2EXT_FLAG_B_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb53), 1)

#define GP_WB_GET_INT_CTRL_MASK_IPCX2EXT_FLAG_B_INTERRUPT_FROM_MASK_IPCX2EXT_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCX2EXT_FLAG_B_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb53), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCX2EXT_FLAG_B_INTERRUPT_TO_MASK_IPCX2EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* masks the inter processor communication source interrupt (... 2 ext) */
#define GP_WB_READ_INT_CTRL_MASK_IPCX2EXT_FLAG_C_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb53), 2)

#define GP_WB_GET_INT_CTRL_MASK_IPCX2EXT_FLAG_C_INTERRUPT_FROM_MASK_IPCX2EXT_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCX2EXT_FLAG_C_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb53), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCX2EXT_FLAG_C_INTERRUPT_TO_MASK_IPCX2EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* masks the inter processor communication source interrupt (... 2 ext) */
#define GP_WB_READ_INT_CTRL_MASK_IPCX2EXT_FLAG_D_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb53), 3)

#define GP_WB_GET_INT_CTRL_MASK_IPCX2EXT_FLAG_D_INTERRUPT_FROM_MASK_IPCX2EXT_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IPCX2EXT_FLAG_D_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb53), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IPCX2EXT_FLAG_D_INTERRUPT_TO_MASK_IPCX2EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_I2CSL_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb54))

#define GP_WB_WRITE_INT_CTRL_MASK_I2CSL_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb54), (val))

/* masks the TX buffer not full interrupt. */
#define GP_WB_READ_INT_CTRL_MASK_I2CSL_TX_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb54), 0)

#define GP_WB_GET_INT_CTRL_MASK_I2CSL_TX_NOT_FULL_INTERRUPT_FROM_MASK_I2CSL_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_I2CSL_TX_NOT_FULL_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb54), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_I2CSL_TX_NOT_FULL_INTERRUPT_TO_MASK_I2CSL_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* masks the RX buffer not empty interrupt */
#define GP_WB_READ_INT_CTRL_MASK_I2CSL_RX_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb54), 1)

#define GP_WB_GET_INT_CTRL_MASK_I2CSL_RX_NOT_EMPTY_INTERRUPT_FROM_MASK_I2CSL_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_I2CSL_RX_NOT_EMPTY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb54), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_I2CSL_RX_NOT_EMPTY_INTERRUPT_TO_MASK_I2CSL_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* masks the TX stretch interrupt. */
#define GP_WB_READ_INT_CTRL_MASK_I2CSL_TX_STRETCH_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb54), 2)

#define GP_WB_GET_INT_CTRL_MASK_I2CSL_TX_STRETCH_INTERRUPT_FROM_MASK_I2CSL_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_I2CSL_TX_STRETCH_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb54), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_I2CSL_TX_STRETCH_INTERRUPT_TO_MASK_I2CSL_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* masks the I2C START event occurred interrupt */
#define GP_WB_READ_INT_CTRL_MASK_I2CSL_START_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb54), 3)

#define GP_WB_GET_INT_CTRL_MASK_I2CSL_START_INTERRUPT_FROM_MASK_I2CSL_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_I2CSL_START_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb54), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_I2CSL_START_INTERRUPT_TO_MASK_I2CSL_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* masks the I2C STOP event occurred interrupt */
#define GP_WB_READ_INT_CTRL_MASK_I2CSL_STOP_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb54), 4)

#define GP_WB_GET_INT_CTRL_MASK_I2CSL_STOP_INTERRUPT_FROM_MASK_I2CSL_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_I2CSL_STOP_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb54), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_I2CSL_STOP_INTERRUPT_TO_MASK_I2CSL_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* masks the I2C SLAD event occurred interrupt */
#define GP_WB_READ_INT_CTRL_MASK_I2CSL_SLAD_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb54), 5)

#define GP_WB_GET_INT_CTRL_MASK_I2CSL_SLAD_INTERRUPT_FROM_MASK_I2CSL_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_I2CSL_SLAD_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb54), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_I2CSL_SLAD_INTERRUPT_TO_MASK_I2CSL_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_PWMS_INTERRUPTS() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb58))

#define GP_WB_WRITE_INT_CTRL_MASK_PWMS_INTERRUPTS(val) \
      GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb58), (val))

/* masks the PWM threshold_match interrupt of pwm0 */
#define GP_WB_READ_INT_CTRL_MASK_PWMS_PWM0_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb58), 0)

#define GP_WB_GET_INT_CTRL_MASK_PWMS_PWM0_THRESHOLD_MATCH_INTERRUPT_FROM_MASK_PWMS_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PWMS_PWM0_THRESHOLD_MATCH_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb58), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PWMS_PWM0_THRESHOLD_MATCH_INTERRUPT_TO_MASK_PWMS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFFE; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* masks the PWM threshold_match interrupt of pwm1 */
#define GP_WB_READ_INT_CTRL_MASK_PWMS_PWM1_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb58), 1)

#define GP_WB_GET_INT_CTRL_MASK_PWMS_PWM1_THRESHOLD_MATCH_INTERRUPT_FROM_MASK_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PWMS_PWM1_THRESHOLD_MATCH_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb58), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PWMS_PWM1_THRESHOLD_MATCH_INTERRUPT_TO_MASK_PWMS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFFD; \
          (tmp) |= (((UInt32)(val)) << 1); \
        } while (0)

/* masks the PWM threshold_match interrupt of pwm2 */
#define GP_WB_READ_INT_CTRL_MASK_PWMS_PWM2_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb58), 2)

#define GP_WB_GET_INT_CTRL_MASK_PWMS_PWM2_THRESHOLD_MATCH_INTERRUPT_FROM_MASK_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PWMS_PWM2_THRESHOLD_MATCH_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb58), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PWMS_PWM2_THRESHOLD_MATCH_INTERRUPT_TO_MASK_PWMS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFFB; \
          (tmp) |= (((UInt32)(val)) << 2); \
        } while (0)

/* masks the PWM threshold_match interrupt of pwm3 */
#define GP_WB_READ_INT_CTRL_MASK_PWMS_PWM3_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb58), 3)

#define GP_WB_GET_INT_CTRL_MASK_PWMS_PWM3_THRESHOLD_MATCH_INTERRUPT_FROM_MASK_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PWMS_PWM3_THRESHOLD_MATCH_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb58), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PWMS_PWM3_THRESHOLD_MATCH_INTERRUPT_TO_MASK_PWMS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFF7; \
          (tmp) |= (((UInt32)(val)) << 3); \
        } while (0)

/* masks the PWM threshold_match interrupt of pwm4 */
#define GP_WB_READ_INT_CTRL_MASK_PWMS_PWM4_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb58), 4)

#define GP_WB_GET_INT_CTRL_MASK_PWMS_PWM4_THRESHOLD_MATCH_INTERRUPT_FROM_MASK_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PWMS_PWM4_THRESHOLD_MATCH_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb58), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PWMS_PWM4_THRESHOLD_MATCH_INTERRUPT_TO_MASK_PWMS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFEF; \
          (tmp) |= (((UInt32)(val)) << 4); \
        } while (0)

/* masks the PWM threshold_match interrupt of pwm5 */
#define GP_WB_READ_INT_CTRL_MASK_PWMS_PWM5_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb58), 5)

#define GP_WB_GET_INT_CTRL_MASK_PWMS_PWM5_THRESHOLD_MATCH_INTERRUPT_FROM_MASK_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PWMS_PWM5_THRESHOLD_MATCH_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb58), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PWMS_PWM5_THRESHOLD_MATCH_INTERRUPT_TO_MASK_PWMS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFDF; \
          (tmp) |= (((UInt32)(val)) << 5); \
        } while (0)

/* masks the PWM threshold_match interrupt of pwm6 */
#define GP_WB_READ_INT_CTRL_MASK_PWMS_PWM6_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb58), 6)

#define GP_WB_GET_INT_CTRL_MASK_PWMS_PWM6_THRESHOLD_MATCH_INTERRUPT_FROM_MASK_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PWMS_PWM6_THRESHOLD_MATCH_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb58), 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PWMS_PWM6_THRESHOLD_MATCH_INTERRUPT_TO_MASK_PWMS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFBF; \
          (tmp) |= (((UInt32)(val)) << 6); \
        } while (0)

/* masks the PWM threshold_match interrupt of pwm7 */
#define GP_WB_READ_INT_CTRL_MASK_PWMS_PWM7_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb58), 7)

#define GP_WB_GET_INT_CTRL_MASK_PWMS_PWM7_THRESHOLD_MATCH_INTERRUPT_FROM_MASK_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PWMS_PWM7_THRESHOLD_MATCH_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb58), 7, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PWMS_PWM7_THRESHOLD_MATCH_INTERRUPT_TO_MASK_PWMS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FF7F; \
          (tmp) |= (((UInt32)(val)) << 7); \
        } while (0)

/* masks the PWM next threshold underrun interrupt */
#define GP_WB_READ_INT_CTRL_MASK_PWMS_NEXT_THRESHOLD_UNDERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb59), 0)

#define GP_WB_GET_INT_CTRL_MASK_PWMS_NEXT_THRESHOLD_UNDERRUN_INTERRUPT_FROM_MASK_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PWMS_NEXT_THRESHOLD_UNDERRUN_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb59), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PWMS_NEXT_THRESHOLD_UNDERRUN_INTERRUPT_TO_MASK_PWMS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FEFF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* masks the PWM next threshold not full interrupt */
#define GP_WB_READ_INT_CTRL_MASK_PWMS_NEXT_THRESHOLD_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb59), 1)

#define GP_WB_GET_INT_CTRL_MASK_PWMS_NEXT_THRESHOLD_NOT_FULL_INTERRUPT_FROM_MASK_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PWMS_NEXT_THRESHOLD_NOT_FULL_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb59), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PWMS_NEXT_THRESHOLD_NOT_FULL_INTERRUPT_TO_MASK_PWMS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FDFF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* masks the PWM timestamp overrun interrupt */
#define GP_WB_READ_INT_CTRL_MASK_PWMS_TIMESTAMP_OVERRUN_INTERRUPT() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb59)) >> 2) & 0x0F)

#define GP_WB_GET_INT_CTRL_MASK_PWMS_TIMESTAMP_OVERRUN_INTERRUPT_FROM_MASK_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 10) & 0x0F)

#define GP_WB_WRITE_INT_CTRL_MASK_PWMS_TIMESTAMP_OVERRUN_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb59), 0x3C, (val) << 2); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PWMS_TIMESTAMP_OVERRUN_INTERRUPT_TO_MASK_PWMS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x03C3FF; \
          (tmp) |= (((UInt32)(val)) << 10); \
        } while (0)

/* masks the PWM timestamp0 overrun interrupt */
#define GP_WB_READ_INT_CTRL_MASK_PWMS_TIMESTAMP0_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb59), 2)

#define GP_WB_GET_INT_CTRL_MASK_PWMS_TIMESTAMP0_OVERRUN_INTERRUPT_FROM_MASK_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PWMS_TIMESTAMP0_OVERRUN_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb59), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PWMS_TIMESTAMP0_OVERRUN_INTERRUPT_TO_MASK_PWMS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FBFF; \
          (tmp) |= (((UInt32)(val)) << 10); \
        } while (0)

/* masks the PWM timestamp1 overrun interrupt */
#define GP_WB_READ_INT_CTRL_MASK_PWMS_TIMESTAMP1_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb59), 3)

#define GP_WB_GET_INT_CTRL_MASK_PWMS_TIMESTAMP1_OVERRUN_INTERRUPT_FROM_MASK_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PWMS_TIMESTAMP1_OVERRUN_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb59), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PWMS_TIMESTAMP1_OVERRUN_INTERRUPT_TO_MASK_PWMS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03F7FF; \
          (tmp) |= (((UInt32)(val)) << 11); \
        } while (0)

/* masks the PWM timestamp2 overrun interrupt */
#define GP_WB_READ_INT_CTRL_MASK_PWMS_TIMESTAMP2_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb59), 4)

#define GP_WB_GET_INT_CTRL_MASK_PWMS_TIMESTAMP2_OVERRUN_INTERRUPT_FROM_MASK_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PWMS_TIMESTAMP2_OVERRUN_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb59), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PWMS_TIMESTAMP2_OVERRUN_INTERRUPT_TO_MASK_PWMS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03EFFF; \
          (tmp) |= (((UInt32)(val)) << 12); \
        } while (0)

/* masks the PWM timestamp3 overrun interrupt */
#define GP_WB_READ_INT_CTRL_MASK_PWMS_TIMESTAMP3_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb59), 5)

#define GP_WB_GET_INT_CTRL_MASK_PWMS_TIMESTAMP3_OVERRUN_INTERRUPT_FROM_MASK_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PWMS_TIMESTAMP3_OVERRUN_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb59), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PWMS_TIMESTAMP3_OVERRUN_INTERRUPT_TO_MASK_PWMS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03DFFF; \
          (tmp) |= (((UInt32)(val)) << 13); \
        } while (0)

/* masks the PWM timestamp not empty interrupt */
#define GP_WB_READ_INT_CTRL_MASK_PWMS_TIMESTAMP_NOT_EMPTY_INTERRUPT() \
        ((GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb59)) >> 6) & 0x000F)

#define GP_WB_GET_INT_CTRL_MASK_PWMS_TIMESTAMP_NOT_EMPTY_INTERRUPT_FROM_MASK_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 14) & 0x000F)

#define GP_WB_WRITE_INT_CTRL_MASK_PWMS_TIMESTAMP_NOT_EMPTY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x000F); \
          GP_WB_MWRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb59), 0x03C0, (UInt16)(val) << 6); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PWMS_TIMESTAMP_NOT_EMPTY_INTERRUPT_TO_MASK_PWMS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x000F); \
          (tmp) &= 0x003FFF; \
          (tmp) |= (((UInt32)(val)) << 14); \
        } while (0)

/* masks the PWM timestamp0 not empty interrupt */
#define GP_WB_READ_INT_CTRL_MASK_PWMS_TIMESTAMP0_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb59), 6)

#define GP_WB_GET_INT_CTRL_MASK_PWMS_TIMESTAMP0_NOT_EMPTY_INTERRUPT_FROM_MASK_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PWMS_TIMESTAMP0_NOT_EMPTY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb59), 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PWMS_TIMESTAMP0_NOT_EMPTY_INTERRUPT_TO_MASK_PWMS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03BFFF; \
          (tmp) |= (((UInt32)(val)) << 14); \
        } while (0)

/* masks the PWM timestamp1 not empty interrupt */
#define GP_WB_READ_INT_CTRL_MASK_PWMS_TIMESTAMP1_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb59), 7)

#define GP_WB_GET_INT_CTRL_MASK_PWMS_TIMESTAMP1_NOT_EMPTY_INTERRUPT_FROM_MASK_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PWMS_TIMESTAMP1_NOT_EMPTY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb59), 7, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PWMS_TIMESTAMP1_NOT_EMPTY_INTERRUPT_TO_MASK_PWMS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x037FFF; \
          (tmp) |= (((UInt32)(val)) << 15); \
        } while (0)

/* masks the PWM timestamp2 not empty interrupt */
#define GP_WB_READ_INT_CTRL_MASK_PWMS_TIMESTAMP2_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5a), 0)

#define GP_WB_GET_INT_CTRL_MASK_PWMS_TIMESTAMP2_NOT_EMPTY_INTERRUPT_FROM_MASK_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PWMS_TIMESTAMP2_NOT_EMPTY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5a), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PWMS_TIMESTAMP2_NOT_EMPTY_INTERRUPT_TO_MASK_PWMS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* masks the PWM timestamp3 not empty interrupt */
#define GP_WB_READ_INT_CTRL_MASK_PWMS_TIMESTAMP3_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5a), 1)

#define GP_WB_GET_INT_CTRL_MASK_PWMS_TIMESTAMP3_NOT_EMPTY_INTERRUPT_FROM_MASK_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 17) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PWMS_TIMESTAMP3_NOT_EMPTY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5a), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PWMS_TIMESTAMP3_NOT_EMPTY_INTERRUPT_TO_MASK_PWMS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFF; \
          (tmp) |= (((UInt32)(val)) << 17); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_ADCIF_INTERRUPTS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5c))

#define GP_WB_WRITE_INT_CTRL_MASK_ADCIF_INTERRUPTS(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5c), (val))

/* masks the buffer a updated interrupt */
#define GP_WB_READ_INT_CTRL_MASK_ADCIF_BUFFER_A_UPDATED_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5c), 0)

#define GP_WB_GET_INT_CTRL_MASK_ADCIF_BUFFER_A_UPDATED_INTERRUPT_FROM_MASK_ADCIF_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_ADCIF_BUFFER_A_UPDATED_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5c), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_ADCIF_BUFFER_A_UPDATED_INTERRUPT_TO_MASK_ADCIF_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FE; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* masks the buffer b updated interrupt */
#define GP_WB_READ_INT_CTRL_MASK_ADCIF_BUFFER_B_UPDATED_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5c), 1)

#define GP_WB_GET_INT_CTRL_MASK_ADCIF_BUFFER_B_UPDATED_INTERRUPT_FROM_MASK_ADCIF_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_ADCIF_BUFFER_B_UPDATED_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5c), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_ADCIF_BUFFER_B_UPDATED_INTERRUPT_TO_MASK_ADCIF_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FD; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

/* masks the buffer c updated interrupt */
#define GP_WB_READ_INT_CTRL_MASK_ADCIF_BUFFER_C_UPDATED_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5c), 2)

#define GP_WB_GET_INT_CTRL_MASK_ADCIF_BUFFER_C_UPDATED_INTERRUPT_FROM_MASK_ADCIF_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_ADCIF_BUFFER_C_UPDATED_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5c), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_ADCIF_BUFFER_C_UPDATED_INTERRUPT_TO_MASK_ADCIF_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FB; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* masks the fifo not empty interrupt */
#define GP_WB_READ_INT_CTRL_MASK_ADCIF_FIFO_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5c), 3)

#define GP_WB_GET_INT_CTRL_MASK_ADCIF_FIFO_NOT_EMPTY_INTERRUPT_FROM_MASK_ADCIF_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_ADCIF_FIFO_NOT_EMPTY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5c), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_ADCIF_FIFO_NOT_EMPTY_INTERRUPT_TO_MASK_ADCIF_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01F7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

/* masks the fifo overrun interrupt */
#define GP_WB_READ_INT_CTRL_MASK_ADCIF_FIFO_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5c), 4)

#define GP_WB_GET_INT_CTRL_MASK_ADCIF_FIFO_OVERRUN_INTERRUPT_FROM_MASK_ADCIF_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_ADCIF_FIFO_OVERRUN_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5c), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_ADCIF_FIFO_OVERRUN_INTERRUPT_TO_MASK_ADCIF_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01EF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* masks the cycle done interrupt */
#define GP_WB_READ_INT_CTRL_MASK_ADCIF_CYCLE_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5c), 5)

#define GP_WB_GET_INT_CTRL_MASK_ADCIF_CYCLE_DONE_INTERRUPT_FROM_MASK_ADCIF_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_ADCIF_CYCLE_DONE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5c), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_ADCIF_CYCLE_DONE_INTERRUPT_TO_MASK_ADCIF_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01DF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

/* masks the fifo overvoltage interrupt */
#define GP_WB_READ_INT_CTRL_MASK_ADCIF_OVERVOLTAGE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5c), 6)

#define GP_WB_GET_INT_CTRL_MASK_ADCIF_OVERVOLTAGE_INTERRUPT_FROM_MASK_ADCIF_INTERRUPTS(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_ADCIF_OVERVOLTAGE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5c), 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_ADCIF_OVERVOLTAGE_INTERRUPT_TO_MASK_ADCIF_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01BF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

/* masks the analog watchdog value above maximum interrupt */
#define GP_WB_READ_INT_CTRL_MASK_ADCIF_AWD_ABOVE_MAXIMUM_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5c), 7)

#define GP_WB_GET_INT_CTRL_MASK_ADCIF_AWD_ABOVE_MAXIMUM_INTERRUPT_FROM_MASK_ADCIF_INTERRUPTS(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_ADCIF_AWD_ABOVE_MAXIMUM_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5c), 7, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_ADCIF_AWD_ABOVE_MAXIMUM_INTERRUPT_TO_MASK_ADCIF_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x017F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* masks the analog watchdog value below minimum interrupt */
#define GP_WB_READ_INT_CTRL_MASK_ADCIF_AWD_BELOW_MINIMUM_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5d), 0)

#define GP_WB_GET_INT_CTRL_MASK_ADCIF_AWD_BELOW_MINIMUM_INTERRUPT_FROM_MASK_ADCIF_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_ADCIF_AWD_BELOW_MINIMUM_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5d), (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_ADCIF_AWD_BELOW_MINIMUM_INTERRUPT_TO_MASK_ADCIF_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x00FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_UART_0_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5e))

#define GP_WB_WRITE_INT_CTRL_MASK_UART_0_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5e), (val))

/* masks the TX not busy interrupt. */
#define GP_WB_READ_INT_CTRL_MASK_UART_0_TX_NOT_BUSY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5e), 0)

#define GP_WB_GET_INT_CTRL_MASK_UART_0_TX_NOT_BUSY_INTERRUPT_FROM_MASK_UART_0_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_UART_0_TX_NOT_BUSY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5e), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_UART_0_TX_NOT_BUSY_INTERRUPT_TO_MASK_UART_0_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* masks the TX not full interrupt. */
#define GP_WB_READ_INT_CTRL_MASK_UART_0_TX_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5e), 1)

#define GP_WB_GET_INT_CTRL_MASK_UART_0_TX_NOT_FULL_INTERRUPT_FROM_MASK_UART_0_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_UART_0_TX_NOT_FULL_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5e), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_UART_0_TX_NOT_FULL_INTERRUPT_TO_MASK_UART_0_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* masks the RX not empty interrupt. */
#define GP_WB_READ_INT_CTRL_MASK_UART_0_RX_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5e), 2)

#define GP_WB_GET_INT_CTRL_MASK_UART_0_RX_NOT_EMPTY_INTERRUPT_FROM_MASK_UART_0_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_UART_0_RX_NOT_EMPTY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5e), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_UART_0_RX_NOT_EMPTY_INTERRUPT_TO_MASK_UART_0_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* masks the RX overrun interrupt. */
#define GP_WB_READ_INT_CTRL_MASK_UART_0_RX_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5e), 3)

#define GP_WB_GET_INT_CTRL_MASK_UART_0_RX_OVERRUN_INTERRUPT_FROM_MASK_UART_0_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_UART_0_RX_OVERRUN_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5e), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_UART_0_RX_OVERRUN_INTERRUPT_TO_MASK_UART_0_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* masks the RX parity error interrupt. */
#define GP_WB_READ_INT_CTRL_MASK_UART_0_RX_PARITY_ERROR_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5e), 4)

#define GP_WB_GET_INT_CTRL_MASK_UART_0_RX_PARITY_ERROR_INTERRUPT_FROM_MASK_UART_0_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_UART_0_RX_PARITY_ERROR_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5e), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_UART_0_RX_PARITY_ERROR_INTERRUPT_TO_MASK_UART_0_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* masks the RX framing error interrupt. */
#define GP_WB_READ_INT_CTRL_MASK_UART_0_RX_FRAMING_ERROR_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5e), 5)

#define GP_WB_GET_INT_CTRL_MASK_UART_0_RX_FRAMING_ERROR_INTERRUPT_FROM_MASK_UART_0_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_UART_0_RX_FRAMING_ERROR_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5e), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_UART_0_RX_FRAMING_ERROR_INTERRUPT_TO_MASK_UART_0_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_UART_1_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5f))

#define GP_WB_WRITE_INT_CTRL_MASK_UART_1_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5f), (val))

/* masks the TX not busy interrupt. */
#define GP_WB_READ_INT_CTRL_MASK_UART_1_TX_NOT_BUSY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5f), 0)

#define GP_WB_GET_INT_CTRL_MASK_UART_1_TX_NOT_BUSY_INTERRUPT_FROM_MASK_UART_1_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_UART_1_TX_NOT_BUSY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5f), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_UART_1_TX_NOT_BUSY_INTERRUPT_TO_MASK_UART_1_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* masks the TX not full interrupt. */
#define GP_WB_READ_INT_CTRL_MASK_UART_1_TX_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5f), 1)

#define GP_WB_GET_INT_CTRL_MASK_UART_1_TX_NOT_FULL_INTERRUPT_FROM_MASK_UART_1_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_UART_1_TX_NOT_FULL_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5f), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_UART_1_TX_NOT_FULL_INTERRUPT_TO_MASK_UART_1_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* masks the RX not empty interrupt. */
#define GP_WB_READ_INT_CTRL_MASK_UART_1_RX_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5f), 2)

#define GP_WB_GET_INT_CTRL_MASK_UART_1_RX_NOT_EMPTY_INTERRUPT_FROM_MASK_UART_1_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_UART_1_RX_NOT_EMPTY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5f), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_UART_1_RX_NOT_EMPTY_INTERRUPT_TO_MASK_UART_1_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* masks the RX overrun interrupt. */
#define GP_WB_READ_INT_CTRL_MASK_UART_1_RX_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5f), 3)

#define GP_WB_GET_INT_CTRL_MASK_UART_1_RX_OVERRUN_INTERRUPT_FROM_MASK_UART_1_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_UART_1_RX_OVERRUN_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5f), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_UART_1_RX_OVERRUN_INTERRUPT_TO_MASK_UART_1_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* masks the RX parity error interrupt. */
#define GP_WB_READ_INT_CTRL_MASK_UART_1_RX_PARITY_ERROR_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5f), 4)

#define GP_WB_GET_INT_CTRL_MASK_UART_1_RX_PARITY_ERROR_INTERRUPT_FROM_MASK_UART_1_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_UART_1_RX_PARITY_ERROR_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5f), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_UART_1_RX_PARITY_ERROR_INTERRUPT_TO_MASK_UART_1_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* masks the RX framing error interrupt. */
#define GP_WB_READ_INT_CTRL_MASK_UART_1_RX_FRAMING_ERROR_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5f), 5)

#define GP_WB_GET_INT_CTRL_MASK_UART_1_RX_FRAMING_ERROR_INTERRUPT_FROM_MASK_UART_1_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_UART_1_RX_FRAMING_ERROR_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb5f), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_UART_1_RX_FRAMING_ERROR_INTERRUPT_TO_MASK_UART_1_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_TIMERS_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb60))

#define GP_WB_WRITE_INT_CTRL_MASK_TIMERS_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb60), (val))

#define GP_WB_READ_INT_CTRL_MASK_TIMERS_TMR0_WRAP_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb60), 0)

#define GP_WB_GET_INT_CTRL_MASK_TIMERS_TMR0_WRAP_INTERRUPT_FROM_MASK_TIMERS_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TIMERS_TMR0_WRAP_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb60), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TIMERS_TMR0_WRAP_INTERRUPT_TO_MASK_TIMERS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_TIMERS_TMR1_WRAP_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb60), 1)

#define GP_WB_GET_INT_CTRL_MASK_TIMERS_TMR1_WRAP_INTERRUPT_FROM_MASK_TIMERS_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TIMERS_TMR1_WRAP_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb60), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TIMERS_TMR1_WRAP_INTERRUPT_TO_MASK_TIMERS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_TIMERS_TMR2_WRAP_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb60), 2)

#define GP_WB_GET_INT_CTRL_MASK_TIMERS_TMR2_WRAP_INTERRUPT_FROM_MASK_TIMERS_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TIMERS_TMR2_WRAP_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb60), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TIMERS_TMR2_WRAP_INTERRUPT_TO_MASK_TIMERS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_TIMERS_TMR3_WRAP_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb60), 3)

#define GP_WB_GET_INT_CTRL_MASK_TIMERS_TMR3_WRAP_INTERRUPT_FROM_MASK_TIMERS_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TIMERS_TMR3_WRAP_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb60), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TIMERS_TMR3_WRAP_INTERRUPT_TO_MASK_TIMERS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_TIMERS_TMR4_WRAP_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb60), 4)

#define GP_WB_GET_INT_CTRL_MASK_TIMERS_TMR4_WRAP_INTERRUPT_FROM_MASK_TIMERS_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_TIMERS_TMR4_WRAP_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb60), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_TIMERS_TMR4_WRAP_INTERRUPT_TO_MASK_TIMERS_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_IR_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb61))

#define GP_WB_WRITE_INT_CTRL_MASK_IR_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb61), (val))

#define GP_WB_READ_INT_CTRL_MASK_IR_SEQUENCE_START_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb61), 0)

#define GP_WB_GET_INT_CTRL_MASK_IR_SEQUENCE_START_INTERRUPT_FROM_MASK_IR_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IR_SEQUENCE_START_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb61), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IR_SEQUENCE_START_INTERRUPT_TO_MASK_IR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_IR_SEQUENCE_REPEAT_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb61), 1)

#define GP_WB_GET_INT_CTRL_MASK_IR_SEQUENCE_REPEAT_INTERRUPT_FROM_MASK_IR_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IR_SEQUENCE_REPEAT_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb61), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IR_SEQUENCE_REPEAT_INTERRUPT_TO_MASK_IR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_IR_SEQUENCE_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb61), 2)

#define GP_WB_GET_INT_CTRL_MASK_IR_SEQUENCE_DONE_INTERRUPT_FROM_MASK_IR_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IR_SEQUENCE_DONE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb61), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IR_SEQUENCE_DONE_INTERRUPT_TO_MASK_IR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_IR_INDEX_MATCH_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb61), 3)

#define GP_WB_GET_INT_CTRL_MASK_IR_INDEX_MATCH_INTERRUPT_FROM_MASK_IR_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_IR_INDEX_MATCH_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb61), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_IR_INDEX_MATCH_INTERRUPT_TO_MASK_IR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_ASP_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb62))

#define GP_WB_WRITE_INT_CTRL_MASK_ASP_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb62), (val))

#define GP_WB_READ_INT_CTRL_MASK_ASP_DATASTREAM_0_VALID_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb62), 0)

#define GP_WB_GET_INT_CTRL_MASK_ASP_DATASTREAM_0_VALID_INTERRUPT_FROM_MASK_ASP_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_ASP_DATASTREAM_0_VALID_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb62), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_ASP_DATASTREAM_0_VALID_INTERRUPT_TO_MASK_ASP_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_ASP_DATASTREAM_1_VALID_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb62), 1)

#define GP_WB_GET_INT_CTRL_MASK_ASP_DATASTREAM_1_VALID_INTERRUPT_FROM_MASK_ASP_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_ASP_DATASTREAM_1_VALID_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb62), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_ASP_DATASTREAM_1_VALID_INTERRUPT_TO_MASK_ASP_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_I2SM_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb63))

#define GP_WB_WRITE_INT_CTRL_MASK_I2SM_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb63), (val))

#define GP_WB_READ_INT_CTRL_MASK_I2SM_TX_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb63), 0)

#define GP_WB_GET_INT_CTRL_MASK_I2SM_TX_NOT_FULL_INTERRUPT_FROM_MASK_I2SM_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_I2SM_TX_NOT_FULL_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb63), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_I2SM_TX_NOT_FULL_INTERRUPT_TO_MASK_I2SM_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_I2SM_RX_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb63), 1)

#define GP_WB_GET_INT_CTRL_MASK_I2SM_RX_NOT_EMPTY_INTERRUPT_FROM_MASK_I2SM_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_I2SM_RX_NOT_EMPTY_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb63), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_I2SM_RX_NOT_EMPTY_INTERRUPT_TO_MASK_I2SM_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_BBPLL_INTERRUPTS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb64))

#define GP_WB_WRITE_INT_CTRL_MASK_BBPLL_INTERRUPTS(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb64), (val))

#define GP_WB_READ_INT_CTRL_MASK_BBPLL_COARSE_OUT_OF_RANGE_HI_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb64), 0)

#define GP_WB_GET_INT_CTRL_MASK_BBPLL_COARSE_OUT_OF_RANGE_HI_INTERRUPT_FROM_MASK_BBPLL_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_BBPLL_COARSE_OUT_OF_RANGE_HI_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb64), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_BBPLL_COARSE_OUT_OF_RANGE_HI_INTERRUPT_TO_MASK_BBPLL_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FE; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_BBPLL_COARSE_OUT_OF_RANGE_LO_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb64), 1)

#define GP_WB_GET_INT_CTRL_MASK_BBPLL_COARSE_OUT_OF_RANGE_LO_INTERRUPT_FROM_MASK_BBPLL_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_BBPLL_COARSE_OUT_OF_RANGE_LO_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb64), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_BBPLL_COARSE_OUT_OF_RANGE_LO_INTERRUPT_TO_MASK_BBPLL_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FD; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_BBPLL_TUNE_OUT_OF_RANGE_HI_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb64), 2)

#define GP_WB_GET_INT_CTRL_MASK_BBPLL_TUNE_OUT_OF_RANGE_HI_INTERRUPT_FROM_MASK_BBPLL_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_BBPLL_TUNE_OUT_OF_RANGE_HI_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb64), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_BBPLL_TUNE_OUT_OF_RANGE_HI_INTERRUPT_TO_MASK_BBPLL_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FB; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_BBPLL_TUNE_OUT_OF_RANGE_LO_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb64), 3)

#define GP_WB_GET_INT_CTRL_MASK_BBPLL_TUNE_OUT_OF_RANGE_LO_INTERRUPT_FROM_MASK_BBPLL_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_BBPLL_TUNE_OUT_OF_RANGE_LO_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb64), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_BBPLL_TUNE_OUT_OF_RANGE_LO_INTERRUPT_TO_MASK_BBPLL_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01F7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_BBPLL_FREQ_OUT_OF_RANGE_HI_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb64), 4)

#define GP_WB_GET_INT_CTRL_MASK_BBPLL_FREQ_OUT_OF_RANGE_HI_INTERRUPT_FROM_MASK_BBPLL_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_BBPLL_FREQ_OUT_OF_RANGE_HI_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb64), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_BBPLL_FREQ_OUT_OF_RANGE_HI_INTERRUPT_TO_MASK_BBPLL_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01EF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_BBPLL_FREQ_OUT_OF_RANGE_LO_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb64), 5)

#define GP_WB_GET_INT_CTRL_MASK_BBPLL_FREQ_OUT_OF_RANGE_LO_INTERRUPT_FROM_MASK_BBPLL_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_BBPLL_FREQ_OUT_OF_RANGE_LO_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb64), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_BBPLL_FREQ_OUT_OF_RANGE_LO_INTERRUPT_TO_MASK_BBPLL_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01DF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_BBPLL_FREQ_OUT_OF_RANGE_TIMEOUT_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb64), 6)

#define GP_WB_GET_INT_CTRL_MASK_BBPLL_FREQ_OUT_OF_RANGE_TIMEOUT_INTERRUPT_FROM_MASK_BBPLL_INTERRUPTS(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_BBPLL_FREQ_OUT_OF_RANGE_TIMEOUT_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb64), 6, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_BBPLL_FREQ_OUT_OF_RANGE_TIMEOUT_INTERRUPT_TO_MASK_BBPLL_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01BF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_BBPLL_IN_LOCK_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb64), 7)

#define GP_WB_GET_INT_CTRL_MASK_BBPLL_IN_LOCK_INTERRUPT_FROM_MASK_BBPLL_INTERRUPTS(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_BBPLL_IN_LOCK_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb64), 7, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_BBPLL_IN_LOCK_INTERRUPT_TO_MASK_BBPLL_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x017F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_INT_CTRL_MASK_BBPLL_OUT_OF_LOCK_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb65), 0)

#define GP_WB_GET_INT_CTRL_MASK_BBPLL_OUT_OF_LOCK_INTERRUPT_FROM_MASK_BBPLL_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_BBPLL_OUT_OF_LOCK_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb65), (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_BBPLL_OUT_OF_LOCK_INTERRUPT_TO_MASK_BBPLL_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x00FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_SECPROC_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb66))

#define GP_WB_WRITE_INT_CTRL_MASK_SECPROC_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb66), (val))

/* masks the interrupt triggered by the CryptoMaster submodule, i.e. the symmetric cryptographic operations engine */
#define GP_WB_READ_INT_CTRL_MASK_SECPROC_CRYPTO_MASTER_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb66), 0)

#define GP_WB_GET_INT_CTRL_MASK_SECPROC_CRYPTO_MASTER_INTERRUPT_FROM_MASK_SECPROC_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_SECPROC_CRYPTO_MASTER_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb66), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_SECPROC_CRYPTO_MASTER_INTERRUPT_TO_MASK_SECPROC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* masks the interrupt triggered by the NDRNG submodule, i.e. the Non-Deterministic Random Number Generator */
#define GP_WB_READ_INT_CTRL_MASK_SECPROC_TRNG_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb66), 1)

#define GP_WB_GET_INT_CTRL_MASK_SECPROC_TRNG_INTERRUPT_FROM_MASK_SECPROC_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_SECPROC_TRNG_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb66), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_SECPROC_TRNG_INTERRUPT_TO_MASK_SECPROC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* masks the interrupt triggered by the Public Key submodule, i.e. the asymmetric cryptographic operations engine */
#define GP_WB_READ_INT_CTRL_MASK_SECPROC_PKE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb66), 2)

#define GP_WB_GET_INT_CTRL_MASK_SECPROC_PKE_INTERRUPT_FROM_MASK_SECPROC_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_SECPROC_PKE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb66), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_SECPROC_PKE_INTERRUPT_TO_MASK_SECPROC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* masks the interrupt triggered when the internal DMA runs into a memory bus error */
#define GP_WB_READ_INT_CTRL_MASK_SECPROC_ERR_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb66), 3)

#define GP_WB_GET_INT_CTRL_MASK_SECPROC_ERR_INTERRUPT_FROM_MASK_SECPROC_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_SECPROC_ERR_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb66), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_SECPROC_ERR_INTERRUPT_TO_MASK_SECPROC_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASK_SINGLE_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb67))

#define GP_WB_WRITE_INT_CTRL_MASK_SINGLE_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb67), (val))

/* masks the triggering an interrupt when n bytes were received */
#define GP_WB_READ_INT_CTRL_MASK_PARFCS_LEVEL_TRIGGER_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb67), 0)

#define GP_WB_GET_INT_CTRL_MASK_PARFCS_LEVEL_TRIGGER_INTERRUPT_FROM_MASK_SINGLE_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_PARFCS_LEVEL_TRIGGER_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb67), 0, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_PARFCS_LEVEL_TRIGGER_INTERRUPT_TO_MASK_SINGLE_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* masks the mri write interrupt */
#define GP_WB_READ_INT_CTRL_MASK_MRI_ACCESS_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb67), 1)

#define GP_WB_GET_INT_CTRL_MASK_MRI_ACCESS_DONE_INTERRUPT_FROM_MASK_SINGLE_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_MRI_ACCESS_DONE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb67), 1, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_MRI_ACCESS_DONE_INTERRUPT_TO_MASK_SINGLE_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* masks the mem exception of gpmicro interrupt. */
#define GP_WB_READ_INT_CTRL_MASK_GPMICRO_MEM_EXCEPTION_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb67), 2)

#define GP_WB_GET_INT_CTRL_MASK_GPMICRO_MEM_EXCEPTION_INTERRUPT_FROM_MASK_SINGLE_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_GPMICRO_MEM_EXCEPTION_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb67), 2, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_GPMICRO_MEM_EXCEPTION_INTERRUPT_TO_MASK_SINGLE_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* masks the watchdog timer expired interrupt */
#define GP_WB_READ_INT_CTRL_MASK_WATCHDOG_TIMER_EXPIRED_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb67), 3)

#define GP_WB_GET_INT_CTRL_MASK_WATCHDOG_TIMER_EXPIRED_INTERRUPT_FROM_MASK_SINGLE_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_WATCHDOG_TIMER_EXPIRED_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb67), 3, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_WATCHDOG_TIMER_EXPIRED_INTERRUPT_TO_MASK_SINGLE_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x77; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* masks the ssp done interrupt */
#define GP_WB_READ_INT_CTRL_MASK_SSP_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb67), 4)

#define GP_WB_GET_INT_CTRL_MASK_SSP_DONE_INTERRUPT_FROM_MASK_SINGLE_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_SSP_DONE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb67), 4, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_SSP_DONE_INTERRUPT_TO_MASK_SINGLE_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x6F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* masks the rpa done interrupt */
#define GP_WB_READ_INT_CTRL_MASK_RPA_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb67), 5)

#define GP_WB_GET_INT_CTRL_MASK_RPA_DONE_INTERRUPT_FROM_MASK_SINGLE_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INT_CTRL_MASK_RPA_DONE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb67), 5, (val)); \
        } while (0)

#define GP_WB_SET_INT_CTRL_MASK_RPA_DONE_INTERRUPT_TO_MASK_SINGLE_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x5F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_GPM_ES_INTERRUPTS() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb68))

/* masked Event Interrupts */
#define GP_WB_READ_INT_CTRL_MASKED_GPM_ES_EVENT_INTERRUPTS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb68))

#define GP_WB_GET_INT_CTRL_MASKED_GPM_ES_EVENT_INTERRUPTS_FROM_MASKED_GPM_ES_INTERRUPTS(tmp) \
        ((tmp) & 0xFFFF)

/* masked Comparator Event interrupts */
#define GP_WB_READ_INT_CTRL_MASKED_GPM_ES_COMP_EVENT_INTERRUPTS() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb6a)) & 0x0F)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_ES_COMP_EVENT_INTERRUPTS_FROM_MASKED_GPM_ES_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0x0F)

/* masked es symbol counter interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_GPM_ES_SYMBOL_COUNTER_VALID_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb6a), 5)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_ES_SYMBOL_COUNTER_VALID_INTERRUPT_FROM_MASKED_GPM_ES_INTERRUPTS(tmp) \
        (((tmp) >> 21) & 0x01)

/* masked es oscillator benchmark interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_GPM_ES_OSCILLATOR_BENCHMARK_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb6a), 6)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_ES_OSCILLATOR_BENCHMARK_DONE_INTERRUPT_FROM_MASKED_GPM_ES_INTERRUPTS(tmp) \
        (((tmp) >> 22) & 0x01)

/* masked es oscillator benchmark sub measurement done interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_GPM_ES_OSCILLATOR_BENCHMARK_SUB_MEAS_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb6a), 7)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_ES_OSCILLATOR_BENCHMARK_SUB_MEAS_DONE_INTERRUPT_FROM_MASKED_GPM_ES_INTERRUPTS(tmp) \
        (((tmp) >> 23) & 0x01)

/* masked es Relative Event Interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_GPM_ES_RELATIVE_EVENT_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb6b), 0)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_ES_RELATIVE_EVENT_INTERRUPT_FROM_MASKED_GPM_ES_INTERRUPTS(tmp) \
        (((tmp) >> 24) & 0x01)

/* masked External Event Interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_GPM_ES_EXTERNAL_EVENT_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb6b), 1)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_ES_EXTERNAL_EVENT_INTERRUPT_FROM_MASKED_GPM_ES_INTERRUPTS(tmp) \
        (((tmp) >> 25) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_GPM_PHY_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb6c))

/* masked interrupt for the fll rx out of range event */
#define GP_WB_READ_INT_CTRL_MASKED_GPM_PHY_FLL_RX_OUT_OF_RANGE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb6c), 0)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_PHY_FLL_RX_OUT_OF_RANGE_INTERRUPT_FROM_MASKED_GPM_PHY_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* masked interrupt for the fll tx out of range event */
#define GP_WB_READ_INT_CTRL_MASKED_GPM_PHY_FLL_TX_OUT_OF_RANGE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb6c), 1)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_PHY_FLL_TX_OUT_OF_RANGE_INTERRUPT_FROM_MASKED_GPM_PHY_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* masked interrupt for the fll tx_out of lock event */
#define GP_WB_READ_INT_CTRL_MASKED_GPM_PHY_FLL_TX_OUT_OF_LOCK_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb6c), 2)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_PHY_FLL_TX_OUT_OF_LOCK_INTERRUPT_FROM_MASKED_GPM_PHY_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* masked interrupt for the fll fp out of range event */
#define GP_WB_READ_INT_CTRL_MASKED_GPM_PHY_FLL_FE_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb6c), 3)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_PHY_FLL_FE_DONE_INTERRUPT_FROM_MASKED_GPM_PHY_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

/* masked interrupt for the fll fp out of range event */
#define GP_WB_READ_INT_CTRL_MASKED_GPM_PHY_FLL_CAL_START_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb6c), 4)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_PHY_FLL_CAL_START_INTERRUPT_FROM_MASKED_GPM_PHY_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

/* masked interrupt for rx_mode changes */
#define GP_WB_READ_INT_CTRL_MASKED_GPM_PHY_RX_MODE_CHANGE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb6c), 5)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_PHY_RX_MODE_CHANGE_INTERRUPT_FROM_MASKED_GPM_PHY_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_GPM_TRC_INTERRUPTS() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb70))

#define GP_WB_READ_INT_CTRL_MASKED_GPM_TRC_PBM_FULL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb70), 0)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_TRC_PBM_FULL_INTERRUPT_FROM_MASKED_GPM_TRC_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_GPM_TRC_TX_STARTED_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb70), 1)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_TRC_TX_STARTED_INTERRUPT_FROM_MASKED_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_GPM_TRC_TX_ACK_STARTED_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb70), 2)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_TRC_TX_ACK_STARTED_INTERRUPT_FROM_MASKED_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_GPM_TRC_PHY_TRANSITION_NOT_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb70), 3)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_TRC_PHY_TRANSITION_NOT_DONE_INTERRUPT_FROM_MASKED_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_GPM_TRC_TX_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb70), 4)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_TRC_TX_DONE_INTERRUPT_FROM_MASKED_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_GPM_TRC_MSG_REQ_WHILE_BUSY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb70), 5)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_TRC_MSG_REQ_WHILE_BUSY_INTERRUPT_FROM_MASKED_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_GPM_TRC_CAL_DONE_INTERRUPTS() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb71)) & 0x3F)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_TRC_CAL_DONE_INTERRUPTS_FROM_MASKED_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x3F)

#define GP_WB_READ_INT_CTRL_MASKED_GPM_TRC_CAL_DONE_CH0_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb71), 0)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_TRC_CAL_DONE_CH0_INTERRUPT_FROM_MASKED_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_GPM_TRC_CAL_DONE_CH1_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb71), 1)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_TRC_CAL_DONE_CH1_INTERRUPT_FROM_MASKED_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_GPM_TRC_CAL_DONE_CH2_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb71), 2)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_TRC_CAL_DONE_CH2_INTERRUPT_FROM_MASKED_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_GPM_TRC_CAL_DONE_CH3_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb71), 3)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_TRC_CAL_DONE_CH3_INTERRUPT_FROM_MASKED_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_GPM_TRC_CAL_DONE_CH4_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb71), 4)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_TRC_CAL_DONE_CH4_INTERRUPT_FROM_MASKED_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_GPM_TRC_CAL_DONE_CH5_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb71), 5)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_TRC_CAL_DONE_CH5_INTERRUPT_FROM_MASKED_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_GPM_TRC_RX_WINDOW_DONE_INTERRUPTS() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb72)) & 0x3F)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_TRC_RX_WINDOW_DONE_INTERRUPTS_FROM_MASKED_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0x3F)

#define GP_WB_READ_INT_CTRL_MASKED_GPM_TRC_RX_WINDOW_DONE_CH0_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb72), 0)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_TRC_RX_WINDOW_DONE_CH0_INTERRUPT_FROM_MASKED_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_GPM_TRC_RX_WINDOW_DONE_CH1_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb72), 1)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_TRC_RX_WINDOW_DONE_CH1_INTERRUPT_FROM_MASKED_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 17) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_GPM_TRC_RX_WINDOW_DONE_CH2_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb72), 2)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_TRC_RX_WINDOW_DONE_CH2_INTERRUPT_FROM_MASKED_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 18) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_GPM_TRC_RX_WINDOW_DONE_CH3_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb72), 3)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_TRC_RX_WINDOW_DONE_CH3_INTERRUPT_FROM_MASKED_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 19) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_GPM_TRC_RX_WINDOW_DONE_CH4_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb72), 4)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_TRC_RX_WINDOW_DONE_CH4_INTERRUPT_FROM_MASKED_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 20) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_GPM_TRC_RX_WINDOW_DONE_CH5_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb72), 5)

#define GP_WB_GET_INT_CTRL_MASKED_GPM_TRC_RX_WINDOW_DONE_CH5_INTERRUPT_FROM_MASKED_GPM_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 21) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_ES_INTERRUPTS() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb74))

/* masked Event Interrupts */
#define GP_WB_READ_INT_CTRL_MASKED_ES_EVENT_INTERRUPTS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb74))

#define GP_WB_GET_INT_CTRL_MASKED_ES_EVENT_INTERRUPTS_FROM_MASKED_ES_INTERRUPTS(tmp) \
        ((tmp) & 0xFFFF)

/* masked Comparator Event interrupts */
#define GP_WB_READ_INT_CTRL_MASKED_ES_COMP_EVENT_INTERRUPTS() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb76)) & 0x0F)

#define GP_WB_GET_INT_CTRL_MASKED_ES_COMP_EVENT_INTERRUPTS_FROM_MASKED_ES_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0x0F)

/* masked es symbol counter interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_ES_SYMBOL_COUNTER_VALID_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb76), 5)

#define GP_WB_GET_INT_CTRL_MASKED_ES_SYMBOL_COUNTER_VALID_INTERRUPT_FROM_MASKED_ES_INTERRUPTS(tmp) \
        (((tmp) >> 21) & 0x01)

/* masked es oscillator benchmark interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_ES_OSCILLATOR_BENCHMARK_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb76), 6)

#define GP_WB_GET_INT_CTRL_MASKED_ES_OSCILLATOR_BENCHMARK_DONE_INTERRUPT_FROM_MASKED_ES_INTERRUPTS(tmp) \
        (((tmp) >> 22) & 0x01)

/* masked es oscillator benchmark sub meas done interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_ES_OSCILLATOR_BENCHMARK_SUB_MEAS_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb76), 7)

#define GP_WB_GET_INT_CTRL_MASKED_ES_OSCILLATOR_BENCHMARK_SUB_MEAS_DONE_INTERRUPT_FROM_MASKED_ES_INTERRUPTS(tmp) \
        (((tmp) >> 23) & 0x01)

/* masked es Relative Event Interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_ES_RELATIVE_EVENT_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb77), 0)

#define GP_WB_GET_INT_CTRL_MASKED_ES_RELATIVE_EVENT_INTERRUPT_FROM_MASKED_ES_INTERRUPTS(tmp) \
        (((tmp) >> 24) & 0x01)

/* masked External Event Interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_ES_EXTERNAL_EVENT_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb77), 1)

#define GP_WB_GET_INT_CTRL_MASKED_ES_EXTERNAL_EVENT_INTERRUPT_FROM_MASKED_ES_INTERRUPTS(tmp) \
        (((tmp) >> 25) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_DMAS_INTERRUPTS() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb78))

#define GP_WB_READ_INT_CTRL_MASKED_DMAS_BUFFER_ALMOST_COMPLETE_0_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb78), 0)

#define GP_WB_GET_INT_CTRL_MASKED_DMAS_BUFFER_ALMOST_COMPLETE_0_INTERRUPT_FROM_MASKED_DMAS_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_DMAS_BUFFER_ALMOST_COMPLETE_1_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb78), 1)

#define GP_WB_GET_INT_CTRL_MASKED_DMAS_BUFFER_ALMOST_COMPLETE_1_INTERRUPT_FROM_MASKED_DMAS_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_DMAS_BUFFER_ALMOST_COMPLETE_2_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb78), 2)

#define GP_WB_GET_INT_CTRL_MASKED_DMAS_BUFFER_ALMOST_COMPLETE_2_INTERRUPT_FROM_MASKED_DMAS_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_DMAS_BUFFER_ALMOST_COMPLETE_3_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb78), 3)

#define GP_WB_GET_INT_CTRL_MASKED_DMAS_BUFFER_ALMOST_COMPLETE_3_INTERRUPT_FROM_MASKED_DMAS_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_DMAS_BUFFER_ALMOST_COMPLETE_4_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb78), 4)

#define GP_WB_GET_INT_CTRL_MASKED_DMAS_BUFFER_ALMOST_COMPLETE_4_INTERRUPT_FROM_MASKED_DMAS_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_DMAS_BUFFER_ALMOST_COMPLETE_5_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb78), 5)

#define GP_WB_GET_INT_CTRL_MASKED_DMAS_BUFFER_ALMOST_COMPLETE_5_INTERRUPT_FROM_MASKED_DMAS_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_DMAS_BUFFER_ALMOST_COMPLETE_6_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb78), 6)

#define GP_WB_GET_INT_CTRL_MASKED_DMAS_BUFFER_ALMOST_COMPLETE_6_INTERRUPT_FROM_MASKED_DMAS_INTERRUPTS(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_DMAS_BUFFER_ALMOST_COMPLETE_7_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb78), 7)

#define GP_WB_GET_INT_CTRL_MASKED_DMAS_BUFFER_ALMOST_COMPLETE_7_INTERRUPT_FROM_MASKED_DMAS_INTERRUPTS(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_DMAS_BUFFER_COMPLETE_0_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb79), 0)

#define GP_WB_GET_INT_CTRL_MASKED_DMAS_BUFFER_COMPLETE_0_INTERRUPT_FROM_MASKED_DMAS_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_DMAS_BUFFER_COMPLETE_1_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb79), 1)

#define GP_WB_GET_INT_CTRL_MASKED_DMAS_BUFFER_COMPLETE_1_INTERRUPT_FROM_MASKED_DMAS_INTERRUPTS(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_DMAS_BUFFER_COMPLETE_2_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb79), 2)

#define GP_WB_GET_INT_CTRL_MASKED_DMAS_BUFFER_COMPLETE_2_INTERRUPT_FROM_MASKED_DMAS_INTERRUPTS(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_DMAS_BUFFER_COMPLETE_3_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb79), 3)

#define GP_WB_GET_INT_CTRL_MASKED_DMAS_BUFFER_COMPLETE_3_INTERRUPT_FROM_MASKED_DMAS_INTERRUPTS(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_DMAS_BUFFER_COMPLETE_4_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb79), 4)

#define GP_WB_GET_INT_CTRL_MASKED_DMAS_BUFFER_COMPLETE_4_INTERRUPT_FROM_MASKED_DMAS_INTERRUPTS(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_DMAS_BUFFER_COMPLETE_5_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb79), 5)

#define GP_WB_GET_INT_CTRL_MASKED_DMAS_BUFFER_COMPLETE_5_INTERRUPT_FROM_MASKED_DMAS_INTERRUPTS(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_DMAS_BUFFER_COMPLETE_6_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb79), 6)

#define GP_WB_GET_INT_CTRL_MASKED_DMAS_BUFFER_COMPLETE_6_INTERRUPT_FROM_MASKED_DMAS_INTERRUPTS(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_DMAS_BUFFER_COMPLETE_7_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb79), 7)

#define GP_WB_GET_INT_CTRL_MASKED_DMAS_BUFFER_COMPLETE_7_INTERRUPT_FROM_MASKED_DMAS_INTERRUPTS(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_DMAS_CPY_ERR_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb7a), 0)

#define GP_WB_GET_INT_CTRL_MASKED_DMAS_CPY_ERR_INTERRUPT_FROM_MASKED_DMAS_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_QTA_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb7b))

#define GP_WB_READ_INT_CTRL_MASKED_QTA_SCH0_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb7b), 0)

#define GP_WB_GET_INT_CTRL_MASKED_QTA_SCH0_EMPTY_INTERRUPT_FROM_MASKED_QTA_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_QTA_SCH1_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb7b), 1)

#define GP_WB_GET_INT_CTRL_MASKED_QTA_SCH1_EMPTY_INTERRUPT_FROM_MASKED_QTA_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_QTA_SCH2_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb7b), 2)

#define GP_WB_GET_INT_CTRL_MASKED_QTA_SCH2_EMPTY_INTERRUPT_FROM_MASKED_QTA_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_QTA_SCH3_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb7b), 3)

#define GP_WB_GET_INT_CTRL_MASKED_QTA_SCH3_EMPTY_INTERRUPT_FROM_MASKED_QTA_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_QTA_QUEUE_FULL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb7b), 4)

#define GP_WB_GET_INT_CTRL_MASKED_QTA_QUEUE_FULL_INTERRUPT_FROM_MASKED_QTA_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_TRC_INTERRUPTS() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb7c))

#define GP_WB_READ_INT_CTRL_MASKED_TRC_PBM_FULL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb7c), 0)

#define GP_WB_GET_INT_CTRL_MASKED_TRC_PBM_FULL_INTERRUPT_FROM_MASKED_TRC_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_TRC_TX_STARTED_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb7c), 1)

#define GP_WB_GET_INT_CTRL_MASKED_TRC_TX_STARTED_INTERRUPT_FROM_MASKED_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_TRC_TX_ACK_STARTED_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb7c), 2)

#define GP_WB_GET_INT_CTRL_MASKED_TRC_TX_ACK_STARTED_INTERRUPT_FROM_MASKED_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_TRC_PHY_TRANSITION_NOT_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb7c), 3)

#define GP_WB_GET_INT_CTRL_MASKED_TRC_PHY_TRANSITION_NOT_DONE_INTERRUPT_FROM_MASKED_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_TRC_TX_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb7c), 4)

#define GP_WB_GET_INT_CTRL_MASKED_TRC_TX_DONE_INTERRUPT_FROM_MASKED_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_TRC_MSG_REQ_WHILE_BUSY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb7c), 5)

#define GP_WB_GET_INT_CTRL_MASKED_TRC_MSG_REQ_WHILE_BUSY_INTERRUPT_FROM_MASKED_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_TRC_CAL_DONE_INTERRUPTS() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb7d)) & 0x3F)

#define GP_WB_GET_INT_CTRL_MASKED_TRC_CAL_DONE_INTERRUPTS_FROM_MASKED_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x3F)

#define GP_WB_READ_INT_CTRL_MASKED_TRC_CAL_DONE_CH0_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb7d), 0)

#define GP_WB_GET_INT_CTRL_MASKED_TRC_CAL_DONE_CH0_INTERRUPT_FROM_MASKED_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_TRC_CAL_DONE_CH1_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb7d), 1)

#define GP_WB_GET_INT_CTRL_MASKED_TRC_CAL_DONE_CH1_INTERRUPT_FROM_MASKED_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_TRC_CAL_DONE_CH2_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb7d), 2)

#define GP_WB_GET_INT_CTRL_MASKED_TRC_CAL_DONE_CH2_INTERRUPT_FROM_MASKED_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_TRC_CAL_DONE_CH3_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb7d), 3)

#define GP_WB_GET_INT_CTRL_MASKED_TRC_CAL_DONE_CH3_INTERRUPT_FROM_MASKED_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_TRC_CAL_DONE_CH4_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb7d), 4)

#define GP_WB_GET_INT_CTRL_MASKED_TRC_CAL_DONE_CH4_INTERRUPT_FROM_MASKED_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_TRC_CAL_DONE_CH5_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb7d), 5)

#define GP_WB_GET_INT_CTRL_MASKED_TRC_CAL_DONE_CH5_INTERRUPT_FROM_MASKED_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_TRC_RX_WINDOW_DONE_INTERRUPTS() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb7e)) & 0x3F)

#define GP_WB_GET_INT_CTRL_MASKED_TRC_RX_WINDOW_DONE_INTERRUPTS_FROM_MASKED_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0x3F)

#define GP_WB_READ_INT_CTRL_MASKED_TRC_RX_WINDOW_DONE_CH0_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb7e), 0)

#define GP_WB_GET_INT_CTRL_MASKED_TRC_RX_WINDOW_DONE_CH0_INTERRUPT_FROM_MASKED_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_TRC_RX_WINDOW_DONE_CH1_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb7e), 1)

#define GP_WB_GET_INT_CTRL_MASKED_TRC_RX_WINDOW_DONE_CH1_INTERRUPT_FROM_MASKED_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 17) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_TRC_RX_WINDOW_DONE_CH2_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb7e), 2)

#define GP_WB_GET_INT_CTRL_MASKED_TRC_RX_WINDOW_DONE_CH2_INTERRUPT_FROM_MASKED_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 18) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_TRC_RX_WINDOW_DONE_CH3_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb7e), 3)

#define GP_WB_GET_INT_CTRL_MASKED_TRC_RX_WINDOW_DONE_CH3_INTERRUPT_FROM_MASKED_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 19) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_TRC_RX_WINDOW_DONE_CH4_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb7e), 4)

#define GP_WB_GET_INT_CTRL_MASKED_TRC_RX_WINDOW_DONE_CH4_INTERRUPT_FROM_MASKED_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 20) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_TRC_RX_WINDOW_DONE_CH5_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb7e), 5)

#define GP_WB_GET_INT_CTRL_MASKED_TRC_RX_WINDOW_DONE_CH5_INTERRUPT_FROM_MASKED_TRC_INTERRUPTS(tmp) \
        (((tmp) >> 21) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_PARBLE_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb7f))

/* triggering an interrupt when n bytes were received */
#define GP_WB_READ_INT_CTRL_MASKED_PARBLE_LEVEL_TRIGGER_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb7f), 0)

#define GP_WB_GET_INT_CTRL_MASKED_PARBLE_LEVEL_TRIGGER_INTERRUPT_FROM_MASKED_PARBLE_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_PARBLE_PACKET_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb7f), 1)

#define GP_WB_GET_INT_CTRL_MASKED_PARBLE_PACKET_DONE_INTERRUPT_FROM_MASKED_PARBLE_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_STBC_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb80))

/* masked standby controller event power on reset detected interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_STBC_PORD_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb80), 0)

#define GP_WB_GET_INT_CTRL_MASKED_STBC_PORD_INTERRUPT_FROM_MASKED_STBC_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* masked standby controller Active state interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_STBC_ACTIVE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb80), 1)

#define GP_WB_GET_INT_CTRL_MASKED_STBC_ACTIVE_INTERRUPT_FROM_MASKED_STBC_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* masked standby controller vlt_status interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_STBC_VLT_STATUS_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb80), 2)

#define GP_WB_GET_INT_CTRL_MASKED_STBC_VLT_STATUS_INTERRUPT_FROM_MASKED_STBC_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_I2CM_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb81))

/* masked I2C master done interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_I2CM_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb81), 0)

#define GP_WB_GET_INT_CTRL_MASKED_I2CM_DONE_INTERRUPT_FROM_MASKED_I2CM_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* masked I2C master arbitration lost interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_I2CM_ARB_LOST_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb81), 1)

#define GP_WB_GET_INT_CTRL_MASKED_I2CM_ARB_LOST_INTERRUPT_FROM_MASKED_I2CM_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* masked I2C master clock synchronization slave wait interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_I2CM_CLK_SYNC_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb81), 2)

#define GP_WB_GET_INT_CTRL_MASKED_I2CM_CLK_SYNC_INTERRUPT_FROM_MASKED_I2CM_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_RCI_INTERRUPTS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb82))

#define GP_WB_READ_INT_CTRL_MASKED_RCI_DATA_IND_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb82), 0)

#define GP_WB_GET_INT_CTRL_MASKED_RCI_DATA_IND_INTERRUPT_FROM_MASKED_RCI_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_RCI_DATA_CNF_0_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb82), 1)

#define GP_WB_GET_INT_CTRL_MASKED_RCI_DATA_CNF_0_INTERRUPT_FROM_MASKED_RCI_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_RCI_DATA_CNF_INTERRUPTS() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb82)) >> 1) & 0x0F)

#define GP_WB_GET_INT_CTRL_MASKED_RCI_DATA_CNF_INTERRUPTS_FROM_MASKED_RCI_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x0F)

#define GP_WB_READ_INT_CTRL_MASKED_RCI_DATA_CNF_1_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb82), 2)

#define GP_WB_GET_INT_CTRL_MASKED_RCI_DATA_CNF_1_INTERRUPT_FROM_MASKED_RCI_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_RCI_DATA_CNF_2_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb82), 3)

#define GP_WB_GET_INT_CTRL_MASKED_RCI_DATA_CNF_2_INTERRUPT_FROM_MASKED_RCI_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_RCI_DATA_CNF_3_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb82), 4)

#define GP_WB_GET_INT_CTRL_MASKED_RCI_DATA_CNF_3_INTERRUPT_FROM_MASKED_RCI_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_RCI_BLE_DATA_IND_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb82), 5)

#define GP_WB_GET_INT_CTRL_MASKED_RCI_BLE_DATA_IND_INTERRUPT_FROM_MASKED_RCI_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_RCI_BLE_ADV_IND_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb82), 6)

#define GP_WB_GET_INT_CTRL_MASKED_RCI_BLE_ADV_IND_INTERRUPT_FROM_MASKED_RCI_INTERRUPTS(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_RCI_BLE_CONN_REQ_IND_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb82), 7)

#define GP_WB_GET_INT_CTRL_MASKED_RCI_BLE_CONN_REQ_IND_INTERRUPT_FROM_MASKED_RCI_INTERRUPTS(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_RCI_BLE_CONN_RSP_IND_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb83), 0)

#define GP_WB_GET_INT_CTRL_MASKED_RCI_BLE_CONN_RSP_IND_INTERRUPT_FROM_MASKED_RCI_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_RCI_BLE_DATA_CNF_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb83), 1)

#define GP_WB_GET_INT_CTRL_MASKED_RCI_BLE_DATA_CNF_INTERRUPT_FROM_MASKED_RCI_INTERRUPTS(tmp) \
        (((tmp) >> 9) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_PHY_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb84))

/* masked interrupt for the fll rx out of range event */
#define GP_WB_READ_INT_CTRL_MASKED_PHY_FLL_RX_OUT_OF_RANGE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb84), 0)

#define GP_WB_GET_INT_CTRL_MASKED_PHY_FLL_RX_OUT_OF_RANGE_INTERRUPT_FROM_MASKED_PHY_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* masked interrupt for the fll tx out of range event */
#define GP_WB_READ_INT_CTRL_MASKED_PHY_FLL_TX_OUT_OF_RANGE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb84), 1)

#define GP_WB_GET_INT_CTRL_MASKED_PHY_FLL_TX_OUT_OF_RANGE_INTERRUPT_FROM_MASKED_PHY_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* masked interrupt for the fll tx_out of lock event */
#define GP_WB_READ_INT_CTRL_MASKED_PHY_FLL_TX_OUT_OF_LOCK_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb84), 2)

#define GP_WB_GET_INT_CTRL_MASKED_PHY_FLL_TX_OUT_OF_LOCK_INTERRUPT_FROM_MASKED_PHY_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* masked interrupt for the fll fp out of range event */
#define GP_WB_READ_INT_CTRL_MASKED_PHY_FLL_FE_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb84), 3)

#define GP_WB_GET_INT_CTRL_MASKED_PHY_FLL_FE_DONE_INTERRUPT_FROM_MASKED_PHY_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

/* masked interrupt for the fll fp out of range event */
#define GP_WB_READ_INT_CTRL_MASKED_PHY_FLL_CAL_START_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb84), 4)

#define GP_WB_GET_INT_CTRL_MASKED_PHY_FLL_CAL_START_INTERRUPT_FROM_MASKED_PHY_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

/* masked interrupt for rx_mode changes */
#define GP_WB_READ_INT_CTRL_MASKED_PHY_RX_MODE_CHANGE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb84), 5)

#define GP_WB_GET_INT_CTRL_MASKED_PHY_RX_MODE_CHANGE_INTERRUPT_FROM_MASKED_PHY_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_GPIO_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb85))

/* masked gpio interrupts for exti 0 of the selected port */
#define GP_WB_READ_INT_CTRL_MASKED_GPIO_EXTI0_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb85), 0)

#define GP_WB_GET_INT_CTRL_MASKED_GPIO_EXTI0_INTERRUPT_FROM_MASKED_GPIO_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* masked gpio interrupts for exti 1 of the selected port */
#define GP_WB_READ_INT_CTRL_MASKED_GPIO_EXTI1_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb85), 1)

#define GP_WB_GET_INT_CTRL_MASKED_GPIO_EXTI1_INTERRUPT_FROM_MASKED_GPIO_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* masked gpio interrupts for exti 2 of the selected port */
#define GP_WB_READ_INT_CTRL_MASKED_GPIO_EXTI2_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb85), 2)

#define GP_WB_GET_INT_CTRL_MASKED_GPIO_EXTI2_INTERRUPT_FROM_MASKED_GPIO_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* masked gpio interrupts for exti 3 of the selected port */
#define GP_WB_READ_INT_CTRL_MASKED_GPIO_EXTI3_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb85), 3)

#define GP_WB_GET_INT_CTRL_MASKED_GPIO_EXTI3_INTERRUPT_FROM_MASKED_GPIO_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

/* masked gpio interrupts for exti 4 of the selected port */
#define GP_WB_READ_INT_CTRL_MASKED_GPIO_EXTI4_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb85), 4)

#define GP_WB_GET_INT_CTRL_MASKED_GPIO_EXTI4_INTERRUPT_FROM_MASKED_GPIO_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

/* masked gpio interrupts for exti 5 of the selected port */
#define GP_WB_READ_INT_CTRL_MASKED_GPIO_EXTI5_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb85), 5)

#define GP_WB_GET_INT_CTRL_MASKED_GPIO_EXTI5_INTERRUPT_FROM_MASKED_GPIO_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

/* masked gpio interrupts for exti 6 of the selected port */
#define GP_WB_READ_INT_CTRL_MASKED_GPIO_EXTI6_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb85), 6)

#define GP_WB_GET_INT_CTRL_MASKED_GPIO_EXTI6_INTERRUPT_FROM_MASKED_GPIO_INTERRUPTS(tmp) \
        (((tmp) >> 6) & 0x01)

/* masked gpio interrupts for exti 7 of the selected port */
#define GP_WB_READ_INT_CTRL_MASKED_GPIO_EXTI7_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb85), 7)

#define GP_WB_GET_INT_CTRL_MASKED_GPIO_EXTI7_INTERRUPT_FROM_MASKED_GPIO_INTERRUPTS(tmp) \
        (((tmp) >> 7) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_SPIM_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb86))

/* masked SPI master transfer not busy interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_SPIM_NOT_BUSY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb86), 0)

#define GP_WB_GET_INT_CTRL_MASKED_SPIM_NOT_BUSY_INTERRUPT_FROM_MASKED_SPIM_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* masked SPI master TX buffer empty interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_SPIM_TX_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb86), 1)

#define GP_WB_GET_INT_CTRL_MASKED_SPIM_TX_NOT_FULL_INTERRUPT_FROM_MASKED_SPIM_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* masked SPI master RX buffer not empty interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_SPIM_RX_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb86), 2)

#define GP_WB_GET_INT_CTRL_MASKED_SPIM_RX_NOT_EMPTY_INTERRUPT_FROM_MASKED_SPIM_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* masked SPI master RX buffer overrun interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_SPIM_RX_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb86), 3)

#define GP_WB_GET_INT_CTRL_MASKED_SPIM_RX_OVERRUN_INTERRUPT_FROM_MASKED_SPIM_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_SPISL_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb87))

/* masked SPI slave TX buffer empty interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_SPISL_TX_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb87), 0)

#define GP_WB_GET_INT_CTRL_MASKED_SPISL_TX_NOT_FULL_INTERRUPT_FROM_MASKED_SPISL_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* masked SPI slave RX buffer not empty interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_SPISL_RX_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb87), 1)

#define GP_WB_GET_INT_CTRL_MASKED_SPISL_RX_NOT_EMPTY_INTERRUPT_FROM_MASKED_SPISL_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* masked SPI slave TX buffer underrun interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_SPISL_TX_UNDERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb87), 2)

#define GP_WB_GET_INT_CTRL_MASKED_SPISL_TX_UNDERRUN_INTERRUPT_FROM_MASKED_SPISL_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* masked SPI slave RX buffer overrun interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_SPISL_RX_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb87), 3)

#define GP_WB_GET_INT_CTRL_MASKED_SPISL_RX_OVERRUN_INTERRUPT_FROM_MASKED_SPISL_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

/* masked SPI slave TX empty interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_SPISL_TX_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb87), 4)

#define GP_WB_GET_INT_CTRL_MASKED_SPISL_TX_EMPTY_INTERRUPT_FROM_MASKED_SPISL_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_IPCGPM2X_INTERRUPTS() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb88))

/* masked inter processor communication source interrupt (gpm 2 ...) */
#define GP_WB_READ_INT_CTRL_MASKED_IPCGPM2X_FLAG_A_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb88), 0)

#define GP_WB_GET_INT_CTRL_MASKED_IPCGPM2X_FLAG_A_INTERRUPT_FROM_MASKED_IPCGPM2X_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* masked inter processor communication source interrupt (gpm 2 ...) */
#define GP_WB_READ_INT_CTRL_MASKED_IPCGPM2X_FLAG_B_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb88), 1)

#define GP_WB_GET_INT_CTRL_MASKED_IPCGPM2X_FLAG_B_INTERRUPT_FROM_MASKED_IPCGPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* masked inter processor communication source interrupt (gpm 2 ...) */
#define GP_WB_READ_INT_CTRL_MASKED_IPCGPM2X_FLAG_C_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb88), 2)

#define GP_WB_GET_INT_CTRL_MASKED_IPCGPM2X_FLAG_C_INTERRUPT_FROM_MASKED_IPCGPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* masked inter processor communication source interrupt (gpm 2 ...) */
#define GP_WB_READ_INT_CTRL_MASKED_IPCGPM2X_FLAG_D_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb88), 3)

#define GP_WB_GET_INT_CTRL_MASKED_IPCGPM2X_FLAG_D_INTERRUPT_FROM_MASKED_IPCGPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

/* Indicates that an internal cmd is processed */
#define GP_WB_READ_INT_CTRL_MASKED_IPCGPM2X_CMD_PROCESSED_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb88), 4)

#define GP_WB_GET_INT_CTRL_MASKED_IPCGPM2X_CMD_PROCESSED_INTERRUPT_FROM_MASKED_IPCGPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

/* masked gpmicro error interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_IPCGPM2X_ERROR_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb88), 5)

#define GP_WB_GET_INT_CTRL_MASKED_IPCGPM2X_ERROR_INTERRUPT_FROM_MASKED_IPCGPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

/* masked gpmicro unexpected condition interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_IPCGPM2X_UNEXPECTED_COND_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb88), 6)

#define GP_WB_GET_INT_CTRL_MASKED_IPCGPM2X_UNEXPECTED_COND_INTERRUPT_FROM_MASKED_IPCGPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 6) & 0x01)

/* masked gpmicro status interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_IPCGPM2X_STAT_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb88), 7)

#define GP_WB_GET_INT_CTRL_MASKED_IPCGPM2X_STAT_INTERRUPT_FROM_MASKED_IPCGPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 7) & 0x01)

/* Indicates a frame is sent during an advertising event */
#define GP_WB_READ_INT_CTRL_MASKED_IPCGPM2X_ADV_TX_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb89), 0)

#define GP_WB_GET_INT_CTRL_MASKED_IPCGPM2X_ADV_TX_INTERRUPT_FROM_MASKED_IPCGPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x01)

/* Indicates a scan request has been received */
#define GP_WB_READ_INT_CTRL_MASKED_IPCGPM2X_SCAN_REQ_RX_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb89), 1)

#define GP_WB_GET_INT_CTRL_MASKED_IPCGPM2X_SCAN_REQ_RX_INTERRUPT_FROM_MASKED_IPCGPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 9) & 0x01)

/* Indicates a scan response is sent */
#define GP_WB_READ_INT_CTRL_MASKED_IPCGPM2X_SCAN_RSP_TX_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb89), 2)

#define GP_WB_GET_INT_CTRL_MASKED_IPCGPM2X_SCAN_RSP_TX_INTERRUPT_FROM_MASKED_IPCGPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 10) & 0x01)

/* Indicates that a SCAN_REQ frame is sent */
#define GP_WB_READ_INT_CTRL_MASKED_IPCGPM2X_SCAN_REQ_TX_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb89), 3)

#define GP_WB_GET_INT_CTRL_MASKED_IPCGPM2X_SCAN_REQ_TX_INTERRUPT_FROM_MASKED_IPCGPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 11) & 0x01)

/* Indicates that a CONN_REQ frame is sent */
#define GP_WB_READ_INT_CTRL_MASKED_IPCGPM2X_CONN_REQ_TX_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb89), 4)

#define GP_WB_GET_INT_CTRL_MASKED_IPCGPM2X_CONN_REQ_TX_INTERRUPT_FROM_MASKED_IPCGPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 12) & 0x01)

/* Indicates that a subevent has been processed */
#define GP_WB_READ_INT_CTRL_MASKED_IPCGPM2X_SUBEV_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb89), 5)

#define GP_WB_GET_INT_CTRL_MASKED_IPCGPM2X_SUBEV_DONE_INTERRUPT_FROM_MASKED_IPCGPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 13) & 0x01)

/* Indicates that a ble event has been processed */
#define GP_WB_READ_INT_CTRL_MASKED_IPCGPM2X_EVENT_PROCESSED_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb89), 6)

#define GP_WB_GET_INT_CTRL_MASKED_IPCGPM2X_EVENT_PROCESSED_INTERRUPT_FROM_MASKED_IPCGPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 14) & 0x01)

/* Indicates that a connection ble event has reached its last_sch_event_cnt (if enabled) */
#define GP_WB_READ_INT_CTRL_MASKED_IPCGPM2X_LAST_CONN_EVENT_CNT_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb89), 7)

#define GP_WB_GET_INT_CTRL_MASKED_IPCGPM2X_LAST_CONN_EVENT_CNT_INTERRUPT_FROM_MASKED_IPCGPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 15) & 0x01)

/* Indicates that a ble event has been skipped */
#define GP_WB_READ_INT_CTRL_MASKED_IPCGPM2X_EVENT_SKIPPED_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb8a), 0)

#define GP_WB_GET_INT_CTRL_MASKED_IPCGPM2X_EVENT_SKIPPED_INTERRUPT_FROM_MASKED_IPCGPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_IPCX2GPM_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb8b))

#define GP_WB_READ_INT_CTRL_MASKED_IPCX2GPM_FLAG_A_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb8b), 0)

#define GP_WB_GET_INT_CTRL_MASKED_IPCX2GPM_FLAG_A_INTERRUPT_FROM_MASKED_IPCX2GPM_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_IPCX2GPM_FLAG_B_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb8b), 1)

#define GP_WB_GET_INT_CTRL_MASKED_IPCX2GPM_FLAG_B_INTERRUPT_FROM_MASKED_IPCX2GPM_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_IPCX2GPM_FLAG_C_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb8b), 2)

#define GP_WB_GET_INT_CTRL_MASKED_IPCX2GPM_FLAG_C_INTERRUPT_FROM_MASKED_IPCX2GPM_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_IPCX2GPM_FLAG_D_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb8b), 3)

#define GP_WB_GET_INT_CTRL_MASKED_IPCX2GPM_FLAG_D_INTERRUPT_FROM_MASKED_IPCX2GPM_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

/* Indicates that a cmd is available to be processed */
#define GP_WB_READ_INT_CTRL_MASKED_IPCX2GPM_CMD_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb8b), 4)

#define GP_WB_GET_INT_CTRL_MASKED_IPCX2GPM_CMD_INTERRUPT_FROM_MASKED_IPCX2GPM_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_IPCINT2X_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb8c))

/* masked inter processor communication source interrupt (int 2 ...) */
#define GP_WB_READ_INT_CTRL_MASKED_IPCINT2X_FLAG_A_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb8c), 0)

#define GP_WB_GET_INT_CTRL_MASKED_IPCINT2X_FLAG_A_INTERRUPT_FROM_MASKED_IPCINT2X_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* masked inter processor communication source interrupt (int 2 ...) */
#define GP_WB_READ_INT_CTRL_MASKED_IPCINT2X_FLAG_B_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb8c), 1)

#define GP_WB_GET_INT_CTRL_MASKED_IPCINT2X_FLAG_B_INTERRUPT_FROM_MASKED_IPCINT2X_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* masked inter processor communication source interrupt (int 2 ...) */
#define GP_WB_READ_INT_CTRL_MASKED_IPCINT2X_FLAG_C_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb8c), 2)

#define GP_WB_GET_INT_CTRL_MASKED_IPCINT2X_FLAG_C_INTERRUPT_FROM_MASKED_IPCINT2X_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* masked inter processor communication source interrupt (int 2 ...) */
#define GP_WB_READ_INT_CTRL_MASKED_IPCINT2X_FLAG_D_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb8c), 3)

#define GP_WB_GET_INT_CTRL_MASKED_IPCINT2X_FLAG_D_INTERRUPT_FROM_MASKED_IPCINT2X_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_IPCX2INT_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb8d))

/* masked inter processor communication source interrupt (... 2 int) */
#define GP_WB_READ_INT_CTRL_MASKED_IPCX2INT_FLAG_A_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb8d), 0)

#define GP_WB_GET_INT_CTRL_MASKED_IPCX2INT_FLAG_A_INTERRUPT_FROM_MASKED_IPCX2INT_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* masked inter processor communication source interrupt (... 2 int) */
#define GP_WB_READ_INT_CTRL_MASKED_IPCX2INT_FLAG_B_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb8d), 1)

#define GP_WB_GET_INT_CTRL_MASKED_IPCX2INT_FLAG_B_INTERRUPT_FROM_MASKED_IPCX2INT_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* masked inter processor communication source interrupt (... 2 int) */
#define GP_WB_READ_INT_CTRL_MASKED_IPCX2INT_FLAG_C_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb8d), 2)

#define GP_WB_GET_INT_CTRL_MASKED_IPCX2INT_FLAG_C_INTERRUPT_FROM_MASKED_IPCX2INT_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* masked inter processor communication source interrupt (... 2 int) */
#define GP_WB_READ_INT_CTRL_MASKED_IPCX2INT_FLAG_D_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb8d), 3)

#define GP_WB_GET_INT_CTRL_MASKED_IPCX2INT_FLAG_D_INTERRUPT_FROM_MASKED_IPCX2INT_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_IPCEXT2X_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb8e))

/* masked inter processor communication source interrupt (ext 2 ...) */
#define GP_WB_READ_INT_CTRL_MASKED_IPCEXT2X_FLAG_A_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb8e), 0)

#define GP_WB_GET_INT_CTRL_MASKED_IPCEXT2X_FLAG_A_INTERRUPT_FROM_MASKED_IPCEXT2X_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* masked inter processor communication source interrupt (ext 2 ...) */
#define GP_WB_READ_INT_CTRL_MASKED_IPCEXT2X_FLAG_B_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb8e), 1)

#define GP_WB_GET_INT_CTRL_MASKED_IPCEXT2X_FLAG_B_INTERRUPT_FROM_MASKED_IPCEXT2X_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* masked inter processor communication source interrupt (ext 2 ...) */
#define GP_WB_READ_INT_CTRL_MASKED_IPCEXT2X_FLAG_C_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb8e), 2)

#define GP_WB_GET_INT_CTRL_MASKED_IPCEXT2X_FLAG_C_INTERRUPT_FROM_MASKED_IPCEXT2X_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* masked inter processor communication source interrupt (ext 2 ...) */
#define GP_WB_READ_INT_CTRL_MASKED_IPCEXT2X_FLAG_D_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb8e), 3)

#define GP_WB_GET_INT_CTRL_MASKED_IPCEXT2X_FLAG_D_INTERRUPT_FROM_MASKED_IPCEXT2X_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_IPCX2EXT_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb8f))

/* masked inter processor communication source interrupt (... 2 ext) */
#define GP_WB_READ_INT_CTRL_MASKED_IPCX2EXT_FLAG_A_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb8f), 0)

#define GP_WB_GET_INT_CTRL_MASKED_IPCX2EXT_FLAG_A_INTERRUPT_FROM_MASKED_IPCX2EXT_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* masked inter processor communication source interrupt (... 2 ext) */
#define GP_WB_READ_INT_CTRL_MASKED_IPCX2EXT_FLAG_B_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb8f), 1)

#define GP_WB_GET_INT_CTRL_MASKED_IPCX2EXT_FLAG_B_INTERRUPT_FROM_MASKED_IPCX2EXT_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* masked inter processor communication source interrupt (... 2 ext) */
#define GP_WB_READ_INT_CTRL_MASKED_IPCX2EXT_FLAG_C_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb8f), 2)

#define GP_WB_GET_INT_CTRL_MASKED_IPCX2EXT_FLAG_C_INTERRUPT_FROM_MASKED_IPCX2EXT_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* masked inter processor communication source interrupt (... 2 ext) */
#define GP_WB_READ_INT_CTRL_MASKED_IPCX2EXT_FLAG_D_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb8f), 3)

#define GP_WB_GET_INT_CTRL_MASKED_IPCX2EXT_FLAG_D_INTERRUPT_FROM_MASKED_IPCX2EXT_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_I2CSL_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb90))

/* masked TX buffer not full interrupt. */
#define GP_WB_READ_INT_CTRL_MASKED_I2CSL_TX_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb90), 0)

#define GP_WB_GET_INT_CTRL_MASKED_I2CSL_TX_NOT_FULL_INTERRUPT_FROM_MASKED_I2CSL_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* masked RX buffer not empty interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_I2CSL_RX_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb90), 1)

#define GP_WB_GET_INT_CTRL_MASKED_I2CSL_RX_NOT_EMPTY_INTERRUPT_FROM_MASKED_I2CSL_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* masked TX stretch interrupt. */
#define GP_WB_READ_INT_CTRL_MASKED_I2CSL_TX_STRETCH_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb90), 2)

#define GP_WB_GET_INT_CTRL_MASKED_I2CSL_TX_STRETCH_INTERRUPT_FROM_MASKED_I2CSL_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* masked I2C START event occurred interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_I2CSL_START_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb90), 3)

#define GP_WB_GET_INT_CTRL_MASKED_I2CSL_START_INTERRUPT_FROM_MASKED_I2CSL_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

/* masked I2C STOP event occurred interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_I2CSL_STOP_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb90), 4)

#define GP_WB_GET_INT_CTRL_MASKED_I2CSL_STOP_INTERRUPT_FROM_MASKED_I2CSL_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

/* masked I2C SLAD event occurred interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_I2CSL_SLAD_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb90), 5)

#define GP_WB_GET_INT_CTRL_MASKED_I2CSL_SLAD_INTERRUPT_FROM_MASKED_I2CSL_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_PWMS_INTERRUPTS() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb94))

/* masked PWM threshold_match interrupt of pwm0 */
#define GP_WB_READ_INT_CTRL_MASKED_PWMS_PWM0_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb94), 0)

#define GP_WB_GET_INT_CTRL_MASKED_PWMS_PWM0_THRESHOLD_MATCH_INTERRUPT_FROM_MASKED_PWMS_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* masked PWM threshold_match interrupt of pwm1 */
#define GP_WB_READ_INT_CTRL_MASKED_PWMS_PWM1_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb94), 1)

#define GP_WB_GET_INT_CTRL_MASKED_PWMS_PWM1_THRESHOLD_MATCH_INTERRUPT_FROM_MASKED_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* masked PWM threshold_match interrupt of pwm2 */
#define GP_WB_READ_INT_CTRL_MASKED_PWMS_PWM2_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb94), 2)

#define GP_WB_GET_INT_CTRL_MASKED_PWMS_PWM2_THRESHOLD_MATCH_INTERRUPT_FROM_MASKED_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* masked PWM threshold_match interrupt of pwm3 */
#define GP_WB_READ_INT_CTRL_MASKED_PWMS_PWM3_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb94), 3)

#define GP_WB_GET_INT_CTRL_MASKED_PWMS_PWM3_THRESHOLD_MATCH_INTERRUPT_FROM_MASKED_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

/* masked PWM threshold_match interrupt of pwm4 */
#define GP_WB_READ_INT_CTRL_MASKED_PWMS_PWM4_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb94), 4)

#define GP_WB_GET_INT_CTRL_MASKED_PWMS_PWM4_THRESHOLD_MATCH_INTERRUPT_FROM_MASKED_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

/* masked PWM threshold_match interrupt of pwm5 */
#define GP_WB_READ_INT_CTRL_MASKED_PWMS_PWM5_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb94), 5)

#define GP_WB_GET_INT_CTRL_MASKED_PWMS_PWM5_THRESHOLD_MATCH_INTERRUPT_FROM_MASKED_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

/* masked PWM threshold_match interrupt of pwm6 */
#define GP_WB_READ_INT_CTRL_MASKED_PWMS_PWM6_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb94), 6)

#define GP_WB_GET_INT_CTRL_MASKED_PWMS_PWM6_THRESHOLD_MATCH_INTERRUPT_FROM_MASKED_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 6) & 0x01)

/* masked PWM threshold_match interrupt of pwm7 */
#define GP_WB_READ_INT_CTRL_MASKED_PWMS_PWM7_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb94), 7)

#define GP_WB_GET_INT_CTRL_MASKED_PWMS_PWM7_THRESHOLD_MATCH_INTERRUPT_FROM_MASKED_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 7) & 0x01)

/* masked PWM next threshold underrun interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_PWMS_NEXT_THRESHOLD_UNDERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb95), 0)

#define GP_WB_GET_INT_CTRL_MASKED_PWMS_NEXT_THRESHOLD_UNDERRUN_INTERRUPT_FROM_MASKED_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x01)

/* masked PWM next threshold not full interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_PWMS_NEXT_THRESHOLD_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb95), 1)

#define GP_WB_GET_INT_CTRL_MASKED_PWMS_NEXT_THRESHOLD_NOT_FULL_INTERRUPT_FROM_MASKED_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 9) & 0x01)

/* masked PWM timestamp overrun interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_PWMS_TIMESTAMP_OVERRUN_INTERRUPT() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb95)) >> 2) & 0x0F)

#define GP_WB_GET_INT_CTRL_MASKED_PWMS_TIMESTAMP_OVERRUN_INTERRUPT_FROM_MASKED_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 10) & 0x0F)

/* masked PWM timestamp0 overrun interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_PWMS_TIMESTAMP0_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb95), 2)

#define GP_WB_GET_INT_CTRL_MASKED_PWMS_TIMESTAMP0_OVERRUN_INTERRUPT_FROM_MASKED_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 10) & 0x01)

/* masked PWM timestamp1 overrun interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_PWMS_TIMESTAMP1_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb95), 3)

#define GP_WB_GET_INT_CTRL_MASKED_PWMS_TIMESTAMP1_OVERRUN_INTERRUPT_FROM_MASKED_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 11) & 0x01)

/* masked PWM timestamp2 overrun interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_PWMS_TIMESTAMP2_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb95), 4)

#define GP_WB_GET_INT_CTRL_MASKED_PWMS_TIMESTAMP2_OVERRUN_INTERRUPT_FROM_MASKED_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 12) & 0x01)

/* masked PWM timestamp3 overrun interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_PWMS_TIMESTAMP3_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb95), 5)

#define GP_WB_GET_INT_CTRL_MASKED_PWMS_TIMESTAMP3_OVERRUN_INTERRUPT_FROM_MASKED_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 13) & 0x01)

/* masked PWM timestamp not empty interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_PWMS_TIMESTAMP_NOT_EMPTY_INTERRUPT() \
        ((GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb95)) >> 6) & 0x000F)

#define GP_WB_GET_INT_CTRL_MASKED_PWMS_TIMESTAMP_NOT_EMPTY_INTERRUPT_FROM_MASKED_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 14) & 0x000F)

/* masked PWM timestamp0 not empty interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_PWMS_TIMESTAMP0_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb95), 6)

#define GP_WB_GET_INT_CTRL_MASKED_PWMS_TIMESTAMP0_NOT_EMPTY_INTERRUPT_FROM_MASKED_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 14) & 0x01)

/* masked PWM timestamp1 not empty interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_PWMS_TIMESTAMP1_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb95), 7)

#define GP_WB_GET_INT_CTRL_MASKED_PWMS_TIMESTAMP1_NOT_EMPTY_INTERRUPT_FROM_MASKED_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 15) & 0x01)

/* masked PWM timestamp2 not empty interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_PWMS_TIMESTAMP2_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb96), 0)

#define GP_WB_GET_INT_CTRL_MASKED_PWMS_TIMESTAMP2_NOT_EMPTY_INTERRUPT_FROM_MASKED_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0x01)

/* masked PWM timestamp3 not empty interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_PWMS_TIMESTAMP3_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb96), 1)

#define GP_WB_GET_INT_CTRL_MASKED_PWMS_TIMESTAMP3_NOT_EMPTY_INTERRUPT_FROM_MASKED_PWMS_INTERRUPTS(tmp) \
        (((tmp) >> 17) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_ADCIF_INTERRUPTS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb98))

/* masked buffer a updated interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_ADCIF_BUFFER_A_UPDATED_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb98), 0)

#define GP_WB_GET_INT_CTRL_MASKED_ADCIF_BUFFER_A_UPDATED_INTERRUPT_FROM_MASKED_ADCIF_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* masked buffer b updated interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_ADCIF_BUFFER_B_UPDATED_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb98), 1)

#define GP_WB_GET_INT_CTRL_MASKED_ADCIF_BUFFER_B_UPDATED_INTERRUPT_FROM_MASKED_ADCIF_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* masked buffer c updated interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_ADCIF_BUFFER_C_UPDATED_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb98), 2)

#define GP_WB_GET_INT_CTRL_MASKED_ADCIF_BUFFER_C_UPDATED_INTERRUPT_FROM_MASKED_ADCIF_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* masked fifo not empty interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_ADCIF_FIFO_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb98), 3)

#define GP_WB_GET_INT_CTRL_MASKED_ADCIF_FIFO_NOT_EMPTY_INTERRUPT_FROM_MASKED_ADCIF_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

/* masked fifo overrun interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_ADCIF_FIFO_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb98), 4)

#define GP_WB_GET_INT_CTRL_MASKED_ADCIF_FIFO_OVERRUN_INTERRUPT_FROM_MASKED_ADCIF_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

/* masked cycle done interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_ADCIF_CYCLE_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb98), 5)

#define GP_WB_GET_INT_CTRL_MASKED_ADCIF_CYCLE_DONE_INTERRUPT_FROM_MASKED_ADCIF_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

/* masked fifo overvoltage interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_ADCIF_OVERVOLTAGE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb98), 6)

#define GP_WB_GET_INT_CTRL_MASKED_ADCIF_OVERVOLTAGE_INTERRUPT_FROM_MASKED_ADCIF_INTERRUPTS(tmp) \
        (((tmp) >> 6) & 0x01)

/* masked analog watchdog value above maximum interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_ADCIF_AWD_ABOVE_MAXIMUM_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb98), 7)

#define GP_WB_GET_INT_CTRL_MASKED_ADCIF_AWD_ABOVE_MAXIMUM_INTERRUPT_FROM_MASKED_ADCIF_INTERRUPTS(tmp) \
        (((tmp) >> 7) & 0x01)

/* masked analog watchdog value below minimum interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_ADCIF_AWD_BELOW_MINIMUM_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb99), 0)

#define GP_WB_GET_INT_CTRL_MASKED_ADCIF_AWD_BELOW_MINIMUM_INTERRUPT_FROM_MASKED_ADCIF_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_UART_0_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb9a))

/* masked TX not busy interrupt. */
#define GP_WB_READ_INT_CTRL_MASKED_UART_0_TX_NOT_BUSY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb9a), 0)

#define GP_WB_GET_INT_CTRL_MASKED_UART_0_TX_NOT_BUSY_INTERRUPT_FROM_MASKED_UART_0_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* masked TX not full interrupt. */
#define GP_WB_READ_INT_CTRL_MASKED_UART_0_TX_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb9a), 1)

#define GP_WB_GET_INT_CTRL_MASKED_UART_0_TX_NOT_FULL_INTERRUPT_FROM_MASKED_UART_0_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* masked RX not empty interrupt. */
#define GP_WB_READ_INT_CTRL_MASKED_UART_0_RX_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb9a), 2)

#define GP_WB_GET_INT_CTRL_MASKED_UART_0_RX_NOT_EMPTY_INTERRUPT_FROM_MASKED_UART_0_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* masked RX overrun interrupt. */
#define GP_WB_READ_INT_CTRL_MASKED_UART_0_RX_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb9a), 3)

#define GP_WB_GET_INT_CTRL_MASKED_UART_0_RX_OVERRUN_INTERRUPT_FROM_MASKED_UART_0_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

/* masked RX parity error interrupt. */
#define GP_WB_READ_INT_CTRL_MASKED_UART_0_RX_PARITY_ERROR_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb9a), 4)

#define GP_WB_GET_INT_CTRL_MASKED_UART_0_RX_PARITY_ERROR_INTERRUPT_FROM_MASKED_UART_0_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

/* masked RX framing error interrupt. */
#define GP_WB_READ_INT_CTRL_MASKED_UART_0_RX_FRAMING_ERROR_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb9a), 5)

#define GP_WB_GET_INT_CTRL_MASKED_UART_0_RX_FRAMING_ERROR_INTERRUPT_FROM_MASKED_UART_0_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_UART_1_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb9b))

/* masked TX not busy interrupt. */
#define GP_WB_READ_INT_CTRL_MASKED_UART_1_TX_NOT_BUSY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb9b), 0)

#define GP_WB_GET_INT_CTRL_MASKED_UART_1_TX_NOT_BUSY_INTERRUPT_FROM_MASKED_UART_1_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* masked TX not full interrupt. */
#define GP_WB_READ_INT_CTRL_MASKED_UART_1_TX_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb9b), 1)

#define GP_WB_GET_INT_CTRL_MASKED_UART_1_TX_NOT_FULL_INTERRUPT_FROM_MASKED_UART_1_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* masked RX not empty interrupt. */
#define GP_WB_READ_INT_CTRL_MASKED_UART_1_RX_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb9b), 2)

#define GP_WB_GET_INT_CTRL_MASKED_UART_1_RX_NOT_EMPTY_INTERRUPT_FROM_MASKED_UART_1_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* masked RX overrun interrupt. */
#define GP_WB_READ_INT_CTRL_MASKED_UART_1_RX_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb9b), 3)

#define GP_WB_GET_INT_CTRL_MASKED_UART_1_RX_OVERRUN_INTERRUPT_FROM_MASKED_UART_1_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

/* masked RX parity error interrupt. */
#define GP_WB_READ_INT_CTRL_MASKED_UART_1_RX_PARITY_ERROR_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb9b), 4)

#define GP_WB_GET_INT_CTRL_MASKED_UART_1_RX_PARITY_ERROR_INTERRUPT_FROM_MASKED_UART_1_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

/* masked RX framing error interrupt. */
#define GP_WB_READ_INT_CTRL_MASKED_UART_1_RX_FRAMING_ERROR_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb9b), 5)

#define GP_WB_GET_INT_CTRL_MASKED_UART_1_RX_FRAMING_ERROR_INTERRUPT_FROM_MASKED_UART_1_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_TIMERS_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb9c))

#define GP_WB_READ_INT_CTRL_MASKED_TIMERS_TMR0_WRAP_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb9c), 0)

#define GP_WB_GET_INT_CTRL_MASKED_TIMERS_TMR0_WRAP_INTERRUPT_FROM_MASKED_TIMERS_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_TIMERS_TMR1_WRAP_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb9c), 1)

#define GP_WB_GET_INT_CTRL_MASKED_TIMERS_TMR1_WRAP_INTERRUPT_FROM_MASKED_TIMERS_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_TIMERS_TMR2_WRAP_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb9c), 2)

#define GP_WB_GET_INT_CTRL_MASKED_TIMERS_TMR2_WRAP_INTERRUPT_FROM_MASKED_TIMERS_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_TIMERS_TMR3_WRAP_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb9c), 3)

#define GP_WB_GET_INT_CTRL_MASKED_TIMERS_TMR3_WRAP_INTERRUPT_FROM_MASKED_TIMERS_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_TIMERS_TMR4_WRAP_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb9c), 4)

#define GP_WB_GET_INT_CTRL_MASKED_TIMERS_TMR4_WRAP_INTERRUPT_FROM_MASKED_TIMERS_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_IR_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb9d))

#define GP_WB_READ_INT_CTRL_MASKED_IR_SEQUENCE_START_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb9d), 0)

#define GP_WB_GET_INT_CTRL_MASKED_IR_SEQUENCE_START_INTERRUPT_FROM_MASKED_IR_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_IR_SEQUENCE_REPEAT_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb9d), 1)

#define GP_WB_GET_INT_CTRL_MASKED_IR_SEQUENCE_REPEAT_INTERRUPT_FROM_MASKED_IR_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_IR_SEQUENCE_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb9d), 2)

#define GP_WB_GET_INT_CTRL_MASKED_IR_SEQUENCE_DONE_INTERRUPT_FROM_MASKED_IR_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_IR_INDEX_MATCH_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb9d), 3)

#define GP_WB_GET_INT_CTRL_MASKED_IR_INDEX_MATCH_INTERRUPT_FROM_MASKED_IR_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_ASP_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb9e))

#define GP_WB_READ_INT_CTRL_MASKED_ASP_DATASTREAM_0_VALID_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb9e), 0)

#define GP_WB_GET_INT_CTRL_MASKED_ASP_DATASTREAM_0_VALID_INTERRUPT_FROM_MASKED_ASP_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_ASP_DATASTREAM_1_VALID_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb9e), 1)

#define GP_WB_GET_INT_CTRL_MASKED_ASP_DATASTREAM_1_VALID_INTERRUPT_FROM_MASKED_ASP_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_I2SM_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb9f))

#define GP_WB_READ_INT_CTRL_MASKED_I2SM_TX_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb9f), 0)

#define GP_WB_GET_INT_CTRL_MASKED_I2SM_TX_NOT_FULL_INTERRUPT_FROM_MASKED_I2SM_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_I2SM_RX_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xb9f), 1)

#define GP_WB_GET_INT_CTRL_MASKED_I2SM_RX_NOT_EMPTY_INTERRUPT_FROM_MASKED_I2SM_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_BBPLL_INTERRUPTS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xba0))

#define GP_WB_READ_INT_CTRL_MASKED_BBPLL_COARSE_OUT_OF_RANGE_HI_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xba0), 0)

#define GP_WB_GET_INT_CTRL_MASKED_BBPLL_COARSE_OUT_OF_RANGE_HI_INTERRUPT_FROM_MASKED_BBPLL_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_BBPLL_COARSE_OUT_OF_RANGE_LO_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xba0), 1)

#define GP_WB_GET_INT_CTRL_MASKED_BBPLL_COARSE_OUT_OF_RANGE_LO_INTERRUPT_FROM_MASKED_BBPLL_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_BBPLL_TUNE_OUT_OF_RANGE_HI_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xba0), 2)

#define GP_WB_GET_INT_CTRL_MASKED_BBPLL_TUNE_OUT_OF_RANGE_HI_INTERRUPT_FROM_MASKED_BBPLL_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_BBPLL_TUNE_OUT_OF_RANGE_LO_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xba0), 3)

#define GP_WB_GET_INT_CTRL_MASKED_BBPLL_TUNE_OUT_OF_RANGE_LO_INTERRUPT_FROM_MASKED_BBPLL_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_BBPLL_FREQ_OUT_OF_RANGE_HI_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xba0), 4)

#define GP_WB_GET_INT_CTRL_MASKED_BBPLL_FREQ_OUT_OF_RANGE_HI_INTERRUPT_FROM_MASKED_BBPLL_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_BBPLL_FREQ_OUT_OF_RANGE_LO_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xba0), 5)

#define GP_WB_GET_INT_CTRL_MASKED_BBPLL_FREQ_OUT_OF_RANGE_LO_INTERRUPT_FROM_MASKED_BBPLL_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_BBPLL_FREQ_OUT_OF_RANGE_TIMEOUT_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xba0), 6)

#define GP_WB_GET_INT_CTRL_MASKED_BBPLL_FREQ_OUT_OF_RANGE_TIMEOUT_INTERRUPT_FROM_MASKED_BBPLL_INTERRUPTS(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_BBPLL_IN_LOCK_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xba0), 7)

#define GP_WB_GET_INT_CTRL_MASKED_BBPLL_IN_LOCK_INTERRUPT_FROM_MASKED_BBPLL_INTERRUPTS(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_READ_INT_CTRL_MASKED_BBPLL_OUT_OF_LOCK_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xba1), 0)

#define GP_WB_GET_INT_CTRL_MASKED_BBPLL_OUT_OF_LOCK_INTERRUPT_FROM_MASKED_BBPLL_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_SECPROC_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xba2))

/* masked interrupt triggered by the CryptoMaster submodule, i.e. the symmetric cryptographic operations engine */
#define GP_WB_READ_INT_CTRL_MASKED_SECPROC_CRYPTO_MASTER_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xba2), 0)

#define GP_WB_GET_INT_CTRL_MASKED_SECPROC_CRYPTO_MASTER_INTERRUPT_FROM_MASKED_SECPROC_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* masked interrupt triggered by the NDRNG submodule, i.e. the Non-Deterministic Random Number Generator */
#define GP_WB_READ_INT_CTRL_MASKED_SECPROC_TRNG_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xba2), 1)

#define GP_WB_GET_INT_CTRL_MASKED_SECPROC_TRNG_INTERRUPT_FROM_MASKED_SECPROC_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* masked interrupt triggered by the Public Key submodule, i.e. the asymmetric cryptographic operations engine */
#define GP_WB_READ_INT_CTRL_MASKED_SECPROC_PKE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xba2), 2)

#define GP_WB_GET_INT_CTRL_MASKED_SECPROC_PKE_INTERRUPT_FROM_MASKED_SECPROC_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* masked interrupt triggered when the internal DMA runs into a memory bus error */
#define GP_WB_READ_INT_CTRL_MASKED_SECPROC_ERR_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xba2), 3)

#define GP_WB_GET_INT_CTRL_MASKED_SECPROC_ERR_INTERRUPT_FROM_MASKED_SECPROC_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INT_CTRL_MASKED_SINGLE_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xba3))

/* masked triggering an interrupt when n bytes were received */
#define GP_WB_READ_INT_CTRL_MASKED_PARFCS_LEVEL_TRIGGER_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xba3), 0)

#define GP_WB_GET_INT_CTRL_MASKED_PARFCS_LEVEL_TRIGGER_INTERRUPT_FROM_MASKED_SINGLE_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* masked mri write interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_MRI_ACCESS_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xba3), 1)

#define GP_WB_GET_INT_CTRL_MASKED_MRI_ACCESS_DONE_INTERRUPT_FROM_MASKED_SINGLE_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* masked mem exception of gpmicro interrupt. */
#define GP_WB_READ_INT_CTRL_MASKED_GPMICRO_MEM_EXCEPTION_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xba3), 2)

#define GP_WB_GET_INT_CTRL_MASKED_GPMICRO_MEM_EXCEPTION_INTERRUPT_FROM_MASKED_SINGLE_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* masked watchdog timer expired interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_WATCHDOG_TIMER_EXPIRED_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xba3), 3)

#define GP_WB_GET_INT_CTRL_MASKED_WATCHDOG_TIMER_EXPIRED_INTERRUPT_FROM_MASKED_SINGLE_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

/* masked ssp done interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_SSP_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xba3), 4)

#define GP_WB_GET_INT_CTRL_MASKED_SSP_DONE_INTERRUPT_FROM_MASKED_SINGLE_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

/* masked rpa done interrupt */
#define GP_WB_READ_INT_CTRL_MASKED_RPA_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xba3), 5)

#define GP_WB_GET_INT_CTRL_MASKED_RPA_DONE_INTERRUPT_FROM_MASKED_SINGLE_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

/***************************
 * layout: gpmicro
 ***************************/

/* location in the gpmicro program space where the vector table starts. offset in 128 byte resolution */
#define GP_WB_READ_GPMICRO_VECTOR_TABLE_OFFSET() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc00))

#define GP_WB_WRITE_GPMICRO_VECTOR_TABLE_OFFSET(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc00), (val)); \
        } while (0)


/* Address to be used as first instruction address for the first program section (128 Byte address) */
#define GP_WB_READ_GPMICRO_PROGRAM_WINDOW_OFFSET_0() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc02))

#define GP_WB_WRITE_GPMICRO_PROGRAM_WINDOW_OFFSET_0(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc02), (val)); \
        } while (0)


/* Address to be used as first instruction address for the second program section (128 Byte address) */
#define GP_WB_READ_GPMICRO_PROGRAM_WINDOW_OFFSET_1() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc04))

#define GP_WB_WRITE_GPMICRO_PROGRAM_WINDOW_OFFSET_1(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc04), (val)); \
        } while (0)


/* Address to be used as first instruction address for the third program section (128 Byte address) */
#define GP_WB_READ_GPMICRO_PROGRAM_WINDOW_OFFSET_2() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc06))

#define GP_WB_WRITE_GPMICRO_PROGRAM_WINDOW_OFFSET_2(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc06), (val)); \
        } while (0)


/* Sets the 128 byte address within the 128kB program address space that identifies the start of the second program section */
#define GP_WB_READ_GPMICRO_PROGRAM_WINDOW_THRESHOLD_0() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc08))

#define GP_WB_WRITE_GPMICRO_PROGRAM_WINDOW_THRESHOLD_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc08), (val)); \
        } while (0)


/* Sets the 128 byte address within the 128kB program address space that identifies the start of the third program section */
#define GP_WB_READ_GPMICRO_PROGRAM_WINDOW_THRESHOLD_1() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc0a))

#define GP_WB_WRITE_GPMICRO_PROGRAM_WINDOW_THRESHOLD_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc0a), (val)); \
        } while (0)


/* compressed address to to which the data section 0 of the gpmicro memory map should point (16 kB page address) */
#define GP_WB_READ_GPMICRO_DATA_SECTION_OFFSET_0() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc0c))

#define GP_WB_WRITE_GPMICRO_DATA_SECTION_OFFSET_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc0c), (val)); \
        } while (0)


/* compressed address to to which the data section 1 of the gpmicro memory map should point (16 kB page address) */
#define GP_WB_READ_GPMICRO_DATA_SECTION_OFFSET_1() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc0e))

#define GP_WB_WRITE_GPMICRO_DATA_SECTION_OFFSET_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc0e), (val)); \
        } while (0)


/* Determines the offset (128 byte granularity) for the first ro data window */
#define GP_WB_READ_GPMICRO_RO_DATA_WINDOW_OFFSET_0() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc10))

#define GP_WB_WRITE_GPMICRO_RO_DATA_WINDOW_OFFSET_0(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc10), (val)); \
        } while (0)


/* Determines the offset (128 byte granularity) for the second ro data window */
#define GP_WB_READ_GPMICRO_RO_DATA_WINDOW_OFFSET_1() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc12))

#define GP_WB_WRITE_GPMICRO_RO_DATA_WINDOW_OFFSET_1(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc12), (val)); \
        } while (0)


/* Determines the offset (128 byte granularity) for the third ro data window */
#define GP_WB_READ_GPMICRO_RO_DATA_WINDOW_OFFSET_2() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc14))

#define GP_WB_WRITE_GPMICRO_RO_DATA_WINDOW_OFFSET_2(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc14), (val)); \
        } while (0)


/* Determines the offset (128 byte granularity) for the fourth ro data window */
#define GP_WB_READ_GPMICRO_RO_DATA_WINDOW_OFFSET_3() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc16))

#define GP_WB_WRITE_GPMICRO_RO_DATA_WINDOW_OFFSET_3(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc16), (val)); \
        } while (0)


/* The current value of the program_ptr (word address) */
#define GP_WB_READ_GPMICRO_PROGRAM_PTR() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc18))


#define GP_WB_READ_GPMICRO_HALTED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc1a), 0)

/* indicates that a mem exception occurred */
#define GP_WB_READ_GPMICRO_UNMASKED_MEM_EXCEPTION_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc1a), 1)

/* indicates what the reason was the an exception occuured (exceptions are caused by a mem error) */
#define GP_WB_READ_GPMICRO_MEM_EXCEPTION_TYPE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc1a), 2)


/* If set the uc will be reset when a memory exception is received from the mm */
#define GP_WB_READ_GPMICRO_RESET_ON_MEM_EXCEPTION() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc1b), 0)

#define GP_WB_WRITE_GPMICRO_RESET_ON_MEM_EXCEPTION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc1b), 0, (val)); \
        } while (0)

/* When 0, the gpmicro wil be woken up with the lowest prio interrupt when trying to go to sleep. */
#define GP_WB_READ_GPMICRO_SLEEP_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc1b), 1)

#define GP_WB_WRITE_GPMICRO_SLEEP_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc1b), 1, (val)); \
        } while (0)


/* Logical address latched when an error occurred ( byte address) */
#define GP_WB_READ_GPMICRO_LOGICAL_ADDRESS_ON_ERR() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc1c))


/* Clears the mmu exception (memory error) */
#define GP_WB_GPMICRO_CLR_MEM_EXCEPTION_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc1e), 0x01)

/* Mimics a a uc soft reset. This resets the software by triggering a restart from vector 0 */
#define GP_WB_GPMICRO_SOFT_RESET() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc1e), 0x02)

/***************************
 * layout: cortexm4
 ***************************/

/* Offset in 256 byte multiples for the vector table */
#define GP_WB_READ_CORTEXM4_VECTOR_TABLE_OFFSET() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc40))

#define GP_WB_WRITE_CORTEXM4_VECTOR_TABLE_OFFSET(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7FFFFF); \
          GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc40), (val)); \
        } while (0)


/* Should be set to the value in order to a 10 ms delay from the FCLK. So needs to change when FCLK changes frequency */
#define GP_WB_READ_CORTEXM4_SYSTICK_CALIB() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc44))

#define GP_WB_WRITE_CORTEXM4_SYSTICK_CALIB(val) do { \
          GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc44), (val)); \
        } while (0)


/* TRSTn pin for the JTAG interface */
#define GP_WB_READ_CORTEXM4_JTAG_NTRST() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc47), 0)

#define GP_WB_WRITE_CORTEXM4_JTAG_NTRST(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc47), 0, (val)); \
        } while (0)

/* This enables the sysreset on lockup feature. So when a lockup happens, this will trigger a system reset */
#define GP_WB_READ_CORTEXM4_SYSRESET_WHEN_LOCKUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc47), 1)

#define GP_WB_WRITE_CORTEXM4_SYSRESET_WHEN_LOCKUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc47), 1, (val)); \
        } while (0)

/* When set, a sysreset req (triggered from debug interface, will trigger a soft por (POR_REASON_SOFT_POR_PRESERVE_DBG_ITF) */
#define GP_WB_READ_CORTEXM4_DO_SOFT_POR_ON_SYSRESETREQ() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc47), 2)

#define GP_WB_WRITE_CORTEXM4_DO_SOFT_POR_ON_SYSRESETREQ(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc47), 2, (val)); \
        } while (0)

/* by default fclk is also gated - this bit allows fdor disabling this clk gating feature - REQUIRED when ENABLING DEBUG INTERFACE ! */
#define GP_WB_READ_CORTEXM4_DISABLE_FCLK_GATING() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc47), 3)

#define GP_WB_WRITE_CORTEXM4_DISABLE_FCLK_GATING(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc47), 3, (val)); \
        } while (0)


/* logical to physical block remapping on dcode and icode mem interface for block 0 (allowed values 0 to 3, bit 2 is reserved) */
#define GP_WB_READ_CORTEXM4_ICODE_DCODE_BLOCK_0_REMAP() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc48)) & 0x07)

#define GP_WB_WRITE_CORTEXM4_ICODE_DCODE_BLOCK_0_REMAP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc48), 0x07, (val)); \
        } while (0)

/* logical to physical block remapping on dcode and icode mem interface for block 1 (allowed values 0 to 3, bit 2 is reserved) */
#define GP_WB_READ_CORTEXM4_ICODE_DCODE_BLOCK_1_REMAP() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc48)) >> 3) & 0x07)

#define GP_WB_WRITE_CORTEXM4_ICODE_DCODE_BLOCK_1_REMAP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc48), 0x38, (val) << 3); \
        } while (0)

/* logical to physical block remapping on dcode and icode mem interface for block 2 (allowed values 0 to 3, bit 2 is reserved) */
#define GP_WB_READ_CORTEXM4_ICODE_DCODE_BLOCK_2_REMAP() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc49)) & 0x07)

#define GP_WB_WRITE_CORTEXM4_ICODE_DCODE_BLOCK_2_REMAP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc49), 0x07, (val)); \
        } while (0)

/* logical to physical block remapping on dcode and icode mem interface for block 3 (allowed values 0 to 3, bit 2 is reserved) */
#define GP_WB_READ_CORTEXM4_ICODE_DCODE_BLOCK_3_REMAP() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc49)) >> 3) & 0x07)

#define GP_WB_WRITE_CORTEXM4_ICODE_DCODE_BLOCK_3_REMAP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc49), 0x38, (val) << 3); \
        } while (0)


/* offset redirecting the 4kB virtual icode/dcode flash window 0 into the main flash array */
#define GP_WB_READ_CORTEXM4_FLASH_VIRT_WINDOW_0_OFFSET() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc4c))

#define GP_WB_WRITE_CORTEXM4_FLASH_VIRT_WINDOW_0_OFFSET(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc4c), (val)); \
        } while (0)

/* offset redirecting the 4kB virtual icode/dcode flash window 1 into the main flash array */
#define GP_WB_READ_CORTEXM4_FLASH_VIRT_WINDOW_1_OFFSET() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc4d))

#define GP_WB_WRITE_CORTEXM4_FLASH_VIRT_WINDOW_1_OFFSET(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc4d), (val)); \
        } while (0)

/* offset redirecting the 4kB virtual icode/dcode flash window 2 into the main flash array */
#define GP_WB_READ_CORTEXM4_FLASH_VIRT_WINDOW_2_OFFSET() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc4e))

#define GP_WB_WRITE_CORTEXM4_FLASH_VIRT_WINDOW_2_OFFSET(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc4e), (val)); \
        } while (0)

/* offset redirecting the 4kB virtual icode/dcode flash window 3 into the main flash array */
#define GP_WB_READ_CORTEXM4_FLASH_VIRT_WINDOW_3_OFFSET() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc4f))

#define GP_WB_WRITE_CORTEXM4_FLASH_VIRT_WINDOW_3_OFFSET(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc4f), (val)); \
        } while (0)


/* offset redirecting the 4kB virtual icode/dcode flash window 4 into the main flash array */
#define GP_WB_READ_CORTEXM4_FLASH_VIRT_WINDOW_4_OFFSET() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc50))

#define GP_WB_WRITE_CORTEXM4_FLASH_VIRT_WINDOW_4_OFFSET(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc50), (val)); \
        } while (0)

/* offset redirecting the 4kB virtual icode/dcode flash window 5 into the main flash array */
#define GP_WB_READ_CORTEXM4_FLASH_VIRT_WINDOW_5_OFFSET() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc51))

#define GP_WB_WRITE_CORTEXM4_FLASH_VIRT_WINDOW_5_OFFSET(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc51), (val)); \
        } while (0)

/* offset redirecting the 4kB virtual icode/dcode flash window 6 into the main flash array */
#define GP_WB_READ_CORTEXM4_FLASH_VIRT_WINDOW_6_OFFSET() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc52))

#define GP_WB_WRITE_CORTEXM4_FLASH_VIRT_WINDOW_6_OFFSET(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc52), (val)); \
        } while (0)

/* offset redirecting the 4kB virtual icode/dcode flash window 7 into the main flash array */
#define GP_WB_READ_CORTEXM4_FLASH_VIRT_WINDOW_7_OFFSET() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc53))

#define GP_WB_WRITE_CORTEXM4_FLASH_VIRT_WINDOW_7_OFFSET(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc53), (val)); \
        } while (0)


/* provides a local handle to do a POR reset of the cortex m4 core. This is a system reset, aka cold reset */
#define GP_WB_CORTEXM4_PORRESET_SW() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc54), 0x01)

/* provides a local to reset the processor excluding debug logic in the NVIC, DWT an ITM */
#define GP_WB_CORTEXM4_SYSRESET_SW() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc54), 0x02)


/* Indicates that the processor is in sleep mode */
#define GP_WB_READ_CORTEXM4_ASLEEP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc55), 0)

/* Indicates that the processor is in deep sleep mode */
#define GP_WB_READ_CORTEXM4_INDEEPSLEEP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xc55), 1)

/***************************
 * layout: bbpll
 ***************************/

/* Way to indicate to the hardware, the 192MHz clock has started up. Should be set by SW */
#define GP_WB_READ_BBPLL_CLK_192M_VALID() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd00), 0)

#define GP_WB_WRITE_BBPLL_CLK_192M_VALID(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd00), (val)); \
        } while (0)


/* Frequency estimation time in microseconds (1 to 8) */
#define GP_WB_READ_BBPLL_F_ESTIMATION_DURATION() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd01))

#define GP_WB_WRITE_BBPLL_F_ESTIMATION_DURATION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd01), (val)); \
        } while (0)


/* Coarse value */
#define GP_WB_WRITE_BBPLL_DCO_COARSE_NEW(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd02), (val)); \
        } while (0)


/* Initial DCO coarse value for calibration */
#define GP_WB_READ_BBPLL_DCO_COARSE_INIT_VALUE_FOR_CALIBRATION() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd03))

#define GP_WB_WRITE_BBPLL_DCO_COARSE_INIT_VALUE_FOR_CALIBRATION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd03), (val)); \
        } while (0)


/* DCO tune value as used when the loop is open */
#define GP_WB_READ_BBPLL_DCO_TUNE_DURING_OPEN_LOOP() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd04))

#define GP_WB_WRITE_BBPLL_DCO_TUNE_DURING_OPEN_LOOP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd04), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BBPLL_DCO_TUNE_OVERRIDE_SETTINGS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd05))

#define GP_WB_WRITE_BBPLL_DCO_TUNE_OVERRIDE_SETTINGS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd05), (val))

/* Tune override value */
#define GP_WB_READ_BBPLL_DCO_TUNE_OVERRIDE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd05)) & 0x1F)

#define GP_WB_GET_BBPLL_DCO_TUNE_OVERRIDE_FROM_DCO_TUNE_OVERRIDE_SETTINGS(tmp) \
        ((tmp) & 0x1F)

#define GP_WB_WRITE_BBPLL_DCO_TUNE_OVERRIDE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd05), 0x1F, (val)); \
        } while (0)

#define GP_WB_SET_BBPLL_DCO_TUNE_OVERRIDE_TO_DCO_TUNE_OVERRIDE_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x20; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Tune override enable */
#define GP_WB_READ_BBPLL_DCO_TUNE_OVERRIDE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd05), 5)

#define GP_WB_GET_BBPLL_DCO_TUNE_OVERRIDE_ENA_FROM_DCO_TUNE_OVERRIDE_SETTINGS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_BBPLL_DCO_TUNE_OVERRIDE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd05), 5, (val)); \
        } while (0)

#define GP_WB_SET_BBPLL_DCO_TUNE_OVERRIDE_ENA_TO_DCO_TUNE_OVERRIDE_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* Coarse safety margin max */
#define GP_WB_READ_BBPLL_COARSE_OUT_OF_RANGE_MAX() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd06))

#define GP_WB_WRITE_BBPLL_COARSE_OUT_OF_RANGE_MAX(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd06), (val)); \
        } while (0)

/* Coarse safety margin min */
#define GP_WB_READ_BBPLL_COARSE_OUT_OF_RANGE_MIN() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd07))

#define GP_WB_WRITE_BBPLL_COARSE_OUT_OF_RANGE_MIN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd07), (val)); \
        } while (0)


/* Tune safety margin max */
#define GP_WB_READ_BBPLL_TUNE_OUT_OF_RANGE_MAX() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd08))

#define GP_WB_WRITE_BBPLL_TUNE_OUT_OF_RANGE_MAX(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd08), (val)); \
        } while (0)

/* Tune safety margin min */
#define GP_WB_READ_BBPLL_TUNE_OUT_OF_RANGE_MIN() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd09))

#define GP_WB_WRITE_BBPLL_TUNE_OUT_OF_RANGE_MIN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd09), (val)); \
        } while (0)


/* Minimum nr of pulses the frequency estimator has to count during the measurement before indicating a frequency too low event */
#define GP_WB_READ_BBPLL_FREQ_OUT_OF_RANGE_FE_MIN() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd0a))

#define GP_WB_WRITE_BBPLL_FREQ_OUT_OF_RANGE_FE_MIN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd0a), (val)); \
        } while (0)


/* Maximum nr of pulses the frequency estimator has to count during the measurement before indicating a frequency too high event */
#define GP_WB_READ_BBPLL_FREQ_OUT_OF_RANGE_FE_MAX() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd0c))

#define GP_WB_WRITE_BBPLL_FREQ_OUT_OF_RANGE_FE_MAX(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd0c), (val)); \
        } while (0)


/* If this value is exceeded, then something strange has happened, eg failing XO clock */
#define GP_WB_READ_BBPLL_FREQ_OUT_OF_RANGE_TIMEOUT() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd0e))

#define GP_WB_WRITE_BBPLL_FREQ_OUT_OF_RANGE_TIMEOUT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd0e), (val)); \
        } while (0)


/* Within this range of integrator output the system is in-lock */
#define GP_WB_READ_BBPLL_PHASE_DETECT_NOCHANGE_COUNT_IN_LOCK() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd10))

#define GP_WB_WRITE_BBPLL_PHASE_DETECT_NOCHANGE_COUNT_IN_LOCK(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd10), (val)); \
        } while (0)

/* system goes out-of-lock when no change on input samples for specified nr of consecutive cycles */
#define GP_WB_READ_BBPLL_PHASE_DETECT_NOCHANGE_COUNT_OUT_OF_LOCK() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd11))

#define GP_WB_WRITE_BBPLL_PHASE_DETECT_NOCHANGE_COUNT_OUT_OF_LOCK(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd11), (val)); \
        } while (0)


/* Value with which lock counter is decremented (0 means 4, 1 means 8, 2 or 3 means 16) */
#define GP_WB_READ_BBPLL_PHASE_DETECT_NOCHANGE_DECREMENT_VALUE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd12))

#define GP_WB_WRITE_BBPLL_PHASE_DETECT_NOCHANGE_DECREMENT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd12), (val)); \
        } while (0)


/* Timeout value masking new out-of-range events */
#define GP_WB_READ_BBPLL_OUT_OF_RANGE_TIMEOUT_VALUE() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd14))

#define GP_WB_WRITE_BBPLL_OUT_OF_RANGE_TIMEOUT_VALUE(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd14), (val)); \
        } while (0)


/* When out of range timeout counter divided by 64 drops below this value, the loop bandwidth is set to the next value */
#define GP_WB_READ_BBPLL_INCREASED_BANDWIDTH_TIMEOUT_LIMIT_1() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd16))

#define GP_WB_WRITE_BBPLL_INCREASED_BANDWIDTH_TIMEOUT_LIMIT_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd16), (val)); \
        } while (0)


/* When out of range timeout counter divided by 64 drops below this value, the loop bandwidth is set to the next value */
#define GP_WB_READ_BBPLL_INCREASED_BANDWIDTH_TIMEOUT_LIMIT_2() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd18))

#define GP_WB_WRITE_BBPLL_INCREASED_BANDWIDTH_TIMEOUT_LIMIT_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd18), (val)); \
        } while (0)


/* When out of range timeout counter divided by 64 drops below this value, the loop bandwidth is set to the nominal value */
#define GP_WB_READ_BBPLL_INCREASED_BANDWIDTH_TIMEOUT_LIMIT_3() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1a))

#define GP_WB_WRITE_BBPLL_INCREASED_BANDWIDTH_TIMEOUT_LIMIT_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1a), (val)); \
        } while (0)


/* Masks bandwidth increase during coarse update due to freq_out_of_range event */
#define GP_WB_READ_BBPLL_MASK_BANDWIDTH_INCREASE_DURING_FOOR() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1c), 0)

#define GP_WB_WRITE_BBPLL_MASK_BANDWIDTH_INCREASE_DURING_FOOR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1c), (val)); \
        } while (0)


/* Gain for sample_in when not increased (range 1, 2, 4, 8) */
#define GP_WB_READ_BBPLL_SAMPLE_IN_NORMAL_GAIN() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1d)) & 0x03)

#define GP_WB_WRITE_BBPLL_SAMPLE_IN_NORMAL_GAIN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1d), 0x03, (val)); \
        } while (0)

/* First gain step setting for sample_in when increased, so after dco_coarse step due to tune_out_of_range event (range 1, 2, 4, 8) */
#define GP_WB_READ_BBPLL_SAMPLE_IN_INCREASE_GAIN_1() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1d)) >> 2) & 0x03)

#define GP_WB_WRITE_BBPLL_SAMPLE_IN_INCREASE_GAIN_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1d), 0x0C, (val) << 2); \
        } while (0)

/* Second gain step setting for sample_in when increased, so after dco_coarse step due to tune_out_of_range event (range 1, 2, 4, 8) */
#define GP_WB_READ_BBPLL_SAMPLE_IN_INCREASE_GAIN_2() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1d)) >> 4) & 0x03)

#define GP_WB_WRITE_BBPLL_SAMPLE_IN_INCREASE_GAIN_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1d), 0x30, (val) << 4); \
        } while (0)

/* Third gain step setting for sample_in when increased, so after dco_coarse step due to tune_out_of_range event (range 1, 2, 4, 8) */
#define GP_WB_READ_BBPLL_SAMPLE_IN_INCREASE_GAIN_3() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1d)) >> 6) & 0x03)

#define GP_WB_WRITE_BBPLL_SAMPLE_IN_INCREASE_GAIN_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1d), 0xC0, (val) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BBPLL_LOOP_AND_FE_CONFIG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1e))

#define GP_WB_WRITE_BBPLL_LOOP_AND_FE_CONFIG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1e), (val))

/* closes and opens the loop. Main loop control bit. */
#define GP_WB_READ_BBPLL_LOOP_IS_CLOSED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1e), 0)

#define GP_WB_GET_BBPLL_LOOP_IS_CLOSED_FROM_LOOP_AND_FE_CONFIG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_BBPLL_LOOP_IS_CLOSED(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1e), 0, (val)); \
        } while (0)

#define GP_WB_SET_BBPLL_LOOP_IS_CLOSED_TO_LOOP_AND_FE_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Debug setting. Allows to increase the loop BW during normal closed loop operation */
#define GP_WB_READ_BBPLL_LOOP_BW_INCREASE_NORMAL() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1e), 1)

#define GP_WB_GET_BBPLL_LOOP_BW_INCREASE_NORMAL_FROM_LOOP_AND_FE_CONFIG(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_BBPLL_LOOP_BW_INCREASE_NORMAL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1e), 1, (val)); \
        } while (0)

#define GP_WB_SET_BBPLL_LOOP_BW_INCREASE_NORMAL_TO_LOOP_AND_FE_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Debug setting. Allows to deccrease the loop BW during coarse bank transition in closed loop */
#define GP_WB_READ_BBPLL_LOOP_BW_INCREASE_TRANSITION() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1e), 2)

#define GP_WB_GET_BBPLL_LOOP_BW_INCREASE_TRANSITION_FROM_LOOP_AND_FE_CONFIG(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_BBPLL_LOOP_BW_INCREASE_TRANSITION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1e), 2, (val)); \
        } while (0)

#define GP_WB_SET_BBPLL_LOOP_BW_INCREASE_TRANSITION_TO_LOOP_AND_FE_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Loop sign control */
#define GP_WB_READ_BBPLL_LOOP_SIGN_INVERT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1e), 3)

#define GP_WB_GET_BBPLL_LOOP_SIGN_INVERT_FROM_LOOP_AND_FE_CONFIG(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_BBPLL_LOOP_SIGN_INVERT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1e), 3, (val)); \
        } while (0)

#define GP_WB_SET_BBPLL_LOOP_SIGN_INVERT_TO_LOOP_AND_FE_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x77; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* When set the loop is allowed to updatee the coarse bank under out of range conditions */
#define GP_WB_READ_BBPLL_LOOP_ALLOW_FOR_TUNE_OUT_OF_RANGE_COARSE_UPDATE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1e), 4)

#define GP_WB_GET_BBPLL_LOOP_ALLOW_FOR_TUNE_OUT_OF_RANGE_COARSE_UPDATE_FROM_LOOP_AND_FE_CONFIG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_BBPLL_LOOP_ALLOW_FOR_TUNE_OUT_OF_RANGE_COARSE_UPDATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1e), 4, (val)); \
        } while (0)

#define GP_WB_SET_BBPLL_LOOP_ALLOW_FOR_TUNE_OUT_OF_RANGE_COARSE_UPDATE_TO_LOOP_AND_FE_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x6F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* When set the loop is allowed to updatee the coarse bank under freq too low or too high conditions conditions */
#define GP_WB_READ_BBPLL_LOOP_ALLOW_FOR_FREQ_OUT_OF_RANGE_COARSE_UPDATE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1e), 5)

#define GP_WB_GET_BBPLL_LOOP_ALLOW_FOR_FREQ_OUT_OF_RANGE_COARSE_UPDATE_FROM_LOOP_AND_FE_CONFIG(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_BBPLL_LOOP_ALLOW_FOR_FREQ_OUT_OF_RANGE_COARSE_UPDATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1e), 5, (val)); \
        } while (0)

#define GP_WB_SET_BBPLL_LOOP_ALLOW_FOR_FREQ_OUT_OF_RANGE_COARSE_UPDATE_TO_LOOP_AND_FE_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x5F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* When set the frequency estimater will do continuous measurements instead of single shot measurements */
#define GP_WB_READ_BBPLL_FE_CONTINUOUS_MODE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1e), 6)

#define GP_WB_GET_BBPLL_FE_CONTINUOUS_MODE_FROM_LOOP_AND_FE_CONFIG(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_BBPLL_FE_CONTINUOUS_MODE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1e), 6, (val)); \
        } while (0)

#define GP_WB_SET_BBPLL_FE_CONTINUOUS_MODE_TO_LOOP_AND_FE_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* If set, property dco_tune gets updated */
#define GP_WB_READ_BBPLL_SHOW_DCO_TUNE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1f), 0)

#define GP_WB_WRITE_BBPLL_SHOW_DCO_TUNE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1f), 0, (val)); \
        } while (0)

/* Dither is enabled when set. It reduces risk of locking to wrong frequency */
#define GP_WB_READ_BBPLL_ENABLE_DITHER() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1f), 1)

#define GP_WB_WRITE_BBPLL_ENABLE_DITHER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1f), 1, (val)); \
        } while (0)

/* Specifies gain of dither value from 1 (0x0) .. 64 (0x6) (128 (0x7) is not supported) */
#define GP_WB_READ_BBPLL_DITHER_GAIN() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1f)) >> 2) & 0x07)

#define GP_WB_WRITE_BBPLL_DITHER_GAIN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd1f), 0x1C, (val) << 2); \
        } while (0)


/* Result from the frequency estimation (nr of 192MHz clocks). Only valid f_estimation_duration (in us) after triggering start_fe */
#define GP_WB_READ_BBPLL_FE_RESULT() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd20))


/* When set, the phase_detect_nochange_count is below the threshold */
#define GP_WB_READ_BBPLL_LOOP_IS_LOCKED_RAW_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd22), 0)


/* Counting freq_out_of_range events */
#define GP_WB_READ_BBPLL_FREQ_OUT_OF_RANGE_CNT() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd23))


/* Counting tune_out_of_range events */
#define GP_WB_READ_BBPLL_TUNE_OUT_OF_RANGE_CNT() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd24))


/* Actual dco_coarse value */
#define GP_WB_READ_BBPLL_DCO_COARSE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd25))


/* Subsampled dco_tune value */
#define GP_WB_READ_BBPLL_DCO_TUNE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd26))


#define GP_WB_WRITE_BBPLL_CLR_INTERRUPTS(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd28), (val))

/* interrupt clear control */
#define GP_WB_BBPLL_CLR_COARSE_OUT_OF_RANGE_HI() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd28), 0x01)

#define GP_WB_SET_BBPLL_CLR_COARSE_OUT_OF_RANGE_HI_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FE; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* interrupt clear control */
#define GP_WB_BBPLL_CLR_COARSE_OUT_OF_RANGE_LO() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd28), 0x02)

#define GP_WB_SET_BBPLL_CLR_COARSE_OUT_OF_RANGE_LO_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FD; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

/* interrupt clear control */
#define GP_WB_BBPLL_CLR_TUNE_OUT_OF_RANGE_HI() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd28), 0x04)

#define GP_WB_SET_BBPLL_CLR_TUNE_OUT_OF_RANGE_HI_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FB; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* interrupt clear control */
#define GP_WB_BBPLL_CLR_TUNE_OUT_OF_RANGE_LO() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd28), 0x08)

#define GP_WB_SET_BBPLL_CLR_TUNE_OUT_OF_RANGE_LO_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01F7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

/* interrupt clear control */
#define GP_WB_BBPLL_CLR_FREQ_OUT_OF_RANGE_LO() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd28), 0x10)

#define GP_WB_SET_BBPLL_CLR_FREQ_OUT_OF_RANGE_LO_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01EF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* interrupt clear control */
#define GP_WB_BBPLL_CLR_FREQ_OUT_OF_RANGE_HI() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd28), 0x20)

#define GP_WB_SET_BBPLL_CLR_FREQ_OUT_OF_RANGE_HI_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01DF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

/* interrupt clear control */
#define GP_WB_BBPLL_CLR_FREQ_OUT_OF_RANGE_TIMEOUT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd28), 0x40)

#define GP_WB_SET_BBPLL_CLR_FREQ_OUT_OF_RANGE_TIMEOUT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01BF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

/* interrupt clear control */
#define GP_WB_BBPLL_CLR_IN_LOCK() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd28), 0x80)

#define GP_WB_SET_BBPLL_CLR_IN_LOCK_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x017F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* interrupt clear control */
#define GP_WB_BBPLL_CLR_OUT_OF_LOCK() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd29), 0x01)

#define GP_WB_SET_BBPLL_CLR_OUT_OF_LOCK_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x00FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)


/* Starts FE measurement */
#define GP_WB_BBPLL_START_FE() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd2a), 0x01)

/* Clears the freq_out_of_range counter */
#define GP_WB_BBPLL_CLR_FREQ_OUT_OF_RANGE_CNT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd2a), 0x02)

/* Clears the tune_out_of_range counter */
#define GP_WB_BBPLL_CLR_TUNE_OUT_OF_RANGE_CNT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd2a), 0x04)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BBPLL_UNMASKED_INTERRUPT_STATUS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd2c))

/* interrupt set when dco coarse passed the high threshold */
#define GP_WB_READ_BBPLL_UNMASKED_COARSE_OUT_OF_RANGE_HI_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd2c), 0)

#define GP_WB_GET_BBPLL_UNMASKED_COARSE_OUT_OF_RANGE_HI_INTERRUPT_FROM_UNMASKED_INTERRUPT_STATUS(tmp) \
        ((tmp) & 0x01)

/* interrupt set when dco coarse passed the low threshold */
#define GP_WB_READ_BBPLL_UNMASKED_COARSE_OUT_OF_RANGE_LO_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd2c), 1)

#define GP_WB_GET_BBPLL_UNMASKED_COARSE_OUT_OF_RANGE_LO_INTERRUPT_FROM_UNMASKED_INTERRUPT_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* interrupt set when dco tune passed the high threshold */
#define GP_WB_READ_BBPLL_UNMASKED_TUNE_OUT_OF_RANGE_HI_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd2c), 2)

#define GP_WB_GET_BBPLL_UNMASKED_TUNE_OUT_OF_RANGE_HI_INTERRUPT_FROM_UNMASKED_INTERRUPT_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)

/* interrupt set when dco tune passed the low threshold */
#define GP_WB_READ_BBPLL_UNMASKED_TUNE_OUT_OF_RANGE_LO_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd2c), 3)

#define GP_WB_GET_BBPLL_UNMASKED_TUNE_OUT_OF_RANGE_LO_INTERRUPT_FROM_UNMASKED_INTERRUPT_STATUS(tmp) \
        (((tmp) >> 3) & 0x01)

/* interrupt set when frequency estimator in continuous mode counts too little pulses */
#define GP_WB_READ_BBPLL_UNMASKED_FREQ_OUT_OF_RANGE_LO_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd2c), 4)

#define GP_WB_GET_BBPLL_UNMASKED_FREQ_OUT_OF_RANGE_LO_INTERRUPT_FROM_UNMASKED_INTERRUPT_STATUS(tmp) \
        (((tmp) >> 4) & 0x01)

/* interrupt set when frequency estimator in continuous mode counts too many pulses */
#define GP_WB_READ_BBPLL_UNMASKED_FREQ_OUT_OF_RANGE_HI_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd2c), 5)

#define GP_WB_GET_BBPLL_UNMASKED_FREQ_OUT_OF_RANGE_HI_INTERRUPT_FROM_UNMASKED_INTERRUPT_STATUS(tmp) \
        (((tmp) >> 5) & 0x01)

/* interrupt set when most likely the XO clock is failing */
#define GP_WB_READ_BBPLL_UNMASKED_FREQ_OUT_OF_RANGE_TIMEOUT_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd2c), 6)

#define GP_WB_GET_BBPLL_UNMASKED_FREQ_OUT_OF_RANGE_TIMEOUT_INTERRUPT_FROM_UNMASKED_INTERRUPT_STATUS(tmp) \
        (((tmp) >> 6) & 0x01)

/* interrupt set when bbpll loop goes in lock */
#define GP_WB_READ_BBPLL_UNMASKED_IN_LOCK_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd2c), 7)

#define GP_WB_GET_BBPLL_UNMASKED_IN_LOCK_INTERRUPT_FROM_UNMASKED_INTERRUPT_STATUS(tmp) \
        (((tmp) >> 7) & 0x01)

/* interrupt set when bbpll loop goes out of lock */
#define GP_WB_READ_BBPLL_UNMASKED_OUT_OF_LOCK_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd2d), 0)

#define GP_WB_GET_BBPLL_UNMASKED_OUT_OF_LOCK_INTERRUPT_FROM_UNMASKED_INTERRUPT_STATUS(tmp) \
        (((tmp) >> 8) & 0x01)


/* enables internal fractional clock synth. Generates fractional clock to be used by peripherals */
#define GP_WB_READ_BBPLL_ENABLE_FRACT_CLOCK() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd2e), 0)

#define GP_WB_WRITE_BBPLL_ENABLE_FRACT_CLOCK(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd2e), (val)); \
        } while (0)


/* Defines the main period Tp of the fractional clock, expressed in 192 MHZ clock cycles */
#define GP_WB_READ_BBPLL_FRACT_CLOCK_PERIOD() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd30))

#define GP_WB_WRITE_BBPLL_FRACT_CLOCK_PERIOD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd30), (val)); \
        } while (0)


/* Defines the main high time of the clock, so effectively duty cycle. */
#define GP_WB_READ_BBPLL_FRACT_CLOCK_HIGH() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd32))

#define GP_WB_WRITE_BBPLL_FRACT_CLOCK_HIGH(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd32), (val)); \
        } while (0)


/* Defines the rate at which one extra pulse is inserted (Ts). The resulting period will be : Tp*(1+1/Ts)*T192 */
#define GP_WB_READ_BBPLL_FRACT_CLOCK_CYCLE_SKIP_COUNT() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd34))

#define GP_WB_WRITE_BBPLL_FRACT_CLOCK_CYCLE_SKIP_COUNT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd34), (val)); \
        } while (0)


/* controls ldo output voltage */
#define GP_WB_READ_BBPLL_BBPLL_LDO_REFBIT() \
        (GP_WB_S8((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd38)) & 0x0F), 4))

#define GP_WB_WRITE_BBPLL_BBPLL_LDO_REFBIT(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -8, 7); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd38), 0x0F, (UInt8)((val))); \
        } while (0)

/* spare */
#define GP_WB_READ_BBPLL_BBPLL_SPARE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd38)) >> 4) & 0x07)

#define GP_WB_WRITE_BBPLL_BBPLL_SPARE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd38), 0x70, (val) << 4); \
        } while (0)

#define GP_WB_READ_BBPLL_BBPLL_SPARE_RESERVED_0() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd38), 4)

#define GP_WB_WRITE_BBPLL_BBPLL_SPARE_RESERVED_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd38), 4, (val)); \
        } while (0)

#define GP_WB_READ_BBPLL_BBPLL_ANA_SAMP_EN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd38), 5)

#define GP_WB_WRITE_BBPLL_BBPLL_ANA_SAMP_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd38), 5, (val)); \
        } while (0)

#define GP_WB_READ_BBPLL_BBPLL_ANA_SAMP_RETIME_EDGE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd38), 6)

#define GP_WB_WRITE_BBPLL_BBPLL_ANA_SAMP_RETIME_EDGE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd38), 6, (val)); \
        } while (0)

/* speeds up settling timing of bias amplifier */
#define GP_WB_READ_BBPLL_BBPLL_BIAS_AMP_SPEEDUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd38), 7)

#define GP_WB_WRITE_BBPLL_BBPLL_BIAS_AMP_SPEEDUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd38), 7, (val)); \
        } while (0)

/* configures nmos threshold voltage for ring osc */
#define GP_WB_READ_BBPLL_BBPLL_VT_SEL() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd39)) & 0x07)

#define GP_WB_WRITE_BBPLL_BBPLL_VT_SEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd39), 0x07, (val)); \
        } while (0)

/* incr/decr bias current by integer ratio */
#define GP_WB_READ_BBPLL_BBPLL_FREQ_SEL() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd39)) >> 3) & 0x03)

#define GP_WB_WRITE_BBPLL_BBPLL_FREQ_SEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd39), 0x18, (val) << 3); \
        } while (0)

/* bypasses pmos bias filter for quicker settling */
#define GP_WB_READ_BBPLL_BBPLL_BIAS_FILT_BYPASS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd39), 5)

#define GP_WB_WRITE_BBPLL_BBPLL_BIAS_FILT_BYPASS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd39), 5, (val)); \
        } while (0)

/* removes output bleed current from ldo */
#define GP_WB_READ_BBPLL_BBPLL_LDO_BLEED_OFF() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd39), 6)

#define GP_WB_WRITE_BBPLL_BBPLL_LDO_BLEED_OFF(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd39), 6, (val)); \
        } while (0)

/* enables bbpll ldo */
#define GP_WB_READ_BBPLL_BBPLL_LDO_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd39), 7)

#define GP_WB_WRITE_BBPLL_BBPLL_LDO_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd39), 7, (val)); \
        } while (0)

/* bypass filter in ldo for quicker settling */
#define GP_WB_READ_BBPLL_BBPLL_LDO_RES_BYPASS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd3a), 0)

#define GP_WB_WRITE_BBPLL_BBPLL_LDO_RES_BYPASS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd3a), 0, (val)); \
        } while (0)

/* selects edge for retiming of control signals */
#define GP_WB_READ_BBPLL_BBPLL_RETIME_EDGE_SEL() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd3a), 1)

#define GP_WB_WRITE_BBPLL_BBPLL_RETIME_EDGE_SEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd3a), 1, (val)); \
        } while (0)

/* enables retiming of bbpll_dco_tune */
#define GP_WB_READ_BBPLL_BBPLL_RETIME_EN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd3a), 2)

#define GP_WB_WRITE_BBPLL_BBPLL_RETIME_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd3a), 2, (val)); \
        } while (0)

/* powers up bias part of bbpll */
#define GP_WB_READ_BBPLL_BBPLL_RING_BIAS_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd3a), 3)

#define GP_WB_WRITE_BBPLL_BBPLL_RING_BIAS_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd3a), 3, (val)); \
        } while (0)

/* powers up ring osc */
#define GP_WB_READ_BBPLL_BBPLL_RING_OSC_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd3a), 4)

#define GP_WB_WRITE_BBPLL_BBPLL_RING_OSC_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xd3a), 4, (val)); \
        } while (0)

/***************************
 * layout: mm
 ***************************/

/* PBM Entries options base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_OPTS_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe00))

#define GP_WB_WRITE_MM_PBM_OPTS_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe00), (val)); \
        } while (0)


/* PBM 0 data base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_0_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe02))

#define GP_WB_WRITE_MM_PBM_0_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe02), (val)); \
        } while (0)


/* PBM 1 data base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_1_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe04))

#define GP_WB_WRITE_MM_PBM_1_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe04), (val)); \
        } while (0)


/* PBM 2 data base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_2_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe06))

#define GP_WB_WRITE_MM_PBM_2_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe06), (val)); \
        } while (0)


/* PBM 3 data base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_3_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe08))

#define GP_WB_WRITE_MM_PBM_3_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe08), (val)); \
        } while (0)


/* PBM 4 data base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_4_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe0a))

#define GP_WB_WRITE_MM_PBM_4_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe0a), (val)); \
        } while (0)


/* PBM 5 database address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_5_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe0c))

#define GP_WB_WRITE_MM_PBM_5_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe0c), (val)); \
        } while (0)


/* PBM 6 data base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_6_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe0e))

#define GP_WB_WRITE_MM_PBM_6_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe0e), (val)); \
        } while (0)


/* PBM 7 data base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_7_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe10))

#define GP_WB_WRITE_MM_PBM_7_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe10), (val)); \
        } while (0)


/* PBM 8 data base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_8_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe12))

#define GP_WB_WRITE_MM_PBM_8_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe12), (val)); \
        } while (0)


/* PBM 9 data base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_9_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe14))

#define GP_WB_WRITE_MM_PBM_9_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe14), (val)); \
        } while (0)


/* PBM 10 data base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_10_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe16))

#define GP_WB_WRITE_MM_PBM_10_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe16), (val)); \
        } while (0)


/* PBM 11 data base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_11_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe18))

#define GP_WB_WRITE_MM_PBM_11_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe18), (val)); \
        } while (0)


/* PBM 12 data base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_12_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe1a))

#define GP_WB_WRITE_MM_PBM_12_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe1a), (val)); \
        } while (0)


/* PBM 13 data base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_13_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe1c))

#define GP_WB_WRITE_MM_PBM_13_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe1c), (val)); \
        } while (0)


/* PBM 13 data base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_14_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe1e))

#define GP_WB_WRITE_MM_PBM_14_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe1e), (val)); \
        } while (0)


/* PBM 15 data base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_15_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe20))

#define GP_WB_WRITE_MM_PBM_15_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe20), (val)); \
        } while (0)


/* PBM 16 data base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_16_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe22))

#define GP_WB_WRITE_MM_PBM_16_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe22), (val)); \
        } while (0)


/* PBM 17 data base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_17_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe24))

#define GP_WB_WRITE_MM_PBM_17_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe24), (val)); \
        } while (0)


/* PBM 18 data base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_18_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe26))

#define GP_WB_WRITE_MM_PBM_18_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe26), (val)); \
        } while (0)


/* PBM 19 data base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_19_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe28))

#define GP_WB_WRITE_MM_PBM_19_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe28), (val)); \
        } while (0)


/* PBM 20 data base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_20_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe2a))

#define GP_WB_WRITE_MM_PBM_20_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe2a), (val)); \
        } while (0)


/* PBM 21 data base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_21_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe2c))

#define GP_WB_WRITE_MM_PBM_21_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe2c), (val)); \
        } while (0)


/* PBM 22 data base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_22_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe2e))

#define GP_WB_WRITE_MM_PBM_22_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe2e), (val)); \
        } while (0)


/* PBM 23 data base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_23_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe30))

#define GP_WB_WRITE_MM_PBM_23_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe30), (val)); \
        } while (0)


/* PBM 24 data base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_24_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe32))

#define GP_WB_WRITE_MM_PBM_24_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe32), (val)); \
        } while (0)


/* PBM 25 data base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_25_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe34))

#define GP_WB_WRITE_MM_PBM_25_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe34), (val)); \
        } while (0)


/* PBM 26 data base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_26_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe36))

#define GP_WB_WRITE_MM_PBM_26_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe36), (val)); \
        } while (0)


/* PBM 27 data base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_27_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe38))

#define GP_WB_WRITE_MM_PBM_27_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe38), (val)); \
        } while (0)


/* PBM 28 data base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_28_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe3a))

#define GP_WB_WRITE_MM_PBM_28_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe3a), (val)); \
        } while (0)


/* PBM 29 data base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_29_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe3c))

#define GP_WB_WRITE_MM_PBM_29_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe3c), (val)); \
        } while (0)


/* PBM 30 data base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_30_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe3e))

#define GP_WB_WRITE_MM_PBM_30_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe3e), (val)); \
        } while (0)


/* PBM 31 data base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_PBM_31_DATA_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe40))

#define GP_WB_WRITE_MM_PBM_31_DATA_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe40), (val)); \
        } while (0)


/* Event Entries base address ( = offset added to SM_linear start address). Resolution 4 bytes */
#define GP_WB_READ_MM_EVENT_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe42))

#define GP_WB_WRITE_MM_EVENT_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe42), (val)); \
        } while (0)


/* Ram regmap (macfilt, ble_mgr) base address ( = offset added to SM_linear start address). Resolution 4 byte - window size 512 bytes */
#define GP_WB_READ_MM_RAM_REGMAP_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe44))

#define GP_WB_WRITE_MM_RAM_REGMAP_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe44), (val)); \
        } while (0)


/* Circular 0 window base address ( = offset added to SM_linear start address). Resolution 1 byte - window size 128 bytes (repeated twice) */
#define GP_WB_READ_MM_CIRC_WINDOW_0_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe46))

#define GP_WB_WRITE_MM_CIRC_WINDOW_0_BASE_ADDRESS(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe46), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MM_FLASH_CTRL_READ() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe48))

#define GP_WB_WRITE_MM_FLASH_CTRL_READ(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe48), (val))

/* Enables read access to the Flash. Puts the controller in read mode all the time */
#define GP_WB_READ_MM_FLASH_CTRL_READ_EN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe48), 0)

#define GP_WB_GET_MM_FLASH_CTRL_READ_EN_FROM_FLASH_CTRL_READ(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_MM_FLASH_CTRL_READ_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe48), 0, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_CTRL_READ_EN_TO_FLASH_CTRL_READ(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When set to '1', the flash is allowed to go into deep power down mode (for saving power) */
#define GP_WB_READ_MM_FLASH_CTRL_DPDOWN_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe48), 1)

#define GP_WB_GET_MM_FLASH_CTRL_DPDOWN_ENABLE_FROM_FLASH_CTRL_READ(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_MM_FLASH_CTRL_DPDOWN_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe48), 1, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_CTRL_DPDOWN_ENABLE_TO_FLASH_CTRL_READ(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Enables the ECC decoding logic on the flash output data. Can correct up to 2 bits per flash data word */
#define GP_WB_READ_MM_FLASH_ENABLE_ECC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe48), 2)

#define GP_WB_GET_MM_FLASH_ENABLE_ECC_FROM_FLASH_CTRL_READ(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_MM_FLASH_ENABLE_ECC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe48), 2, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_ENABLE_ECC_TO_FLASH_CTRL_READ(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* TESTMODE ... When enabled, the ecc bits will be mapped to teh 16 lsb bits of the 128 bit flash dataword, and can be read out throught the uController read interface */
#define GP_WB_READ_MM_FLASH_TM_MAP_ECC_BITS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe48), 3)

#define GP_WB_GET_MM_FLASH_TM_MAP_ECC_BITS_FROM_FLASH_CTRL_READ(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_MM_FLASH_TM_MAP_ECC_BITS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe48), 3, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_TM_MAP_ECC_BITS_TO_FLASH_CTRL_READ(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* TESTMODE ... When enabled, the 128 bits + 16 ECC bits will be compressed to a 32 bit word (LSB word). The compression algorithm will indicate a 1 on bit position x, when flash dout(x) = flash_dout(x+32) = flash_dout(x+64) = flash_dout(x+96) = flash_dout(x+128). Applies to uController read interface */
#define GP_WB_READ_MM_FLASH_TM_COMPRESS_DOUT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe48), 4)

#define GP_WB_GET_MM_FLASH_TM_COMPRESS_DOUT_FROM_FLASH_CTRL_READ(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_MM_FLASH_TM_COMPRESS_DOUT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe48), 4, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_TM_COMPRESS_DOUT_TO_FLASH_CTRL_READ(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* Clears any latched ECC err-ors */
#define GP_WB_MM_FLASH_CLR_ECC_ERR_MAP() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe49), 0x01)


/* Determines the minimum time (in multiples of 500ns), the flash will wait to do an access after dpdown was released - default according to spec should equal 25 us */
#define GP_WB_READ_MM_FLASH_CTRL_DPDOWN_TIMEOUT() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe4a))

#define GP_WB_WRITE_MM_FLASH_CTRL_DPDOWN_TIMEOUT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe4a), (val)); \
        } while (0)


/* err map of last latched ecc err-ors. (bits 0-3) 1 bit per 32 bit data sub-word + 1 bit (bit 5) for an err-or in 16 bit ecc data itself */
#define GP_WB_READ_MM_FLASH_ECC_ERR_MAP() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe4b))


/* 32 bit word address register for accessing nvm directly -- supports 1MByte flash */
#define GP_WB_READ_MM_MRI_NVM_ADDRESS() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe4c))

#define GP_WB_WRITE_MM_MRI_NVM_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FFFF); \
          GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe4c), (val)); \
        } while (0)


/* 32 bit LSB write date register for writing to nvm */
#define GP_WB_READ_MM_MRI_NVM_WRITE_DATA_0() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe50))

#define GP_WB_WRITE_MM_MRI_NVM_WRITE_DATA_0(val) do { \
          GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe50), (val)); \
        } while (0)


/* 32 bit second write date register for writing to nvm */
#define GP_WB_READ_MM_MRI_NVM_WRITE_DATA_1() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe54))

#define GP_WB_WRITE_MM_MRI_NVM_WRITE_DATA_1(val) do { \
          GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe54), (val)); \
        } while (0)


/* 32 bit third write date register for writing to nvm */
#define GP_WB_READ_MM_MRI_NVM_WRITE_DATA_2() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe58))

#define GP_WB_WRITE_MM_MRI_NVM_WRITE_DATA_2(val) do { \
          GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe58), (val)); \
        } while (0)


/* 32 bit fourth write date register for writing to nvm */
#define GP_WB_READ_MM_MRI_NVM_WRITE_DATA_3() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe5c))

#define GP_WB_WRITE_MM_MRI_NVM_WRITE_DATA_3(val) do { \
          GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe5c), (val)); \
        } while (0)


/* 16 bit ecc data as part of the word to be written. Can also be generated internally */
#define GP_WB_READ_MM_MRI_NVM_WRITE_ECC() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe60))

#define GP_WB_WRITE_MM_MRI_NVM_WRITE_ECC(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe60), (val)); \
        } while (0)


/* 32 bit read data register holding nvm data read LSB */
#define GP_WB_READ_MM_MRI_NVM_READ_DATA_0() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe64))


/* 32 bit read data register holding nvm data read second word */
#define GP_WB_READ_MM_MRI_NVM_READ_DATA_1() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe68))


/* 32 bit read data register holding nvm data read third word */
#define GP_WB_READ_MM_MRI_NVM_READ_DATA_2() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe6c))


/* 32 bit read data register holding nvm data read MSB */
#define GP_WB_READ_MM_MRI_NVM_READ_DATA_3() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe70))


/* 16 bit eccread data register holding 16 bit nvm ecc data */
#define GP_WB_READ_MM_MRI_NVM_READ_ECC() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe74))


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MM_MRI_CONFIG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe76))

#define GP_WB_WRITE_MM_MRI_CONFIG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe76), (val))

/* When direct access is enabled (and the flash is in overrule mode), the mri nvm address and the different flash control bits are directly connected to the flash (so this overrules the signals generated by the mri command). Use this for testing flash or using flash in async mode */
#define GP_WB_READ_MM_MRI_DIRECT_ACCESS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe76), 0)

#define GP_WB_GET_MM_MRI_DIRECT_ACCESS_FROM_MRI_CONFIG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_MM_MRI_DIRECT_ACCESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe76), 0, (val)); \
        } while (0)

#define GP_WB_SET_MM_MRI_DIRECT_ACCESS_TO_MRI_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* when set the flash data word written to NVM will use mri_nvm_write_ecc as ECC bits instead of the internally generated ECC bits */
#define GP_WB_READ_MM_MRI_DONT_USE_INTERNAL_ECC_GENERATION() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe76), 1)

#define GP_WB_GET_MM_MRI_DONT_USE_INTERNAL_ECC_GENERATION_FROM_MRI_CONFIG(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_MM_MRI_DONT_USE_INTERNAL_ECC_GENERATION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe76), 1, (val)); \
        } while (0)

#define GP_WB_SET_MM_MRI_DONT_USE_INTERNAL_ECC_GENERATION_TO_MRI_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MM_MRI_NVM_STATUS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe77))

/* Bit that indicates if the mri is doing an access */
#define GP_WB_READ_MM_MRI_NVM_ACCESS_BUSY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe77), 0)

#define GP_WB_GET_MM_MRI_NVM_ACCESS_BUSY_FROM_MRI_NVM_STATUS(tmp) \
        ((tmp) & 0x01)

/* Bit that indicates if the flash is currently still in deep power down mode */
#define GP_WB_READ_MM_MRI_NVM_IN_DPDOWN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe77), 1)

#define GP_WB_GET_MM_MRI_NVM_IN_DPDOWN_FROM_MRI_NVM_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* Indicates that there was a memory access failure. Cleared on each new access */
#define GP_WB_READ_MM_MRI_NVM_MEMORY_ERR() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe77), 2)

#define GP_WB_GET_MM_MRI_NVM_MEMORY_ERR_FROM_MRI_NVM_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)

/* Indicates that a unmasked write interrupt occurred */
#define GP_WB_READ_MM_MRI_NVM_UNMASKED_ACCESS_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe77), 3)

#define GP_WB_GET_MM_MRI_NVM_UNMASKED_ACCESS_DONE_INTERRUPT_FROM_MRI_NVM_STATUS(tmp) \
        (((tmp) >> 3) & 0x01)


#define GP_WB_WRITE_MM_MRI_NVM_CMD_TRIGGER_CTRL(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe78), (val))

/* trigger a nvm access, defined by the flash_config settings when in overrule mode */
#define GP_WB_MM_MRI_NVM_CMD_TRIGGER() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe78), 0x01)

#define GP_WB_SET_MM_MRI_NVM_CMD_TRIGGER_TO_MRI_NVM_CMD_TRIGGER_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* nvm address post increment */
#define GP_WB_MM_MRI_NVM_AUTO_INCREMENT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe78), 0x02)

#define GP_WB_SET_MM_MRI_NVM_AUTO_INCREMENT_TO_MRI_NVM_CMD_TRIGGER_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* write interrupt clear */
#define GP_WB_MM_MRI_NVM_CLR_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe78), 0x04)

#define GP_WB_SET_MM_MRI_NVM_CLR_INTERRUPT_TO_MRI_NVM_CMD_TRIGGER_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MM_FLASH_CONFIG_0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe79))

#define GP_WB_WRITE_MM_FLASH_CONFIG_0(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe79), (val))

/* When set to '1', the flash pins are directly controlled by the settings in these flash_config registers. Is required to have write access to the flash */
#define GP_WB_READ_MM_FLASH_OVERRULE_MODE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe79), 0)

#define GP_WB_GET_MM_FLASH_OVERRULE_MODE_FROM_FLASH_CONFIG_0(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_MM_FLASH_OVERRULE_MODE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe79), 0, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_OVERRULE_MODE_TO_FLASH_CONFIG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Controls the POR of the flash when in overrule mode */
#define GP_WB_READ_MM_FLASH_POR() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe79), 1)

#define GP_WB_GET_MM_FLASH_POR_FROM_FLASH_CONFIG_0(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_MM_FLASH_POR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe79), 1, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_POR_TO_FLASH_CONFIG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Controls the deep power down mode pin of the flash when in overrule mode */
#define GP_WB_READ_MM_FLASH_DPDOWN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe79), 2)

#define GP_WB_GET_MM_FLASH_DPDOWN_FROM_FLASH_CONFIG_0(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_MM_FLASH_DPDOWN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe79), 2, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_DPDOWN_TO_FLASH_CONFIG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Controls the tmen pin of the flash when in overrule mode */
#define GP_WB_READ_MM_FLASH_TMEN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe79), 3)

#define GP_WB_GET_MM_FLASH_TMEN_FROM_FLASH_CONFIG_0(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_MM_FLASH_TMEN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe79), 3, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_TMEN_TO_FLASH_CONFIG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Controls the rden of the flash when in overrule mode and direct access mode */
#define GP_WB_READ_MM_FLASH_RDEN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe79), 4)

#define GP_WB_GET_MM_FLASH_RDEN_FROM_FLASH_CONFIG_0(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_MM_FLASH_RDEN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe79), 4, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_RDEN_TO_FLASH_CONFIG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Erase retry control pin. "00" for erase */
#define GP_WB_READ_MM_FLASH_RETRY() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe79)) >> 5) & 0x03)

#define GP_WB_GET_MM_FLASH_RETRY_FROM_FLASH_CONFIG_0(tmp) \
        (((tmp) >> 5) & 0x03)

#define GP_WB_WRITE_MM_FLASH_RETRY(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe79), 0x60, (val) << 5); \
        } while (0)

#define GP_WB_SET_MM_FLASH_RETRY_TO_FLASH_CONFIG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x9F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* LVCTL=1 indicates that vdd12 can range from 0.81V to 1.32 V. Flash IP works in low speed */
#define GP_WB_READ_MM_FLASH_LVCTL() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe79), 7)

#define GP_WB_GET_MM_FLASH_LVCTL_FROM_FLASH_CONFIG_0(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_MM_FLASH_LVCTL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe79), 7, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_LVCTL_TO_FLASH_CONFIG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MM_FLASH_CONFIG_1() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7a))

#define GP_WB_WRITE_MM_FLASH_CONFIG_1(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7a), (val))

/* Controls the ceb pin of the flash when in overrule mode (Active low) */
#define GP_WB_READ_MM_FLASH_CEB() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7a), 0)

#define GP_WB_GET_MM_FLASH_CEB_FROM_FLASH_CONFIG_1(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_MM_FLASH_CEB(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7a), 0, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_CEB_TO_FLASH_CONFIG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Controls the web pin of the flash when in overrule mode */
#define GP_WB_READ_MM_FLASH_WEB() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7a), 1)

#define GP_WB_GET_MM_FLASH_WEB_FROM_FLASH_CONFIG_1(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_MM_FLASH_WEB(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7a), 1, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_WEB_TO_FLASH_CONFIG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Controls the confen pin of the flash when in overrule mode */
#define GP_WB_READ_MM_FLASH_CONFEN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7a), 2)

#define GP_WB_GET_MM_FLASH_CONFEN_FROM_FLASH_CONFIG_1(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_MM_FLASH_CONFEN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7a), 2, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_CONFEN_TO_FLASH_CONFIG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Controls the recall pin of the flash when in overrule mode */
#define GP_WB_READ_MM_FLASH_RECALL() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7a), 3)

#define GP_WB_GET_MM_FLASH_RECALL_FROM_FLASH_CONFIG_1(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_MM_FLASH_RECALL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7a), 3, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_RECALL_TO_FLASH_CONFIG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Controls the vread0 pin of the flash when in overrule mode */
#define GP_WB_READ_MM_FLASH_VREAD0() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7a), 4)

#define GP_WB_GET_MM_FLASH_VREAD0_FROM_FLASH_CONFIG_1(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_MM_FLASH_VREAD0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7a), 4, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_VREAD0_TO_FLASH_CONFIG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Controls the vread1 pin of the flash when in overrule mode */
#define GP_WB_READ_MM_FLASH_VREAD1() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7a), 5)

#define GP_WB_GET_MM_FLASH_VREAD1_FROM_FLASH_CONFIG_1(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_MM_FLASH_VREAD1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7a), 5, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_VREAD1_TO_FLASH_CONFIG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* NVR_CFG=1 to select NVR_CFG sector */
#define GP_WB_READ_MM_FLASH_NVR_CFG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7a), 6)

#define GP_WB_GET_MM_FLASH_NVR_CFG_FROM_FLASH_CONFIG_1(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_MM_FLASH_NVR_CFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7a), 6, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_NVR_CFG_TO_FLASH_CONFIG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* LCK_CFG=0 to enable NVR_CFG sector program/erase. Should be 1 in all other cases */
#define GP_WB_READ_MM_FLASH_LCK_CFG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7a), 7)

#define GP_WB_GET_MM_FLASH_LCK_CFG_FROM_FLASH_CONFIG_1(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_MM_FLASH_LCK_CFG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7a), 7, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_LCK_CFG_TO_FLASH_CONFIG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MM_FLASH_CONFIG_2() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7c))

#define GP_WB_WRITE_MM_FLASH_CONFIG_2(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7c), (val))

/* Controls the prog pin of the flash when in overrule mode */
#define GP_WB_READ_MM_FLASH_PROG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7c), 0)

#define GP_WB_GET_MM_FLASH_PROG_FROM_FLASH_CONFIG_2(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_MM_FLASH_PROG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7c), 0, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_PROG_TO_FLASH_CONFIG_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F1E; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Controls the erase pin of the flash when in overrule mode */
#define GP_WB_READ_MM_FLASH_ERASE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7c), 1)

#define GP_WB_GET_MM_FLASH_ERASE_FROM_FLASH_CONFIG_2(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_MM_FLASH_ERASE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7c), 1, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_ERASE_TO_FLASH_CONFIG_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F1D; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

/* Controls the prog2 pin of the flash when in overrule mode */
#define GP_WB_READ_MM_FLASH_PROG2() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7c), 2)

#define GP_WB_GET_MM_FLASH_PROG2_FROM_FLASH_CONFIG_2(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_MM_FLASH_PROG2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7c), 2, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_PROG2_TO_FLASH_CONFIG_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F1B; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* Controls the chip pin of the flash when in overrule mode */
#define GP_WB_READ_MM_FLASH_CHIP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7c), 3)

#define GP_WB_GET_MM_FLASH_CHIP_FROM_FLASH_CONFIG_2(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_MM_FLASH_CHIP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7c), 3, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_CHIP_TO_FLASH_CONFIG_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F17; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

/* Controls the nvr pin of the flash when in overrule mode */
#define GP_WB_READ_MM_FLASH_NVR() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7c), 4)

#define GP_WB_GET_MM_FLASH_NVR_FROM_FLASH_CONFIG_2(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_MM_FLASH_NVR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7c), 4, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_NVR_TO_FLASH_CONFIG_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F0F; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* Controls the arrdn pin of the flash when in overrule mode */
#define GP_WB_READ_MM_FLASH_ARRDN() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7d)) & 0x0F)

#define GP_WB_GET_MM_FLASH_ARRDN_FROM_FLASH_CONFIG_2(tmp) \
        (((tmp) >> 8) & 0x0F)

#define GP_WB_WRITE_MM_FLASH_ARRDN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7d), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_ARRDN_TO_FLASH_CONFIG_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x101F; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* When flash is in direct overrule mode, this bit enables direct access to the di(0) pin, in order to be able to put an analog signal on this pin */
#define GP_WB_READ_MM_FLASH_ENABLE_ANALOG_TEST_MODE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7d), 4)

#define GP_WB_GET_MM_FLASH_ENABLE_ANALOG_TEST_MODE_FROM_FLASH_CONFIG_2(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_MM_FLASH_ENABLE_ANALOG_TEST_MODE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7d), 4, (val)); \
        } while (0)

#define GP_WB_SET_MM_FLASH_ENABLE_ANALOG_TEST_MODE_TO_FLASH_CONFIG_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F1F; \
          (tmp) |= (((UInt16)(val)) << 12); \
        } while (0)


/* Controls the expected flash Tacc time in multiples of 31.25 ns. For normal, minimum wait state operation, this parameter should be set to 0. When using margin read mode it should be set to 7 (~200 ns) */
#define GP_WB_READ_MM_FLASH_READ_ACCESS_DELAY() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7e)) & 0x7F)

#define GP_WB_WRITE_MM_FLASH_READ_ACCESS_DELAY(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7e), 0x7F, (val)); \
        } while (0)

/* When set a 31 ns setup and 31 ns hold time will be guaranteed on the flash read interface. This allows for margin read testmodes to be run through the main read interface. ONLY works if flash_read_access_delay > 1 */
#define GP_WB_READ_MM_FLASH_INCREASED_READ_SETUP_HOLD() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7e), 7)

#define GP_WB_WRITE_MM_FLASH_INCREASED_READ_SETUP_HOLD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe7e), 7, (val)); \
        } while (0)


/* Ram Start address (word address of a 32 bit word) for perfoming a dedicated RAM crc or init */
#define GP_WB_READ_MM_SM_CRC_INIT_START_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe80))

#define GP_WB_WRITE_MM_SM_CRC_INIT_START_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe80), (val)); \
        } while (0)


/* Ram end address (word address of a 32 bit word) for perfoming a dedicated RAM crc or init */
#define GP_WB_READ_MM_SM_CRC_INIT_END_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe82))

#define GP_WB_WRITE_MM_SM_CRC_INIT_END_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe82), (val)); \
        } while (0)


/* Ram Start address (word address of a 32 bit word) for perfoming a dedicated RAM crc or init */
#define GP_WB_READ_MM_UCRAM_CRC_INIT_START_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe84))

#define GP_WB_WRITE_MM_UCRAM_CRC_INIT_START_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe84), (val)); \
        } while (0)


/* Ram end address (word address of a 32 bit word) for perfoming a dedicated RAM crc or init */
#define GP_WB_READ_MM_UCRAM_CRC_INIT_END_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe86))

#define GP_WB_WRITE_MM_UCRAM_CRC_INIT_END_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe86), (val)); \
        } while (0)


/* Result of the crc calculation */
#define GP_WB_READ_MM_SM_CRC_RESULT() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe88))


/* Result of the crc calculation */
#define GP_WB_READ_MM_UCRAM_CRC_RESULT() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe8c))


/* When set to '1', the BIST is allowed to take control of the RAM interface. */
#define GP_WB_READ_MM_BIST_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe90), 0)

#define GP_WB_WRITE_MM_BIST_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe90), (val)); \
        } while (0)


#define GP_WB_WRITE_MM_RAM_OPERATION_TRIGGERS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe91), (val))

/* Triggers the BIST test (when enabled !). Beware ... this will block all other RAM accesses and overwrite ALL  memory content !!! */
#define GP_WB_MM_SM_BIST_START() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe91), 0x01)

#define GP_WB_SET_MM_SM_BIST_START_TO_RAM_OPERATION_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Triggers the CRC calculation on sm ram over the range defined by sm_crc_init_start_address and end address */
#define GP_WB_MM_SM_CRC_START() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe91), 0x02)

#define GP_WB_SET_MM_SM_CRC_START_TO_RAM_OPERATION_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Triggers the CRC calculation on sm ram over the range defined by ram_crc_init_start_address and end address */
#define GP_WB_MM_SM_INIT_START() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe91), 0x04)

#define GP_WB_SET_MM_SM_INIT_START_TO_RAM_OPERATION_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Triggers the BIST  test (when enabled !) on ucram. Beware ... this will block all other RAM accesses and overwrite ALL  memory content !!! */
#define GP_WB_MM_UCRAM_BIST_START() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe91), 0x08)

#define GP_WB_SET_MM_UCRAM_BIST_START_TO_RAM_OPERATION_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Triggers the CRC calculation on ucram over the range defined by ucram_crc_init_start_address and end address */
#define GP_WB_MM_UCRAM_CRC_START() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe91), 0x10)

#define GP_WB_SET_MM_UCRAM_CRC_START_TO_RAM_OPERATION_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Triggers the CRC calculation on ucram over the range defined by ucram_crc_init_start_address and end address */
#define GP_WB_MM_UCRAM_INIT_START() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe91), 0x20)

#define GP_WB_SET_MM_UCRAM_INIT_START_TO_RAM_OPERATION_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* Triggers the Fast retention rgisters backup */
#define GP_WB_MM_BACKUP_START() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe91), 0x40)

#define GP_WB_SET_MM_BACKUP_START_TO_RAM_OPERATION_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* Triggers the Fast retetntion registers restore */
#define GP_WB_MM_RESTORE_START() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe91), 0x80)

#define GP_WB_SET_MM_RESTORE_START_TO_RAM_OPERATION_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MM_RAM_OPERATION_STATUS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe92))

/* Indicates that the BIST test is finished */
#define GP_WB_READ_MM_SM_BIST_RDY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe92), 0)

#define GP_WB_GET_MM_SM_BIST_RDY_FROM_RAM_OPERATION_STATUS(tmp) \
        ((tmp) & 0x01)

/* Indicates that the BIST test passed or failed */
#define GP_WB_READ_MM_SM_BIST_OK() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe92), 1)

#define GP_WB_GET_MM_SM_BIST_OK_FROM_RAM_OPERATION_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* Indicates that the BIST test is finished */
#define GP_WB_READ_MM_UCRAM_BIST_RDY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe92), 2)

#define GP_WB_GET_MM_UCRAM_BIST_RDY_FROM_RAM_OPERATION_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)

/* Indicates that the BIST test passed or failed */
#define GP_WB_READ_MM_UCRAM_BIST_OK() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe92), 3)

#define GP_WB_GET_MM_UCRAM_BIST_OK_FROM_RAM_OPERATION_STATUS(tmp) \
        (((tmp) >> 3) & 0x01)

/* Indicates that the ram crc calculation or init is ongoing */
#define GP_WB_READ_MM_SM_CRC_INIT_BUSY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe92), 4)

#define GP_WB_GET_MM_SM_CRC_INIT_BUSY_FROM_RAM_OPERATION_STATUS(tmp) \
        (((tmp) >> 4) & 0x01)

/* Indicates that the ram crc calculation or init is ongoing */
#define GP_WB_READ_MM_UCRAM_CRC_INIT_BUSY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe92), 5)

#define GP_WB_GET_MM_UCRAM_CRC_INIT_BUSY_FROM_RAM_OPERATION_STATUS(tmp) \
        (((tmp) >> 5) & 0x01)


#define GP_WB_WRITE_MM_FLASH_CONV_BUFFER_INVALIDATE(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe93), (val))

/* Invalidate the buffer content for flash conv_0 (Security engine) */
#define GP_WB_MM_CONV_0_BUFFER_INVALIDATE() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe93), 0x01)

#define GP_WB_SET_MM_CONV_0_BUFFER_INVALIDATE_TO_FLASH_CONV_BUFFER_INVALIDATE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Invalidate the buffer content for flash conv_1 (MSI, PHY_SIG, SSP, GPM_DM) */
#define GP_WB_MM_CONV_1_BUFFER_INVALIDATE() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe93), 0x02)

#define GP_WB_SET_MM_CONV_1_BUFFER_INVALIDATE_TO_FLASH_CONV_BUFFER_INVALIDATE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Invalidate the buffer content for flash conv_2 (GPM_PM) */
#define GP_WB_MM_CONV_2_BUFFER_INVALIDATE() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe93), 0x04)

#define GP_WB_SET_MM_CONV_2_BUFFER_INVALIDATE_TO_FLASH_CONV_BUFFER_INVALIDATE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Invalidate the buffer content for flash conv_3 (ARM_DCODE) */
#define GP_WB_MM_CONV_3_BUFFER_INVALIDATE() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe93), 0x08)

#define GP_WB_SET_MM_CONV_3_BUFFER_INVALIDATE_TO_FLASH_CONV_BUFFER_INVALIDATE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Invalidate the buffer content for flash conv_4 (ARM_ICODE) */
#define GP_WB_MM_CONV_4_BUFFER_INVALIDATE() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe93), 0x10)

#define GP_WB_SET_MM_CONV_4_BUFFER_INVALIDATE_TO_FLASH_CONV_BUFFER_INVALIDATE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MM_FLASH_CONV_CONFIG() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe94))

#define GP_WB_WRITE_MM_FLASH_CONV_CONFIG(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe94), (val))

/* Disable the buffer for flash conv_1 (Security engines). Each access will result in a flash access. Also invalidated the buffer content. */
#define GP_WB_READ_MM_CONV_0_BUFFER_DISABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe94), 0)

#define GP_WB_GET_MM_CONV_0_BUFFER_DISABLE_FROM_FLASH_CONV_CONFIG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_MM_CONV_0_BUFFER_DISABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe94), 0, (val)); \
        } while (0)

#define GP_WB_SET_MM_CONV_0_BUFFER_DISABLE_TO_FLASH_CONV_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FE; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Disable the buffer for flash conv_1 (MSI, PHY_SIG, SSP, GPM_DM). Each access will result in a flash access. Also invalidated the buffer content. */
#define GP_WB_READ_MM_CONV_1_BUFFER_DISABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe94), 1)

#define GP_WB_GET_MM_CONV_1_BUFFER_DISABLE_FROM_FLASH_CONV_CONFIG(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_MM_CONV_1_BUFFER_DISABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe94), 1, (val)); \
        } while (0)

#define GP_WB_SET_MM_CONV_1_BUFFER_DISABLE_TO_FLASH_CONV_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FD; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

/* Disable the buffer for flash conv_2 (GPM_PM). Each access will result in a flash access. Also invalidated the buffer content. */
#define GP_WB_READ_MM_CONV_2_BUFFER_DISABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe94), 2)

#define GP_WB_GET_MM_CONV_2_BUFFER_DISABLE_FROM_FLASH_CONV_CONFIG(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_MM_CONV_2_BUFFER_DISABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe94), 2, (val)); \
        } while (0)

#define GP_WB_SET_MM_CONV_2_BUFFER_DISABLE_TO_FLASH_CONV_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FB; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* Disable the buffer for flash conv_3 (ARM_DCODE). Each access will result in a flash access. Also invalidated the buffer content. */
#define GP_WB_READ_MM_CONV_3_BUFFER_DISABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe94), 3)

#define GP_WB_GET_MM_CONV_3_BUFFER_DISABLE_FROM_FLASH_CONV_CONFIG(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_MM_CONV_3_BUFFER_DISABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe94), 3, (val)); \
        } while (0)

#define GP_WB_SET_MM_CONV_3_BUFFER_DISABLE_TO_FLASH_CONV_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03F7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

/* Disable the buffer for flash conv_4 (ARM_ICODE). Each access will result in a flash access. Also invalidated the buffer content. */
#define GP_WB_READ_MM_CONV_4_BUFFER_DISABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe94), 4)

#define GP_WB_GET_MM_CONV_4_BUFFER_DISABLE_FROM_FLASH_CONV_CONFIG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_MM_CONV_4_BUFFER_DISABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe94), 4, (val)); \
        } while (0)

#define GP_WB_SET_MM_CONV_4_BUFFER_DISABLE_TO_FLASH_CONV_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03EF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* Disable the prefecting for flash conv_4 (ARM_ICODE). Results in a trailing buffer only (mini cache) behavior. */
#define GP_WB_READ_MM_CONV_4_PREFETCHER_DISABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe94), 5)

#define GP_WB_GET_MM_CONV_4_PREFETCHER_DISABLE_FROM_FLASH_CONV_CONFIG(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_MM_CONV_4_PREFETCHER_DISABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe94), 5, (val)); \
        } while (0)

#define GP_WB_SET_MM_CONV_4_PREFETCHER_DISABLE_TO_FLASH_CONV_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03DF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

/* Disable halting the prefecter upon a decode time conditional branch backwards. */
#define GP_WB_READ_MM_CONV_4_BRCHSTAT1_HALT_PREFETCH_DISABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe94), 6)

#define GP_WB_GET_MM_CONV_4_BRCHSTAT1_HALT_PREFETCH_DISABLE_FROM_FLASH_CONV_CONFIG(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_MM_CONV_4_BRCHSTAT1_HALT_PREFETCH_DISABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe94), 6, (val)); \
        } while (0)

#define GP_WB_SET_MM_CONV_4_BRCHSTAT1_HALT_PREFETCH_DISABLE_TO_FLASH_CONV_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03BF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

/* Disable halting the prefecter upon a decode time conditional branch. */
#define GP_WB_READ_MM_CONV_4_BRCHSTAT2_HALT_PREFETCH_DISABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe94), 7)

#define GP_WB_GET_MM_CONV_4_BRCHSTAT2_HALT_PREFETCH_DISABLE_FROM_FLASH_CONV_CONFIG(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_MM_CONV_4_BRCHSTAT2_HALT_PREFETCH_DISABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe94), 7, (val)); \
        } while (0)

#define GP_WB_SET_MM_CONV_4_BRCHSTAT2_HALT_PREFETCH_DISABLE_TO_FLASH_CONV_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x037F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* Disable halting the prefecter upon a execute time conditional branch. */
#define GP_WB_READ_MM_CONV_4_BRCHSTAT3_HALT_PREFETCH_DISABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe95), 0)

#define GP_WB_GET_MM_CONV_4_BRCHSTAT3_HALT_PREFETCH_DISABLE_FROM_FLASH_CONV_CONFIG(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_MM_CONV_4_BRCHSTAT3_HALT_PREFETCH_DISABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe95), 0, (val)); \
        } while (0)

#define GP_WB_SET_MM_CONV_4_BRCHSTAT3_HALT_PREFETCH_DISABLE_TO_FLASH_CONV_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* Select between 2 versions of replacement config (dumb and dumber). */
#define GP_WB_READ_MM_CONV_4_REPLACEMENT_CONFIG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe95), 1)

#define GP_WB_GET_MM_CONV_4_REPLACEMENT_CONFIG_FROM_FLASH_CONV_CONFIG(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_MM_CONV_4_REPLACEMENT_CONFIG(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe95), 1, (val)); \
        } while (0)

#define GP_WB_SET_MM_CONV_4_REPLACEMENT_CONFIG_TO_FLASH_CONV_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)


/* Enables the ahb MRI */
#define GP_WB_READ_MM_MRI_AHB_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe96), 0)

#define GP_WB_WRITE_MM_MRI_AHB_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe96), (val)); \
        } while (0)


/* 16 bit address register for accessing the ahb bus directly */
#define GP_WB_READ_MM_MRI_AHB_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe98))

#define GP_WB_WRITE_MM_MRI_AHB_ADDRESS(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe98), (val)); \
        } while (0)


/* 32 bit write date register for writing to the ahb bus */
#define GP_WB_READ_MM_MRI_AHB_WRITE_DATA() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe9c))

#define GP_WB_WRITE_MM_MRI_AHB_WRITE_DATA(val) do { \
          GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xe9c), (val)); \
        } while (0)


/* 32 bit read data register holding ahb data read */
#define GP_WB_READ_MM_MRI_AHB_READ_DATA() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xea0))


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MM_MRI_AHB_STATUS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xea4))

/* Bit that indicates if the mri is doing an access */
#define GP_WB_READ_MM_MRI_AHB_ACCESS_BUSY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xea4), 0)

#define GP_WB_GET_MM_MRI_AHB_ACCESS_BUSY_FROM_MRI_AHB_STATUS(tmp) \
        ((tmp) & 0x01)

/* Indicates that there was an access failure */
#define GP_WB_READ_MM_MRI_AHB_ACCESS_ERR() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xea4), 1)

#define GP_WB_GET_MM_MRI_AHB_ACCESS_ERR_FROM_MRI_AHB_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)


#define GP_WB_WRITE_MM_MRI_AHB_CMD_TRIGGER_CTRL(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xea5), (val))

/* trigger a ahb access, defined by the flash_config settings when in overrule mode */
#define GP_WB_MM_MRI_AHB_WR_CMD_TRIGGER() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xea5), 0x01)

#define GP_WB_SET_MM_MRI_AHB_WR_CMD_TRIGGER_TO_MRI_AHB_CMD_TRIGGER_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* trigger a ahb access, defined by the flash_config settings when in overrule mode */
#define GP_WB_MM_MRI_AHB_RD_CMD_TRIGGER() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xea5), 0x02)

#define GP_WB_SET_MM_MRI_AHB_RD_CMD_TRIGGER_TO_MRI_AHB_CMD_TRIGGER_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* clear the ahb access error flag */
#define GP_WB_MM_MRI_AHB_CLR_ACCESS_ERR() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xea5), 0x04)

#define GP_WB_SET_MM_MRI_AHB_CLR_ACCESS_ERR_TO_MRI_AHB_CMD_TRIGGER_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* 32 bit rom word address for rom patching */
#define GP_WB_READ_MM_ROM_PATCH_ENTRY_0_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xea6))

#define GP_WB_WRITE_MM_ROM_PATCH_ENTRY_0_ADDRESS(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xea6), (val)); \
        } while (0)


/* 32 bit patch data */
#define GP_WB_READ_MM_ROM_PATCH_ENTRY_0_DATA() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xea8))

#define GP_WB_WRITE_MM_ROM_PATCH_ENTRY_0_DATA(val) do { \
          GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xea8), (val)); \
        } while (0)


/* 32 bit rom word address for rom patching */
#define GP_WB_READ_MM_ROM_PATCH_ENTRY_1_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xeac))

#define GP_WB_WRITE_MM_ROM_PATCH_ENTRY_1_ADDRESS(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xeac), (val)); \
        } while (0)


/* 32 bit patch data */
#define GP_WB_READ_MM_ROM_PATCH_ENTRY_1_DATA() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xeb0))

#define GP_WB_WRITE_MM_ROM_PATCH_ENTRY_1_DATA(val) do { \
          GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xeb0), (val)); \
        } while (0)


/* 32 bit rom word address for rom patching */
#define GP_WB_READ_MM_ROM_PATCH_ENTRY_2_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xeb4))

#define GP_WB_WRITE_MM_ROM_PATCH_ENTRY_2_ADDRESS(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xeb4), (val)); \
        } while (0)


/* 32 bit patch data */
#define GP_WB_READ_MM_ROM_PATCH_ENTRY_2_DATA() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xeb8))

#define GP_WB_WRITE_MM_ROM_PATCH_ENTRY_2_DATA(val) do { \
          GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xeb8), (val)); \
        } while (0)


/* 32 bit rom word address for rom patching */
#define GP_WB_READ_MM_ROM_PATCH_ENTRY_3_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xebc))

#define GP_WB_WRITE_MM_ROM_PATCH_ENTRY_3_ADDRESS(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xebc), (val)); \
        } while (0)


/* 32 bit patch data */
#define GP_WB_READ_MM_ROM_PATCH_ENTRY_3_DATA() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xec0))

#define GP_WB_WRITE_MM_ROM_PATCH_ENTRY_3_DATA(val) do { \
          GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xec0), (val)); \
        } while (0)


/* 32 bit rom word address for rom patching */
#define GP_WB_READ_MM_ROM_PATCH_ENTRY_4_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xec4))

#define GP_WB_WRITE_MM_ROM_PATCH_ENTRY_4_ADDRESS(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xec4), (val)); \
        } while (0)


/* 32 bit patch data */
#define GP_WB_READ_MM_ROM_PATCH_ENTRY_4_DATA() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xec8))

#define GP_WB_WRITE_MM_ROM_PATCH_ENTRY_4_DATA(val) do { \
          GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xec8), (val)); \
        } while (0)


/* 32 bit rom word address for rom patching */
#define GP_WB_READ_MM_ROM_PATCH_ENTRY_5_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xecc))

#define GP_WB_WRITE_MM_ROM_PATCH_ENTRY_5_ADDRESS(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xecc), (val)); \
        } while (0)


/* 32 bit patch data */
#define GP_WB_READ_MM_ROM_PATCH_ENTRY_5_DATA() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xed0))

#define GP_WB_WRITE_MM_ROM_PATCH_ENTRY_5_DATA(val) do { \
          GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xed0), (val)); \
        } while (0)


/* 32 bit rom word address for rom patching */
#define GP_WB_READ_MM_ROM_PATCH_ENTRY_6_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xed4))

#define GP_WB_WRITE_MM_ROM_PATCH_ENTRY_6_ADDRESS(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xed4), (val)); \
        } while (0)


/* 32 bit patch data */
#define GP_WB_READ_MM_ROM_PATCH_ENTRY_6_DATA() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xed8))

#define GP_WB_WRITE_MM_ROM_PATCH_ENTRY_6_DATA(val) do { \
          GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xed8), (val)); \
        } while (0)


/* 32 bit rom word address for rom patching */
#define GP_WB_READ_MM_ROM_PATCH_ENTRY_7_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xedc))

#define GP_WB_WRITE_MM_ROM_PATCH_ENTRY_7_ADDRESS(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xedc), (val)); \
        } while (0)


/* 32 bit patch data */
#define GP_WB_READ_MM_ROM_PATCH_ENTRY_7_DATA() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xee0))

#define GP_WB_WRITE_MM_ROM_PATCH_ENTRY_7_DATA(val) do { \
          GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xee0), (val)); \
        } while (0)


/* when set patch entry will be used */
#define GP_WB_READ_MM_ROM_PATCH_ENTRY_0_VALID() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xee4), 0)

#define GP_WB_WRITE_MM_ROM_PATCH_ENTRY_0_VALID(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xee4), 0, (val)); \
        } while (0)

/* when set patch entry will be used */
#define GP_WB_READ_MM_ROM_PATCH_ENTRY_1_VALID() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xee4), 1)

#define GP_WB_WRITE_MM_ROM_PATCH_ENTRY_1_VALID(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xee4), 1, (val)); \
        } while (0)

/* when set patch entry will be used */
#define GP_WB_READ_MM_ROM_PATCH_ENTRY_2_VALID() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xee4), 2)

#define GP_WB_WRITE_MM_ROM_PATCH_ENTRY_2_VALID(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xee4), 2, (val)); \
        } while (0)

/* when set patch entry will be used */
#define GP_WB_READ_MM_ROM_PATCH_ENTRY_3_VALID() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xee4), 3)

#define GP_WB_WRITE_MM_ROM_PATCH_ENTRY_3_VALID(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xee4), 3, (val)); \
        } while (0)

/* when set patch entry will be used */
#define GP_WB_READ_MM_ROM_PATCH_ENTRY_4_VALID() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xee4), 4)

#define GP_WB_WRITE_MM_ROM_PATCH_ENTRY_4_VALID(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xee4), 4, (val)); \
        } while (0)

/* when set patch entry will be used */
#define GP_WB_READ_MM_ROM_PATCH_ENTRY_5_VALID() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xee4), 5)

#define GP_WB_WRITE_MM_ROM_PATCH_ENTRY_5_VALID(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xee4), 5, (val)); \
        } while (0)

/* when set patch entry will be used */
#define GP_WB_READ_MM_ROM_PATCH_ENTRY_6_VALID() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xee4), 6)

#define GP_WB_WRITE_MM_ROM_PATCH_ENTRY_6_VALID(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xee4), 6, (val)); \
        } while (0)

/* when set patch entry will be used */
#define GP_WB_READ_MM_ROM_PATCH_ENTRY_7_VALID() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xee4), 7)

#define GP_WB_WRITE_MM_ROM_PATCH_ENTRY_7_VALID(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xee4), 7, (val)); \
        } while (0)

/***************************
 * layout: pbm_adm
 ***************************/

/* PBM entry external uC bit mask (bit 1 = '1' => entry 1 can be claimed, etc.) */
#define GP_WB_READ_PBM_ADM_PBM_ENTRY_UC_MASK() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xf00))

#define GP_WB_WRITE_PBM_ADM_PBM_ENTRY_UC_MASK(val) do { \
          GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xf00), (val)); \
        } while (0)


/* PBM entry RT-MAC bit mask (bit 2 = '1' => entry 2 can be claimed, etc.) */
#define GP_WB_READ_PBM_ADM_PBM_ENTRY_RXMAC_MASK() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xf04))

#define GP_WB_WRITE_PBM_ADM_PBM_ENTRY_RXMAC_MASK(val) do { \
          GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xf04), (val)); \
        } while (0)


/* Claim PBM entry by external uC, read to claim an available one */
#define GP_WB_READ_PBM_ADM_PBM_ENTRY_CLAIM() \
        GP_WB_READ_SER_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xf08))


/* Free PBM entry by writing a number */
#define GP_WB_WRITE_PBM_ADM_PBM_ENTRY_RETURN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xf09), (val)); \
        } while (0)


/* Currently claimed PBM entries (bit 0 = '1' => entry 0 is claimed ect.) */
#define GP_WB_READ_PBM_ADM_PBM_ENTRY_CLAIMED() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xf0c))

#define GP_WB_WRITE_PBM_ADM_PBM_ENTRY_CLAIMED(val) do { \
          GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0xf0c), (val)); \
        } while (0)

/***************************
 * layout: gpio
 ***************************/

/* Gpio clock enabled when 0x1 */
#define GP_WB_READ_GPIO_GPIO_CLOCK_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1000), 0)

#define GP_WB_WRITE_GPIO_GPIO_CLOCK_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1000), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_GPIO_GPIO_PORTA_DIRECTION() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1001))

#define GP_WB_WRITE_GPIO_GPIO_PORTA_DIRECTION(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1001), (val))

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO0_DIRECTION() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1001), 0)

#define GP_WB_GET_GPIO_GPIO0_DIRECTION_FROM_GPIO_PORTA_DIRECTION(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO0_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1001), 0, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO0_DIRECTION_TO_GPIO_PORTA_DIRECTION(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO1_DIRECTION() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1001), 1)

#define GP_WB_GET_GPIO_GPIO1_DIRECTION_FROM_GPIO_PORTA_DIRECTION(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO1_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1001), 1, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO1_DIRECTION_TO_GPIO_PORTA_DIRECTION(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO2_DIRECTION() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1001), 2)

#define GP_WB_GET_GPIO_GPIO2_DIRECTION_FROM_GPIO_PORTA_DIRECTION(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO2_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1001), 2, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO2_DIRECTION_TO_GPIO_PORTA_DIRECTION(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO3_DIRECTION() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1001), 3)

#define GP_WB_GET_GPIO_GPIO3_DIRECTION_FROM_GPIO_PORTA_DIRECTION(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO3_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1001), 3, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO3_DIRECTION_TO_GPIO_PORTA_DIRECTION(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO4_DIRECTION() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1001), 4)

#define GP_WB_GET_GPIO_GPIO4_DIRECTION_FROM_GPIO_PORTA_DIRECTION(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO4_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1001), 4, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO4_DIRECTION_TO_GPIO_PORTA_DIRECTION(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO5_DIRECTION() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1001), 5)

#define GP_WB_GET_GPIO_GPIO5_DIRECTION_FROM_GPIO_PORTA_DIRECTION(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO5_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1001), 5, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO5_DIRECTION_TO_GPIO_PORTA_DIRECTION(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO6_DIRECTION() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1001), 6)

#define GP_WB_GET_GPIO_GPIO6_DIRECTION_FROM_GPIO_PORTA_DIRECTION(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO6_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1001), 6, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO6_DIRECTION_TO_GPIO_PORTA_DIRECTION(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO7_DIRECTION() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1001), 7)

#define GP_WB_GET_GPIO_GPIO7_DIRECTION_FROM_GPIO_PORTA_DIRECTION(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO7_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1001), 7, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO7_DIRECTION_TO_GPIO_PORTA_DIRECTION(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_GPIO_GPIO_PORTB_DIRECTION() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1002))

#define GP_WB_WRITE_GPIO_GPIO_PORTB_DIRECTION(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1002), (val))

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO8_DIRECTION() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1002), 0)

#define GP_WB_GET_GPIO_GPIO8_DIRECTION_FROM_GPIO_PORTB_DIRECTION(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO8_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1002), 0, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO8_DIRECTION_TO_GPIO_PORTB_DIRECTION(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO9_DIRECTION() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1002), 1)

#define GP_WB_GET_GPIO_GPIO9_DIRECTION_FROM_GPIO_PORTB_DIRECTION(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO9_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1002), 1, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO9_DIRECTION_TO_GPIO_PORTB_DIRECTION(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO10_DIRECTION() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1002), 2)

#define GP_WB_GET_GPIO_GPIO10_DIRECTION_FROM_GPIO_PORTB_DIRECTION(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO10_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1002), 2, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO10_DIRECTION_TO_GPIO_PORTB_DIRECTION(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO11_DIRECTION() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1002), 3)

#define GP_WB_GET_GPIO_GPIO11_DIRECTION_FROM_GPIO_PORTB_DIRECTION(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO11_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1002), 3, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO11_DIRECTION_TO_GPIO_PORTB_DIRECTION(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO12_DIRECTION() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1002), 4)

#define GP_WB_GET_GPIO_GPIO12_DIRECTION_FROM_GPIO_PORTB_DIRECTION(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO12_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1002), 4, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO12_DIRECTION_TO_GPIO_PORTB_DIRECTION(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO13_DIRECTION() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1002), 5)

#define GP_WB_GET_GPIO_GPIO13_DIRECTION_FROM_GPIO_PORTB_DIRECTION(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO13_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1002), 5, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO13_DIRECTION_TO_GPIO_PORTB_DIRECTION(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO14_DIRECTION() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1002), 6)

#define GP_WB_GET_GPIO_GPIO14_DIRECTION_FROM_GPIO_PORTB_DIRECTION(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO14_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1002), 6, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO14_DIRECTION_TO_GPIO_PORTB_DIRECTION(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO15_DIRECTION() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1002), 7)

#define GP_WB_GET_GPIO_GPIO15_DIRECTION_FROM_GPIO_PORTB_DIRECTION(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO15_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1002), 7, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO15_DIRECTION_TO_GPIO_PORTB_DIRECTION(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_GPIO_GPIO_PORTC_DIRECTION() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1003))

#define GP_WB_WRITE_GPIO_GPIO_PORTC_DIRECTION(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1003), (val))

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO16_DIRECTION() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1003), 0)

#define GP_WB_GET_GPIO_GPIO16_DIRECTION_FROM_GPIO_PORTC_DIRECTION(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO16_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1003), 0, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO16_DIRECTION_TO_GPIO_PORTC_DIRECTION(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO17_DIRECTION() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1003), 1)

#define GP_WB_GET_GPIO_GPIO17_DIRECTION_FROM_GPIO_PORTC_DIRECTION(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO17_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1003), 1, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO17_DIRECTION_TO_GPIO_PORTC_DIRECTION(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO18_DIRECTION() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1003), 2)

#define GP_WB_GET_GPIO_GPIO18_DIRECTION_FROM_GPIO_PORTC_DIRECTION(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO18_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1003), 2, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO18_DIRECTION_TO_GPIO_PORTC_DIRECTION(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO19_DIRECTION() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1003), 3)

#define GP_WB_GET_GPIO_GPIO19_DIRECTION_FROM_GPIO_PORTC_DIRECTION(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO19_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1003), 3, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO19_DIRECTION_TO_GPIO_PORTC_DIRECTION(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x77; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO20_DIRECTION() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1003), 4)

#define GP_WB_GET_GPIO_GPIO20_DIRECTION_FROM_GPIO_PORTC_DIRECTION(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO20_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1003), 4, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO20_DIRECTION_TO_GPIO_PORTC_DIRECTION(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x6F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO21_DIRECTION() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1003), 5)

#define GP_WB_GET_GPIO_GPIO21_DIRECTION_FROM_GPIO_PORTC_DIRECTION(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO21_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1003), 5, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO21_DIRECTION_TO_GPIO_PORTC_DIRECTION(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x5F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* 0 = input, 1 = output */
#define GP_WB_READ_GPIO_GPIO22_DIRECTION() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1003), 6)

#define GP_WB_GET_GPIO_GPIO22_DIRECTION_FROM_GPIO_PORTC_DIRECTION(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO22_DIRECTION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1003), 6, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO22_DIRECTION_TO_GPIO_PORTC_DIRECTION(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_GPIO_GPIO_PORTA_OUTPUT_VALUE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1004))

#define GP_WB_WRITE_GPIO_GPIO_PORTA_OUTPUT_VALUE(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1004), (val))

#define GP_WB_READ_GPIO_GPIO0_OUTPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1004), 0)

#define GP_WB_GET_GPIO_GPIO0_OUTPUT_VALUE_FROM_GPIO_PORTA_OUTPUT_VALUE(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO0_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1004), 0, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO0_OUTPUT_VALUE_TO_GPIO_PORTA_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO1_OUTPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1004), 1)

#define GP_WB_GET_GPIO_GPIO1_OUTPUT_VALUE_FROM_GPIO_PORTA_OUTPUT_VALUE(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO1_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1004), 1, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO1_OUTPUT_VALUE_TO_GPIO_PORTA_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO2_OUTPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1004), 2)

#define GP_WB_GET_GPIO_GPIO2_OUTPUT_VALUE_FROM_GPIO_PORTA_OUTPUT_VALUE(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO2_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1004), 2, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO2_OUTPUT_VALUE_TO_GPIO_PORTA_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO3_OUTPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1004), 3)

#define GP_WB_GET_GPIO_GPIO3_OUTPUT_VALUE_FROM_GPIO_PORTA_OUTPUT_VALUE(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO3_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1004), 3, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO3_OUTPUT_VALUE_TO_GPIO_PORTA_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO4_OUTPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1004), 4)

#define GP_WB_GET_GPIO_GPIO4_OUTPUT_VALUE_FROM_GPIO_PORTA_OUTPUT_VALUE(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO4_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1004), 4, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO4_OUTPUT_VALUE_TO_GPIO_PORTA_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO5_OUTPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1004), 5)

#define GP_WB_GET_GPIO_GPIO5_OUTPUT_VALUE_FROM_GPIO_PORTA_OUTPUT_VALUE(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO5_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1004), 5, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO5_OUTPUT_VALUE_TO_GPIO_PORTA_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO6_OUTPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1004), 6)

#define GP_WB_GET_GPIO_GPIO6_OUTPUT_VALUE_FROM_GPIO_PORTA_OUTPUT_VALUE(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO6_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1004), 6, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO6_OUTPUT_VALUE_TO_GPIO_PORTA_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO7_OUTPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1004), 7)

#define GP_WB_GET_GPIO_GPIO7_OUTPUT_VALUE_FROM_GPIO_PORTA_OUTPUT_VALUE(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO7_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1004), 7, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO7_OUTPUT_VALUE_TO_GPIO_PORTA_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_GPIO_GPIO_PORTB_OUTPUT_VALUE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1005))

#define GP_WB_WRITE_GPIO_GPIO_PORTB_OUTPUT_VALUE(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1005), (val))

#define GP_WB_READ_GPIO_GPIO8_OUTPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1005), 0)

#define GP_WB_GET_GPIO_GPIO8_OUTPUT_VALUE_FROM_GPIO_PORTB_OUTPUT_VALUE(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO8_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1005), 0, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO8_OUTPUT_VALUE_TO_GPIO_PORTB_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO9_OUTPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1005), 1)

#define GP_WB_GET_GPIO_GPIO9_OUTPUT_VALUE_FROM_GPIO_PORTB_OUTPUT_VALUE(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO9_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1005), 1, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO9_OUTPUT_VALUE_TO_GPIO_PORTB_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO10_OUTPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1005), 2)

#define GP_WB_GET_GPIO_GPIO10_OUTPUT_VALUE_FROM_GPIO_PORTB_OUTPUT_VALUE(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO10_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1005), 2, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO10_OUTPUT_VALUE_TO_GPIO_PORTB_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO11_OUTPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1005), 3)

#define GP_WB_GET_GPIO_GPIO11_OUTPUT_VALUE_FROM_GPIO_PORTB_OUTPUT_VALUE(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO11_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1005), 3, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO11_OUTPUT_VALUE_TO_GPIO_PORTB_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO12_OUTPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1005), 4)

#define GP_WB_GET_GPIO_GPIO12_OUTPUT_VALUE_FROM_GPIO_PORTB_OUTPUT_VALUE(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO12_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1005), 4, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO12_OUTPUT_VALUE_TO_GPIO_PORTB_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO13_OUTPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1005), 5)

#define GP_WB_GET_GPIO_GPIO13_OUTPUT_VALUE_FROM_GPIO_PORTB_OUTPUT_VALUE(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO13_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1005), 5, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO13_OUTPUT_VALUE_TO_GPIO_PORTB_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO14_OUTPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1005), 6)

#define GP_WB_GET_GPIO_GPIO14_OUTPUT_VALUE_FROM_GPIO_PORTB_OUTPUT_VALUE(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO14_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1005), 6, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO14_OUTPUT_VALUE_TO_GPIO_PORTB_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO15_OUTPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1005), 7)

#define GP_WB_GET_GPIO_GPIO15_OUTPUT_VALUE_FROM_GPIO_PORTB_OUTPUT_VALUE(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO15_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1005), 7, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO15_OUTPUT_VALUE_TO_GPIO_PORTB_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_GPIO_GPIO_PORTC_OUTPUT_VALUE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1006))

#define GP_WB_WRITE_GPIO_GPIO_PORTC_OUTPUT_VALUE(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1006), (val))

#define GP_WB_READ_GPIO_GPIO16_OUTPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1006), 0)

#define GP_WB_GET_GPIO_GPIO16_OUTPUT_VALUE_FROM_GPIO_PORTC_OUTPUT_VALUE(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO16_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1006), 0, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO16_OUTPUT_VALUE_TO_GPIO_PORTC_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO17_OUTPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1006), 1)

#define GP_WB_GET_GPIO_GPIO17_OUTPUT_VALUE_FROM_GPIO_PORTC_OUTPUT_VALUE(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO17_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1006), 1, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO17_OUTPUT_VALUE_TO_GPIO_PORTC_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO18_OUTPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1006), 2)

#define GP_WB_GET_GPIO_GPIO18_OUTPUT_VALUE_FROM_GPIO_PORTC_OUTPUT_VALUE(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO18_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1006), 2, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO18_OUTPUT_VALUE_TO_GPIO_PORTC_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO19_OUTPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1006), 3)

#define GP_WB_GET_GPIO_GPIO19_OUTPUT_VALUE_FROM_GPIO_PORTC_OUTPUT_VALUE(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO19_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1006), 3, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO19_OUTPUT_VALUE_TO_GPIO_PORTC_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x77; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO20_OUTPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1006), 4)

#define GP_WB_GET_GPIO_GPIO20_OUTPUT_VALUE_FROM_GPIO_PORTC_OUTPUT_VALUE(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO20_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1006), 4, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO20_OUTPUT_VALUE_TO_GPIO_PORTC_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x6F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO21_OUTPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1006), 5)

#define GP_WB_GET_GPIO_GPIO21_OUTPUT_VALUE_FROM_GPIO_PORTC_OUTPUT_VALUE(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO21_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1006), 5, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO21_OUTPUT_VALUE_TO_GPIO_PORTC_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x5F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

#define GP_WB_READ_GPIO_GPIO22_OUTPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1006), 6)

#define GP_WB_GET_GPIO_GPIO22_OUTPUT_VALUE_FROM_GPIO_PORTC_OUTPUT_VALUE(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_GPIO_GPIO22_OUTPUT_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1006), 6, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_GPIO22_OUTPUT_VALUE_TO_GPIO_PORTC_OUTPUT_VALUE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_GPIO_GPIO_PORTA_INPUT_VALUE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1007))

#define GP_WB_READ_GPIO_GPIO0_INPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1007), 0)

#define GP_WB_GET_GPIO_GPIO0_INPUT_VALUE_FROM_GPIO_PORTA_INPUT_VALUE(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_GPIO_GPIO1_INPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1007), 1)

#define GP_WB_GET_GPIO_GPIO1_INPUT_VALUE_FROM_GPIO_PORTA_INPUT_VALUE(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_GPIO_GPIO2_INPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1007), 2)

#define GP_WB_GET_GPIO_GPIO2_INPUT_VALUE_FROM_GPIO_PORTA_INPUT_VALUE(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_GPIO_GPIO3_INPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1007), 3)

#define GP_WB_GET_GPIO_GPIO3_INPUT_VALUE_FROM_GPIO_PORTA_INPUT_VALUE(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_READ_GPIO_GPIO4_INPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1007), 4)

#define GP_WB_GET_GPIO_GPIO4_INPUT_VALUE_FROM_GPIO_PORTA_INPUT_VALUE(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_READ_GPIO_GPIO5_INPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1007), 5)

#define GP_WB_GET_GPIO_GPIO5_INPUT_VALUE_FROM_GPIO_PORTA_INPUT_VALUE(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_READ_GPIO_GPIO6_INPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1007), 6)

#define GP_WB_GET_GPIO_GPIO6_INPUT_VALUE_FROM_GPIO_PORTA_INPUT_VALUE(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_READ_GPIO_GPIO7_INPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1007), 7)

#define GP_WB_GET_GPIO_GPIO7_INPUT_VALUE_FROM_GPIO_PORTA_INPUT_VALUE(tmp) \
        (((tmp) >> 7) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_GPIO_GPIO_PORTB_INPUT_VALUE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1008))

#define GP_WB_READ_GPIO_GPIO8_INPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1008), 0)

#define GP_WB_GET_GPIO_GPIO8_INPUT_VALUE_FROM_GPIO_PORTB_INPUT_VALUE(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_GPIO_GPIO9_INPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1008), 1)

#define GP_WB_GET_GPIO_GPIO9_INPUT_VALUE_FROM_GPIO_PORTB_INPUT_VALUE(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_GPIO_GPIO10_INPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1008), 2)

#define GP_WB_GET_GPIO_GPIO10_INPUT_VALUE_FROM_GPIO_PORTB_INPUT_VALUE(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_GPIO_GPIO11_INPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1008), 3)

#define GP_WB_GET_GPIO_GPIO11_INPUT_VALUE_FROM_GPIO_PORTB_INPUT_VALUE(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_READ_GPIO_GPIO12_INPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1008), 4)

#define GP_WB_GET_GPIO_GPIO12_INPUT_VALUE_FROM_GPIO_PORTB_INPUT_VALUE(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_READ_GPIO_GPIO13_INPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1008), 5)

#define GP_WB_GET_GPIO_GPIO13_INPUT_VALUE_FROM_GPIO_PORTB_INPUT_VALUE(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_READ_GPIO_GPIO14_INPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1008), 6)

#define GP_WB_GET_GPIO_GPIO14_INPUT_VALUE_FROM_GPIO_PORTB_INPUT_VALUE(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_READ_GPIO_GPIO15_INPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1008), 7)

#define GP_WB_GET_GPIO_GPIO15_INPUT_VALUE_FROM_GPIO_PORTB_INPUT_VALUE(tmp) \
        (((tmp) >> 7) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_GPIO_GPIO_PORTC_INPUT_VALUE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1009))

#define GP_WB_READ_GPIO_GPIO16_INPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1009), 0)

#define GP_WB_GET_GPIO_GPIO16_INPUT_VALUE_FROM_GPIO_PORTC_INPUT_VALUE(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_GPIO_GPIO17_INPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1009), 1)

#define GP_WB_GET_GPIO_GPIO17_INPUT_VALUE_FROM_GPIO_PORTC_INPUT_VALUE(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_GPIO_GPIO18_INPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1009), 2)

#define GP_WB_GET_GPIO_GPIO18_INPUT_VALUE_FROM_GPIO_PORTC_INPUT_VALUE(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_GPIO_GPIO19_INPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1009), 3)

#define GP_WB_GET_GPIO_GPIO19_INPUT_VALUE_FROM_GPIO_PORTC_INPUT_VALUE(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_READ_GPIO_GPIO20_INPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1009), 4)

#define GP_WB_GET_GPIO_GPIO20_INPUT_VALUE_FROM_GPIO_PORTC_INPUT_VALUE(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_READ_GPIO_GPIO21_INPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1009), 5)

#define GP_WB_GET_GPIO_GPIO21_INPUT_VALUE_FROM_GPIO_PORTC_INPUT_VALUE(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_READ_GPIO_GPIO22_INPUT_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1009), 6)

#define GP_WB_GET_GPIO_GPIO22_INPUT_VALUE_FROM_GPIO_PORTC_INPUT_VALUE(tmp) \
        (((tmp) >> 6) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_GPIO_EXTI_PORT_SEL() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100a))

#define GP_WB_WRITE_GPIO_EXTI_PORT_SEL(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100a), (val))

/* Select the correct port for the exti0 interrupt */
#define GP_WB_READ_GPIO_EXTI0_PORT_SEL() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100a)) & 0x03)

#define GP_WB_GET_GPIO_EXTI0_PORT_SEL_FROM_EXTI_PORT_SEL(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_GPIO_EXTI0_PORT_SEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100a), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_EXTI0_PORT_SEL_TO_EXTI_PORT_SEL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0xFFFC; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Select the correct port for the exti1 interrupt */
#define GP_WB_READ_GPIO_EXTI1_PORT_SEL() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100a)) >> 2) & 0x03)

#define GP_WB_GET_GPIO_EXTI1_PORT_SEL_FROM_EXTI_PORT_SEL(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_GPIO_EXTI1_PORT_SEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100a), 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_GPIO_EXTI1_PORT_SEL_TO_EXTI_PORT_SEL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0xFFF3; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* Select the correct port for the exti2 interrupt */
#define GP_WB_READ_GPIO_EXTI2_PORT_SEL() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100a)) >> 4) & 0x03)

#define GP_WB_GET_GPIO_EXTI2_PORT_SEL_FROM_EXTI_PORT_SEL(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_GPIO_EXTI2_PORT_SEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100a), 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_GPIO_EXTI2_PORT_SEL_TO_EXTI_PORT_SEL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0xFFCF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* Select the correct port for the exti3 interrupt */
#define GP_WB_READ_GPIO_EXTI3_PORT_SEL() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100a)) >> 6) & 0x03)

#define GP_WB_GET_GPIO_EXTI3_PORT_SEL_FROM_EXTI_PORT_SEL(tmp) \
        (((tmp) >> 6) & 0x03)

#define GP_WB_WRITE_GPIO_EXTI3_PORT_SEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100a), 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_GPIO_EXTI3_PORT_SEL_TO_EXTI_PORT_SEL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0xFF3F; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

/* Select the correct port for the exti4 interrupt */
#define GP_WB_READ_GPIO_EXTI4_PORT_SEL() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100b)) & 0x03)

#define GP_WB_GET_GPIO_EXTI4_PORT_SEL_FROM_EXTI_PORT_SEL(tmp) \
        (((tmp) >> 8) & 0x03)

#define GP_WB_WRITE_GPIO_EXTI4_PORT_SEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100b), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_EXTI4_PORT_SEL_TO_EXTI_PORT_SEL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0xFCFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* Select the correct port for the exti5 interrupt */
#define GP_WB_READ_GPIO_EXTI5_PORT_SEL() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100b)) >> 2) & 0x03)

#define GP_WB_GET_GPIO_EXTI5_PORT_SEL_FROM_EXTI_PORT_SEL(tmp) \
        (((tmp) >> 10) & 0x03)

#define GP_WB_WRITE_GPIO_EXTI5_PORT_SEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100b), 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_GPIO_EXTI5_PORT_SEL_TO_EXTI_PORT_SEL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0xF3FF; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)

/* Select the correct port for the exti6 interrupt */
#define GP_WB_READ_GPIO_EXTI6_PORT_SEL() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100b)) >> 4) & 0x03)

#define GP_WB_GET_GPIO_EXTI6_PORT_SEL_FROM_EXTI_PORT_SEL(tmp) \
        (((tmp) >> 12) & 0x03)

#define GP_WB_WRITE_GPIO_EXTI6_PORT_SEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100b), 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_GPIO_EXTI6_PORT_SEL_TO_EXTI_PORT_SEL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0xCFFF; \
          (tmp) |= (((UInt16)(val)) << 12); \
        } while (0)

/* Select the correct port for the exti7 interrupt */
#define GP_WB_READ_GPIO_EXTI7_PORT_SEL() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100b)) >> 6) & 0x03)

#define GP_WB_GET_GPIO_EXTI7_PORT_SEL_FROM_EXTI_PORT_SEL(tmp) \
        (((tmp) >> 14) & 0x03)

#define GP_WB_WRITE_GPIO_EXTI7_PORT_SEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100b), 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_GPIO_EXTI7_PORT_SEL_TO_EXTI_PORT_SEL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3FFF; \
          (tmp) |= (((UInt16)(val)) << 14); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_GPIO_EXTI_EXPECTED_VALUE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100c))

#define GP_WB_WRITE_GPIO_EXTI_EXPECTED_VALUE(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100c), (val))

/* Expected value for the pin associated with exti0 interrupt */
#define GP_WB_READ_GPIO_EXTI0_EXPECTED_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100c), 0)

#define GP_WB_GET_GPIO_EXTI0_EXPECTED_VALUE_FROM_EXTI_EXPECTED_VALUE(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_GPIO_EXTI0_EXPECTED_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100c), 0, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_EXTI0_EXPECTED_VALUE_TO_EXTI_EXPECTED_VALUE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Expected value for the pin associated with exti1 interrupt */
#define GP_WB_READ_GPIO_EXTI1_EXPECTED_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100c), 1)

#define GP_WB_GET_GPIO_EXTI1_EXPECTED_VALUE_FROM_EXTI_EXPECTED_VALUE(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_GPIO_EXTI1_EXPECTED_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100c), 1, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_EXTI1_EXPECTED_VALUE_TO_EXTI_EXPECTED_VALUE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Expected value for the pin associated with exti2 interrupt */
#define GP_WB_READ_GPIO_EXTI2_EXPECTED_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100c), 2)

#define GP_WB_GET_GPIO_EXTI2_EXPECTED_VALUE_FROM_EXTI_EXPECTED_VALUE(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_GPIO_EXTI2_EXPECTED_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100c), 2, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_EXTI2_EXPECTED_VALUE_TO_EXTI_EXPECTED_VALUE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Expected value for the pin associated with exti3 interrupt */
#define GP_WB_READ_GPIO_EXTI3_EXPECTED_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100c), 3)

#define GP_WB_GET_GPIO_EXTI3_EXPECTED_VALUE_FROM_EXTI_EXPECTED_VALUE(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_GPIO_EXTI3_EXPECTED_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100c), 3, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_EXTI3_EXPECTED_VALUE_TO_EXTI_EXPECTED_VALUE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Expected value for the pin associated with exti4 interrupt */
#define GP_WB_READ_GPIO_EXTI4_EXPECTED_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100c), 4)

#define GP_WB_GET_GPIO_EXTI4_EXPECTED_VALUE_FROM_EXTI_EXPECTED_VALUE(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_GPIO_EXTI4_EXPECTED_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100c), 4, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_EXTI4_EXPECTED_VALUE_TO_EXTI_EXPECTED_VALUE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Expected value for the pin associated with exti5 interrupt */
#define GP_WB_READ_GPIO_EXTI5_EXPECTED_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100c), 5)

#define GP_WB_GET_GPIO_EXTI5_EXPECTED_VALUE_FROM_EXTI_EXPECTED_VALUE(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_GPIO_EXTI5_EXPECTED_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100c), 5, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_EXTI5_EXPECTED_VALUE_TO_EXTI_EXPECTED_VALUE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* Expected value for the pin associated with exti6 interrupt */
#define GP_WB_READ_GPIO_EXTI6_EXPECTED_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100c), 6)

#define GP_WB_GET_GPIO_EXTI6_EXPECTED_VALUE_FROM_EXTI_EXPECTED_VALUE(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_GPIO_EXTI6_EXPECTED_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100c), 6, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_EXTI6_EXPECTED_VALUE_TO_EXTI_EXPECTED_VALUE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* Expected value for the pin associated with exti7 interrupt */
#define GP_WB_READ_GPIO_EXTI7_EXPECTED_VALUE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100c), 7)

#define GP_WB_GET_GPIO_EXTI7_EXPECTED_VALUE_FROM_EXTI_EXPECTED_VALUE(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_GPIO_EXTI7_EXPECTED_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100c), 7, (val)); \
        } while (0)

#define GP_WB_SET_GPIO_EXTI7_EXPECTED_VALUE_TO_EXTI_EXPECTED_VALUE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_GPIO_UNMASKED_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100d))

/* Unmasked Interrupt event, set to 0x1 when detected */
#define GP_WB_READ_GPIO_UNMASKED_EXTI_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100d))

#define GP_WB_GET_GPIO_UNMASKED_EXTI_INTERRUPTS_FROM_UNMASKED_INTERRUPTS(tmp) \
        ((tmp) & 0xFF)

/* Unmasked Interrupt event, set to 0x1 when detected */
#define GP_WB_READ_GPIO_UNMASKED_EXTI0_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100d), 0)

#define GP_WB_GET_GPIO_UNMASKED_EXTI0_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* Unmasked Interrupt event, set to 0x1 when detected */
#define GP_WB_READ_GPIO_UNMASKED_EXTI1_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100d), 1)

#define GP_WB_GET_GPIO_UNMASKED_EXTI1_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* Unmasked Interrupt event, set to 0x1 when detected */
#define GP_WB_READ_GPIO_UNMASKED_EXTI2_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100d), 2)

#define GP_WB_GET_GPIO_UNMASKED_EXTI2_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* Unmasked Interrupt event, set to 0x1 when detected */
#define GP_WB_READ_GPIO_UNMASKED_EXTI3_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100d), 3)

#define GP_WB_GET_GPIO_UNMASKED_EXTI3_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

/* Unmasked Interrupt event, set to 0x1 when detected */
#define GP_WB_READ_GPIO_UNMASKED_EXTI4_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100d), 4)

#define GP_WB_GET_GPIO_UNMASKED_EXTI4_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

/* Unmasked Interrupt event, set to 0x1 when detected */
#define GP_WB_READ_GPIO_UNMASKED_EXTI5_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100d), 5)

#define GP_WB_GET_GPIO_UNMASKED_EXTI5_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

/* Unmasked Interrupt event, set to 0x1 when detected */
#define GP_WB_READ_GPIO_UNMASKED_EXTI6_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100d), 6)

#define GP_WB_GET_GPIO_UNMASKED_EXTI6_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 6) & 0x01)

/* Unmasked Interrupt event, set to 0x1 when detected */
#define GP_WB_READ_GPIO_UNMASKED_EXTI7_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100d), 7)

#define GP_WB_GET_GPIO_UNMASKED_EXTI7_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 7) & 0x01)


#define GP_WB_WRITE_GPIO_CLR_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100e), (val))

/* Interrupt event clear by writing 0x1 */
#define GP_WB_WRITE_GPIO_CLR_EXTI_INTERRUPTS(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100e), (val)); \
        } while (0)

#define GP_WB_SET_GPIO_CLR_EXTI_INTERRUPTS_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          (tmp) &= 0x00; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Interrupt event clear by writing 0x1 */
#define GP_WB_GPIO_CLR_EXTI0_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100e), 0x01)

#define GP_WB_SET_GPIO_CLR_EXTI0_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Interrupt event clear by writing 0x1 */
#define GP_WB_GPIO_CLR_EXTI1_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100e), 0x02)

#define GP_WB_SET_GPIO_CLR_EXTI1_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Interrupt event clear by writing 0x1 */
#define GP_WB_GPIO_CLR_EXTI2_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100e), 0x04)

#define GP_WB_SET_GPIO_CLR_EXTI2_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Interrupt event clear by writing 0x1 */
#define GP_WB_GPIO_CLR_EXTI3_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100e), 0x08)

#define GP_WB_SET_GPIO_CLR_EXTI3_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Interrupt event clear by writing 0x1 */
#define GP_WB_GPIO_CLR_EXTI4_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100e), 0x10)

#define GP_WB_SET_GPIO_CLR_EXTI4_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Interrupt event clear by writing 0x1 */
#define GP_WB_GPIO_CLR_EXTI5_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100e), 0x20)

#define GP_WB_SET_GPIO_CLR_EXTI5_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* Interrupt event clear by writing 0x1 */
#define GP_WB_GPIO_CLR_EXTI6_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100e), 0x40)

#define GP_WB_SET_GPIO_CLR_EXTI6_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* Interrupt event clear by writing 0x1 */
#define GP_WB_GPIO_CLR_EXTI7_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x100e), 0x80)

#define GP_WB_SET_GPIO_CLR_EXTI7_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)

/***************************
 * layout: i2c_m
 ***************************/

#define GP_WB_READ_I2C_M_PRESCALER() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1020))

#define GP_WB_WRITE_I2C_M_PRESCALER(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1020), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_I2C_M_CONFIG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1022))

#define GP_WB_WRITE_I2C_M_CONFIG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1022), (val))

/* Enable core when '1' : en has to be put to '0' when a new prescaler value is loaded */
#define GP_WB_READ_I2C_M_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1022), 0)

#define GP_WB_GET_I2C_M_ENABLE_FROM_CONFIG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_I2C_M_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1022), 0, (val)); \
        } while (0)

#define GP_WB_SET_I2C_M_ENABLE_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* ACK to be transmitted */
#define GP_WB_READ_I2C_M_ACK() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1022), 1)

#define GP_WB_GET_I2C_M_ACK_FROM_CONFIG(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_I2C_M_ACK(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1022), 1, (val)); \
        } while (0)

#define GP_WB_SET_I2C_M_ACK_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Disable clock synchronization slave wait detection */
#define GP_WB_READ_I2C_M_CLK_SYNC_DISABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1022), 2)

#define GP_WB_GET_I2C_M_CLK_SYNC_DISABLE_FROM_CONFIG(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_I2C_M_CLK_SYNC_DISABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1022), 2, (val)); \
        } while (0)

#define GP_WB_SET_I2C_M_CLK_SYNC_DISABLE_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* Byte to be transferred */
#define GP_WB_READ_I2C_M_TX_DATA() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1023))

#define GP_WB_WRITE_I2C_M_TX_DATA(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1023), (val)); \
        } while (0)


/* Byte received */
#define GP_WB_READ_I2C_M_RX_DATA() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1024))


#define GP_WB_WRITE_I2C_M_CONTROL(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1025), (val))

/* Write to slave */
#define GP_WB_I2C_M_WRITE() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1025), 0x01)

#define GP_WB_SET_I2C_M_WRITE_TO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Read from slave */
#define GP_WB_I2C_M_READ() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1025), 0x02)

#define GP_WB_SET_I2C_M_READ_TO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Generate stop condition */
#define GP_WB_I2C_M_STOP() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1025), 0x04)

#define GP_WB_SET_I2C_M_STOP_TO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Generate (repeated) start condition */
#define GP_WB_I2C_M_START() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1025), 0x08)

#define GP_WB_SET_I2C_M_START_TO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x77; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* TWI Done Interrupt clear */
#define GP_WB_I2C_M_CLR_DONE_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1025), 0x10)

#define GP_WB_SET_I2C_M_CLR_DONE_INTERRUPT_TO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x6F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* TWI Arbitration Lost Interrupt clear */
#define GP_WB_I2C_M_CLR_ARB_LOST_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1025), 0x20)

#define GP_WB_SET_I2C_M_CLR_ARB_LOST_INTERRUPT_TO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x5F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* TWI Clock Synchronization Slave Wait Interrupt clear */
#define GP_WB_I2C_M_CLR_CLK_SYNC_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1025), 0x40)

#define GP_WB_SET_I2C_M_CLR_CLK_SYNC_INTERRUPT_TO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_I2C_M_STATUS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1026))

/* Byte Read or Byte Write in progress */
#define GP_WB_READ_I2C_M_READ_WRITE_BUSY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1026), 0)

#define GP_WB_GET_I2C_M_READ_WRITE_BUSY_FROM_STATUS(tmp) \
        ((tmp) & 0x01)

/* Data Transfer in progress (between start and stop condition) */
#define GP_WB_READ_I2C_M_TRANSFER_BUSY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1026), 1)

#define GP_WB_GET_I2C_M_TRANSFER_BUSY_FROM_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* ACK from slave received */
#define GP_WB_READ_I2C_M_RX_ACK() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1026), 2)

#define GP_WB_GET_I2C_M_RX_ACK_FROM_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)

/* Clock Synchornization Slave Wait */
#define GP_WB_READ_I2C_M_CLK_SYNC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1026), 3)

#define GP_WB_GET_I2C_M_CLK_SYNC_FROM_STATUS(tmp) \
        (((tmp) >> 3) & 0x01)

/* Unmasked Done Interrupt */
#define GP_WB_READ_I2C_M_UNMASKED_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1026), 4)

#define GP_WB_GET_I2C_M_UNMASKED_DONE_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 4) & 0x01)

/* Unmasked Arbitration Lost Interrupt */
#define GP_WB_READ_I2C_M_UNMASKED_ARB_LOST_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1026), 5)

#define GP_WB_GET_I2C_M_UNMASKED_ARB_LOST_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 5) & 0x01)

/* Unmasked Clock Synchronization Slave Wait Interrupt */
#define GP_WB_READ_I2C_M_UNMASKED_CLK_SYNC_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1026), 6)

#define GP_WB_GET_I2C_M_UNMASKED_CLK_SYNC_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 6) & 0x01)

/***************************
 * layout: adcif
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADCIF_GENERAL_CONFIG() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1040))

#define GP_WB_WRITE_ADCIF_GENERAL_CONFIG(val) \
      GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1040), (val))

/* Defines when the adc measurement is triggered - see enum for possibilities */
#define GP_WB_READ_ADCIF_TRIGGER_MODE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1040)) & 0x07)

#define GP_WB_GET_ADCIF_TRIGGER_MODE_FROM_GENERAL_CONFIG(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_ADCIF_TRIGGER_MODE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1040), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_TRIGGER_MODE_TO_GENERAL_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x01FF08; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Enables the adc to perform measurements */
#define GP_WB_READ_ADCIF_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1040), 3)

#define GP_WB_GET_ADCIF_ENABLE_FROM_GENERAL_CONFIG(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_ADCIF_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1040), 3, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_ENABLE_TO_GENERAL_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FF07; \
          (tmp) |= (((UInt32)(val)) << 3); \
        } while (0)

/* Sets the number of slots that are used in a measurement cycle. Up to 4 slots can be used, resulting in an way to measure 4 different channels per cycle. This setting specifies the number of slots-1 (so setting 0 -> 1 slot, setting 3 -> 4 slots) */
#define GP_WB_READ_ADCIF_NBR_OF_SLOTS_IN_CYCLE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1041)) & 0x03)

#define GP_WB_GET_ADCIF_NBR_OF_SLOTS_IN_CYCLE_FROM_GENERAL_CONFIG(tmp) \
        (((tmp) >> 8) & 0x03)

#define GP_WB_WRITE_ADCIF_NBR_OF_SLOTS_IN_CYCLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1041), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_NBR_OF_SLOTS_IN_CYCLE_TO_GENERAL_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x01FC0F; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* Sets the number of conversions that are rejected in a chopped measurement after changing the adc swap input */
#define GP_WB_READ_ADCIF_NBR_OF_REJECTED_SWAP_CONV() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1041)) >> 2) & 0x03)

#define GP_WB_GET_ADCIF_NBR_OF_REJECTED_SWAP_CONV_FROM_GENERAL_CONFIG(tmp) \
        (((tmp) >> 10) & 0x03)

#define GP_WB_WRITE_ADCIF_NBR_OF_REJECTED_SWAP_CONV(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1041), 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_ADCIF_NBR_OF_REJECTED_SWAP_CONV_TO_GENERAL_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x01F30F; \
          (tmp) |= (((UInt32)(val)) << 10); \
        } while (0)

/* Sets the number of conversions that are rejected between 2 measurements on different channels - acoounts for channel select mux settling time */
#define GP_WB_READ_ADCIF_NBR_OF_REJECTED_CONVERSIONS() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1041)) >> 4) & 0x0F)

#define GP_WB_GET_ADCIF_NBR_OF_REJECTED_CONVERSIONS_FROM_GENERAL_CONFIG(tmp) \
        (((tmp) >> 12) & 0x0F)

#define GP_WB_WRITE_ADCIF_NBR_OF_REJECTED_CONVERSIONS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1041), 0xF0, (val) << 4); \
        } while (0)

#define GP_WB_SET_ADCIF_NBR_OF_REJECTED_CONVERSIONS_TO_GENERAL_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x010F0F; \
          (tmp) |= (((UInt32)(val)) << 12); \
        } while (0)

/* When set to 1, the clock that is sent to the analog domain is coming from the fractional clock generator (needs bbpll to be on). If not set the clock is a 4MHz 50pct duty cycle clock */
#define GP_WB_READ_ADCIF_USE_FRACT_CLOCK_AS_SAMPLE_CLK_SOURCE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1042), 0)

#define GP_WB_GET_ADCIF_USE_FRACT_CLOCK_AS_SAMPLE_CLK_SOURCE_FROM_GENERAL_CONFIG(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_ADCIF_USE_FRACT_CLOCK_AS_SAMPLE_CLK_SOURCE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1042), (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_USE_FRACT_CLOCK_AS_SAMPLE_CLK_SOURCE_TO_GENERAL_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x00FF0F; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADCIF_SLOT_A_CONFIG() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1044))

#define GP_WB_WRITE_ADCIF_SLOT_A_CONFIG(val) \
      GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1044), (val))

/* The adc channel for slot a */
#define GP_WB_READ_ADCIF_SLOT_A_CHANNEL() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1044)) & 0x0F)

#define GP_WB_GET_ADCIF_SLOT_A_CHANNEL_FROM_SLOT_A_CONFIG(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_ADCIF_SLOT_A_CHANNEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1044), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_A_CHANNEL_TO_SLOT_A_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x03FFF0; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* post result to first result buffer */
#define GP_WB_READ_ADCIF_SLOT_A_POST_TO_BUFFER_A() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1044), 4)

#define GP_WB_GET_ADCIF_SLOT_A_POST_TO_BUFFER_A_FROM_SLOT_A_CONFIG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_A_POST_TO_BUFFER_A(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1044), 4, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_A_POST_TO_BUFFER_A_TO_SLOT_A_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFEF; \
          (tmp) |= (((UInt32)(val)) << 4); \
        } while (0)

/* post result to second result buffer */
#define GP_WB_READ_ADCIF_SLOT_A_POST_TO_BUFFER_B() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1044), 5)

#define GP_WB_GET_ADCIF_SLOT_A_POST_TO_BUFFER_B_FROM_SLOT_A_CONFIG(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_A_POST_TO_BUFFER_B(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1044), 5, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_A_POST_TO_BUFFER_B_TO_SLOT_A_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFDF; \
          (tmp) |= (((UInt32)(val)) << 5); \
        } while (0)

/* post result to third result buffer */
#define GP_WB_READ_ADCIF_SLOT_A_POST_TO_BUFFER_C() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1044), 6)

#define GP_WB_GET_ADCIF_SLOT_A_POST_TO_BUFFER_C_FROM_SLOT_A_CONFIG(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_A_POST_TO_BUFFER_C(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1044), 6, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_A_POST_TO_BUFFER_C_TO_SLOT_A_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFBF; \
          (tmp) |= (((UInt32)(val)) << 6); \
        } while (0)

/* post result to result fifo */
#define GP_WB_READ_ADCIF_SLOT_A_POST_TO_FIFO() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1044), 7)

#define GP_WB_GET_ADCIF_SLOT_A_POST_TO_FIFO_FROM_SLOT_A_CONFIG(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_A_POST_TO_FIFO(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1044), 7, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_A_POST_TO_FIFO_TO_SLOT_A_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FF7F; \
          (tmp) |= (((UInt32)(val)) << 7); \
        } while (0)

/* post result to analog watchdog */
#define GP_WB_READ_ADCIF_SLOT_A_POST_TO_AWD() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1045), 0)

#define GP_WB_GET_ADCIF_SLOT_A_POST_TO_AWD_FROM_SLOT_A_CONFIG(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_A_POST_TO_AWD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1045), 0, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_A_POST_TO_AWD_TO_SLOT_A_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FEFF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* gain to use on the input, note that this is differential gain. Single ended to differential gain will be half of this. */
#define GP_WB_READ_ADCIF_SLOT_A_SCALER_GAIN() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1045)) >> 1) & 0x07)

#define GP_WB_GET_ADCIF_SLOT_A_SCALER_GAIN_FROM_SLOT_A_CONFIG(tmp) \
        (((tmp) >> 9) & 0x07)

#define GP_WB_WRITE_ADCIF_SLOT_A_SCALER_GAIN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1045), 0x0E, (val) << 1); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_A_SCALER_GAIN_TO_SLOT_A_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x03F1FF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* idicates whether we want to do a chopped measurement to cancel out offset errors in the signal path */
#define GP_WB_READ_ADCIF_SLOT_A_CHOPPING_ENABLED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1045), 4)

#define GP_WB_GET_ADCIF_SLOT_A_CHOPPING_ENABLED_FROM_SLOT_A_CONFIG(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_A_CHOPPING_ENABLED(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1045), 4, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_A_CHOPPING_ENABLED_TO_SLOT_A_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03EFFF; \
          (tmp) |= (((UInt32)(val)) << 12); \
        } while (0)

/* idicates whether we want to do a single_ended or differential measurement */
#define GP_WB_READ_ADCIF_SLOT_A_DIFFERENTIAL_MODE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1045), 5)

#define GP_WB_GET_ADCIF_SLOT_A_DIFFERENTIAL_MODE_FROM_SLOT_A_CONFIG(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_A_DIFFERENTIAL_MODE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1045), 5, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_A_DIFFERENTIAL_MODE_TO_SLOT_A_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03DFFF; \
          (tmp) |= (((UInt32)(val)) << 13); \
        } while (0)

/* constant current pup */
#define GP_WB_READ_ADCIF_SLOT_A_SCALER_BIAS_CC_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1045), 6)

#define GP_WB_GET_ADCIF_SLOT_A_SCALER_BIAS_CC_PUP_FROM_SLOT_A_CONFIG(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_A_SCALER_BIAS_CC_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1045), 6, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_A_SCALER_BIAS_CC_PUP_TO_SLOT_A_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03BFFF; \
          (tmp) |= (((UInt32)(val)) << 14); \
        } while (0)

/* constant gm pup */
#define GP_WB_READ_ADCIF_SLOT_A_SCALER_BIAS_CGM_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1045), 7)

#define GP_WB_GET_ADCIF_SLOT_A_SCALER_BIAS_CGM_PUP_FROM_SLOT_A_CONFIG(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_A_SCALER_BIAS_CGM_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1045), 7, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_A_SCALER_BIAS_CGM_PUP_TO_SLOT_A_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x037FFF; \
          (tmp) |= (((UInt32)(val)) << 15); \
        } while (0)

/* bypasses the unity gain buffer (buffer will be forced off) for n-input adc */
#define GP_WB_READ_ADCIF_SLOT_A_SMUX_ADC_BUF_N_BYPASS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1046), 0)

#define GP_WB_GET_ADCIF_SLOT_A_SMUX_ADC_BUF_N_BYPASS_FROM_SLOT_A_CONFIG(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_A_SMUX_ADC_BUF_N_BYPASS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1046), 0, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_A_SMUX_ADC_BUF_N_BYPASS_TO_SLOT_A_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* bypasses the unity gain buffer (buffer will be forced off) for p-input adc */
#define GP_WB_READ_ADCIF_SLOT_A_SMUX_ADC_BUF_P_BYPASS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1046), 1)

#define GP_WB_GET_ADCIF_SLOT_A_SMUX_ADC_BUF_P_BYPASS_FROM_SLOT_A_CONFIG(tmp) \
        (((tmp) >> 17) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_A_SMUX_ADC_BUF_P_BYPASS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1046), 1, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_A_SMUX_ADC_BUF_P_BYPASS_TO_SLOT_A_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFF; \
          (tmp) |= (((UInt32)(val)) << 17); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADCIF_SLOT_B_CONFIG() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1048))

#define GP_WB_WRITE_ADCIF_SLOT_B_CONFIG(val) \
      GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1048), (val))

/* The adc channel for slot b */
#define GP_WB_READ_ADCIF_SLOT_B_CHANNEL() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1048)) & 0x0F)

#define GP_WB_GET_ADCIF_SLOT_B_CHANNEL_FROM_SLOT_B_CONFIG(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_ADCIF_SLOT_B_CHANNEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1048), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_B_CHANNEL_TO_SLOT_B_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x03FFF0; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* post result to first result buffer */
#define GP_WB_READ_ADCIF_SLOT_B_POST_TO_BUFFER_A() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1048), 4)

#define GP_WB_GET_ADCIF_SLOT_B_POST_TO_BUFFER_A_FROM_SLOT_B_CONFIG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_B_POST_TO_BUFFER_A(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1048), 4, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_B_POST_TO_BUFFER_A_TO_SLOT_B_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFEF; \
          (tmp) |= (((UInt32)(val)) << 4); \
        } while (0)

/* post result to second result buffer */
#define GP_WB_READ_ADCIF_SLOT_B_POST_TO_BUFFER_B() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1048), 5)

#define GP_WB_GET_ADCIF_SLOT_B_POST_TO_BUFFER_B_FROM_SLOT_B_CONFIG(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_B_POST_TO_BUFFER_B(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1048), 5, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_B_POST_TO_BUFFER_B_TO_SLOT_B_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFDF; \
          (tmp) |= (((UInt32)(val)) << 5); \
        } while (0)

/* post result to third result buffer */
#define GP_WB_READ_ADCIF_SLOT_B_POST_TO_BUFFER_C() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1048), 6)

#define GP_WB_GET_ADCIF_SLOT_B_POST_TO_BUFFER_C_FROM_SLOT_B_CONFIG(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_B_POST_TO_BUFFER_C(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1048), 6, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_B_POST_TO_BUFFER_C_TO_SLOT_B_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFBF; \
          (tmp) |= (((UInt32)(val)) << 6); \
        } while (0)

/* post result to result fifo */
#define GP_WB_READ_ADCIF_SLOT_B_POST_TO_FIFO() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1048), 7)

#define GP_WB_GET_ADCIF_SLOT_B_POST_TO_FIFO_FROM_SLOT_B_CONFIG(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_B_POST_TO_FIFO(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1048), 7, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_B_POST_TO_FIFO_TO_SLOT_B_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FF7F; \
          (tmp) |= (((UInt32)(val)) << 7); \
        } while (0)

/* post result to analog watchdog */
#define GP_WB_READ_ADCIF_SLOT_B_POST_TO_AWD() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1049), 0)

#define GP_WB_GET_ADCIF_SLOT_B_POST_TO_AWD_FROM_SLOT_B_CONFIG(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_B_POST_TO_AWD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1049), 0, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_B_POST_TO_AWD_TO_SLOT_B_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FEFF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* gain to use on the input, note that this is differential gain. Single ended to differential gain will be half of this. */
#define GP_WB_READ_ADCIF_SLOT_B_SCALER_GAIN() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1049)) >> 1) & 0x07)

#define GP_WB_GET_ADCIF_SLOT_B_SCALER_GAIN_FROM_SLOT_B_CONFIG(tmp) \
        (((tmp) >> 9) & 0x07)

#define GP_WB_WRITE_ADCIF_SLOT_B_SCALER_GAIN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1049), 0x0E, (val) << 1); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_B_SCALER_GAIN_TO_SLOT_B_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x03F1FF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* idicates whether we want to do a chopped measurement to cancel out offset errors in the signal path */
#define GP_WB_READ_ADCIF_SLOT_B_CHOPPING_ENABLED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1049), 4)

#define GP_WB_GET_ADCIF_SLOT_B_CHOPPING_ENABLED_FROM_SLOT_B_CONFIG(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_B_CHOPPING_ENABLED(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1049), 4, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_B_CHOPPING_ENABLED_TO_SLOT_B_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03EFFF; \
          (tmp) |= (((UInt32)(val)) << 12); \
        } while (0)

/* idicates whether we want to do a single_ended or differential measurement */
#define GP_WB_READ_ADCIF_SLOT_B_DIFFERENTIAL_MODE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1049), 5)

#define GP_WB_GET_ADCIF_SLOT_B_DIFFERENTIAL_MODE_FROM_SLOT_B_CONFIG(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_B_DIFFERENTIAL_MODE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1049), 5, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_B_DIFFERENTIAL_MODE_TO_SLOT_B_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03DFFF; \
          (tmp) |= (((UInt32)(val)) << 13); \
        } while (0)

/* constant current pup */
#define GP_WB_READ_ADCIF_SLOT_B_SCALER_BIAS_CC_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1049), 6)

#define GP_WB_GET_ADCIF_SLOT_B_SCALER_BIAS_CC_PUP_FROM_SLOT_B_CONFIG(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_B_SCALER_BIAS_CC_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1049), 6, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_B_SCALER_BIAS_CC_PUP_TO_SLOT_B_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03BFFF; \
          (tmp) |= (((UInt32)(val)) << 14); \
        } while (0)

/* constant gm pup */
#define GP_WB_READ_ADCIF_SLOT_B_SCALER_BIAS_CGM_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1049), 7)

#define GP_WB_GET_ADCIF_SLOT_B_SCALER_BIAS_CGM_PUP_FROM_SLOT_B_CONFIG(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_B_SCALER_BIAS_CGM_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1049), 7, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_B_SCALER_BIAS_CGM_PUP_TO_SLOT_B_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x037FFF; \
          (tmp) |= (((UInt32)(val)) << 15); \
        } while (0)

/* bypasses the unity gain buffer (buffer will be forced off) for n-input adc */
#define GP_WB_READ_ADCIF_SLOT_B_SMUX_ADC_BUF_N_BYPASS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104a), 0)

#define GP_WB_GET_ADCIF_SLOT_B_SMUX_ADC_BUF_N_BYPASS_FROM_SLOT_B_CONFIG(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_B_SMUX_ADC_BUF_N_BYPASS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104a), 0, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_B_SMUX_ADC_BUF_N_BYPASS_TO_SLOT_B_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* bypasses the unity gain buffer (buffer will be forced off) for p-input adc */
#define GP_WB_READ_ADCIF_SLOT_B_SMUX_ADC_BUF_P_BYPASS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104a), 1)

#define GP_WB_GET_ADCIF_SLOT_B_SMUX_ADC_BUF_P_BYPASS_FROM_SLOT_B_CONFIG(tmp) \
        (((tmp) >> 17) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_B_SMUX_ADC_BUF_P_BYPASS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104a), 1, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_B_SMUX_ADC_BUF_P_BYPASS_TO_SLOT_B_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFF; \
          (tmp) |= (((UInt32)(val)) << 17); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADCIF_SLOT_C_CONFIG() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104c))

#define GP_WB_WRITE_ADCIF_SLOT_C_CONFIG(val) \
      GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104c), (val))

/* The adc channel for slot c */
#define GP_WB_READ_ADCIF_SLOT_C_CHANNEL() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104c)) & 0x0F)

#define GP_WB_GET_ADCIF_SLOT_C_CHANNEL_FROM_SLOT_C_CONFIG(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_ADCIF_SLOT_C_CHANNEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104c), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_C_CHANNEL_TO_SLOT_C_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x03FFF0; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* post result to first result buffer */
#define GP_WB_READ_ADCIF_SLOT_C_POST_TO_BUFFER_A() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104c), 4)

#define GP_WB_GET_ADCIF_SLOT_C_POST_TO_BUFFER_A_FROM_SLOT_C_CONFIG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_C_POST_TO_BUFFER_A(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104c), 4, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_C_POST_TO_BUFFER_A_TO_SLOT_C_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFEF; \
          (tmp) |= (((UInt32)(val)) << 4); \
        } while (0)

/* post result to second result buffer */
#define GP_WB_READ_ADCIF_SLOT_C_POST_TO_BUFFER_B() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104c), 5)

#define GP_WB_GET_ADCIF_SLOT_C_POST_TO_BUFFER_B_FROM_SLOT_C_CONFIG(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_C_POST_TO_BUFFER_B(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104c), 5, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_C_POST_TO_BUFFER_B_TO_SLOT_C_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFDF; \
          (tmp) |= (((UInt32)(val)) << 5); \
        } while (0)

/* post result to third result buffer */
#define GP_WB_READ_ADCIF_SLOT_C_POST_TO_BUFFER_C() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104c), 6)

#define GP_WB_GET_ADCIF_SLOT_C_POST_TO_BUFFER_C_FROM_SLOT_C_CONFIG(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_C_POST_TO_BUFFER_C(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104c), 6, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_C_POST_TO_BUFFER_C_TO_SLOT_C_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFBF; \
          (tmp) |= (((UInt32)(val)) << 6); \
        } while (0)

/* post result to result fifo */
#define GP_WB_READ_ADCIF_SLOT_C_POST_TO_FIFO() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104c), 7)

#define GP_WB_GET_ADCIF_SLOT_C_POST_TO_FIFO_FROM_SLOT_C_CONFIG(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_C_POST_TO_FIFO(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104c), 7, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_C_POST_TO_FIFO_TO_SLOT_C_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FF7F; \
          (tmp) |= (((UInt32)(val)) << 7); \
        } while (0)

/* post result to analog watchdog */
#define GP_WB_READ_ADCIF_SLOT_C_POST_TO_AWD() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104d), 0)

#define GP_WB_GET_ADCIF_SLOT_C_POST_TO_AWD_FROM_SLOT_C_CONFIG(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_C_POST_TO_AWD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104d), 0, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_C_POST_TO_AWD_TO_SLOT_C_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FEFF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* gain to use on the input, note that this is differential gain. Single ended to differential gain will be half of this. */
#define GP_WB_READ_ADCIF_SLOT_C_SCALER_GAIN() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104d)) >> 1) & 0x07)

#define GP_WB_GET_ADCIF_SLOT_C_SCALER_GAIN_FROM_SLOT_C_CONFIG(tmp) \
        (((tmp) >> 9) & 0x07)

#define GP_WB_WRITE_ADCIF_SLOT_C_SCALER_GAIN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104d), 0x0E, (val) << 1); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_C_SCALER_GAIN_TO_SLOT_C_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x03F1FF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* idicates whether we want to do a chopped measurement to cancel out offset errors in the signal path */
#define GP_WB_READ_ADCIF_SLOT_C_CHOPPING_ENABLED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104d), 4)

#define GP_WB_GET_ADCIF_SLOT_C_CHOPPING_ENABLED_FROM_SLOT_C_CONFIG(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_C_CHOPPING_ENABLED(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104d), 4, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_C_CHOPPING_ENABLED_TO_SLOT_C_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03EFFF; \
          (tmp) |= (((UInt32)(val)) << 12); \
        } while (0)

/* idicates whether we want to do a single_ended or differential measurement */
#define GP_WB_READ_ADCIF_SLOT_C_DIFFERENTIAL_MODE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104d), 5)

#define GP_WB_GET_ADCIF_SLOT_C_DIFFERENTIAL_MODE_FROM_SLOT_C_CONFIG(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_C_DIFFERENTIAL_MODE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104d), 5, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_C_DIFFERENTIAL_MODE_TO_SLOT_C_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03DFFF; \
          (tmp) |= (((UInt32)(val)) << 13); \
        } while (0)

/* constant current pup */
#define GP_WB_READ_ADCIF_SLOT_C_SCALER_BIAS_CC_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104d), 6)

#define GP_WB_GET_ADCIF_SLOT_C_SCALER_BIAS_CC_PUP_FROM_SLOT_C_CONFIG(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_C_SCALER_BIAS_CC_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104d), 6, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_C_SCALER_BIAS_CC_PUP_TO_SLOT_C_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03BFFF; \
          (tmp) |= (((UInt32)(val)) << 14); \
        } while (0)

/* constant gm pup */
#define GP_WB_READ_ADCIF_SLOT_C_SCALER_BIAS_CGM_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104d), 7)

#define GP_WB_GET_ADCIF_SLOT_C_SCALER_BIAS_CGM_PUP_FROM_SLOT_C_CONFIG(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_C_SCALER_BIAS_CGM_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104d), 7, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_C_SCALER_BIAS_CGM_PUP_TO_SLOT_C_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x037FFF; \
          (tmp) |= (((UInt32)(val)) << 15); \
        } while (0)

/* bypasses the unity gain buffer (buffer will be forced off) for n-input adc */
#define GP_WB_READ_ADCIF_SLOT_C_SMUX_ADC_BUF_N_BYPASS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104e), 0)

#define GP_WB_GET_ADCIF_SLOT_C_SMUX_ADC_BUF_N_BYPASS_FROM_SLOT_C_CONFIG(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_C_SMUX_ADC_BUF_N_BYPASS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104e), 0, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_C_SMUX_ADC_BUF_N_BYPASS_TO_SLOT_C_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* bypasses the unity gain buffer (buffer will be forced off) for p-input adc */
#define GP_WB_READ_ADCIF_SLOT_C_SMUX_ADC_BUF_P_BYPASS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104e), 1)

#define GP_WB_GET_ADCIF_SLOT_C_SMUX_ADC_BUF_P_BYPASS_FROM_SLOT_C_CONFIG(tmp) \
        (((tmp) >> 17) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_C_SMUX_ADC_BUF_P_BYPASS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x104e), 1, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_C_SMUX_ADC_BUF_P_BYPASS_TO_SLOT_C_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFF; \
          (tmp) |= (((UInt32)(val)) << 17); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADCIF_SLOT_D_CONFIG() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1050))

#define GP_WB_WRITE_ADCIF_SLOT_D_CONFIG(val) \
      GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1050), (val))

/* The adc channel for slot d */
#define GP_WB_READ_ADCIF_SLOT_D_CHANNEL() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1050)) & 0x0F)

#define GP_WB_GET_ADCIF_SLOT_D_CHANNEL_FROM_SLOT_D_CONFIG(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_ADCIF_SLOT_D_CHANNEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1050), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_D_CHANNEL_TO_SLOT_D_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x03FFF0; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* post result to first result buffer */
#define GP_WB_READ_ADCIF_SLOT_D_POST_TO_BUFFER_A() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1050), 4)

#define GP_WB_GET_ADCIF_SLOT_D_POST_TO_BUFFER_A_FROM_SLOT_D_CONFIG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_D_POST_TO_BUFFER_A(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1050), 4, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_D_POST_TO_BUFFER_A_TO_SLOT_D_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFEF; \
          (tmp) |= (((UInt32)(val)) << 4); \
        } while (0)

/* post result to second result buffer */
#define GP_WB_READ_ADCIF_SLOT_D_POST_TO_BUFFER_B() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1050), 5)

#define GP_WB_GET_ADCIF_SLOT_D_POST_TO_BUFFER_B_FROM_SLOT_D_CONFIG(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_D_POST_TO_BUFFER_B(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1050), 5, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_D_POST_TO_BUFFER_B_TO_SLOT_D_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFDF; \
          (tmp) |= (((UInt32)(val)) << 5); \
        } while (0)

/* post result to third result buffer */
#define GP_WB_READ_ADCIF_SLOT_D_POST_TO_BUFFER_C() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1050), 6)

#define GP_WB_GET_ADCIF_SLOT_D_POST_TO_BUFFER_C_FROM_SLOT_D_CONFIG(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_D_POST_TO_BUFFER_C(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1050), 6, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_D_POST_TO_BUFFER_C_TO_SLOT_D_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FFBF; \
          (tmp) |= (((UInt32)(val)) << 6); \
        } while (0)

/* post result to result fifo */
#define GP_WB_READ_ADCIF_SLOT_D_POST_TO_FIFO() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1050), 7)

#define GP_WB_GET_ADCIF_SLOT_D_POST_TO_FIFO_FROM_SLOT_D_CONFIG(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_D_POST_TO_FIFO(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1050), 7, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_D_POST_TO_FIFO_TO_SLOT_D_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FF7F; \
          (tmp) |= (((UInt32)(val)) << 7); \
        } while (0)

/* post result to analog watchdog */
#define GP_WB_READ_ADCIF_SLOT_D_POST_TO_AWD() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1051), 0)

#define GP_WB_GET_ADCIF_SLOT_D_POST_TO_AWD_FROM_SLOT_D_CONFIG(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_D_POST_TO_AWD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1051), 0, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_D_POST_TO_AWD_TO_SLOT_D_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FEFF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* gain to use on the input, note that this is differential gain. Single ended to differential gain will be half of this. */
#define GP_WB_READ_ADCIF_SLOT_D_SCALER_GAIN() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1051)) >> 1) & 0x07)

#define GP_WB_GET_ADCIF_SLOT_D_SCALER_GAIN_FROM_SLOT_D_CONFIG(tmp) \
        (((tmp) >> 9) & 0x07)

#define GP_WB_WRITE_ADCIF_SLOT_D_SCALER_GAIN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1051), 0x0E, (val) << 1); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_D_SCALER_GAIN_TO_SLOT_D_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x03F1FF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* idicates whether we want to do a chopped measurement to cancel out offset errors in the signal path */
#define GP_WB_READ_ADCIF_SLOT_D_CHOPPING_ENABLED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1051), 4)

#define GP_WB_GET_ADCIF_SLOT_D_CHOPPING_ENABLED_FROM_SLOT_D_CONFIG(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_D_CHOPPING_ENABLED(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1051), 4, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_D_CHOPPING_ENABLED_TO_SLOT_D_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03EFFF; \
          (tmp) |= (((UInt32)(val)) << 12); \
        } while (0)

/* idicates whether we want to do a single_ended or differential measurement */
#define GP_WB_READ_ADCIF_SLOT_D_DIFFERENTIAL_MODE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1051), 5)

#define GP_WB_GET_ADCIF_SLOT_D_DIFFERENTIAL_MODE_FROM_SLOT_D_CONFIG(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_D_DIFFERENTIAL_MODE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1051), 5, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_D_DIFFERENTIAL_MODE_TO_SLOT_D_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03DFFF; \
          (tmp) |= (((UInt32)(val)) << 13); \
        } while (0)

/* constant current pup */
#define GP_WB_READ_ADCIF_SLOT_D_SCALER_BIAS_CC_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1051), 6)

#define GP_WB_GET_ADCIF_SLOT_D_SCALER_BIAS_CC_PUP_FROM_SLOT_D_CONFIG(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_D_SCALER_BIAS_CC_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1051), 6, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_D_SCALER_BIAS_CC_PUP_TO_SLOT_D_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03BFFF; \
          (tmp) |= (((UInt32)(val)) << 14); \
        } while (0)

/* constant gm pup */
#define GP_WB_READ_ADCIF_SLOT_D_SCALER_BIAS_CGM_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1051), 7)

#define GP_WB_GET_ADCIF_SLOT_D_SCALER_BIAS_CGM_PUP_FROM_SLOT_D_CONFIG(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_D_SCALER_BIAS_CGM_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1051), 7, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_D_SCALER_BIAS_CGM_PUP_TO_SLOT_D_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x037FFF; \
          (tmp) |= (((UInt32)(val)) << 15); \
        } while (0)

/* bypasses the unity gain buffer (buffer will be forced off) for n-input adc */
#define GP_WB_READ_ADCIF_SLOT_D_SMUX_ADC_BUF_N_BYPASS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1052), 0)

#define GP_WB_GET_ADCIF_SLOT_D_SMUX_ADC_BUF_N_BYPASS_FROM_SLOT_D_CONFIG(tmp) \
        (((tmp) >> 16) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_D_SMUX_ADC_BUF_N_BYPASS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1052), 0, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_D_SMUX_ADC_BUF_N_BYPASS_TO_SLOT_D_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* bypasses the unity gain buffer (buffer will be forced off) for p-input adc */
#define GP_WB_READ_ADCIF_SLOT_D_SMUX_ADC_BUF_P_BYPASS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1052), 1)

#define GP_WB_GET_ADCIF_SLOT_D_SMUX_ADC_BUF_P_BYPASS_FROM_SLOT_D_CONFIG(tmp) \
        (((tmp) >> 17) & 0x01)

#define GP_WB_WRITE_ADCIF_SLOT_D_SMUX_ADC_BUF_P_BYPASS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1052), 1, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SLOT_D_SMUX_ADC_BUF_P_BYPASS_TO_SLOT_D_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FFFF; \
          (tmp) |= (((UInt32)(val)) << 17); \
        } while (0)


/* This is the value that is used to preset the awd/buffer_a/b/c maximal value when buffer_a_preset / buffer_b_preset / buffer_c_preset / awd_preset is applied */
#define GP_WB_READ_ADCIF_PRESET_MAX_VALUE() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1054))

#define GP_WB_WRITE_ADCIF_PRESET_MAX_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1054), (val)); \
        } while (0)


/* This is the value that is used to preset the awd/buffer_a/b/c minimal value when buffer_a_preset / buffer_b_preset / buffer_c_preset / awd_preset is applied */
#define GP_WB_READ_ADCIF_PRESET_MIN_VALUE() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1056))

#define GP_WB_WRITE_ADCIF_PRESET_MIN_VALUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1056), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADCIF_MAILBOX_CONFIG() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1058))

#define GP_WB_WRITE_ADCIF_MAILBOX_CONFIG(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1058), (val))

/* Defines the rate at which samples are put into the fifo (every fifo_subsample_rate+1 'th sample is used) */
#define GP_WB_READ_ADCIF_FIFO_SUBSAMPLE_RATE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1058)) & 0x07)

#define GP_WB_GET_ADCIF_FIFO_SUBSAMPLE_RATE_FROM_MAILBOX_CONFIG(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_ADCIF_FIFO_SUBSAMPLE_RATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1058), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_FIFO_SUBSAMPLE_RATE_TO_MAILBOX_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x1FF8; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Puts fifo in 8 bits mode (iso 10 bits mode) - the result is in the LSB bits of fifo */
#define GP_WB_READ_ADCIF_FIFO_MODE8BITS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1058), 3)

#define GP_WB_GET_ADCIF_FIFO_MODE8BITS_FROM_MAILBOX_CONFIG(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_ADCIF_FIFO_MODE8BITS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1058), 3, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_FIFO_MODE8BITS_TO_MAILBOX_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FF7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

/* Puts buffer a in 8 bits mode (iso 10 bits mode) - the result is in the LSB bits of buffer_a */
#define GP_WB_READ_ADCIF_BUFFER_A_MODE8BITS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1058), 4)

#define GP_WB_GET_ADCIF_BUFFER_A_MODE8BITS_FROM_MAILBOX_CONFIG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_ADCIF_BUFFER_A_MODE8BITS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1058), 4, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_BUFFER_A_MODE8BITS_TO_MAILBOX_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FEF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* Sets the update mode of buffer a (normal, minimum hold, maximum hold or out-of-range mode) */
#define GP_WB_READ_ADCIF_BUFFER_A_UPDATE_MODE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1058)) >> 5) & 0x03)

#define GP_WB_GET_ADCIF_BUFFER_A_UPDATE_MODE_FROM_MAILBOX_CONFIG(tmp) \
        (((tmp) >> 5) & 0x03)

#define GP_WB_WRITE_ADCIF_BUFFER_A_UPDATE_MODE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1058), 0x60, (val) << 5); \
        } while (0)

#define GP_WB_SET_ADCIF_BUFFER_A_UPDATE_MODE_TO_MAILBOX_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x1F9F; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

/* Puts buffer b in 8 bits mode (iso 10 bits mode) - the result is in the LSB bits of buffer_b */
#define GP_WB_READ_ADCIF_BUFFER_B_MODE8BITS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1058), 7)

#define GP_WB_GET_ADCIF_BUFFER_B_MODE8BITS_FROM_MAILBOX_CONFIG(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADCIF_BUFFER_B_MODE8BITS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1058), 7, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_BUFFER_B_MODE8BITS_TO_MAILBOX_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* Sets the update mode of buffer b (normal, minimum hold, maximum hold or out-of-range mode) */
#define GP_WB_READ_ADCIF_BUFFER_B_UPDATE_MODE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1059)) & 0x03)

#define GP_WB_GET_ADCIF_BUFFER_B_UPDATE_MODE_FROM_MAILBOX_CONFIG(tmp) \
        (((tmp) >> 8) & 0x03)

#define GP_WB_WRITE_ADCIF_BUFFER_B_UPDATE_MODE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1059), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_BUFFER_B_UPDATE_MODE_TO_MAILBOX_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x1CFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* Puts buffer c in 8 bits mode (iso 10 bits mode) - the result is in the LSB bits of buffer_c */
#define GP_WB_READ_ADCIF_BUFFER_C_MODE8BITS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1059), 2)

#define GP_WB_GET_ADCIF_BUFFER_C_MODE8BITS_FROM_MAILBOX_CONFIG(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_ADCIF_BUFFER_C_MODE8BITS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1059), 2, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_BUFFER_C_MODE8BITS_TO_MAILBOX_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1BFF; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)

/* Sets the update mode of buffer c (normal, minimum hold, maximum hold or out-of-range mode) */
#define GP_WB_READ_ADCIF_BUFFER_C_UPDATE_MODE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1059)) >> 3) & 0x03)

#define GP_WB_GET_ADCIF_BUFFER_C_UPDATE_MODE_FROM_MAILBOX_CONFIG(tmp) \
        (((tmp) >> 11) & 0x03)

#define GP_WB_WRITE_ADCIF_BUFFER_C_UPDATE_MODE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1059), 0x18, (val) << 3); \
        } while (0)

#define GP_WB_SET_ADCIF_BUFFER_C_UPDATE_MODE_TO_MAILBOX_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x07FF; \
          (tmp) |= (((UInt16)(val)) << 11); \
        } while (0)


#define GP_WB_WRITE_ADCIF_ACTION_TRIGGERS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x105a), (val))

/* When set, buffer a will be preset with the values defined in preset_min_value and preset_max_value */
#define GP_WB_ADCIF_BUFFER_A_PRESET() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x105a), 0x01)

#define GP_WB_SET_ADCIF_BUFFER_A_PRESET_TO_ACTION_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When set, buffer b will be preset with the values defined in preset_min_value and preset_max_value */
#define GP_WB_ADCIF_BUFFER_B_PRESET() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x105a), 0x02)

#define GP_WB_SET_ADCIF_BUFFER_B_PRESET_TO_ACTION_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* When set, buffer c will be preset with the values defined in preset_min_value and preset_max_value */
#define GP_WB_ADCIF_BUFFER_C_PRESET() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x105a), 0x04)

#define GP_WB_SET_ADCIF_BUFFER_C_PRESET_TO_ACTION_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* When set, the analog watchdog will be preset with the values defined in preset_min_value and preset_max_value */
#define GP_WB_ADCIF_AWD_PRESET() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x105a), 0x08)

#define GP_WB_SET_ADCIF_AWD_PRESET_TO_ACTION_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Resets the FIFO subsample counter */
#define GP_WB_ADCIF_CLR_FIFO_SUBSAMPLE_CNT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x105a), 0x10)

#define GP_WB_SET_ADCIF_CLR_FIFO_SUBSAMPLE_CNT_TO_ACTION_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


#define GP_WB_WRITE_ADCIF_CLR_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x105b), (val))

/* buffer_a_updated interrupt clear */
#define GP_WB_ADCIF_CLR_BUFFER_A_UPDATED_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x105b), 0x01)

#define GP_WB_SET_ADCIF_CLR_BUFFER_A_UPDATED_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* buffer_b_updated interrupt clear */
#define GP_WB_ADCIF_CLR_BUFFER_B_UPDATED_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x105b), 0x02)

#define GP_WB_SET_ADCIF_CLR_BUFFER_B_UPDATED_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* buffer_c_updated interrupt clear */
#define GP_WB_ADCIF_CLR_BUFFER_C_UPDATED_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x105b), 0x04)

#define GP_WB_SET_ADCIF_CLR_BUFFER_C_UPDATED_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* fifo overrun interrupt clear */
#define GP_WB_ADCIF_CLR_FIFO_OVERRUN_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x105b), 0x08)

#define GP_WB_SET_ADCIF_CLR_FIFO_OVERRUN_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* awd_below_minimum interrupt clear */
#define GP_WB_ADCIF_CLR_AWD_BELOW_MINIMUM_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x105b), 0x10)

#define GP_WB_SET_ADCIF_CLR_AWD_BELOW_MINIMUM_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* awd_above_maximum interrupt clear */
#define GP_WB_ADCIF_CLR_AWD_ABOVE_MAXIMUM_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x105b), 0x20)

#define GP_WB_SET_ADCIF_CLR_AWD_ABOVE_MAXIMUM_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* measurement cycle done interrupt clear */
#define GP_WB_ADCIF_CLR_CYCLE_DONE_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x105b), 0x40)

#define GP_WB_SET_ADCIF_CLR_CYCLE_DONE_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* overvoltage interrupt clear */
#define GP_WB_ADCIF_CLR_OVERVOLTAGE_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x105b), 0x80)

#define GP_WB_SET_ADCIF_CLR_OVERVOLTAGE_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADCIF_FIFO_RESULT_PB() \
        GP_WB_READ_SER_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x105c))

/* LSB bits of the result FIFO (clear on read - clear is done when MSB bits are read) */
#define GP_WB_READ_ADCIF_FIFO_RESULT_0() \
        GP_WB_READ_SER_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x105c))

#define GP_WB_GET_ADCIF_FIFO_RESULT_0_FROM_FIFO_RESULT_PB(tmp) \
        ((tmp) & 0xFF)

/* result FIFO (clear on read - clear is done when MSB bits are read) */
#define GP_WB_READ_ADCIF_FIFO_RESULT() \
        (GP_WB_READ_SER_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x105c)) & 0x03FF)

#define GP_WB_GET_ADCIF_FIFO_RESULT_FROM_FIFO_RESULT_PB(tmp) \
        ((tmp) & 0x03FF)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADCIF_BUFFER_A_RESULT_PB() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x105e))

/* LSB bits of the result buffer a */
#define GP_WB_READ_ADCIF_BUFFER_A_RESULT_0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x105e))

#define GP_WB_GET_ADCIF_BUFFER_A_RESULT_0_FROM_BUFFER_A_RESULT_PB(tmp) \
        ((tmp) & 0xFF)

/* result buffer a */
#define GP_WB_READ_ADCIF_BUFFER_A_RESULT() \
        (GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x105e)) & 0x03FF)

#define GP_WB_GET_ADCIF_BUFFER_A_RESULT_FROM_BUFFER_A_RESULT_PB(tmp) \
        ((tmp) & 0x03FF)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADCIF_BUFFER_B_RESULT_PB() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1060))

/* LSB bits of the result buffer b */
#define GP_WB_READ_ADCIF_BUFFER_B_RESULT_0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1060))

#define GP_WB_GET_ADCIF_BUFFER_B_RESULT_0_FROM_BUFFER_B_RESULT_PB(tmp) \
        ((tmp) & 0xFF)

/* result buffer b */
#define GP_WB_READ_ADCIF_BUFFER_B_RESULT() \
        (GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1060)) & 0x03FF)

#define GP_WB_GET_ADCIF_BUFFER_B_RESULT_FROM_BUFFER_B_RESULT_PB(tmp) \
        ((tmp) & 0x03FF)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADCIF_BUFFER_C_RESULT_PB() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1062))

/* LSB bits of the result buffer c */
#define GP_WB_READ_ADCIF_BUFFER_C_RESULT_0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1062))

#define GP_WB_GET_ADCIF_BUFFER_C_RESULT_0_FROM_BUFFER_C_RESULT_PB(tmp) \
        ((tmp) & 0xFF)

/* result buffer c */
#define GP_WB_READ_ADCIF_BUFFER_C_RESULT() \
        (GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1062)) & 0x03FF)

#define GP_WB_GET_ADCIF_BUFFER_C_RESULT_FROM_BUFFER_C_RESULT_PB(tmp) \
        ((tmp) & 0x03FF)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADCIF_ANA_FORCE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1064))

#define GP_WB_WRITE_ADCIF_ANA_FORCE(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1064), (val))

/* makes it able to invert the generated swap signal. */
#define GP_WB_READ_ADCIF_SMUX_CROSS_INVERT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1064), 0)

#define GP_WB_GET_ADCIF_SMUX_CROSS_INVERT_FROM_ANA_FORCE(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_ADCIF_SMUX_CROSS_INVERT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1064), 0, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SMUX_CROSS_INVERT_TO_ANA_FORCE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* makes it able to invert the generated swap signal. */
#define GP_WB_READ_ADCIF_SMUX_TSENSOR_SWAP_INPUT_INVERT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1064), 1)

#define GP_WB_GET_ADCIF_SMUX_TSENSOR_SWAP_INPUT_INVERT_FROM_ANA_FORCE(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_ADCIF_SMUX_TSENSOR_SWAP_INPUT_INVERT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1064), 1, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SMUX_TSENSOR_SWAP_INPUT_INVERT_TO_ANA_FORCE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADCIF_GENERAL_STATUS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1065))

/* The current value of the end of conversion counter */
#define GP_WB_READ_ADCIF_EOC_COUNTER_VALUE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1065)) & 0x0F)

#define GP_WB_GET_ADCIF_EOC_COUNTER_VALUE_FROM_GENERAL_STATUS(tmp) \
        ((tmp) & 0x0F)

/* The slot index of the currently active slot */
#define GP_WB_READ_ADCIF_ACTIVE_SLOT_IDX() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1065)) >> 4) & 0x03)

#define GP_WB_GET_ADCIF_ACTIVE_SLOT_IDX_FROM_GENERAL_STATUS(tmp) \
        (((tmp) >> 4) & 0x03)

/* Indicates that a conversion is ongoing */
#define GP_WB_READ_ADCIF_CONVERSION_CYCLE_BUSY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1065), 6)

#define GP_WB_GET_ADCIF_CONVERSION_CYCLE_BUSY_FROM_GENERAL_STATUS(tmp) \
        (((tmp) >> 6) & 0x01)

/* Flag indicating that the voltage at the ADC input is too high */
#define GP_WB_READ_ADCIF_ADC_CLAMP_ACTIVE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1065), 7)

#define GP_WB_GET_ADCIF_ADC_CLAMP_ACTIVE_FROM_GENERAL_STATUS(tmp) \
        (((tmp) >> 7) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADCIF_UNMASKED_INTERRUPTS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1066))

/* Interrupt triggered when the value in buffer a updated */
#define GP_WB_READ_ADCIF_UNMASKED_BUFFER_A_UPDATED_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1066), 0)

#define GP_WB_GET_ADCIF_UNMASKED_BUFFER_A_UPDATED_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* Interrupt triggered when the value in buffer b updated */
#define GP_WB_READ_ADCIF_UNMASKED_BUFFER_B_UPDATED_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1066), 1)

#define GP_WB_GET_ADCIF_UNMASKED_BUFFER_B_UPDATED_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* Interrupt triggered when the value in buffer c updated */
#define GP_WB_READ_ADCIF_UNMASKED_BUFFER_C_UPDATED_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1066), 2)

#define GP_WB_GET_ADCIF_UNMASKED_BUFFER_C_UPDATED_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* Interrupts generated when there is data in the FIFO */
#define GP_WB_READ_ADCIF_UNMASKED_FIFO_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1066), 3)

#define GP_WB_GET_ADCIF_UNMASKED_FIFO_NOT_EMPTY_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

/* Interrupts generated when new data was available while FIFO was full */
#define GP_WB_READ_ADCIF_UNMASKED_FIFO_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1066), 4)

#define GP_WB_GET_ADCIF_UNMASKED_FIFO_OVERRUN_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

/* Interrupt triggered when the value is below the configured minimum */
#define GP_WB_READ_ADCIF_UNMASKED_AWD_BELOW_MINIMUM_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1066), 5)

#define GP_WB_GET_ADCIF_UNMASKED_AWD_BELOW_MINIMUM_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

/* Interrupt triggered when the value is above the configured maximum */
#define GP_WB_READ_ADCIF_UNMASKED_AWD_ABOVE_MAXIMUM_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1066), 6)

#define GP_WB_GET_ADCIF_UNMASKED_AWD_ABOVE_MAXIMUM_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 6) & 0x01)

/* Interrupts generated when a complete measurement cycle finished */
#define GP_WB_READ_ADCIF_UNMASKED_CYCLE_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1066), 7)

#define GP_WB_GET_ADCIF_UNMASKED_CYCLE_DONE_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 7) & 0x01)

/* interrupt indicating that the voltage at the ADC input was too high during a measurement */
#define GP_WB_READ_ADCIF_UNMASKED_OVERVOLTAGE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1067), 0)

#define GP_WB_GET_ADCIF_UNMASKED_OVERVOLTAGE_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x01)


/* tuning bits for the gp-adc analogue ldo output voltage */
#define GP_WB_READ_ADCIF_ADC_LDO_REFBITS() \
        (GP_WB_S8((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1068)) & 0x0F), 4))

#define GP_WB_WRITE_ADCIF_ADC_LDO_REFBITS(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -8, 7); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1068), 0x0F, (UInt8)((val))); \
        } while (0)

/* tuning bits for the adc reference ldo output voltage */
#define GP_WB_READ_ADCIF_ADC_VREF_REFBITS() \
        (GP_WB_S8(((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1068)) >> 4) & 0x0F), 4))

#define GP_WB_WRITE_ADCIF_ADC_VREF_REFBITS(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -8, 7); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1068), 0xF0, (UInt8)((val) << 4)); \
        } while (0)

/* set resistor ladder for bias current of constant-gm block */
#define GP_WB_READ_ADCIF_ADC_SCALER_BIAS_CGM_RES() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1069)) & 0x03)

#define GP_WB_WRITE_ADCIF_ADC_SCALER_BIAS_CGM_RES(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1069), 0x03, (val)); \
        } while (0)

#define GP_WB_READ_ADCIF_ADC_SCALER_VCM_REFBITS() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1069)) >> 2) & 0x03)

#define GP_WB_WRITE_ADCIF_ADC_SCALER_VCM_REFBITS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1069), 0x0C, (val) << 2); \
        } while (0)

/* spare */
#define GP_WB_READ_ADCIF_ADC_SPARE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1069)) >> 4) & 0x03)

#define GP_WB_WRITE_ADCIF_ADC_SPARE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1069), 0x30, (val) << 4); \
        } while (0)

/* 2 bits resistive load on testbus:0=900k, 1=300k, 2=100k, 3=33k */
#define GP_WB_READ_ADCIF_SMUX_RESLOAD() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1069)) >> 6) & 0x03)

#define GP_WB_WRITE_ADCIF_SMUX_RESLOAD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1069), 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_READ_ADCIF_ADC_CLK_MUX_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106a), 0)

#define GP_WB_WRITE_ADCIF_ADC_CLK_MUX_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106a), 0, (val)); \
        } while (0)

#define GP_WB_READ_ADCIF_ADC_CLK_SELECT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106a), 1)

#define GP_WB_WRITE_ADCIF_ADC_CLK_SELECT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106a), 1, (val)); \
        } while (0)

#define GP_WB_READ_ADCIF_ADC_CLK_SPEED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106a), 2)

#define GP_WB_WRITE_ADCIF_ADC_CLK_SPEED(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106a), 2, (val)); \
        } while (0)

/* doubles the bias current in the comparator */
#define GP_WB_READ_ADCIF_ADC_COMP_BIAS_BOOST() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106a), 3)

#define GP_WB_WRITE_ADCIF_ADC_COMP_BIAS_BOOST(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106a), 3, (val)); \
        } while (0)

#define GP_WB_READ_ADCIF_ADC_COMP_BIAS_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106a), 4)

#define GP_WB_WRITE_ADCIF_ADC_COMP_BIAS_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106a), 4, (val)); \
        } while (0)

/* disable for the bleed transistor at the gp-adc analogue ldo output */
#define GP_WB_READ_ADCIF_ADC_LDO_BLEED_OFF() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106a), 5)

#define GP_WB_WRITE_ADCIF_ADC_LDO_BLEED_OFF(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106a), 5, (val)); \
        } while (0)

/* pup signal for the gp-adc analogue ldo */
#define GP_WB_READ_ADCIF_ADC_LDO_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106a), 6)

#define GP_WB_WRITE_ADCIF_ADC_LDO_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106a), 6, (val)); \
        } while (0)

/* signal to bypass the lpf resistor in the gp-adc analogue ldo */
#define GP_WB_READ_ADCIF_ADC_LDO_RESBYPASS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106a), 7)

#define GP_WB_WRITE_ADCIF_ADC_LDO_RESBYPASS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106a), 7, (val)); \
        } while (0)

/* enables overvoltage detection (previously smux) */
#define GP_WB_READ_ADCIF_ADC_OVP_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106b), 0)

#define GP_WB_WRITE_ADCIF_ADC_OVP_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106b), 0, (val)); \
        } while (0)

#define GP_WB_READ_ADCIF_ADC_SCALER_BYPASS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106b), 1)

#define GP_WB_WRITE_ADCIF_ADC_SCALER_BYPASS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106b), 1, (val)); \
        } while (0)

#define GP_WB_READ_ADCIF_ADC_SCALER_FILTER_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106b), 2)

#define GP_WB_WRITE_ADCIF_ADC_SCALER_FILTER_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106b), 2, (val)); \
        } while (0)

#define GP_WB_READ_ADCIF_ADC_SCALER_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106b), 3)

#define GP_WB_WRITE_ADCIF_ADC_SCALER_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106b), 3, (val)); \
        } while (0)

/* connect reference voltage directly to adc for measuring gain error */
#define GP_WB_READ_ADCIF_ADC_TEST_VREF() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106b), 4)

#define GP_WB_WRITE_ADCIF_ADC_TEST_VREF(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106b), 4, (val)); \
        } while (0)

/* enable signal for the adc vcm buffer, 1.2v */
#define GP_WB_READ_ADCIF_ADC_VCM_BUF_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106b), 5)

#define GP_WB_WRITE_ADCIF_ADC_VCM_BUF_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106b), 5, (val)); \
        } while (0)

/* enable signal for the adc vddref buffer */
#define GP_WB_READ_ADCIF_ADC_VREF_BUF_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106b), 6)

#define GP_WB_WRITE_ADCIF_ADC_VREF_BUF_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106b), 6, (val)); \
        } while (0)

/* signal to bypass the lpf resistor in the adc reference ldo */
#define GP_WB_READ_ADCIF_ADC_VREF_RESBYPASS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106b), 7)

#define GP_WB_WRITE_ADCIF_ADC_VREF_RESBYPASS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106b), 7, (val)); \
        } while (0)

/* switches unity gain buffer to use full scale (enabling nmos input pair as well) for n-input adc */
#define GP_WB_READ_ADCIF_SMUX_ADC_BUF_N_FULLSCALE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106c), 0)

#define GP_WB_WRITE_ADCIF_SMUX_ADC_BUF_N_FULLSCALE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106c), 0, (val)); \
        } while (0)

/* enables unity-gain buffer from bus to adc for n-input adc */
#define GP_WB_READ_ADCIF_SMUX_ADC_BUF_N_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106c), 1)

#define GP_WB_WRITE_ADCIF_SMUX_ADC_BUF_N_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106c), 1, (val)); \
        } while (0)

/* switches unity gain buffer to use full scale (enabling nmos input pair as well) for p-input adc */
#define GP_WB_READ_ADCIF_SMUX_ADC_BUF_P_FULLSCALE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106c), 2)

#define GP_WB_WRITE_ADCIF_SMUX_ADC_BUF_P_FULLSCALE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106c), 2, (val)); \
        } while (0)

/* enables unity-gain buffer from bus to adc for p-input adc */
#define GP_WB_READ_ADCIF_SMUX_ADC_BUF_P_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106c), 3)

#define GP_WB_WRITE_ADCIF_SMUX_ADC_BUF_P_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106c), 3, (val)); \
        } while (0)

/* enabled any anio to be connected to adc-bus */
#define GP_WB_READ_ADCIF_SMUX_ADC_CHANNEL_SEL_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106c), 4)

#define GP_WB_WRITE_ADCIF_SMUX_ADC_CHANNEL_SEL_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106c), 4, (val)); \
        } while (0)

/* use */
#define GP_WB_READ_ADCIF_SMUX_EXTERNAL_REFERENCE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106c), 5)

#define GP_WB_WRITE_ADCIF_SMUX_EXTERNAL_REFERENCE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106c), 5, (val)); \
        } while (0)

/* enable resistive load on n-side of testbus */
#define GP_WB_READ_ADCIF_SMUX_RESLOAD_EN_N() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106c), 6)

#define GP_WB_WRITE_ADCIF_SMUX_RESLOAD_EN_N(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106c), 6, (val)); \
        } while (0)

/* enable resistive load on p-side of testbus */
#define GP_WB_READ_ADCIF_SMUX_RESLOAD_EN_P() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106c), 7)

#define GP_WB_WRITE_ADCIF_SMUX_RESLOAD_EN_P(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106c), 7, (val)); \
        } while (0)

/* selects either offset or gain mode for internal self test */
#define GP_WB_READ_ADCIF_SMUX_SELFTEST_MODE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106d), 0)

#define GP_WB_WRITE_ADCIF_SMUX_SELFTEST_MODE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106d), 0, (val)); \
        } while (0)

/* enables temperature sensor */
#define GP_WB_READ_ADCIF_SMUX_TSENSOR_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106d), 1)

#define GP_WB_WRITE_ADCIF_SMUX_TSENSOR_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106d), 1, (val)); \
        } while (0)

/* enables the 4 mhz clock to the general purpose adc block */
#define GP_WB_READ_ADCIF_XO_CLK_4M_PUP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106d), 2)

#define GP_WB_WRITE_ADCIF_XO_CLK_4M_PUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106d), 2, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADCIF_ANA_OVERRULE() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106e))

#define GP_WB_WRITE_ADCIF_ANA_OVERRULE(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106e), (val))

/* selects which anio is connected to adc-bus */
#define GP_WB_READ_ADCIF_SMUX_ADC_CHANNEL_SEL_OVERRULE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106e)) & 0x0F)

#define GP_WB_GET_ADCIF_SMUX_ADC_CHANNEL_SEL_OVERRULE_FROM_ANA_OVERRULE(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_ADCIF_SMUX_ADC_CHANNEL_SEL_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106e), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SMUX_ADC_CHANNEL_SEL_OVERRULE_TO_ANA_OVERRULE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0xFFF0; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

#define GP_WB_READ_ADCIF_ADC_SCALER_OVERRULE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106e)) >> 4) & 0x07)

#define GP_WB_GET_ADCIF_ADC_SCALER_OVERRULE_FROM_ANA_OVERRULE(tmp) \
        (((tmp) >> 4) & 0x07)

#define GP_WB_WRITE_ADCIF_ADC_SCALER_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106e), 0x70, (val) << 4); \
        } while (0)

#define GP_WB_SET_ADCIF_ADC_SCALER_OVERRULE_TO_ANA_OVERRULE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0xFF8F; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* selects differential mode usage =1, otherwise single ended adc input */
#define GP_WB_READ_ADCIF_ADC_DIFF_MODE_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106e), 7)

#define GP_WB_GET_ADCIF_ADC_DIFF_MODE_OVERRULE_FROM_ANA_OVERRULE(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADCIF_ADC_DIFF_MODE_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106e), 7, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_ADC_DIFF_MODE_OVERRULE_TO_ANA_OVERRULE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_ADCIF_ADC_SCALER_BIAS_CC_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106f), 0)

#define GP_WB_GET_ADCIF_ADC_SCALER_BIAS_CC_PUP_OVERRULE_FROM_ANA_OVERRULE(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_ADCIF_ADC_SCALER_BIAS_CC_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106f), 0, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_ADC_SCALER_BIAS_CC_PUP_OVERRULE_TO_ANA_OVERRULE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFEFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

#define GP_WB_READ_ADCIF_ADC_SCALER_BIAS_CGM_PUP_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106f), 1)

#define GP_WB_GET_ADCIF_ADC_SCALER_BIAS_CGM_PUP_OVERRULE_FROM_ANA_OVERRULE(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_ADCIF_ADC_SCALER_BIAS_CGM_PUP_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106f), 1, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_ADC_SCALER_BIAS_CGM_PUP_OVERRULE_TO_ANA_OVERRULE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFDFF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)

/* request to do a conversion, 1.2v */
#define GP_WB_READ_ADCIF_ADC_START_CONV_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106f), 2)

#define GP_WB_GET_ADCIF_ADC_START_CONV_OVERRULE_FROM_ANA_OVERRULE(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_ADCIF_ADC_START_CONV_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106f), 2, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_ADC_START_CONV_OVERRULE_TO_ANA_OVERRULE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFBFF; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)

/* adc conversion clock connected to synthesizer */
#define GP_WB_READ_ADCIF_CLK_ADC_DIG_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106f), 3)

#define GP_WB_GET_ADCIF_CLK_ADC_DIG_OVERRULE_FROM_ANA_OVERRULE(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_ADCIF_CLK_ADC_DIG_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106f), 3, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_CLK_ADC_DIG_OVERRULE_TO_ANA_OVERRULE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7FF; \
          (tmp) |= (((UInt16)(val)) << 11); \
        } while (0)

/* bypasses the unity gain buffer (buffer will be forced off) for n-input adc */
#define GP_WB_READ_ADCIF_SMUX_ADC_BUF_N_BYPASS_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106f), 4)

#define GP_WB_GET_ADCIF_SMUX_ADC_BUF_N_BYPASS_OVERRULE_FROM_ANA_OVERRULE(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_ADCIF_SMUX_ADC_BUF_N_BYPASS_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106f), 4, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SMUX_ADC_BUF_N_BYPASS_OVERRULE_TO_ANA_OVERRULE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEFFF; \
          (tmp) |= (((UInt16)(val)) << 12); \
        } while (0)

/* bypasses the unity gain buffer (buffer will be forced off) for p-input adc */
#define GP_WB_READ_ADCIF_SMUX_ADC_BUF_P_BYPASS_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106f), 5)

#define GP_WB_GET_ADCIF_SMUX_ADC_BUF_P_BYPASS_OVERRULE_FROM_ANA_OVERRULE(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_ADCIF_SMUX_ADC_BUF_P_BYPASS_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106f), 5, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SMUX_ADC_BUF_P_BYPASS_OVERRULE_TO_ANA_OVERRULE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDFFF; \
          (tmp) |= (((UInt16)(val)) << 13); \
        } while (0)

/* swaps anio connection from p/n to n/p on bus for adc, (differential input of adc). this applies to the inputs: anio[0], anio[1], testbus_ch0, testbus_ch1, testbus_ch2, and vbat. */
#define GP_WB_READ_ADCIF_SMUX_CROSS_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106f), 6)

#define GP_WB_GET_ADCIF_SMUX_CROSS_OVERRULE_FROM_ANA_OVERRULE(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_ADCIF_SMUX_CROSS_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106f), 6, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SMUX_CROSS_OVERRULE_TO_ANA_OVERRULE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBFFF; \
          (tmp) |= (((UInt16)(val)) << 14); \
        } while (0)

/* swaps differential outputs of temperature sensor that go to gp-adc */
#define GP_WB_READ_ADCIF_SMUX_TSENSOR_SWAP_INPUT_OVERRULE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106f), 7)

#define GP_WB_GET_ADCIF_SMUX_TSENSOR_SWAP_INPUT_OVERRULE_FROM_ANA_OVERRULE(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_ADCIF_SMUX_TSENSOR_SWAP_INPUT_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x106f), 7, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SMUX_TSENSOR_SWAP_INPUT_OVERRULE_TO_ANA_OVERRULE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7FFF; \
          (tmp) |= (((UInt16)(val)) << 15); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADCIF_ANA_OVERRULE_ENA() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1070))

#define GP_WB_WRITE_ADCIF_ANA_OVERRULE_ENA(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1070), (val))

/* selects differential mode usage =1, otherwise single ended adc input */
#define GP_WB_READ_ADCIF_ADC_DIFF_MODE_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1070), 0)

#define GP_WB_GET_ADCIF_ADC_DIFF_MODE_OVERRULE_ENA_FROM_ANA_OVERRULE_ENA(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_ADCIF_ADC_DIFF_MODE_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1070), 0, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_ADC_DIFF_MODE_OVERRULE_ENA_TO_ANA_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FE; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

#define GP_WB_READ_ADCIF_ADC_SCALER_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1070), 1)

#define GP_WB_GET_ADCIF_ADC_SCALER_OVERRULE_ENA_FROM_ANA_OVERRULE_ENA(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_ADCIF_ADC_SCALER_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1070), 1, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_ADC_SCALER_OVERRULE_ENA_TO_ANA_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FD; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

#define GP_WB_READ_ADCIF_ADC_SCALER_BIAS_CC_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1070), 2)

#define GP_WB_GET_ADCIF_ADC_SCALER_BIAS_CC_PUP_OVERRULE_ENA_FROM_ANA_OVERRULE_ENA(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_ADCIF_ADC_SCALER_BIAS_CC_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1070), 2, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_ADC_SCALER_BIAS_CC_PUP_OVERRULE_ENA_TO_ANA_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FB; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

#define GP_WB_READ_ADCIF_ADC_SCALER_BIAS_CGM_PUP_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1070), 3)

#define GP_WB_GET_ADCIF_ADC_SCALER_BIAS_CGM_PUP_OVERRULE_ENA_FROM_ANA_OVERRULE_ENA(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_ADCIF_ADC_SCALER_BIAS_CGM_PUP_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1070), 3, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_ADC_SCALER_BIAS_CGM_PUP_OVERRULE_ENA_TO_ANA_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07F7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

/* request to do a conversion, 1.2v */
#define GP_WB_READ_ADCIF_ADC_START_CONV_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1070), 4)

#define GP_WB_GET_ADCIF_ADC_START_CONV_OVERRULE_ENA_FROM_ANA_OVERRULE_ENA(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_ADCIF_ADC_START_CONV_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1070), 4, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_ADC_START_CONV_OVERRULE_ENA_TO_ANA_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07EF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* adc conversion clock connected to synthesizer */
#define GP_WB_READ_ADCIF_CLK_ADC_DIG_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1070), 5)

#define GP_WB_GET_ADCIF_CLK_ADC_DIG_OVERRULE_ENA_FROM_ANA_OVERRULE_ENA(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_ADCIF_CLK_ADC_DIG_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1070), 5, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_CLK_ADC_DIG_OVERRULE_ENA_TO_ANA_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07DF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

/* bypasses the unity gain buffer (buffer will be forced off) for n-input adc */
#define GP_WB_READ_ADCIF_SMUX_ADC_BUF_N_BYPASS_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1070), 6)

#define GP_WB_GET_ADCIF_SMUX_ADC_BUF_N_BYPASS_OVERRULE_ENA_FROM_ANA_OVERRULE_ENA(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_ADCIF_SMUX_ADC_BUF_N_BYPASS_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1070), 6, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SMUX_ADC_BUF_N_BYPASS_OVERRULE_ENA_TO_ANA_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07BF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

/* bypasses the unity gain buffer (buffer will be forced off) for p-input adc */
#define GP_WB_READ_ADCIF_SMUX_ADC_BUF_P_BYPASS_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1070), 7)

#define GP_WB_GET_ADCIF_SMUX_ADC_BUF_P_BYPASS_OVERRULE_ENA_FROM_ANA_OVERRULE_ENA(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADCIF_SMUX_ADC_BUF_P_BYPASS_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1070), 7, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SMUX_ADC_BUF_P_BYPASS_OVERRULE_ENA_TO_ANA_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x077F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* selects which anio is connected to adc-bus */
#define GP_WB_READ_ADCIF_SMUX_ADC_CHANNEL_SEL_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1071), 0)

#define GP_WB_GET_ADCIF_SMUX_ADC_CHANNEL_SEL_OVERRULE_ENA_FROM_ANA_OVERRULE_ENA(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_ADCIF_SMUX_ADC_CHANNEL_SEL_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1071), 0, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SMUX_ADC_CHANNEL_SEL_OVERRULE_ENA_TO_ANA_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* swaps anio connection from p/n to n/p on bus for adc, (differential input of adc). this applies to the inputs: anio[0], anio[1], testbus_ch0, testbus_ch1, testbus_ch2, and vbat. */
#define GP_WB_READ_ADCIF_SMUX_CROSS_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1071), 1)

#define GP_WB_GET_ADCIF_SMUX_CROSS_OVERRULE_ENA_FROM_ANA_OVERRULE_ENA(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_ADCIF_SMUX_CROSS_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1071), 1, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SMUX_CROSS_OVERRULE_ENA_TO_ANA_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05FF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)

/* swaps differential outputs of temperature sensor that go to gp-adc */
#define GP_WB_READ_ADCIF_SMUX_TSENSOR_SWAP_INPUT_OVERRULE_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1071), 2)

#define GP_WB_GET_ADCIF_SMUX_TSENSOR_SWAP_INPUT_OVERRULE_ENA_FROM_ANA_OVERRULE_ENA(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_ADCIF_SMUX_TSENSOR_SWAP_INPUT_OVERRULE_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1071), 2, (val)); \
        } while (0)

#define GP_WB_SET_ADCIF_SMUX_TSENSOR_SWAP_INPUT_OVERRULE_ENA_TO_ANA_OVERRULE_ENA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FF; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)

/***************************
 * layout: ssp
 ***************************/

/* Authentication pointer */
#define GP_WB_READ_SSP_A_PTR() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1080))

#define GP_WB_WRITE_SSP_A_PTR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7FFFFF); \
          GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1080), (val)); \
        } while (0)


/* Authentication length */
#define GP_WB_READ_SSP_A_LEN() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1083))

#define GP_WB_WRITE_SSP_A_LEN(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1083), (val)); \
        } while (0)


/* Message in pointer */
#define GP_WB_READ_SSP_MSG_PTR() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1084))

#define GP_WB_WRITE_SSP_MSG_PTR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7FFFFF); \
          GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1084), (val)); \
        } while (0)


/* Message length */
#define GP_WB_READ_SSP_MSG_LEN() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1087))

#define GP_WB_WRITE_SSP_MSG_LEN(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1087), (val)); \
        } while (0)


/* Mic pointer */
#define GP_WB_READ_SSP_MIC_PTR() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1088))

#define GP_WB_WRITE_SSP_MIC_PTR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7FFFFF); \
          GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1088), (val)); \
        } while (0)


/* key pointer - for access to secured keys, key pointer has to be a multiple of 16 bytes */
#define GP_WB_READ_SSP_KEY_PTR() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x108c))

#define GP_WB_WRITE_SSP_KEY_PTR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7FFFFF); \
          GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x108c), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SSP_KEY_MIC_LEN() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x108f))

#define GP_WB_WRITE_SSP_KEY_MIC_LEN(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x108f), (val))

/* key length enumerate : "00" = 128 bit key, "01" = 192 bit key, "10" = 256 bit key */
#define GP_WB_READ_SSP_KEY_LEN() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x108f)) & 0x03)

#define GP_WB_GET_SSP_KEY_LEN_FROM_KEY_MIC_LEN(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_SSP_KEY_LEN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x108f), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_SSP_KEY_LEN_TO_KEY_MIC_LEN(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3C; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Mic length/2 (actual length is the value set by this property multiplied by 2) */
#define GP_WB_READ_SSP_MIC_LEN() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x108f)) >> 2) & 0x0F)

#define GP_WB_GET_SSP_MIC_LEN_FROM_KEY_MIC_LEN(tmp) \
        (((tmp) >> 2) & 0x0F)

#define GP_WB_WRITE_SSP_MIC_LEN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x108f), 0x3C, (val) << 2); \
        } while (0)

#define GP_WB_SET_SSP_MIC_LEN_TO_KEY_MIC_LEN(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* Pointer to destination location for encrypted data */
#define GP_WB_READ_SSP_MSG_OUT_PTR() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1090))

#define GP_WB_WRITE_SSP_MSG_OUT_PTR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7FFFFF); \
          GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1090), (val)); \
        } while (0)


/* Pointer to destination location for encrypted data */
#define GP_WB_READ_SSP_NONCE_PTR() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1094))

#define GP_WB_WRITE_SSP_NONCE_PTR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7FFFFF); \
          GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1094), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SSP_MODE_AND_INT_CONTROL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1097))

#define GP_WB_WRITE_SSP_MODE_AND_INT_CONTROL(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1097), (val))

/* "00" = Encryption, "01" = decryption, "10" = aes mode, "11" = reserved */
#define GP_WB_READ_SSP_MODE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1097)) & 0x03)

#define GP_WB_GET_SSP_MODE_FROM_MODE_AND_INT_CONTROL(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_SSP_MODE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1097), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_SSP_MODE_TO_MODE_AND_INT_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x0C; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* uses internal secret key  when '1' */
#define GP_WB_READ_SSP_USE_SKEY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1097), 2)

#define GP_WB_GET_SSP_USE_SKEY_FROM_MODE_AND_INT_CONTROL(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_SSP_USE_SKEY(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1097), 2, (val)); \
        } while (0)

#define GP_WB_SET_SSP_USE_SKEY_TO_MODE_AND_INT_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* when set the engine is set into aes_mmo mode - only affects aes_mode */
#define GP_WB_READ_SSP_AES_MMO() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1097), 3)

#define GP_WB_GET_SSP_AES_MMO_FROM_MODE_AND_INT_CONTROL(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_SSP_AES_MMO(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1097), 3, (val)); \
        } while (0)

#define GP_WB_SET_SSP_AES_MMO_TO_MODE_AND_INT_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SSP_CUSTOM_AES_CONTROL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1098))

#define GP_WB_WRITE_SSP_CUSTOM_AES_CONTROL(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1098), (val))

/* enables to override the standard aes sequence and define the number of rounds. When enabled, secure key access is disabled */
#define GP_WB_READ_SSP_CUSTOM_AES_MODE_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1098), 0)

#define GP_WB_GET_SSP_CUSTOM_AES_MODE_ENABLE_FROM_CUSTOM_AES_CONTROL(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_SSP_CUSTOM_AES_MODE_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1098), 0, (val)); \
        } while (0)

#define GP_WB_SET_SSP_CUSTOM_AES_MODE_ENABLE_TO_CUSTOM_AES_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* standard value for key_len 128 = 9, kay_len 192 = 10, key_len 256 = 12. When set differently, aes operation will be non-standard */
#define GP_WB_READ_SSP_CUSTOM_AES_ROUNDS() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1098)) >> 1) & 0x0F)

#define GP_WB_GET_SSP_CUSTOM_AES_ROUNDS_FROM_CUSTOM_AES_CONTROL(tmp) \
        (((tmp) >> 1) & 0x0F)

#define GP_WB_WRITE_SSP_CUSTOM_AES_ROUNDS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1098), 0x1E, (val) << 1); \
        } while (0)

#define GP_WB_SET_SSP_CUSTOM_AES_ROUNDS_TO_CUSTOM_AES_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


#define GP_WB_WRITE_SSP_ENCRYPTION_CONTROL(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1099), (val))

/* Starts an encryption cycle */
#define GP_WB_SSP_START_ENCRYPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1099), 0x01)

#define GP_WB_SET_SSP_START_ENCRYPT_TO_ENCRYPTION_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Interrupt clear */
#define GP_WB_SSP_CLR_DONE_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1099), 0x02)

#define GP_WB_SET_SSP_CLR_DONE_INTERRUPT_TO_ENCRYPTION_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SSP_ENCRYPTION_STATUS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x109a))

/* Indicates the encryption cycle is running */
#define GP_WB_READ_SSP_BUSY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x109a), 0)

#define GP_WB_GET_SSP_BUSY_FROM_ENCRYPTION_STATUS(tmp) \
        ((tmp) & 0x01)

/* Set when an error occurred while accessing the memory */
#define GP_WB_READ_SSP_MEM_ERR() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x109a), 1)

#define GP_WB_GET_SSP_MEM_ERR_FROM_ENCRYPTION_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* Unmasked interrupt indicating encryption cycle finished */
#define GP_WB_READ_SSP_UNMASKED_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x109a), 2)

#define GP_WB_GET_SSP_UNMASKED_DONE_INTERRUPT_FROM_ENCRYPTION_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)

/***************************
 * layout: uart_0
 ***************************/

/* TX data FIFO LSB. In case of 8 data bits or less, transmission in triggered by writing this. */
#define GP_WB_WRITE_UART_0_TX_DATA_0(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a0), (val)); \
        } while (0)


/* TX data FIFO MSB. In case of 9 data bits, transmission in triggered by writing this. */
#define GP_WB_WRITE_UART_0_TX_DATA_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a1), (val)); \
        } while (0)


/* RX data FIFO LSB. In case of 8 data bits or less, reading this will clear the data from the RX data FIFO. */
#define GP_WB_READ_UART_0_RX_DATA_0() \
        GP_WB_READ_SER_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a2))


/* RX data FIFO MSB. In case of 9 data bits, reading this will clear the data from the RX data FIFO. */
#define GP_WB_READ_UART_0_RX_DATA_1() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a3), 0)


/* Actual baud rate = 16MHz / 8*(baud_rate+1) */
#define GP_WB_READ_UART_0_BAUD_RATE() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a4))

#define GP_WB_WRITE_UART_0_BAUD_RATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a4), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_UART_0_CONFIG() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a6))

#define GP_WB_WRITE_UART_0_CONFIG(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a6), (val))

/* Number of data bits in an SPI frame - 1 (0x7 = one byte) */
#define GP_WB_READ_UART_0_DATA_BITS() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a6)) & 0x0F)

#define GP_WB_GET_UART_0_DATA_BITS_FROM_CONFIG(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_UART_0_DATA_BITS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a6), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_UART_0_DATA_BITS_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x03F0; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Parity bit mode. Controls both the generation for TX and the check for RX. */
#define GP_WB_READ_UART_0_PARITY() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a6)) >> 4) & 0x03)

#define GP_WB_GET_UART_0_PARITY_FROM_CONFIG(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_UART_0_PARITY(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a6), 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_UART_0_PARITY_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x03CF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* Number of stop bits - 1 (0x0 = 1, 0x1 = 2. For RX only the first one is checked) */
#define GP_WB_READ_UART_0_STOP_BITS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a6), 6)

#define GP_WB_GET_UART_0_STOP_BITS_FROM_CONFIG(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_UART_0_STOP_BITS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a6), 6, (val)); \
        } while (0)

#define GP_WB_SET_UART_0_STOP_BITS_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03BF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

/* In case of the HW MSI interface (stream_to_regmap = 0), interpret bit 8 as sync bit to reset internal logic. */
#define GP_WB_READ_UART_0_USE_SYNC_BIT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a6), 7)

#define GP_WB_GET_UART_0_USE_SYNC_BIT_FROM_CONFIG(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_UART_0_USE_SYNC_BIT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a6), 7, (val)); \
        } while (0)

#define GP_WB_SET_UART_0_USE_SYNC_BIT_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x037F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* Enable the UART receiver.  (Note the transmitter is automatically enabled when loading data into tx_data) */
#define GP_WB_READ_UART_0_RX_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a7), 0)

#define GP_WB_GET_UART_0_RX_ENABLE_FROM_CONFIG(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_UART_0_RX_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a7), 0, (val)); \
        } while (0)

#define GP_WB_SET_UART_0_RX_ENABLE_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* In case of the HW MSI interface (stream_to_regmap = 0), bit_reverse the data part of the reply. This feature was added for Lime. */
#define GP_WB_READ_UART_0_BIT_REVERSE_REPLY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a7), 1)

#define GP_WB_GET_UART_0_BIT_REVERSE_REPLY_FROM_CONFIG(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_UART_0_BIT_REVERSE_REPLY(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a7), 1, (val)); \
        } while (0)

#define GP_WB_SET_UART_0_BIT_REVERSE_REPLY_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_UART_0_STATUS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a8))

/* Status and unmasked interrupt flag for UART TX not busy. The interrupt is cleared implicitly when writing new TX data. Active when no TX transfer ongoing and no data in TX buffer. */
#define GP_WB_READ_UART_0_UNMASKED_TX_NOT_BUSY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a8), 0)

#define GP_WB_GET_UART_0_UNMASKED_TX_NOT_BUSY_INTERRUPT_FROM_STATUS(tmp) \
        ((tmp) & 0x01)

/* Status and unmasked interrupt flag for TX buffer not full. The interrupt is cleared implicitly when writing new TX data fills the buffer. */
#define GP_WB_READ_UART_0_UNMASKED_TX_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a8), 1)

#define GP_WB_GET_UART_0_UNMASKED_TX_NOT_FULL_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* Status and unmasked interrupt flag for RX buffer not empty. The interrupt is cleared implicitly when reading the last RX data from the buffer. */
#define GP_WB_READ_UART_0_UNMASKED_RX_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a8), 2)

#define GP_WB_GET_UART_0_UNMASKED_RX_NOT_EMPTY_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)

/* Event and unmasked interrupt flag for the occurrence of a rx data buffer overrun event. Set when the rx data buffer is full and new rx data is available. Cleared explicitly by the SW. */
#define GP_WB_READ_UART_0_UNMASKED_RX_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a8), 3)

#define GP_WB_GET_UART_0_UNMASKED_RX_OVERRUN_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 3) & 0x01)

/* Event and unmasked interrupt flag for the occurrence of a rx parity error. Set when the parity checking is enabled and the received parity bit does not match with the calculated. Cleared explicitly by the SW. */
#define GP_WB_READ_UART_0_UNMASKED_RX_PARITY_ERROR_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a8), 4)

#define GP_WB_GET_UART_0_UNMASKED_RX_PARITY_ERROR_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 4) & 0x01)

/* Event and unmasked interrupt flag for the occurrence of a rx framing error. Set when the (first) stop bit of a received frame was not 1. Cleared explicitly by the SW. */
#define GP_WB_READ_UART_0_UNMASKED_RX_FRAMING_ERROR_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a8), 5)

#define GP_WB_GET_UART_0_UNMASKED_RX_FRAMING_ERROR_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 5) & 0x01)

/* Status flag for UART RX not busy. Active when no RX transfer is ongoing. */
#define GP_WB_READ_UART_0_RX_NOT_BUSY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a8), 6)

#define GP_WB_GET_UART_0_RX_NOT_BUSY_FROM_STATUS(tmp) \
        (((tmp) >> 6) & 0x01)


#define GP_WB_WRITE_UART_0_CLR_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a9), (val))

/* Clear the rx_overrun_interrupt. */
#define GP_WB_UART_0_CLR_RX_OVERRUN_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a9), 0x01)

#define GP_WB_SET_UART_0_CLR_RX_OVERRUN_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Clear the rx_parity_error_interrupt. */
#define GP_WB_UART_0_CLR_RX_PARITY_ERROR_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a9), 0x02)

#define GP_WB_SET_UART_0_CLR_RX_PARITY_ERROR_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Clear the rx_framining_error_interrupt. */
#define GP_WB_UART_0_CLR_RX_FRAMING_ERROR_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10a9), 0x04)

#define GP_WB_SET_UART_0_CLR_RX_FRAMING_ERROR_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/***************************
 * layout: uart_1
 ***************************/

/* TX data FIFO LSB. In case of 8 data bits or less, transmission in triggered by writing this. */
#define GP_WB_WRITE_UART_1_TX_DATA_0(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10b0), (val)); \
        } while (0)


/* TX data FIFO MSB. In case of 9 data bits, transmission in triggered by writing this. */
#define GP_WB_WRITE_UART_1_TX_DATA_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10b1), (val)); \
        } while (0)


/* RX data FIFO LSB. In case of 8 data bits or less, reading this will clear the data from the RX data FIFO. */
#define GP_WB_READ_UART_1_RX_DATA_0() \
        GP_WB_READ_SER_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10b2))


/* RX data FIFO MSB. In case of 9 data bits, reading this will clear the data from the RX data FIFO. */
#define GP_WB_READ_UART_1_RX_DATA_1() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10b3), 0)


/* Actual baud rate = 16MHz / 8*(baud_rate+1) */
#define GP_WB_READ_UART_1_BAUD_RATE() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10b4))

#define GP_WB_WRITE_UART_1_BAUD_RATE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10b4), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_UART_1_CONFIG() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10b6))

#define GP_WB_WRITE_UART_1_CONFIG(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10b6), (val))

/* Number of data bits in an SPI frame - 1 (0x7 = one byte) */
#define GP_WB_READ_UART_1_DATA_BITS() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10b6)) & 0x0F)

#define GP_WB_GET_UART_1_DATA_BITS_FROM_CONFIG(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_UART_1_DATA_BITS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10b6), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_UART_1_DATA_BITS_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x03F0; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Parity bit mode. Controls both the generation for TX and the check for RX. */
#define GP_WB_READ_UART_1_PARITY() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10b6)) >> 4) & 0x03)

#define GP_WB_GET_UART_1_PARITY_FROM_CONFIG(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_UART_1_PARITY(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10b6), 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_UART_1_PARITY_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x03CF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* Number of stop bits - 1 (0x0 = 1, 0x1 = 2. For RX only the first one is checked) */
#define GP_WB_READ_UART_1_STOP_BITS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10b6), 6)

#define GP_WB_GET_UART_1_STOP_BITS_FROM_CONFIG(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_UART_1_STOP_BITS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10b6), 6, (val)); \
        } while (0)

#define GP_WB_SET_UART_1_STOP_BITS_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03BF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

/* In case of the HW MSI interface (stream_to_regmap = 0), interpret bit 8 as sync bit to reset internal logic. */
#define GP_WB_READ_UART_1_USE_SYNC_BIT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10b6), 7)

#define GP_WB_GET_UART_1_USE_SYNC_BIT_FROM_CONFIG(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_UART_1_USE_SYNC_BIT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10b6), 7, (val)); \
        } while (0)

#define GP_WB_SET_UART_1_USE_SYNC_BIT_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x037F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* Enable the UART receiver.  (Note the transmitter is automatically enabled when loading data into tx_data) */
#define GP_WB_READ_UART_1_RX_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10b7), 0)

#define GP_WB_GET_UART_1_RX_ENABLE_FROM_CONFIG(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_UART_1_RX_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10b7), 0, (val)); \
        } while (0)

#define GP_WB_SET_UART_1_RX_ENABLE_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* In case of the HW MSI interface (stream_to_regmap = 0), bit_reverse the data part of the reply. This feature was added for Lime. */
#define GP_WB_READ_UART_1_BIT_REVERSE_REPLY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10b7), 1)

#define GP_WB_GET_UART_1_BIT_REVERSE_REPLY_FROM_CONFIG(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_UART_1_BIT_REVERSE_REPLY(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10b7), 1, (val)); \
        } while (0)

#define GP_WB_SET_UART_1_BIT_REVERSE_REPLY_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_UART_1_STATUS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10b8))

/* Status and unmasked interrupt flag for UART TX not busy. The interrupt is cleared implicitly when writing new TX data. Active when no TX transfer ongoing and no data in TX buffer. */
#define GP_WB_READ_UART_1_UNMASKED_TX_NOT_BUSY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10b8), 0)

#define GP_WB_GET_UART_1_UNMASKED_TX_NOT_BUSY_INTERRUPT_FROM_STATUS(tmp) \
        ((tmp) & 0x01)

/* Status and unmasked interrupt flag for TX buffer not full. The interrupt is cleared implicitly when writing new TX data fills the buffer. */
#define GP_WB_READ_UART_1_UNMASKED_TX_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10b8), 1)

#define GP_WB_GET_UART_1_UNMASKED_TX_NOT_FULL_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* Status and unmasked interrupt flag for RX buffer not empty. The interrupt is cleared implicitly when reading the last RX data from the buffer. */
#define GP_WB_READ_UART_1_UNMASKED_RX_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10b8), 2)

#define GP_WB_GET_UART_1_UNMASKED_RX_NOT_EMPTY_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)

/* Event and unmasked interrupt flag for the occurrence of a rx data buffer overrun event. Set when the rx data buffer is full and new rx data is available. Cleared explicitly by the SW. */
#define GP_WB_READ_UART_1_UNMASKED_RX_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10b8), 3)

#define GP_WB_GET_UART_1_UNMASKED_RX_OVERRUN_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 3) & 0x01)

/* Event and unmasked interrupt flag for the occurrence of a rx parity error. Set when the parity checking is enabled and the received parity bit does not match with the calculated. Cleared explicitly by the SW. */
#define GP_WB_READ_UART_1_UNMASKED_RX_PARITY_ERROR_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10b8), 4)

#define GP_WB_GET_UART_1_UNMASKED_RX_PARITY_ERROR_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 4) & 0x01)

/* Event and unmasked interrupt flag for the occurrence of a rx framing error. Set when the (first) stop bit of a received frame was not 1. Cleared explicitly by the SW. */
#define GP_WB_READ_UART_1_UNMASKED_RX_FRAMING_ERROR_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10b8), 5)

#define GP_WB_GET_UART_1_UNMASKED_RX_FRAMING_ERROR_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 5) & 0x01)

/* Status flag for UART RX not busy. Active when no RX transfer is ongoing. */
#define GP_WB_READ_UART_1_RX_NOT_BUSY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10b8), 6)

#define GP_WB_GET_UART_1_RX_NOT_BUSY_FROM_STATUS(tmp) \
        (((tmp) >> 6) & 0x01)


#define GP_WB_WRITE_UART_1_CLR_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10b9), (val))

/* Clear the rx_overrun_interrupt. */
#define GP_WB_UART_1_CLR_RX_OVERRUN_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10b9), 0x01)

#define GP_WB_SET_UART_1_CLR_RX_OVERRUN_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Clear the rx_parity_error_interrupt. */
#define GP_WB_UART_1_CLR_RX_PARITY_ERROR_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10b9), 0x02)

#define GP_WB_SET_UART_1_CLR_RX_PARITY_ERROR_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Clear the rx_framining_error_interrupt. */
#define GP_WB_UART_1_CLR_RX_FRAMING_ERROR_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10b9), 0x04)

#define GP_WB_SET_UART_1_CLR_RX_FRAMING_ERROR_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/***************************
 * layout: spi_m
 ***************************/

/* TX data FIFO LSB. In case of 8 data bits or less, transmission in triggered by writing this. */
#define GP_WB_WRITE_SPI_M_TX_DATA_0(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10d0), (val)); \
        } while (0)


/* TX data FIFO MSB. In case of 9 data bits or more, transmission in triggered by writing this. */
#define GP_WB_WRITE_SPI_M_TX_DATA_1(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10d1), (val)); \
        } while (0)


/* RX data FIFO LSB. In case of 8 data bits or less, reading this will clear the data from the RX data FIFO. */
#define GP_WB_READ_SPI_M_RX_DATA_0() \
        GP_WB_READ_SER_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10d2))


/* RX data FIFO MSB. In case of 9 data bits or more, reading this will clear the data from the RX data FIFO. */
#define GP_WB_READ_SPI_M_RX_DATA_1() \
        GP_WB_READ_SER_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10d3))


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SPI_M_CONFIG() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10d4))

#define GP_WB_WRITE_SPI_M_CONFIG(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10d4), (val))

/* Number of data bits in an SPI frame - 1 (0x7 = one byte) */
#define GP_WB_READ_SPI_M_DATA_BITS() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10d4)) & 0x0F)

#define GP_WB_GET_SPI_M_DATA_BITS_FROM_CONFIG(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_SPI_M_DATA_BITS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10d4), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_SPI_M_DATA_BITS_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x0FF0; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* SCLK clock frequency: 32MHz / 2**sclk_freq */
#define GP_WB_READ_SPI_M_SCLK_FREQ() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10d4)) >> 4) & 0x07)

#define GP_WB_GET_SPI_M_SCLK_FREQ_FROM_CONFIG(tmp) \
        (((tmp) >> 4) & 0x07)

#define GP_WB_WRITE_SPI_M_SCLK_FREQ(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10d4), 0x70, (val) << 4); \
        } while (0)

#define GP_WB_SET_SPI_M_SCLK_FREQ_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x0F8F; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* Master SPI data order. */
#define GP_WB_READ_SPI_M_LSB_FIRST() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10d4), 7)

#define GP_WB_GET_SPI_M_LSB_FIRST_FROM_CONFIG(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_SPI_M_LSB_FIRST(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10d4), 7, (val)); \
        } while (0)

#define GP_WB_SET_SPI_M_LSB_FIRST_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* Master SPI mode */
#define GP_WB_READ_SPI_M_MODE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10d5)) & 0x03)

#define GP_WB_GET_SPI_M_MODE_FROM_CONFIG(tmp) \
        (((tmp) >> 8) & 0x03)

#define GP_WB_WRITE_SPI_M_MODE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10d5), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_SPI_M_MODE_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x0CFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* Free running mode, spi transfers are back-to-back triggered, even when no new tx_data is provided. Can be used for capturing PDM outputs. */
#define GP_WB_READ_SPI_M_FREE_RUNNING() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10d5), 2)

#define GP_WB_GET_SPI_M_FREE_RUNNING_FROM_CONFIG(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_SPI_M_FREE_RUNNING(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10d5), 2, (val)); \
        } while (0)

#define GP_WB_SET_SPI_M_FREE_RUNNING_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0BFF; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)

/* When enabled, a transfer will be stalled (frozen in the last clock cycle of the word) as long as the rx_data FIFO remains full. This will prevent an rx_overrun from happening. */
#define GP_WB_READ_SPI_M_STALL_ON_RX_FULL() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10d5), 3)

#define GP_WB_GET_SPI_M_STALL_ON_RX_FULL_FROM_CONFIG(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_SPI_M_STALL_ON_RX_FULL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10d5), 3, (val)); \
        } while (0)

#define GP_WB_SET_SPI_M_STALL_ON_RX_FULL_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FF; \
          (tmp) |= (((UInt16)(val)) << 11); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SPI_M_UNMASKED_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10d6))

/* Status and unmasked interrupt flag for transfer not busy. The interrupt is cleared implicitly when writing new TX data. Active when no transfer ongoing and no data in TX buffer. */
#define GP_WB_READ_SPI_M_UNMASKED_NOT_BUSY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10d6), 0)

#define GP_WB_GET_SPI_M_UNMASKED_NOT_BUSY_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* Status and unmasked interrupt flag for TX buffer not full. The interrupt is cleared implicitly when writing new TX data fills the buffer. */
#define GP_WB_READ_SPI_M_UNMASKED_TX_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10d6), 1)

#define GP_WB_GET_SPI_M_UNMASKED_TX_NOT_FULL_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* Status and unmasked interrupt flag for RX buffer not empty. The interrupt is cleared implicitly when reading the last RX data from the buffer. */
#define GP_WB_READ_SPI_M_UNMASKED_RX_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10d6), 2)

#define GP_WB_GET_SPI_M_UNMASKED_RX_NOT_EMPTY_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* Event and unmasked interrupt flag for the occurrence of a rx data buffer overrun event. Set when the rx data buffer is full and new rx data is available. Cleared explicitly by the SW. */
#define GP_WB_READ_SPI_M_UNMASKED_RX_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10d6), 3)

#define GP_WB_GET_SPI_M_UNMASKED_RX_OVERRUN_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)


/* Clear the rx_overrun_interrupt. */
#define GP_WB_SPI_M_CLR_RX_OVERRUN_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10d7), 0x01)

/***************************
 * layout: keypad
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_KEYPAD_KEYPAD_CONFIG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e0))

#define GP_WB_WRITE_KEYPAD_KEYPAD_CONFIG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e0), (val))

/* Keypad scan enabled */
#define GP_WB_READ_KEYPAD_KEYPAD_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e0), 0)

#define GP_WB_GET_KEYPAD_KEYPAD_ENABLE_FROM_KEYPAD_CONFIG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_KEYPAD_KEYPAD_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e0), 0, (val)); \
        } while (0)

#define GP_WB_SET_KEYPAD_KEYPAD_ENABLE_TO_KEYPAD_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When '1' the scan outputs are driven to 0 during active to allow new keypad press to be detected */
#define GP_WB_READ_KEYPAD_SENSITIVE_DURING_ACTIVE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e0), 1)

#define GP_WB_GET_KEYPAD_SENSITIVE_DURING_ACTIVE_FROM_KEYPAD_CONFIG(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_KEYPAD_SENSITIVE_DURING_ACTIVE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e0), 1, (val)); \
        } while (0)

#define GP_WB_SET_KEYPAD_SENSITIVE_DURING_ACTIVE_TO_KEYPAD_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* When '1', the scan outputs are driven to 0 after the real measurement (debug) */
#define GP_WB_READ_KEYPAD_PROLONGED_ROW_DRIVE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e0), 2)

#define GP_WB_GET_KEYPAD_PROLONGED_ROW_DRIVE_FROM_KEYPAD_CONFIG(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_KEYPAD_PROLONGED_ROW_DRIVE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e0), 2, (val)); \
        } while (0)

#define GP_WB_SET_KEYPAD_PROLONGED_ROW_DRIVE_TO_KEYPAD_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Spreads output changes over time to reduce sso effects */
#define GP_WB_READ_KEYPAD_SSO_SPREAD_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e0), 3)

#define GP_WB_GET_KEYPAD_SSO_SPREAD_ENABLE_FROM_KEYPAD_CONFIG(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_KEYPAD_SSO_SPREAD_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e0), 3, (val)); \
        } while (0)

#define GP_WB_SET_KEYPAD_SSO_SPREAD_ENABLE_TO_KEYPAD_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Enables clock gating (to be enabled when changing sensitive_during_active setting) */
#define GP_WB_READ_KEYPAD_ENABLE_CLK_KEYPAD_BY_UC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e0), 4)

#define GP_WB_GET_KEYPAD_ENABLE_CLK_KEYPAD_BY_UC_FROM_KEYPAD_CONFIG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_KEYPAD_ENABLE_CLK_KEYPAD_BY_UC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e0), 4, (val)); \
        } while (0)

#define GP_WB_SET_KEYPAD_ENABLE_CLK_KEYPAD_BY_UC_TO_KEYPAD_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* Active columns charge period selection: 0=250ns 1=500ns, 2=750ns, ..., FF= disabled */
#define GP_WB_READ_KEYPAD_ACTIVE_COLUMNS_CHARGE_PERIOD() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e1))

#define GP_WB_WRITE_KEYPAD_ACTIVE_COLUMNS_CHARGE_PERIOD(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e1), (val)); \
        } while (0)


/* Passive columns charge period selection: 0=250ns 1=500ns, 2=750ns, ..., FF= disabled */
#define GP_WB_READ_KEYPAD_PASSIVE_COLUMNS_CHARGE_PERIOD() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e2))

#define GP_WB_WRITE_KEYPAD_PASSIVE_COLUMNS_CHARGE_PERIOD(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e2), (val)); \
        } while (0)


/* Time that scan outputs are driven to 0 before measurement is done:0=250ns 1=500ns, 2=750ns, ..., FF = 63750ns */
#define GP_WB_READ_KEYPAD_ROW_DRIVE_PERIOD() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e3))

#define GP_WB_WRITE_KEYPAD_ROW_DRIVE_PERIOD(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e3), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_KEYPAD_KEYPAD_STATE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e4))

/* Indicates if a keypad scan is busy */
#define GP_WB_READ_KEYPAD_KEYPAD_SCAN_BUSY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e4), 0)

#define GP_WB_GET_KEYPAD_KEYPAD_SCAN_BUSY_FROM_KEYPAD_STATE(tmp) \
        ((tmp) & 0x01)

/* Indicates the state of a ongoing keypad scan */
#define GP_WB_READ_KEYPAD_KEYPAD_SCAN_STATE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e4)) >> 1) & 0x07)

#define GP_WB_GET_KEYPAD_KEYPAD_SCAN_STATE_FROM_KEYPAD_STATE(tmp) \
        (((tmp) >> 1) & 0x07)

/* Indicates the row counter of a ongoing keypad scan */
#define GP_WB_READ_KEYPAD_KEYPAD_SCAN_COUNTER() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e4)) >> 4) & 0x07)

#define GP_WB_GET_KEYPAD_KEYPAD_SCAN_COUNTER_FROM_KEYPAD_STATE(tmp) \
        (((tmp) >> 4) & 0x07)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_KEYPAD_KEYPAD_STATUS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e5))

/* Results updated indication: this bit is set to 0x1 when one of the scan results is updated, cleared by writing 0x1 to clear_results_updated */
#define GP_WB_READ_KEYPAD_RESULTS_UPDATED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e5), 0)

#define GP_WB_GET_KEYPAD_RESULTS_UPDATED_FROM_KEYPAD_STATUS(tmp) \
        ((tmp) & 0x01)

/* Results changed indication: this bit is set to 0x1 when one of the scan results is updated and was different from previous value, cleared by writing 0x1 to clear_results_changed */
#define GP_WB_READ_KEYPAD_RESULTS_CHANGED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e5), 1)

#define GP_WB_GET_KEYPAD_RESULTS_CHANGED_FROM_KEYPAD_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* Results valid indication: this bit is set to 0x1 when all of the keypad scan's inputs are connected to the device's input pads. Cleared by writing 0x1 to clear_results_valid */
#define GP_WB_READ_KEYPAD_RESULTS_VALID() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e5), 2)

#define GP_WB_GET_KEYPAD_RESULTS_VALID_FROM_KEYPAD_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)


/* Read back of keypad scan output value */
#define GP_WB_READ_KEYPAD_KEYPAD_SCANS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e6))


/* Read back of keypad senses active charge output value */
#define GP_WB_READ_KEYPAD_KEYPAD_SENSES_ACTIVE_CHARGE() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e7))


/* Read back of keypad senses input value */
#define GP_WB_READ_KEYPAD_KEYPAD_SENSES() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e8))


#define GP_WB_WRITE_KEYPAD_KEYPAD_CONTROL(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e9), (val))

/* Clears results updated */
#define GP_WB_KEYPAD_CLEAR_RESULTS_UPDATED() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e9), 0x01)

#define GP_WB_SET_KEYPAD_CLEAR_RESULTS_UPDATED_TO_KEYPAD_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Clears results changed */
#define GP_WB_KEYPAD_CLEAR_RESULTS_CHANGED() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e9), 0x02)

#define GP_WB_SET_KEYPAD_CLEAR_RESULTS_CHANGED_TO_KEYPAD_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Clears results valid */
#define GP_WB_KEYPAD_CLEAR_RESULTS_VALID() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10e9), 0x04)

#define GP_WB_SET_KEYPAD_CLEAR_RESULTS_VALID_TO_KEYPAD_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* Counts the number of consecutive times the same result was detected, cleared by writing 0x0 */
#define GP_WB_READ_KEYPAD_RESULTS_STABLE_COUNTER() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10ea))

#define GP_WB_WRITE_KEYPAD_RESULTS_STABLE_COUNTER(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10ea), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_KEYPAD_KEYPAD_RESULT_SUMMARY() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10eb))

#define GP_WB_WRITE_KEYPAD_KEYPAD_RESULT_SUMMARY(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10eb), (val))

/* Number of keys detected, 0=no key, 1=single key, 2=two keys, 3= more than 2 keys. */
#define GP_WB_READ_KEYPAD_NUMBER_OF_KEYS() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10eb)) & 0x03)

#define GP_WB_GET_KEYPAD_NUMBER_OF_KEYS_FROM_KEYPAD_RESULT_SUMMARY(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_KEYPAD_NUMBER_OF_KEYS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10eb), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_KEYPAD_NUMBER_OF_KEYS_TO_KEYPAD_RESULT_SUMMARY(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0xFC; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Single key scan (row) number (0...7). */
#define GP_WB_READ_KEYPAD_SINGLE_KEY_SCAN() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10eb)) >> 2) & 0x07)

#define GP_WB_GET_KEYPAD_SINGLE_KEY_SCAN_FROM_KEYPAD_RESULT_SUMMARY(tmp) \
        (((tmp) >> 2) & 0x07)

#define GP_WB_WRITE_KEYPAD_SINGLE_KEY_SCAN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10eb), 0x1C, (val) << 2); \
        } while (0)

#define GP_WB_SET_KEYPAD_SINGLE_KEY_SCAN_TO_KEYPAD_RESULT_SUMMARY(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0xE3; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Single key sense (column) number (0...7). */
#define GP_WB_READ_KEYPAD_SINGLE_KEY_SENSE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10eb)) >> 5) & 0x07)

#define GP_WB_GET_KEYPAD_SINGLE_KEY_SENSE_FROM_KEYPAD_RESULT_SUMMARY(tmp) \
        (((tmp) >> 5) & 0x07)

#define GP_WB_WRITE_KEYPAD_SINGLE_KEY_SENSE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10eb), 0xE0, (val) << 5); \
        } while (0)

#define GP_WB_SET_KEYPAD_SINGLE_KEY_SENSE_TO_KEYPAD_RESULT_SUMMARY(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* Key sense vector 0. */
#define GP_WB_READ_KEYPAD_KEY_VECTOR_0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10ec))

#define GP_WB_WRITE_KEYPAD_KEY_VECTOR_0(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10ec), (val)); \
        } while (0)


/* Key sense vector 1. */
#define GP_WB_READ_KEYPAD_KEY_VECTOR_1() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10ed))

#define GP_WB_WRITE_KEYPAD_KEY_VECTOR_1(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10ed), (val)); \
        } while (0)


/* Key sense vector 2. */
#define GP_WB_READ_KEYPAD_KEY_VECTOR_2() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10ee))

#define GP_WB_WRITE_KEYPAD_KEY_VECTOR_2(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10ee), (val)); \
        } while (0)


/* Key sense vector 3. */
#define GP_WB_READ_KEYPAD_KEY_VECTOR_3() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10ef))

#define GP_WB_WRITE_KEYPAD_KEY_VECTOR_3(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10ef), (val)); \
        } while (0)


/* Key sense vector 4. */
#define GP_WB_READ_KEYPAD_KEY_VECTOR_4() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10f0))

#define GP_WB_WRITE_KEYPAD_KEY_VECTOR_4(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10f0), (val)); \
        } while (0)


/* Key sense vector 5. */
#define GP_WB_READ_KEYPAD_KEY_VECTOR_5() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10f1))

#define GP_WB_WRITE_KEYPAD_KEY_VECTOR_5(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10f1), (val)); \
        } while (0)


/* Key sense vector 6. */
#define GP_WB_READ_KEYPAD_KEY_VECTOR_6() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10f2))

#define GP_WB_WRITE_KEYPAD_KEY_VECTOR_6(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10f2), (val)); \
        } while (0)


/* Key sense vector 7. */
#define GP_WB_READ_KEYPAD_KEY_VECTOR_7() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10f3))

#define GP_WB_WRITE_KEYPAD_KEY_VECTOR_7(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10f3), (val)); \
        } while (0)


/* Masked interrupt event status,  Active when 0x1 */
#define GP_WB_READ_KEYPAD_UNMASKED_SCAN_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10f4), 0)


/* Interrupt event clear by writing 0x1 */
#define GP_WB_KEYPAD_CLR_SCAN_DONE_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10f5), 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_KEYPAD_KEYPAD_RETENTION() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10f6))

#define GP_WB_WRITE_KEYPAD_KEYPAD_RETENTION(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10f6), (val))

/* Retention unmasked keypad interrupt */
#define GP_WB_READ_KEYPAD_RETENTION_UNMASKED_SCAN_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10f6), 0)

#define GP_WB_GET_KEYPAD_RETENTION_UNMASKED_SCAN_DONE_INTERRUPT_FROM_KEYPAD_RETENTION(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_KEYPAD_RETENTION_UNMASKED_SCAN_DONE_INTERRUPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10f6), 0, (val)); \
        } while (0)

#define GP_WB_SET_KEYPAD_RETENTION_UNMASKED_SCAN_DONE_INTERRUPT_TO_KEYPAD_RETENTION(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Retention results updated */
#define GP_WB_READ_KEYPAD_RETENTION_RESULTS_UPDATED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10f6), 1)

#define GP_WB_GET_KEYPAD_RETENTION_RESULTS_UPDATED_FROM_KEYPAD_RETENTION(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_KEYPAD_RETENTION_RESULTS_UPDATED(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10f6), 1, (val)); \
        } while (0)

#define GP_WB_SET_KEYPAD_RETENTION_RESULTS_UPDATED_TO_KEYPAD_RETENTION(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Retention results changed */
#define GP_WB_READ_KEYPAD_RETENTION_RESULTS_CHANGED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10f6), 2)

#define GP_WB_GET_KEYPAD_RETENTION_RESULTS_CHANGED_FROM_KEYPAD_RETENTION(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_KEYPAD_RETENTION_RESULTS_CHANGED(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10f6), 2, (val)); \
        } while (0)

#define GP_WB_SET_KEYPAD_RETENTION_RESULTS_CHANGED_TO_KEYPAD_RETENTION(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Retention results valid */
#define GP_WB_READ_KEYPAD_RETENTION_RESULTS_VALID() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10f6), 3)

#define GP_WB_GET_KEYPAD_RETENTION_RESULTS_VALID_FROM_KEYPAD_RETENTION(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_KEYPAD_RETENTION_RESULTS_VALID(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x10f6), 3, (val)); \
        } while (0)

#define GP_WB_SET_KEYPAD_RETENTION_RESULTS_VALID_TO_KEYPAD_RETENTION(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/***************************
 * layout: ir
 ***************************/

/* Sets the divide factor for the prescaler. The prescaled frequecy is 16MHz/(2**prescale_div). */
#define GP_WB_READ_IR_PRESCALE_DIV() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1100))

#define GP_WB_WRITE_IR_PRESCALE_DIV(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1100), (val)); \
        } while (0)


/* Sets the 'on' time of the pwm carrier expressed in prescale clock periods. On time is: Ton = Tprescale*(threshold+1). Setting used when use_alt_carrier_configuration equals '0'. */
#define GP_WB_READ_IR_THRESHOLD() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1101))

#define GP_WB_WRITE_IR_THRESHOLD(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1101), (val)); \
        } while (0)


/* Sets the PWM carrier period as a function of the prescale period. Tcarrierper = Tprescale*(wrap+1). Setting used when use_alt_carrier_configuration equals '0'. */
#define GP_WB_READ_IR_WRAP() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1102))

#define GP_WB_WRITE_IR_WRAP(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1102), (val)); \
        } while (0)


/* Sets the 'on' time of the pwm carrier expressed in prescale clock periods. On time is: Ton = Tprescale*(threshold+1). Setting used when use_alt_carrier_configuration equals '1'. */
#define GP_WB_READ_IR_ALT_THRESHOLD() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1103))

#define GP_WB_WRITE_IR_ALT_THRESHOLD(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1103), (val)); \
        } while (0)


/* Sets the PWM carrier period as a function of the prescale period. Tcarrierper = Tprescale*(wrap+1). Setting used when use_alt_carrier_configuration equals '1'. */
#define GP_WB_READ_IR_ALT_WRAP() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1104))

#define GP_WB_WRITE_IR_ALT_WRAP(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1104), (val)); \
        } while (0)


/* Sets the carrier Tu in number of carrier rising edges. Is used when ir  driver is in pattern mode */
#define GP_WB_READ_IR_CARRIER_TU() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1105))

#define GP_WB_WRITE_IR_CARRIER_TU(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1105), (val)); \
        } while (0)


/* Sets the time unit for the time based ram sequence mode. The time unit can be 500ns, 1us(=default), 2us or 4 us */
#define GP_WB_READ_IR_TIMER_TU() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1106))

#define GP_WB_WRITE_IR_TIMER_TU(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1106), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IR_MODULATION_CONTROL_0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1107))

#define GP_WB_WRITE_IR_MODULATION_CONTROL_0(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1107), (val))

/* Selects what source will be used for envelope modulation. Can be from registermap, from external pin, from  event scheduler or from ram sequence */
#define GP_WB_READ_IR_MODULATION_MODE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1107)) & 0x07)

#define GP_WB_GET_IR_MODULATION_MODE_FROM_MODULATION_CONTROL_0(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_IR_MODULATION_MODE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1107), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_IR_MODULATION_MODE_TO_MODULATION_CONTROL_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x78; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When set to '1', the carrier only starts running when the modulation is on. So the carrier is always aligned with the modulation start */
#define GP_WB_READ_IR_ALIGN_ON_START() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1107), 3)

#define GP_WB_GET_IR_ALIGN_ON_START_FROM_MODULATION_CONTROL_0(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_IR_ALIGN_ON_START(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1107), 3, (val)); \
        } while (0)

#define GP_WB_SET_IR_ALIGN_ON_START_TO_MODULATION_CONTROL_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x77; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* When set to '1', the value of the modulation (or envelope) is sampled when the carrier period starts. In this way it can be guaranteed that carrier period is not interrupted (so no glitches) */
#define GP_WB_READ_IR_MODULATION_LATCH_ON_START() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1107), 4)

#define GP_WB_GET_IR_MODULATION_LATCH_ON_START_FROM_MODULATION_CONTROL_0(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_IR_MODULATION_LATCH_ON_START(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1107), 4, (val)); \
        } while (0)

#define GP_WB_SET_IR_MODULATION_LATCH_ON_START_TO_MODULATION_CONTROL_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x6F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* direct control of the modulation in the case the register_based modulation mode is chosen */
#define GP_WB_READ_IR_MODULATION() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1107), 5)

#define GP_WB_GET_IR_MODULATION_FROM_MODULATION_CONTROL_0(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_IR_MODULATION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1107), 5, (val)); \
        } while (0)

#define GP_WB_SET_IR_MODULATION_TO_MODULATION_CONTROL_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x5F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* When set to '1', the ram sequence will be repeated when it is finished (only for time_based and pattern_based modes) */
#define GP_WB_READ_IR_REPEAT_SEQUENCE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1107), 6)

#define GP_WB_GET_IR_REPEAT_SEQUENCE_FROM_MODULATION_CONTROL_0(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_IR_REPEAT_SEQUENCE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1107), 6, (val)); \
        } while (0)

#define GP_WB_SET_IR_REPEAT_SEQUENCE_TO_MODULATION_CONTROL_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IR_MODULATION_CONTROL_1() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1108))

#define GP_WB_WRITE_IR_MODULATION_CONTROL_1(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1108), (val))

/* When set to '1', the ram sequence start pointer and ram sequence length are latched when a ram sequence is fired (only for time_based and pattern_based modes) */
#define GP_WB_READ_IR_LATCH_RAM_SEQUENCE_START_PTR_AND_LEN_ON_START() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1108), 0)

#define GP_WB_GET_IR_LATCH_RAM_SEQUENCE_START_PTR_AND_LEN_ON_START_FROM_MODULATION_CONTROL_1(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IR_LATCH_RAM_SEQUENCE_START_PTR_AND_LEN_ON_START(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1108), 0, (val)); \
        } while (0)

#define GP_WB_SET_IR_LATCH_RAM_SEQUENCE_START_PTR_AND_LEN_ON_START_TO_MODULATION_CONTROL_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When set to '1', the ram sequence start pointer and ram sequence length are latched when a ram sequence is repeated, because the repeat seuance bit was set (only for time_based and pattern_based modes) */
#define GP_WB_READ_IR_LATCH_RAM_SEQUENCE_START_PTR_AND_LEN_ON_REPEAT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1108), 1)

#define GP_WB_GET_IR_LATCH_RAM_SEQUENCE_START_PTR_AND_LEN_ON_REPEAT_FROM_MODULATION_CONTROL_1(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_IR_LATCH_RAM_SEQUENCE_START_PTR_AND_LEN_ON_REPEAT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1108), 1, (val)); \
        } while (0)

#define GP_WB_SET_IR_LATCH_RAM_SEQUENCE_START_PTR_AND_LEN_ON_REPEAT_TO_MODULATION_CONTROL_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* When set to '1', the use_alt_carrier_config will be toggle on an index match (only for time_based and pattern_based modes) */
#define GP_WB_READ_IR_TOGGLE_ALT_CARRIER_CONFIG_ON_INDEX_MATCH() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1108), 2)

#define GP_WB_GET_IR_TOGGLE_ALT_CARRIER_CONFIG_ON_INDEX_MATCH_FROM_MODULATION_CONTROL_1(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_IR_TOGGLE_ALT_CARRIER_CONFIG_ON_INDEX_MATCH(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1108), 2, (val)); \
        } while (0)

#define GP_WB_SET_IR_TOGGLE_ALT_CARRIER_CONFIG_ON_INDEX_MATCH_TO_MODULATION_CONTROL_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* When set to '1', the ram sequencer can be start by the ES (only for time_based and pattern_based modes) */
#define GP_WB_READ_IR_SENSITIVE_FOR_ES_START() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1108), 3)

#define GP_WB_GET_IR_SENSITIVE_FOR_ES_START_FROM_MODULATION_CONTROL_1(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_IR_SENSITIVE_FOR_ES_START(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1108), 3, (val)); \
        } while (0)

#define GP_WB_SET_IR_SENSITIVE_FOR_ES_START_TO_MODULATION_CONTROL_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* Sets the start pointer of the ram modulation sequence block (16 bit word address offset with respect to RAM start adddress) */
#define GP_WB_READ_IR_RAM_SEQUENCE_START_PTR() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x110a))

#define GP_WB_WRITE_IR_RAM_SEQUENCE_START_PTR(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x110a), (val)); \
        } while (0)


/* Sets the length of the ram sequence - len is set to number of entries - 1 */
#define GP_WB_READ_IR_RAM_SEQUENCE_LEN() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x110c))

#define GP_WB_WRITE_IR_RAM_SEQUENCE_LEN(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x110c), (val)); \
        } while (0)


/* Sets the index value that is checked for matches */
#define GP_WB_READ_IR_RAM_SEQUENCE_MATCH_INDEX() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x110d))

#define GP_WB_WRITE_IR_RAM_SEQUENCE_MATCH_INDEX(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x110d), (val)); \
        } while (0)


#define GP_WB_WRITE_IR_MODULATION_TRIGGERS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x110e), (val))

/* Fire off a ram sequence */
#define GP_WB_IR_START_RAM_SEQUENCER() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x110e), 0x01)

#define GP_WB_SET_IR_START_RAM_SEQUENCER_TO_MODULATION_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Set use_alt_carrier_configuration to 1 */
#define GP_WB_IR_ALT_CARRIER_SET() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x110e), 0x02)

#define GP_WB_SET_IR_ALT_CARRIER_SET_TO_MODULATION_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Set use_alt_carrier_configuration to 0 */
#define GP_WB_IR_ALT_CARRIER_UNSET() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x110e), 0x04)

#define GP_WB_SET_IR_ALT_CARRIER_UNSET_TO_MODULATION_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


#define GP_WB_WRITE_IR_INTERRUPT_TRIGGERS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x110f), (val))

/* sequence start interrupt clear */
#define GP_WB_IR_CLR_SEQUENCE_START_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x110f), 0x01)

#define GP_WB_SET_IR_CLR_SEQUENCE_START_INTERRUPT_TO_INTERRUPT_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* sequence repeat interrupt clear */
#define GP_WB_IR_CLR_SEQUENCE_REPEAT_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x110f), 0x02)

#define GP_WB_SET_IR_CLR_SEQUENCE_REPEAT_INTERRUPT_TO_INTERRUPT_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* sequence done interrupt clear */
#define GP_WB_IR_CLR_SEQUENCE_DONE_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x110f), 0x04)

#define GP_WB_SET_IR_CLR_SEQUENCE_DONE_INTERRUPT_TO_INTERRUPT_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* index match interrupt clear */
#define GP_WB_IR_CLR_INDEX_MATCH_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x110f), 0x08)

#define GP_WB_SET_IR_CLR_INDEX_MATCH_INTERRUPT_TO_INTERRUPT_TRIGGERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IR_MODULATION_STATUS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1110))

/* ram sequence is ongoing */
#define GP_WB_READ_IR_BUSY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1110), 0)

#define GP_WB_GET_IR_BUSY_FROM_MODULATION_STATUS(tmp) \
        ((tmp) & 0x01)

/* indicates that the ram sequence was aborted because of a memory access err-or */
#define GP_WB_READ_IR_MEM_ERR() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1110), 1)

#define GP_WB_GET_IR_MEM_ERR_FROM_MODULATION_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* Shows the status of the envelope - just for observability */
#define GP_WB_READ_IR_ENVELOPE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1110), 2)

#define GP_WB_GET_IR_ENVELOPE_FROM_MODULATION_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)

/* Shows the status of the carrier - just for observability */
#define GP_WB_READ_IR_CARRIER() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1110), 3)

#define GP_WB_GET_IR_CARRIER_FROM_MODULATION_STATUS(tmp) \
        (((tmp) >> 3) & 0x01)

/* when '0', threshold and wrap are used for carrier generation. when '1', alt_threshold and alt_wrap are used for carrier generation. */
#define GP_WB_READ_IR_USE_ALT_CARRIER_CONFIG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1110), 4)

#define GP_WB_GET_IR_USE_ALT_CARRIER_CONFIG_FROM_MODULATION_STATUS(tmp) \
        (((tmp) >> 4) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IR_INTERRUPT_STATUS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1111))

/* unmasked interrupt status of the interrupt triggered by starting a ram sequence */
#define GP_WB_READ_IR_UNMASKED_SEQUENCE_START_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1111), 0)

#define GP_WB_GET_IR_UNMASKED_SEQUENCE_START_INTERRUPT_FROM_INTERRUPT_STATUS(tmp) \
        ((tmp) & 0x01)

/* unmasked interrupt status of the interrupt triggered by repeating a ram sequence */
#define GP_WB_READ_IR_UNMASKED_SEQUENCE_REPEAT_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1111), 1)

#define GP_WB_GET_IR_UNMASKED_SEQUENCE_REPEAT_INTERRUPT_FROM_INTERRUPT_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* unmasked interrupt status of the interrupt triggered by finishing a ram sequence */
#define GP_WB_READ_IR_UNMASKED_SEQUENCE_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1111), 2)

#define GP_WB_GET_IR_UNMASKED_SEQUENCE_DONE_INTERRUPT_FROM_INTERRUPT_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)

/* unmasked interrupt status of the interrupt triggered by the ram sequence hitting a certain index */
#define GP_WB_READ_IR_UNMASKED_INDEX_MATCH_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1111), 3)

#define GP_WB_GET_IR_UNMASKED_INDEX_MATCH_INTERRUPT_FROM_INTERRUPT_STATUS(tmp) \
        (((tmp) >> 3) & 0x01)


/* shows the what index in the ram sequence is currently being executed */
#define GP_WB_READ_IR_SEQUENCE_IDX() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1112))


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IR_IO_CONTROL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1113))

#define GP_WB_WRITE_IR_IO_CONTROL(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1113), (val))

/* Sets the drive type for the output */
#define GP_WB_READ_IR_OUTPUT_DRIVE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1113), 0)

#define GP_WB_GET_IR_OUTPUT_DRIVE_FROM_IO_CONTROL(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_IR_OUTPUT_DRIVE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1113), 0, (val)); \
        } while (0)

#define GP_WB_SET_IR_OUTPUT_DRIVE_TO_IO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Inverts the output */
#define GP_WB_READ_IR_OUTPUT_INVERT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1113), 1)

#define GP_WB_GET_IR_OUTPUT_INVERT_FROM_IO_CONTROL(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_IR_OUTPUT_INVERT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1113), 1, (val)); \
        } while (0)

#define GP_WB_SET_IR_OUTPUT_INVERT_TO_IO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* inverts the input */
#define GP_WB_READ_IR_INPUT_INVERT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1113), 2)

#define GP_WB_GET_IR_INPUT_INVERT_FROM_IO_CONTROL(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_IR_INPUT_INVERT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1113), 2, (val)); \
        } while (0)

#define GP_WB_SET_IR_INPUT_INVERT_TO_IO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/***************************
 * layout: watchdog
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_WATCHDOG_CONTROL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1120))

#define GP_WB_WRITE_WATCHDOG_CONTROL(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1120), (val))

/* Watchdog enabled when 0x1 - Writing this register only has effect when in the control settings change sequence */
#define GP_WB_READ_WATCHDOG_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1120), 0)

#define GP_WB_GET_WATCHDOG_ENABLE_FROM_CONTROL(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_WATCHDOG_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1120), 0, (val)); \
        } while (0)

#define GP_WB_SET_WATCHDOG_ENABLE_TO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Function of watchdog, triggered when timer reaches zero - Writing this register only has effect when in the control settings change sequence */
#define GP_WB_READ_WATCHDOG_WATCHDOG_FUNCTION() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1120)) >> 1) & 0x07)

#define GP_WB_GET_WATCHDOG_WATCHDOG_FUNCTION_FROM_CONTROL(tmp) \
        (((tmp) >> 1) & 0x07)

#define GP_WB_WRITE_WATCHDOG_WATCHDOG_FUNCTION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1120), 0x0E, (val) << 1); \
        } while (0)

#define GP_WB_SET_WATCHDOG_WATCHDOG_FUNCTION_TO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x11; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* When set to 1 a keep alive mechanism is enabled, where the standby RC clock is used to check if the main clock is still runninig. A POR will be triggered if the main clock is not running */
#define GP_WB_READ_WATCHDOG_ENABLE_KEEP_ALIVE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1120), 4)

#define GP_WB_GET_WATCHDOG_ENABLE_KEEP_ALIVE_FROM_CONTROL(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_WATCHDOG_ENABLE_KEEP_ALIVE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1120), 4, (val)); \
        } while (0)

#define GP_WB_SET_WATCHDOG_ENABLE_KEEP_ALIVE_TO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* Watchdog timeout value in 16 us -  Writing this register only has effect when in the control settings change sequence */
#define GP_WB_READ_WATCHDOG_TIMEOUT() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1122))

#define GP_WB_WRITE_WATCHDOG_TIMEOUT(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1122), (val)); \
        } while (0)


/* Watchdog key register. Write 0xAA to reset the wachdog, Write 0x55 to initiate a control settings change sequence */
#define GP_WB_WRITE_WATCHDOG_KEY(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1124), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_WATCHDOG_CONFIG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1125))

#define GP_WB_WRITE_WATCHDOG_CONFIG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1125), (val))

/* When set to 1, the watchdog timer will be frozen whan the internal uc goes to sleep */
#define GP_WB_READ_WATCHDOG_FREEZE_WHEN_UC_ASLEEP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1125), 0)

#define GP_WB_GET_WATCHDOG_FREEZE_WHEN_UC_ASLEEP_FROM_CONFIG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_WATCHDOG_FREEZE_WHEN_UC_ASLEEP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1125), 0, (val)); \
        } while (0)

#define GP_WB_SET_WATCHDOG_FREEZE_WHEN_UC_ASLEEP_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When set to 1, the watchdog timer will be frozen whan the internal uc hits a break point in debug mode */
#define GP_WB_READ_WATCHDOG_FREEZE_WHEN_UC_BREAK_POINT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1125), 1)

#define GP_WB_GET_WATCHDOG_FREEZE_WHEN_UC_BREAK_POINT_FROM_CONFIG(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_WATCHDOG_FREEZE_WHEN_UC_BREAK_POINT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1125), 1, (val)); \
        } while (0)

#define GP_WB_SET_WATCHDOG_FREEZE_WHEN_UC_BREAK_POINT_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* Clears the watchdog expired interrupt */
#define GP_WB_WATCHDOG_CLR_TIMER_EXPIRED_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1126), 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_WATCHDOG_STATUS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1127))

/* This status bit indicates that the window for changing watchdog control settings is open. Control settings can only be changed when this status bit is 1 */
#define GP_WB_READ_WATCHDOG_CONTROL_CHANGE_WINDOW_ONGOING() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1127), 0)

#define GP_WB_GET_WATCHDOG_CONTROL_CHANGE_WINDOW_ONGOING_FROM_STATUS(tmp) \
        ((tmp) & 0x01)

/* Unmasked status of the timer expired interrupt */
#define GP_WB_READ_WATCHDOG_UNMASKED_TIMER_EXPIRED_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1127), 1)

#define GP_WB_GET_WATCHDOG_UNMASKED_TIMER_EXPIRED_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* Indicates that the timer has reached 0. This status is reset by a watchdog reset, or by a control settings change */
#define GP_WB_READ_WATCHDOG_TIMER_EXPIRED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1127), 2)

#define GP_WB_GET_WATCHDOG_TIMER_EXPIRED_FROM_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)


/* Watchdog current time (16 us multiples) */
#define GP_WB_READ_WATCHDOG_CURRENT_TIME() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1128))

/***************************
 * layout: leds
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_LEDS_CONTROL_0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1140))

#define GP_WB_WRITE_LEDS_CONTROL_0(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1140), (val))

/* Set to 1 to enable the led */
#define GP_WB_READ_LEDS_LED0_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1140), 0)

#define GP_WB_GET_LEDS_LED0_ENABLE_FROM_CONTROL_0(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_LEDS_LED0_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1140), 0, (val)); \
        } while (0)

#define GP_WB_SET_LEDS_LED0_ENABLE_TO_CONTROL_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When set to 1, fading will be used when enabling or disabling the led */
#define GP_WB_READ_LEDS_LED0_FADE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1140), 1)

#define GP_WB_GET_LEDS_LED0_FADE_FROM_CONTROL_0(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_LEDS_LED0_FADE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1140), 1, (val)); \
        } while (0)

#define GP_WB_SET_LEDS_LED0_FADE_TO_CONTROL_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* Sets the target PWM threshold (255 =  max duty cycle) */
#define GP_WB_READ_LEDS_LED0_THRESHOLD() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1141))

#define GP_WB_WRITE_LEDS_LED0_THRESHOLD(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1141), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_LEDS_LED0_IO_CONTROL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1142))

#define GP_WB_WRITE_LEDS_LED0_IO_CONTROL(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1142), (val))

/* Sets the drive type for the output */
#define GP_WB_READ_LEDS_LED0_OUTPUT_DRIVE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1142), 0)

#define GP_WB_GET_LEDS_LED0_OUTPUT_DRIVE_FROM_LED0_IO_CONTROL(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_LEDS_LED0_OUTPUT_DRIVE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1142), 0, (val)); \
        } while (0)

#define GP_WB_SET_LEDS_LED0_OUTPUT_DRIVE_TO_LED0_IO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Inverts the output */
#define GP_WB_READ_LEDS_LED0_OUTPUT_INVERT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1142), 1)

#define GP_WB_GET_LEDS_LED0_OUTPUT_INVERT_FROM_LED0_IO_CONTROL(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_LEDS_LED0_OUTPUT_INVERT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1142), 1, (val)); \
        } while (0)

#define GP_WB_SET_LEDS_LED0_OUTPUT_INVERT_TO_LED0_IO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* When set, the chip may go to sleep, even if the led is driven continuously (dutycycling prevents chip from going to sleep) */
#define GP_WB_READ_LEDS_LED0_ALLOW_GOTOSLEEP_WHEN_ON() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1142), 2)

#define GP_WB_GET_LEDS_LED0_ALLOW_GOTOSLEEP_WHEN_ON_FROM_LED0_IO_CONTROL(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_LEDS_LED0_ALLOW_GOTOSLEEP_WHEN_ON(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1142), 2, (val)); \
        } while (0)

#define GP_WB_SET_LEDS_LED0_ALLOW_GOTOSLEEP_WHEN_ON_TO_LED0_IO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_LEDS_CONTROL_1() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1144))

#define GP_WB_WRITE_LEDS_CONTROL_1(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1144), (val))

/* Set to 1 to enable the led */
#define GP_WB_READ_LEDS_LED1_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1144), 0)

#define GP_WB_GET_LEDS_LED1_ENABLE_FROM_CONTROL_1(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_LEDS_LED1_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1144), 0, (val)); \
        } while (0)

#define GP_WB_SET_LEDS_LED1_ENABLE_TO_CONTROL_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When set to 1, fading will be used when enabling or disabling the led */
#define GP_WB_READ_LEDS_LED1_FADE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1144), 1)

#define GP_WB_GET_LEDS_LED1_FADE_FROM_CONTROL_1(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_LEDS_LED1_FADE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1144), 1, (val)); \
        } while (0)

#define GP_WB_SET_LEDS_LED1_FADE_TO_CONTROL_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* Sets the target PWM threshold (255 =  max duty cycle) */
#define GP_WB_READ_LEDS_LED1_THRESHOLD() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1145))

#define GP_WB_WRITE_LEDS_LED1_THRESHOLD(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1145), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_LEDS_LED1_IO_CONTROL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1146))

#define GP_WB_WRITE_LEDS_LED1_IO_CONTROL(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1146), (val))

/* Sets the drive type for the output */
#define GP_WB_READ_LEDS_LED1_OUTPUT_DRIVE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1146), 0)

#define GP_WB_GET_LEDS_LED1_OUTPUT_DRIVE_FROM_LED1_IO_CONTROL(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_LEDS_LED1_OUTPUT_DRIVE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1146), 0, (val)); \
        } while (0)

#define GP_WB_SET_LEDS_LED1_OUTPUT_DRIVE_TO_LED1_IO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Inverts the output */
#define GP_WB_READ_LEDS_LED1_OUTPUT_INVERT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1146), 1)

#define GP_WB_GET_LEDS_LED1_OUTPUT_INVERT_FROM_LED1_IO_CONTROL(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_LEDS_LED1_OUTPUT_INVERT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1146), 1, (val)); \
        } while (0)

#define GP_WB_SET_LEDS_LED1_OUTPUT_INVERT_TO_LED1_IO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* When set, the chip may go to sleep, even if the led is driven continuously (dutycycling prevents chip from going to sleep) */
#define GP_WB_READ_LEDS_LED1_ALLOW_GOTOSLEEP_WHEN_ON() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1146), 2)

#define GP_WB_GET_LEDS_LED1_ALLOW_GOTOSLEEP_WHEN_ON_FROM_LED1_IO_CONTROL(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_LEDS_LED1_ALLOW_GOTOSLEEP_WHEN_ON(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1146), 2, (val)); \
        } while (0)

#define GP_WB_SET_LEDS_LED1_ALLOW_GOTOSLEEP_WHEN_ON_TO_LED1_IO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_LEDS_CONTROL_2() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1148))

#define GP_WB_WRITE_LEDS_CONTROL_2(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1148), (val))

/* Set to 1 to enable the led */
#define GP_WB_READ_LEDS_LED2_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1148), 0)

#define GP_WB_GET_LEDS_LED2_ENABLE_FROM_CONTROL_2(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_LEDS_LED2_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1148), 0, (val)); \
        } while (0)

#define GP_WB_SET_LEDS_LED2_ENABLE_TO_CONTROL_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When set to 1, fading will be used when enabling or disabling the led */
#define GP_WB_READ_LEDS_LED2_FADE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1148), 1)

#define GP_WB_GET_LEDS_LED2_FADE_FROM_CONTROL_2(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_LEDS_LED2_FADE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1148), 1, (val)); \
        } while (0)

#define GP_WB_SET_LEDS_LED2_FADE_TO_CONTROL_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* Sets the target PWM threshold (255 =  max duty cycle) */
#define GP_WB_READ_LEDS_LED2_THRESHOLD() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1149))

#define GP_WB_WRITE_LEDS_LED2_THRESHOLD(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1149), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_LEDS_LED2_IO_CONTROL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x114a))

#define GP_WB_WRITE_LEDS_LED2_IO_CONTROL(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x114a), (val))

/* Sets the drive type for the output */
#define GP_WB_READ_LEDS_LED2_OUTPUT_DRIVE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x114a), 0)

#define GP_WB_GET_LEDS_LED2_OUTPUT_DRIVE_FROM_LED2_IO_CONTROL(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_LEDS_LED2_OUTPUT_DRIVE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x114a), 0, (val)); \
        } while (0)

#define GP_WB_SET_LEDS_LED2_OUTPUT_DRIVE_TO_LED2_IO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Inverts the output */
#define GP_WB_READ_LEDS_LED2_OUTPUT_INVERT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x114a), 1)

#define GP_WB_GET_LEDS_LED2_OUTPUT_INVERT_FROM_LED2_IO_CONTROL(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_LEDS_LED2_OUTPUT_INVERT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x114a), 1, (val)); \
        } while (0)

#define GP_WB_SET_LEDS_LED2_OUTPUT_INVERT_TO_LED2_IO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* When set, the chip may go to sleep, even if the led is driven continuously (dutycycling prevents chip from going to sleep) */
#define GP_WB_READ_LEDS_LED2_ALLOW_GOTOSLEEP_WHEN_ON() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x114a), 2)

#define GP_WB_GET_LEDS_LED2_ALLOW_GOTOSLEEP_WHEN_ON_FROM_LED2_IO_CONTROL(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_LEDS_LED2_ALLOW_GOTOSLEEP_WHEN_ON(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x114a), 2, (val)); \
        } while (0)

#define GP_WB_SET_LEDS_LED2_ALLOW_GOTOSLEEP_WHEN_ON_TO_LED2_IO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_LEDS_CONTROL_3() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x114c))

#define GP_WB_WRITE_LEDS_CONTROL_3(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x114c), (val))

/* Set to 1 to enable the led */
#define GP_WB_READ_LEDS_LED3_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x114c), 0)

#define GP_WB_GET_LEDS_LED3_ENABLE_FROM_CONTROL_3(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_LEDS_LED3_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x114c), 0, (val)); \
        } while (0)

#define GP_WB_SET_LEDS_LED3_ENABLE_TO_CONTROL_3(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When set to 1, fading will be used when enabling or disabling the led */
#define GP_WB_READ_LEDS_LED3_FADE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x114c), 1)

#define GP_WB_GET_LEDS_LED3_FADE_FROM_CONTROL_3(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_LEDS_LED3_FADE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x114c), 1, (val)); \
        } while (0)

#define GP_WB_SET_LEDS_LED3_FADE_TO_CONTROL_3(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* Sets the target PWM threshold (255 =  max duty cycle) */
#define GP_WB_READ_LEDS_LED3_THRESHOLD() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x114d))

#define GP_WB_WRITE_LEDS_LED3_THRESHOLD(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x114d), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_LEDS_LED3_IO_CONTROL() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x114e))

#define GP_WB_WRITE_LEDS_LED3_IO_CONTROL(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x114e), (val))

/* Sets the drive type for the output */
#define GP_WB_READ_LEDS_LED3_OUTPUT_DRIVE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x114e), 0)

#define GP_WB_GET_LEDS_LED3_OUTPUT_DRIVE_FROM_LED3_IO_CONTROL(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_LEDS_LED3_OUTPUT_DRIVE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x114e), 0, (val)); \
        } while (0)

#define GP_WB_SET_LEDS_LED3_OUTPUT_DRIVE_TO_LED3_IO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Inverts the output */
#define GP_WB_READ_LEDS_LED3_OUTPUT_INVERT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x114e), 1)

#define GP_WB_GET_LEDS_LED3_OUTPUT_INVERT_FROM_LED3_IO_CONTROL(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_LEDS_LED3_OUTPUT_INVERT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x114e), 1, (val)); \
        } while (0)

#define GP_WB_SET_LEDS_LED3_OUTPUT_INVERT_TO_LED3_IO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* When set, the chip may go to sleep, even if the led is driven continuously (dutycycling prevents chip from going to sleep) */
#define GP_WB_READ_LEDS_LED3_ALLOW_GOTOSLEEP_WHEN_ON() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x114e), 2)

#define GP_WB_GET_LEDS_LED3_ALLOW_GOTOSLEEP_WHEN_ON_FROM_LED3_IO_CONTROL(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_LEDS_LED3_ALLOW_GOTOSLEEP_WHEN_ON(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x114e), 2, (val)); \
        } while (0)

#define GP_WB_SET_LEDS_LED3_ALLOW_GOTOSLEEP_WHEN_ON_TO_LED3_IO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_LEDS_TIMER_CONFIG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x114f))

#define GP_WB_WRITE_LEDS_TIMER_CONFIG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x114f), (val))

/* Sets the timer to use for the main counter, which gets compared to the thresholds */
#define GP_WB_READ_LEDS_MAIN_TMR() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x114f)) & 0x07)

#define GP_WB_GET_LEDS_MAIN_TMR_FROM_TIMER_CONFIG(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_LEDS_MAIN_TMR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x114f), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_LEDS_MAIN_TMR_TO_TIMER_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x70; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Sets the timer to use for updating the threshold, each slope timer wrap shall increment/decrement the threshold (if fading is enabled) */
#define GP_WB_READ_LEDS_SLOPE_TMR() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x114f)) >> 4) & 0x07)

#define GP_WB_GET_LEDS_SLOPE_TMR_FROM_TIMER_CONFIG(tmp) \
        (((tmp) >> 4) & 0x07)

#define GP_WB_WRITE_LEDS_SLOPE_TMR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x114f), 0x70, (val) << 4); \
        } while (0)

#define GP_WB_SET_LEDS_SLOPE_TMR_TO_TIMER_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* dummy - regmap generation thing ... */
#define GP_WB_READ_LEDS_DUMMY_STATUS() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1150), 0)

/***************************
 * layout: ipc
 ***************************/

#define GP_WB_WRITE_IPC_SET_GPM2X_INTERRUPTS(val) \
      GP_WB_WRITE_U64(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1180), (val))

/* Set the (gpmicro to ...) interrupt a used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_SET_GPM2X_FLAG_A_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1180), 0x01)

#define GP_WB_SET_IPC_SET_GPM2X_FLAG_A_INTERRUPT_TO_SET_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFF3FFE; \
          (tmp) |= ((UInt64)(val)); \
        } while (0)

/* Set the (gpmicro to ...) interrupt b used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_SET_GPM2X_FLAG_B_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1180), 0x02)

#define GP_WB_SET_IPC_SET_GPM2X_FLAG_B_INTERRUPT_TO_SET_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFF3FFD; \
          (tmp) |= (((UInt64)(val)) << 1); \
        } while (0)

/* Set the (gpmicro to ...) interrupt c used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_SET_GPM2X_FLAG_C_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1180), 0x04)

#define GP_WB_SET_IPC_SET_GPM2X_FLAG_C_INTERRUPT_TO_SET_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFF3FFB; \
          (tmp) |= (((UInt64)(val)) << 2); \
        } while (0)

/* Set the (gpmicro to ...) interrupt d used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_SET_GPM2X_TX_POWER_MEAS_DONE_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1180), 0x08)

#define GP_WB_SET_IPC_SET_GPM2X_TX_POWER_MEAS_DONE_INTERRUPT_TO_SET_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFF3FF7; \
          (tmp) |= (((UInt64)(val)) << 3); \
        } while (0)

/* Indicates that a command is processed */
#define GP_WB_IPC_SET_GPM2X_CMD_PROCESSED_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1180), 0x10)

#define GP_WB_SET_IPC_SET_GPM2X_CMD_PROCESSED_INTERRUPT_TO_SET_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFF3FEF; \
          (tmp) |= (((UInt64)(val)) << 4); \
        } while (0)

/* Set the (gpmicro to ...) error interrupt, by writing 1 (oneshot register) */
#define GP_WB_IPC_SET_GPM2X_ERROR_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1180), 0x20)

#define GP_WB_SET_IPC_SET_GPM2X_ERROR_INTERRUPT_TO_SET_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFF3FDF; \
          (tmp) |= (((UInt64)(val)) << 5); \
        } while (0)

/* Set the (gpmicro to ...) unexpected condition interrupt, by writing 1 (oneshot register) */
#define GP_WB_IPC_SET_GPM2X_UNEXPECTED_COND_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1180), 0x40)

#define GP_WB_SET_IPC_SET_GPM2X_UNEXPECTED_COND_INTERRUPT_TO_SET_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFF3FBF; \
          (tmp) |= (((UInt64)(val)) << 6); \
        } while (0)

/* Set the (gpmicro to ...) status interrupt used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_SET_GPM2X_STAT_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1180), 0x80)

#define GP_WB_SET_IPC_SET_GPM2X_STAT_INTERRUPT_TO_SET_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFF3F7F; \
          (tmp) |= (((UInt64)(val)) << 7); \
        } while (0)

/* Indicates a frame is sent during an advertising event */
#define GP_WB_IPC_SET_GPM2X_ADV_TX_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1181), 0x01)

#define GP_WB_SET_IPC_SET_GPM2X_ADV_TX_INTERRUPT_TO_SET_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFF3EFF; \
          (tmp) |= (((UInt64)(val)) << 8); \
        } while (0)

/* Indicates a scan request has been received */
#define GP_WB_IPC_SET_GPM2X_SCAN_REQ_RX_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1181), 0x02)

#define GP_WB_SET_IPC_SET_GPM2X_SCAN_REQ_RX_INTERRUPT_TO_SET_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFF3DFF; \
          (tmp) |= (((UInt64)(val)) << 9); \
        } while (0)

/* Indicates a scan response is sent */
#define GP_WB_IPC_SET_GPM2X_SCAN_RSP_TX_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1181), 0x04)

#define GP_WB_SET_IPC_SET_GPM2X_SCAN_RSP_TX_INTERRUPT_TO_SET_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFF3BFF; \
          (tmp) |= (((UInt64)(val)) << 10); \
        } while (0)

/* Indicates that a SCAN_REQ frame is sent */
#define GP_WB_IPC_SET_GPM2X_SCAN_REQ_TX_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1181), 0x08)

#define GP_WB_SET_IPC_SET_GPM2X_SCAN_REQ_TX_INTERRUPT_TO_SET_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFF37FF; \
          (tmp) |= (((UInt64)(val)) << 11); \
        } while (0)

/* Indicates that a CONN_REQ frame is sent */
#define GP_WB_IPC_SET_GPM2X_CONN_REQ_TX_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1181), 0x10)

#define GP_WB_SET_IPC_SET_GPM2X_CONN_REQ_TX_INTERRUPT_TO_SET_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFF2FFF; \
          (tmp) |= (((UInt64)(val)) << 12); \
        } while (0)

/* Indicates that a subevent has been processed */
#define GP_WB_IPC_SET_GPM2X_SUBEV_DONE_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1181), 0x20)

#define GP_WB_SET_IPC_SET_GPM2X_SUBEV_DONE_INTERRUPT_TO_SET_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFF1FFF; \
          (tmp) |= (((UInt64)(val)) << 13); \
        } while (0)

/* Indicates that a ble event has been processed */
#define GP_WB_WRITE_IPC_SET_GPM2X_EVENT_PROCESSED_INTERRUPTS(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1182), (val)); \
        } while (0)

#define GP_WB_SET_IPC_SET_GPM2X_EVENT_PROCESSED_INTERRUPTS_TO_SET_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFFFF00003FFF; \
          (tmp) |= (((UInt64)(val)) << 16); \
        } while (0)

/* Indicates that a connection ble event has reached its last_sch_event_cnt (if enabled) */
#define GP_WB_WRITE_IPC_SET_GPM2X_LAST_CONN_EVENT_CNT_INTERRUPTS(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1184), (val)); \
        } while (0)

#define GP_WB_SET_IPC_SET_GPM2X_LAST_CONN_EVENT_CNT_INTERRUPTS_TO_SET_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFF0000FFFF3FFF; \
          (tmp) |= (((UInt64)(val)) << 32); \
        } while (0)

/* Indicates that a ble event has been skipped */
#define GP_WB_WRITE_IPC_SET_GPM2X_EVENT_SKIPPED_INTERRUPTS(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1186), (val)); \
        } while (0)

#define GP_WB_SET_IPC_SET_GPM2X_EVENT_SKIPPED_INTERRUPTS_TO_SET_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0x0000FFFFFFFF3FFF; \
          (tmp) |= (((UInt64)(val)) << 48); \
        } while (0)


#define GP_WB_WRITE_IPC_SET_X2GPM_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1188), (val))

/* Set the (... to gpmicro) interrupt a used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_SET_X2GPM_FLAG_A_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1188), 0x01)

#define GP_WB_SET_IPC_SET_X2GPM_FLAG_A_INTERRUPT_TO_SET_X2GPM_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Set the (... to gpmicro) interrupt b used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_SET_X2GPM_FLAG_B_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1188), 0x02)

#define GP_WB_SET_IPC_SET_X2GPM_FLAG_B_INTERRUPT_TO_SET_X2GPM_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Set the (... to gpmicro) interrupt c used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_SET_X2GPM_FLAG_C_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1188), 0x04)

#define GP_WB_SET_IPC_SET_X2GPM_FLAG_C_INTERRUPT_TO_SET_X2GPM_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Set the (... to gpmicro) interrupt d used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_SET_X2GPM_FLAG_D_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1188), 0x08)

#define GP_WB_SET_IPC_SET_X2GPM_FLAG_D_INTERRUPT_TO_SET_X2GPM_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Indicates that a command is available to be processed */
#define GP_WB_IPC_SET_X2GPM_CMD_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1188), 0x10)

#define GP_WB_SET_IPC_SET_X2GPM_CMD_INTERRUPT_TO_SET_X2GPM_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


#define GP_WB_WRITE_IPC_CLR_GPM2X_INTERRUPTS(val) \
      GP_WB_WRITE_U64(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x118a), (val))

/* Clear the (gpmicro to ...) interrupt a used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_CLR_GPM2X_FLAG_A_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x118a), 0x01)

#define GP_WB_SET_IPC_CLR_GPM2X_FLAG_A_INTERRUPT_TO_CLR_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFF3FFE; \
          (tmp) |= ((UInt64)(val)); \
        } while (0)

/* Clear the (gpmicro to ...) interrupt b used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_CLR_GPM2X_FLAG_B_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x118a), 0x02)

#define GP_WB_SET_IPC_CLR_GPM2X_FLAG_B_INTERRUPT_TO_CLR_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFF3FFD; \
          (tmp) |= (((UInt64)(val)) << 1); \
        } while (0)

/* Clear the (gpmicro to ...) interrupt c used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_CLR_GPM2X_FLAG_C_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x118a), 0x04)

#define GP_WB_SET_IPC_CLR_GPM2X_FLAG_C_INTERRUPT_TO_CLR_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFF3FFB; \
          (tmp) |= (((UInt64)(val)) << 2); \
        } while (0)

/* Clear the (gpmicro to ...) interrupt d used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_CLR_GPM2X_TX_POWER_MEAS_DONE_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x118a), 0x08)

#define GP_WB_SET_IPC_CLR_GPM2X_TX_POWER_MEAS_DONE_INTERRUPT_TO_CLR_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFF3FF7; \
          (tmp) |= (((UInt64)(val)) << 3); \
        } while (0)

/* Indicates that a command is processed */
#define GP_WB_IPC_CLR_GPM2X_CMD_PROCESSED_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x118a), 0x10)

#define GP_WB_SET_IPC_CLR_GPM2X_CMD_PROCESSED_INTERRUPT_TO_CLR_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFF3FEF; \
          (tmp) |= (((UInt64)(val)) << 4); \
        } while (0)

/* Clear the (gpmicro to ...) error interrupt, by writing 1 (oneshot register) */
#define GP_WB_IPC_CLR_GPM2X_ERROR_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x118a), 0x20)

#define GP_WB_SET_IPC_CLR_GPM2X_ERROR_INTERRUPT_TO_CLR_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFF3FDF; \
          (tmp) |= (((UInt64)(val)) << 5); \
        } while (0)

/* Clear the (gpmicro to ...) unexpected condition interrupt, by writing 1 (oneshot register) */
#define GP_WB_IPC_CLR_GPM2X_UNEXPECTED_COND_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x118a), 0x40)

#define GP_WB_SET_IPC_CLR_GPM2X_UNEXPECTED_COND_INTERRUPT_TO_CLR_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFF3FBF; \
          (tmp) |= (((UInt64)(val)) << 6); \
        } while (0)

/* Clear the (gpmicro to ...) status interrupt used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_CLR_GPM2X_STAT_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x118a), 0x80)

#define GP_WB_SET_IPC_CLR_GPM2X_STAT_INTERRUPT_TO_CLR_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFF3F7F; \
          (tmp) |= (((UInt64)(val)) << 7); \
        } while (0)

/* Indicates a frame is sent during an advertising event */
#define GP_WB_IPC_CLR_GPM2X_ADV_TX_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x118b), 0x01)

#define GP_WB_SET_IPC_CLR_GPM2X_ADV_TX_INTERRUPT_TO_CLR_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFF3EFF; \
          (tmp) |= (((UInt64)(val)) << 8); \
        } while (0)

/* Indicates a scan request has been received */
#define GP_WB_IPC_CLR_GPM2X_SCAN_REQ_RX_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x118b), 0x02)

#define GP_WB_SET_IPC_CLR_GPM2X_SCAN_REQ_RX_INTERRUPT_TO_CLR_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFF3DFF; \
          (tmp) |= (((UInt64)(val)) << 9); \
        } while (0)

/* Indicates a scan response is sent */
#define GP_WB_IPC_CLR_GPM2X_SCAN_RSP_TX_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x118b), 0x04)

#define GP_WB_SET_IPC_CLR_GPM2X_SCAN_RSP_TX_INTERRUPT_TO_CLR_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFF3BFF; \
          (tmp) |= (((UInt64)(val)) << 10); \
        } while (0)

/* Indicates that a SCAN_REQ frame is sent */
#define GP_WB_IPC_CLR_GPM2X_SCAN_REQ_TX_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x118b), 0x08)

#define GP_WB_SET_IPC_CLR_GPM2X_SCAN_REQ_TX_INTERRUPT_TO_CLR_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFF37FF; \
          (tmp) |= (((UInt64)(val)) << 11); \
        } while (0)

/* Indicates that a CONN_REQ frame is sent */
#define GP_WB_IPC_CLR_GPM2X_CONN_REQ_TX_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x118b), 0x10)

#define GP_WB_SET_IPC_CLR_GPM2X_CONN_REQ_TX_INTERRUPT_TO_CLR_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFF2FFF; \
          (tmp) |= (((UInt64)(val)) << 12); \
        } while (0)

/* Indicates that a subevent has been processed */
#define GP_WB_IPC_CLR_GPM2X_SUBEV_DONE_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x118b), 0x20)

#define GP_WB_SET_IPC_CLR_GPM2X_SUBEV_DONE_INTERRUPT_TO_CLR_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFFFFFFF1FFF; \
          (tmp) |= (((UInt64)(val)) << 13); \
        } while (0)

/* Indicates that a ble event has been processed */
#define GP_WB_WRITE_IPC_CLR_GPM2X_EVENT_PROCESSED_INTERRUPTS(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x118c), (val)); \
        } while (0)

#define GP_WB_SET_IPC_CLR_GPM2X_EVENT_PROCESSED_INTERRUPTS_TO_CLR_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFFFF00003FFF; \
          (tmp) |= (((UInt64)(val)) << 16); \
        } while (0)

/* Indicates that a connection ble event has reached its last_sch_event_cnt (if enabled) */
#define GP_WB_WRITE_IPC_CLR_GPM2X_LAST_CONN_EVENT_CNT_INTERRUPTS(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x118e), (val)); \
        } while (0)

#define GP_WB_SET_IPC_CLR_GPM2X_LAST_CONN_EVENT_CNT_INTERRUPTS_TO_CLR_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFF0000FFFF3FFF; \
          (tmp) |= (((UInt64)(val)) << 32); \
        } while (0)

/* Indicates that a ble event has been skipped */
#define GP_WB_WRITE_IPC_CLR_GPM2X_EVENT_SKIPPED_INTERRUPTS(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1190), (val)); \
        } while (0)

#define GP_WB_SET_IPC_CLR_GPM2X_EVENT_SKIPPED_INTERRUPTS_TO_CLR_GPM2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0x0000FFFFFFFF3FFF; \
          (tmp) |= (((UInt64)(val)) << 48); \
        } while (0)


#define GP_WB_WRITE_IPC_CLR_X2GPM_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1192), (val))

/* Clear the (... to gpmicro) interrupt a used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_CLR_X2GPM_FLAG_A_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1192), 0x01)

#define GP_WB_SET_IPC_CLR_X2GPM_FLAG_A_INTERRUPT_TO_CLR_X2GPM_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Clear the (... to gpmicro) interrupt b used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_CLR_X2GPM_FLAG_B_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1192), 0x02)

#define GP_WB_SET_IPC_CLR_X2GPM_FLAG_B_INTERRUPT_TO_CLR_X2GPM_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Clear the (... to gpmicro) interrupt c used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_CLR_X2GPM_FLAG_C_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1192), 0x04)

#define GP_WB_SET_IPC_CLR_X2GPM_FLAG_C_INTERRUPT_TO_CLR_X2GPM_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Clear the (... to gpmicro) interrupt d used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_CLR_X2GPM_FLAG_D_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1192), 0x08)

#define GP_WB_SET_IPC_CLR_X2GPM_FLAG_D_INTERRUPT_TO_CLR_X2GPM_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Indicates that a command is available to be processed */
#define GP_WB_IPC_CLR_X2GPM_CMD_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1192), 0x10)

#define GP_WB_SET_IPC_CLR_X2GPM_CMD_INTERRUPT_TO_CLR_X2GPM_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IPC_UNMASKED_GPM2X_INTERRUPTS() \
        GP_WB_READ_U64(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1194))

#define GP_WB_READ_IPC_UNMASKED_GPM2X_FLAG_A_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1194), 0)

#define GP_WB_GET_IPC_UNMASKED_GPM2X_FLAG_A_INTERRUPT_FROM_UNMASKED_GPM2X_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_IPC_UNMASKED_GPM2X_FLAG_B_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1194), 1)

#define GP_WB_GET_IPC_UNMASKED_GPM2X_FLAG_B_INTERRUPT_FROM_UNMASKED_GPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_IPC_UNMASKED_GPM2X_FLAG_C_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1194), 2)

#define GP_WB_GET_IPC_UNMASKED_GPM2X_FLAG_C_INTERRUPT_FROM_UNMASKED_GPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_IPC_UNMASKED_GPM2X_TX_POWER_MEAS_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1194), 3)

#define GP_WB_GET_IPC_UNMASKED_GPM2X_TX_POWER_MEAS_DONE_INTERRUPT_FROM_UNMASKED_GPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

/* Indicates that a command is processed */
#define GP_WB_READ_IPC_UNMASKED_GPM2X_CMD_PROCESSED_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1194), 4)

#define GP_WB_GET_IPC_UNMASKED_GPM2X_CMD_PROCESSED_INTERRUPT_FROM_UNMASKED_GPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

/* Indicates that the gpmicro encountered and error and is halted */
#define GP_WB_READ_IPC_UNMASKED_GPM2X_ERROR_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1194), 5)

#define GP_WB_GET_IPC_UNMASKED_GPM2X_ERROR_INTERRUPT_FROM_UNMASKED_GPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)

/* Indicates that the gpmicro has encountered an unexpected condition */
#define GP_WB_READ_IPC_UNMASKED_GPM2X_UNEXPECTED_COND_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1194), 6)

#define GP_WB_GET_IPC_UNMASKED_GPM2X_UNEXPECTED_COND_INTERRUPT_FROM_UNMASKED_GPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 6) & 0x01)

/* Indicates that the gpmicro has a status message */
#define GP_WB_READ_IPC_UNMASKED_GPM2X_STAT_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1194), 7)

#define GP_WB_GET_IPC_UNMASKED_GPM2X_STAT_INTERRUPT_FROM_UNMASKED_GPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 7) & 0x01)

/* Indicates a frame is sent during an advertising event */
#define GP_WB_READ_IPC_UNMASKED_GPM2X_ADV_TX_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1195), 0)

#define GP_WB_GET_IPC_UNMASKED_GPM2X_ADV_TX_INTERRUPT_FROM_UNMASKED_GPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 8) & 0x01)

/* Indicates a scan request has been received */
#define GP_WB_READ_IPC_UNMASKED_GPM2X_SCAN_REQ_RX_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1195), 1)

#define GP_WB_GET_IPC_UNMASKED_GPM2X_SCAN_REQ_RX_INTERRUPT_FROM_UNMASKED_GPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 9) & 0x01)

/* Indicates a scan response is sent */
#define GP_WB_READ_IPC_UNMASKED_GPM2X_SCAN_RSP_TX_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1195), 2)

#define GP_WB_GET_IPC_UNMASKED_GPM2X_SCAN_RSP_TX_INTERRUPT_FROM_UNMASKED_GPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 10) & 0x01)

/* Indicates that a SCAN_REQ frame is sent */
#define GP_WB_READ_IPC_UNMASKED_GPM2X_SCAN_REQ_TX_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1195), 3)

#define GP_WB_GET_IPC_UNMASKED_GPM2X_SCAN_REQ_TX_INTERRUPT_FROM_UNMASKED_GPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 11) & 0x01)

/* Indicates that a CONN_REQ frame is sent */
#define GP_WB_READ_IPC_UNMASKED_GPM2X_CONN_REQ_TX_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1195), 4)

#define GP_WB_GET_IPC_UNMASKED_GPM2X_CONN_REQ_TX_INTERRUPT_FROM_UNMASKED_GPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 12) & 0x01)

/* Indicates that a subevent has been processed */
#define GP_WB_READ_IPC_UNMASKED_GPM2X_SUBEV_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1195), 5)

#define GP_WB_GET_IPC_UNMASKED_GPM2X_SUBEV_DONE_INTERRUPT_FROM_UNMASKED_GPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 13) & 0x01)

/* Indicates that a ble event has been processed */
#define GP_WB_READ_IPC_UNMASKED_GPM2X_EVENT_PROCESSED_INTERRUPTS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1196))

#define GP_WB_GET_IPC_UNMASKED_GPM2X_EVENT_PROCESSED_INTERRUPTS_FROM_UNMASKED_GPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 16) & 0xFFFF)

/* Indicates that a connection ble event has reached its last_sch_event_cnt (if enabled) */
#define GP_WB_READ_IPC_UNMASKED_GPM2X_LAST_CONN_EVENT_CNT_INTERRUPTS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1198))

#define GP_WB_GET_IPC_UNMASKED_GPM2X_LAST_CONN_EVENT_CNT_INTERRUPTS_FROM_UNMASKED_GPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 32) & 0xFFFF)

/* Indicates that a ble event has been skipped */
#define GP_WB_READ_IPC_UNMASKED_GPM2X_EVENT_SKIPPED_INTERRUPTS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x119a))

#define GP_WB_GET_IPC_UNMASKED_GPM2X_EVENT_SKIPPED_INTERRUPTS_FROM_UNMASKED_GPM2X_INTERRUPTS(tmp) \
        (((tmp) >> 48) & 0xFFFF)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IPC_UNMASKED_X2GPM_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x119c))

#define GP_WB_READ_IPC_UNMASKED_X2GPM_FLAG_A_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x119c), 0)

#define GP_WB_GET_IPC_UNMASKED_X2GPM_FLAG_A_INTERRUPT_FROM_UNMASKED_X2GPM_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_IPC_UNMASKED_X2GPM_FLAG_B_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x119c), 1)

#define GP_WB_GET_IPC_UNMASKED_X2GPM_FLAG_B_INTERRUPT_FROM_UNMASKED_X2GPM_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_IPC_UNMASKED_X2GPM_FLAG_C_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x119c), 2)

#define GP_WB_GET_IPC_UNMASKED_X2GPM_FLAG_C_INTERRUPT_FROM_UNMASKED_X2GPM_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_IPC_UNMASKED_X2GPM_FLAG_D_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x119c), 3)

#define GP_WB_GET_IPC_UNMASKED_X2GPM_FLAG_D_INTERRUPT_FROM_UNMASKED_X2GPM_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

/* Indicates that a command is available to be processed */
#define GP_WB_READ_IPC_UNMASKED_X2GPM_CMD_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x119c), 4)

#define GP_WB_GET_IPC_UNMASKED_X2GPM_CMD_INTERRUPT_FROM_UNMASKED_X2GPM_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)


#define GP_WB_WRITE_IPC_SET_INT2X_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x119d), (val))

/* Set the internal to ... interrupt a used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_SET_INT2X_FLAG_A_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x119d), 0x01)

#define GP_WB_SET_IPC_SET_INT2X_FLAG_A_INTERRUPT_TO_SET_INT2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Set the internal to ... interrupt b used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_SET_INT2X_FLAG_B_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x119d), 0x02)

#define GP_WB_SET_IPC_SET_INT2X_FLAG_B_INTERRUPT_TO_SET_INT2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Set the internal to ... interrupt c used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_SET_INT2X_FLAG_C_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x119d), 0x04)

#define GP_WB_SET_IPC_SET_INT2X_FLAG_C_INTERRUPT_TO_SET_INT2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Set the internal to ... interrupt d used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_SET_INT2X_FLAG_D_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x119d), 0x08)

#define GP_WB_SET_IPC_SET_INT2X_FLAG_D_INTERRUPT_TO_SET_INT2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


#define GP_WB_WRITE_IPC_SET_X2INT_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x119e), (val))

/* Set the ... to internal interrupt a used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_SET_X2INT_FLAG_A_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x119e), 0x01)

#define GP_WB_SET_IPC_SET_X2INT_FLAG_A_INTERRUPT_TO_SET_X2INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Set the ... to internal interrupt b used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_SET_X2INT_FLAG_B_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x119e), 0x02)

#define GP_WB_SET_IPC_SET_X2INT_FLAG_B_INTERRUPT_TO_SET_X2INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Set the ... to internal interrupt c used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_SET_X2INT_FLAG_C_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x119e), 0x04)

#define GP_WB_SET_IPC_SET_X2INT_FLAG_C_INTERRUPT_TO_SET_X2INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Set the ... to internal interrupt d used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_SET_X2INT_FLAG_D_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x119e), 0x08)

#define GP_WB_SET_IPC_SET_X2INT_FLAG_D_INTERRUPT_TO_SET_X2INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


#define GP_WB_WRITE_IPC_CLR_INT2X_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x119f), (val))

/* Clear the internal to ... interrupt a used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_CLR_INT2X_FLAG_A_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x119f), 0x01)

#define GP_WB_SET_IPC_CLR_INT2X_FLAG_A_INTERRUPT_TO_CLR_INT2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Clear the internal to ... interrupt b used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_CLR_INT2X_FLAG_B_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x119f), 0x02)

#define GP_WB_SET_IPC_CLR_INT2X_FLAG_B_INTERRUPT_TO_CLR_INT2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Clear the internal to ... interrupt c used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_CLR_INT2X_FLAG_C_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x119f), 0x04)

#define GP_WB_SET_IPC_CLR_INT2X_FLAG_C_INTERRUPT_TO_CLR_INT2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Clear the internal to ... interrupt d used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_CLR_INT2X_FLAG_D_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x119f), 0x08)

#define GP_WB_SET_IPC_CLR_INT2X_FLAG_D_INTERRUPT_TO_CLR_INT2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


#define GP_WB_WRITE_IPC_CLR_X2INT_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a0), (val))

/* Clear the ... to internal interrupt a used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_CLR_X2INT_FLAG_A_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a0), 0x01)

#define GP_WB_SET_IPC_CLR_X2INT_FLAG_A_INTERRUPT_TO_CLR_X2INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Clear the ... to internal interrupt b used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_CLR_X2INT_FLAG_B_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a0), 0x02)

#define GP_WB_SET_IPC_CLR_X2INT_FLAG_B_INTERRUPT_TO_CLR_X2INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Clear the ... to internal interrupt c used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_CLR_X2INT_FLAG_C_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a0), 0x04)

#define GP_WB_SET_IPC_CLR_X2INT_FLAG_C_INTERRUPT_TO_CLR_X2INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Clear the ... to internal interrupt d used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_CLR_X2INT_FLAG_D_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a0), 0x08)

#define GP_WB_SET_IPC_CLR_X2INT_FLAG_D_INTERRUPT_TO_CLR_X2INT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IPC_UNMASKED_INT2X_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a1))

#define GP_WB_READ_IPC_UNMASKED_INT2X_FLAG_A_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a1), 0)

#define GP_WB_GET_IPC_UNMASKED_INT2X_FLAG_A_INTERRUPT_FROM_UNMASKED_INT2X_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_IPC_UNMASKED_INT2X_FLAG_B_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a1), 1)

#define GP_WB_GET_IPC_UNMASKED_INT2X_FLAG_B_INTERRUPT_FROM_UNMASKED_INT2X_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_IPC_UNMASKED_INT2X_FLAG_C_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a1), 2)

#define GP_WB_GET_IPC_UNMASKED_INT2X_FLAG_C_INTERRUPT_FROM_UNMASKED_INT2X_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_IPC_UNMASKED_INT2X_FLAG_D_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a1), 3)

#define GP_WB_GET_IPC_UNMASKED_INT2X_FLAG_D_INTERRUPT_FROM_UNMASKED_INT2X_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IPC_UNMASKED_X2INT_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a2))

#define GP_WB_READ_IPC_UNMASKED_X2INT_FLAG_A_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a2), 0)

#define GP_WB_GET_IPC_UNMASKED_X2INT_FLAG_A_INTERRUPT_FROM_UNMASKED_X2INT_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_IPC_UNMASKED_X2INT_FLAG_B_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a2), 1)

#define GP_WB_GET_IPC_UNMASKED_X2INT_FLAG_B_INTERRUPT_FROM_UNMASKED_X2INT_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_IPC_UNMASKED_X2INT_FLAG_C_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a2), 2)

#define GP_WB_GET_IPC_UNMASKED_X2INT_FLAG_C_INTERRUPT_FROM_UNMASKED_X2INT_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_IPC_UNMASKED_X2INT_FLAG_D_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a2), 3)

#define GP_WB_GET_IPC_UNMASKED_X2INT_FLAG_D_INTERRUPT_FROM_UNMASKED_X2INT_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)


#define GP_WB_WRITE_IPC_SET_EXT2X_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a3), (val))

/* Set the external to ... interrupt a used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_SET_EXT2X_FLAG_A_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a3), 0x01)

#define GP_WB_SET_IPC_SET_EXT2X_FLAG_A_INTERRUPT_TO_SET_EXT2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Set the external to ... interrupt b used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_SET_EXT2X_FLAG_B_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a3), 0x02)

#define GP_WB_SET_IPC_SET_EXT2X_FLAG_B_INTERRUPT_TO_SET_EXT2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Set the external to ... interrupt c used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_SET_EXT2X_FLAG_C_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a3), 0x04)

#define GP_WB_SET_IPC_SET_EXT2X_FLAG_C_INTERRUPT_TO_SET_EXT2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Set the external to ... interrupt d used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_SET_EXT2X_FLAG_D_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a3), 0x08)

#define GP_WB_SET_IPC_SET_EXT2X_FLAG_D_INTERRUPT_TO_SET_EXT2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


#define GP_WB_WRITE_IPC_SET_X2EXT_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a4), (val))

/* Set the ... to external interrupt a used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_SET_X2EXT_FLAG_A_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a4), 0x01)

#define GP_WB_SET_IPC_SET_X2EXT_FLAG_A_INTERRUPT_TO_SET_X2EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Set the ... to external interrupt b used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_SET_X2EXT_FLAG_B_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a4), 0x02)

#define GP_WB_SET_IPC_SET_X2EXT_FLAG_B_INTERRUPT_TO_SET_X2EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Set the ... to external interrupt c used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_SET_X2EXT_FLAG_C_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a4), 0x04)

#define GP_WB_SET_IPC_SET_X2EXT_FLAG_C_INTERRUPT_TO_SET_X2EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Set the ... to external interrupt d used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_SET_X2EXT_FLAG_D_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a4), 0x08)

#define GP_WB_SET_IPC_SET_X2EXT_FLAG_D_INTERRUPT_TO_SET_X2EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


#define GP_WB_WRITE_IPC_CLR_EXT2X_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a5), (val))

/* Clear the external to ... interrupt a used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_CLR_EXT2X_FLAG_A_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a5), 0x01)

#define GP_WB_SET_IPC_CLR_EXT2X_FLAG_A_INTERRUPT_TO_CLR_EXT2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Clear the external to ... interrupt b used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_CLR_EXT2X_FLAG_B_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a5), 0x02)

#define GP_WB_SET_IPC_CLR_EXT2X_FLAG_B_INTERRUPT_TO_CLR_EXT2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Clear the external to ... interrupt c used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_CLR_EXT2X_FLAG_C_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a5), 0x04)

#define GP_WB_SET_IPC_CLR_EXT2X_FLAG_C_INTERRUPT_TO_CLR_EXT2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Clear the external to ... interrupt d used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_CLR_EXT2X_FLAG_D_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a5), 0x08)

#define GP_WB_SET_IPC_CLR_EXT2X_FLAG_D_INTERRUPT_TO_CLR_EXT2X_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


#define GP_WB_WRITE_IPC_CLR_X2EXT_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a6), (val))

/* Clear the ... to external interrupt a used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_CLR_X2EXT_FLAG_A_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a6), 0x01)

#define GP_WB_SET_IPC_CLR_X2EXT_FLAG_A_INTERRUPT_TO_CLR_X2EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Clear the ... to external interrupt b used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_CLR_X2EXT_FLAG_B_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a6), 0x02)

#define GP_WB_SET_IPC_CLR_X2EXT_FLAG_B_INTERRUPT_TO_CLR_X2EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Clear the ... to external interrupt c used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_CLR_X2EXT_FLAG_C_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a6), 0x04)

#define GP_WB_SET_IPC_CLR_X2EXT_FLAG_C_INTERRUPT_TO_CLR_X2EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Clear the ... to external interrupt d used for inter processer com, by writing 1 (oneshot register) */
#define GP_WB_IPC_CLR_X2EXT_FLAG_D_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a6), 0x08)

#define GP_WB_SET_IPC_CLR_X2EXT_FLAG_D_INTERRUPT_TO_CLR_X2EXT_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IPC_UNMASKED_EXT2X_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a7))

#define GP_WB_READ_IPC_UNMASKED_EXT2X_FLAG_A_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a7), 0)

#define GP_WB_GET_IPC_UNMASKED_EXT2X_FLAG_A_INTERRUPT_FROM_UNMASKED_EXT2X_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_IPC_UNMASKED_EXT2X_FLAG_B_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a7), 1)

#define GP_WB_GET_IPC_UNMASKED_EXT2X_FLAG_B_INTERRUPT_FROM_UNMASKED_EXT2X_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_IPC_UNMASKED_EXT2X_FLAG_C_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a7), 2)

#define GP_WB_GET_IPC_UNMASKED_EXT2X_FLAG_C_INTERRUPT_FROM_UNMASKED_EXT2X_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_IPC_UNMASKED_EXT2X_FLAG_D_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a7), 3)

#define GP_WB_GET_IPC_UNMASKED_EXT2X_FLAG_D_INTERRUPT_FROM_UNMASKED_EXT2X_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_IPC_UNMASKED_X2EXT_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a8))

#define GP_WB_READ_IPC_UNMASKED_X2EXT_FLAG_A_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a8), 0)

#define GP_WB_GET_IPC_UNMASKED_X2EXT_FLAG_A_INTERRUPT_FROM_UNMASKED_X2EXT_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_IPC_UNMASKED_X2EXT_FLAG_B_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a8), 1)

#define GP_WB_GET_IPC_UNMASKED_X2EXT_FLAG_B_INTERRUPT_FROM_UNMASKED_X2EXT_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_IPC_UNMASKED_X2EXT_FLAG_C_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a8), 2)

#define GP_WB_GET_IPC_UNMASKED_X2EXT_FLAG_C_INTERRUPT_FROM_UNMASKED_X2EXT_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_IPC_UNMASKED_X2EXT_FLAG_D_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11a8), 3)

#define GP_WB_GET_IPC_UNMASKED_X2EXT_FLAG_D_INTERRUPT_FROM_UNMASKED_X2EXT_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

/***************************
 * layout: spi_sl
 ***************************/

/* spi_sl TX byte. FIFO is cleared upon slave de-selection. */
#define GP_WB_WRITE_SPI_SL_TX_DATA(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11c0), (val)); \
        } while (0)


/* Last received spi_sl RX byte. FIFO is cleared upon slave de-selection. */
#define GP_WB_READ_SPI_SL_RX_DATA() \
        GP_WB_READ_SER_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11c1))


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SPI_SL_CONFIG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11c2))

#define GP_WB_WRITE_SPI_SL_CONFIG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11c2), (val))

/* Enable core when '1' */
#define GP_WB_READ_SPI_SL_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11c2), 0)

#define GP_WB_GET_SPI_SL_ENABLE_FROM_CONFIG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_SPI_SL_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11c2), 0, (val)); \
        } while (0)

#define GP_WB_SET_SPI_SL_ENABLE_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When set, the rx data byte buffer will be cleared whn the ssn pin is inactive */
#define GP_WB_READ_SPI_SL_CLR_RX_FIFO_ON_DESELECT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11c2), 1)

#define GP_WB_GET_SPI_SL_CLR_RX_FIFO_ON_DESELECT_FROM_CONFIG(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_SPI_SL_CLR_RX_FIFO_ON_DESELECT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11c2), 1, (val)); \
        } while (0)

#define GP_WB_SET_SPI_SL_CLR_RX_FIFO_ON_DESELECT_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* When set, the tx data byte buffer will be cleared whn the ssn pin is inactive */
#define GP_WB_READ_SPI_SL_CLR_TX_FIFO_ON_DESELECT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11c2), 2)

#define GP_WB_GET_SPI_SL_CLR_TX_FIFO_ON_DESELECT_FROM_CONFIG(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_SPI_SL_CLR_TX_FIFO_ON_DESELECT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11c2), 2, (val)); \
        } while (0)

#define GP_WB_SET_SPI_SL_CLR_TX_FIFO_ON_DESELECT_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Amount of dummy of bytes that shift out of the MISO after the slave is selected and before real data is transmitted. Number of dummy bytes = tx_latency + 1 */
#define GP_WB_READ_SPI_SL_TX_LATENCY() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11c2)) >> 3) & 0x0F)

#define GP_WB_GET_SPI_SL_TX_LATENCY_FROM_CONFIG(tmp) \
        (((tmp) >> 3) & 0x0F)

#define GP_WB_WRITE_SPI_SL_TX_LATENCY(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11c2), 0x78, (val) << 3); \
        } while (0)

#define GP_WB_SET_SPI_SL_TX_LATENCY_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SPI_SL_UNMASKED_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11c3))

/* Status and unmasked interrupt flag for TX buffer not full. The interrupt is cleared implicitly when writing new TX data fills the buffer. */
#define GP_WB_READ_SPI_SL_UNMASKED_TX_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11c3), 1)

#define GP_WB_GET_SPI_SL_UNMASKED_TX_NOT_FULL_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* Status and unmasked interrupt flag for TX bufferbeing empty. The interrupt is cleared implicitly when writing new TX data fills the buffer. */
#define GP_WB_READ_SPI_SL_UNMASKED_TX_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11c3), 2)

#define GP_WB_GET_SPI_SL_UNMASKED_TX_EMPTY_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* Status and unmasked interrupt flag for RX buffer not empty. The interrupt is cleared implicitly when reading the last RX data from the buffer. */
#define GP_WB_READ_SPI_SL_UNMASKED_RX_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11c3), 3)

#define GP_WB_GET_SPI_SL_UNMASKED_RX_NOT_EMPTY_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

/* Status and unmasked interrupt flag for the occurrence of a tx data buffer underrun. Set when the tx data buffer is empty when master pulls data from slave. Cleared explicitly by the SW. */
#define GP_WB_READ_SPI_SL_UNMASKED_TX_UNDERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11c3), 4)

#define GP_WB_GET_SPI_SL_UNMASKED_TX_UNDERRUN_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

/* Status and unmasked interrupt flag for the occurrence of a rx data buffer overrun. Set when the rx data buffer is full and new rx data is available. Cleared explicitly by the SW. */
#define GP_WB_READ_SPI_SL_UNMASKED_RX_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11c3), 5)

#define GP_WB_GET_SPI_SL_UNMASKED_RX_OVERRUN_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)


/* Clear the tx_underrun_interrupt. */
#define GP_WB_SPI_SL_CLR_TX_UNDERRUN_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11c4), 0x01)

/* Clear the rx_overrun_interrupt. */
#define GP_WB_SPI_SL_CLR_RX_OVERRUN_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11c4), 0x02)

/* manually clears the receive byte buffer */
#define GP_WB_SPI_SL_CLR_RX_FIFO() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11c4), 0x04)

/* manually clears the transmit byte buffer */
#define GP_WB_SPI_SL_CLR_TX_FIFO() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11c4), 0x08)

/***************************
 * layout: i2c_sl
 ***************************/

/* TX data FIFO. Data to be transmitted to the master. The FIFO is kept cleared between STOP and START condition. */
#define GP_WB_WRITE_I2C_SL_TX_DATA(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11e0), (val)); \
        } while (0)


/* RX data FIFO. Data received from the master. The FIFO is kept cleared between STOP and START condition. */
#define GP_WB_READ_I2C_SL_RX_DATA() \
        GP_WB_READ_SER_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11e1))


/* I2C slave address */
#define GP_WB_READ_I2C_SL_SLAVE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11e2))

#define GP_WB_WRITE_I2C_SL_SLAVE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03FF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11e2), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_I2C_SL_CONFIG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11e4))

#define GP_WB_WRITE_I2C_SL_CONFIG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11e4), (val))

/* Enable core when '1' */
#define GP_WB_READ_I2C_SL_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11e4), 0)

#define GP_WB_GET_I2C_SL_ENABLE_FROM_CONFIG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_I2C_SL_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11e4), 0, (val)); \
        } while (0)

#define GP_WB_SET_I2C_SL_ENABLE_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Enable clock stretching by the slave. */
#define GP_WB_READ_I2C_SL_SCL_STRETCH_EN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11e4), 1)

#define GP_WB_GET_I2C_SL_SCL_STRETCH_EN_FROM_CONFIG(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_I2C_SL_SCL_STRETCH_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11e4), 1, (val)); \
        } while (0)

#define GP_WB_SET_I2C_SL_SCL_STRETCH_EN_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Enable slave selection via the general call address. */
#define GP_WB_READ_I2C_SL_ACCEPT_GENERAL_CALL() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11e4), 2)

#define GP_WB_GET_I2C_SL_ACCEPT_GENERAL_CALL_FROM_CONFIG(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_I2C_SL_ACCEPT_GENERAL_CALL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11e4), 2, (val)); \
        } while (0)

#define GP_WB_SET_I2C_SL_ACCEPT_GENERAL_CALL_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_I2C_SL_STATUS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11e5))

/* Status of the RnW bit of the last successful slave addressing. When 0, this indicated master-to-slave direction. When 0, this indicated slave-to-master direction. The flag is updated on each slad event. */
#define GP_WB_READ_I2C_SL_READ_FLAG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11e5), 0)

#define GP_WB_GET_I2C_SL_READ_FLAG_FROM_STATUS(tmp) \
        ((tmp) & 0x01)

/* Status of the address match of the last successful slave addressing . When 0, the slave was selected by its own address. When 1, the slave was selected by the general call address (= all 0).  The flag is updated on each slad event. */
#define GP_WB_READ_I2C_SL_GENERAL_CALL_FLAG() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11e5), 1)

#define GP_WB_GET_I2C_SL_GENERAL_CALL_FLAG_FROM_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* When 1, an I2C transfer is busy  Set upon a START event, cleared upon a STOP event. */
#define GP_WB_READ_I2C_SL_BUSY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11e5), 2)

#define GP_WB_GET_I2C_SL_BUSY_FROM_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)

/* When 1, the slave is currently selected, an I2C transfer is busy.  Set upon a SLAD event, cleared upon a STOP event. */
#define GP_WB_READ_I2C_SL_BUSY_SLAD() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11e5), 3)

#define GP_WB_GET_I2C_SL_BUSY_SLAD_FROM_STATUS(tmp) \
        (((tmp) >> 3) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_I2C_SL_UNMASKED_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11e6))

/* Status and unmasked interrupt flag for TX buffer not full. The interrupt is set when TX data is ready to accept new bytes. */
#define GP_WB_READ_I2C_SL_UNMASKED_TX_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11e6), 0)

#define GP_WB_GET_I2C_SL_UNMASKED_TX_NOT_FULL_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* Status and unmasked interrupt flag for RX buffer not empty. The interrupt is cleared implicitly when reading the last RX data from the buffer. */
#define GP_WB_READ_I2C_SL_UNMASKED_RX_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11e6), 1)

#define GP_WB_GET_I2C_SL_UNMASKED_RX_NOT_EMPTY_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* Status and unmasked interrupt flag for SCL stretching ongoing. The interrupt is active when SCL is being stretched by the slave. SCL stretching occurs when scl_stretch_en = '1', the slave has been successfully addressed in read direction, and the tx_data FIFO is empty. This interrupt can be used to trigger writes to tx_data. */
#define GP_WB_READ_I2C_SL_UNMASKED_TX_STRETCH_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11e6), 2)

#define GP_WB_GET_I2C_SL_UNMASKED_TX_STRETCH_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* Event and unmasked interrupt flag for the occurrence of a START condition on the I2C bus. Set when a START or a repeated START condition is detected. Cleared explicitly by the SW. */
#define GP_WB_READ_I2C_SL_UNMASKED_START_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11e6), 3)

#define GP_WB_GET_I2C_SL_UNMASKED_START_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)

/* Event and unmasked interrupt flag for the occurrence of a STOP condition on the I2C bus. Set when the STOP condition is detected. Cleared explicitly by the SW. */
#define GP_WB_READ_I2C_SL_UNMASKED_STOP_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11e6), 4)

#define GP_WB_GET_I2C_SL_UNMASKED_STOP_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 4) & 0x01)

/* Event and unmasked interrupt flag for the occurrence of a SLAD event (slave addressed). Set when this slave has been (re-)selected or upon a general call. Cleared explicitly by the SW. */
#define GP_WB_READ_I2C_SL_UNMASKED_SLAD_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11e6), 5)

#define GP_WB_GET_I2C_SL_UNMASKED_SLAD_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 5) & 0x01)


#define GP_WB_WRITE_I2C_SL_CLR_INTERRUPTS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11e7), (val))

/* Clear the START condition interrupt. */
#define GP_WB_I2C_SL_CLR_START_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11e7), 0x01)

#define GP_WB_SET_I2C_SL_CLR_START_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Clear the STOP condition interrupt. */
#define GP_WB_I2C_SL_CLR_STOP_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11e7), 0x02)

#define GP_WB_SET_I2C_SL_CLR_STOP_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Clear the SLAD condition interrupt. */
#define GP_WB_I2C_SL_CLR_SLAD_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x11e7), 0x04)

#define GP_WB_SET_I2C_SL_CLR_SLAD_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/***************************
 * layout: dmas
 ***************************/

/* Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode) */
#define GP_WB_READ_DMAS_SRC_ADDR_0() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1200))

#define GP_WB_WRITE_DMAS_SRC_ADDR_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFFFF); \
          GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1200), (val)); \
        } while (0)


/* Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode) */
#define GP_WB_READ_DMAS_DEST_ADDR_0() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1204))

#define GP_WB_WRITE_DMAS_DEST_ADDR_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFFFF); \
          GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1204), (val)); \
        } while (0)


/* Size of either the source or destination buffer_0, depending on circular_buffer_select_0. Expressed as a multiple of the DMA memory access unit. buffer_size_0=n_units-1 */
#define GP_WB_READ_DMAS_BUFFER_SIZE_0() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1208))

#define GP_WB_WRITE_DMAS_BUFFER_SIZE_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1208), (val)); \
        } while (0)


/* Threshold to be used for generating either an almost empty or almost full interrupt, depending on circular_buffer_select_0. If SRC_BUFFER, interrupt is triggered when there are only (threshold-1) units left in the src buffer_0. If DEST_BUFFER, interrupt is triggered when there are (threshold+1) units written in the dest buffer_0. */
#define GP_WB_READ_DMAS_BUFFER_ALMOST_COMPLETE_THRESHOLD_0() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x120a))

#define GP_WB_WRITE_DMAS_BUFFER_ALMOST_COMPLETE_THRESHOLD_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x120a), (val)); \
        } while (0)


/* Pointer value to be used when triggering the different pointer sets (allows for atomic pointer set) */
#define GP_WB_READ_DMAS_BUFFER_PTR_VALUE_0() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x120c))

#define GP_WB_WRITE_DMAS_BUFFER_PTR_VALUE_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x120c), (val)); \
        } while (0)


/* Pointer wrap value to be used when triggering the different pointer sets (allows for atomic pointer set) */
#define GP_WB_READ_DMAS_BUFFER_PTR_WRAP_VALUE_0() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x120e), 0)

#define GP_WB_WRITE_DMAS_BUFFER_PTR_WRAP_VALUE_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x120e), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_DMAS_CONFIG_0() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1210))

#define GP_WB_WRITE_DMAS_CONFIG_0(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1210), (val))

/* Sets the size of the memory access unit. DMA supports 8/16/32-bit memory access. byte = 8 bits, half_word = 16 bits, word = 32 bits */
#define GP_WB_READ_DMAS_WORD_MODE_0() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1210)) & 0x03)

#define GP_WB_GET_DMAS_WORD_MODE_0_FROM_CONFIG_0(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_DMAS_WORD_MODE_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1210), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_DMAS_WORD_MODE_0_TO_CONFIG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x1FFC; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Selects the slave interface that will be the source for triggering the dma copy action */
#define GP_WB_READ_DMAS_CPY_TRIGGER_SRC_SELECT_0() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1210)) >> 2) & 0x1F)

#define GP_WB_GET_DMAS_CPY_TRIGGER_SRC_SELECT_0_FROM_CONFIG_0(tmp) \
        (((tmp) >> 2) & 0x1F)

#define GP_WB_WRITE_DMAS_CPY_TRIGGER_SRC_SELECT_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1210), 0x7C, (val) << 2); \
        } while (0)

#define GP_WB_SET_DMAS_CPY_TRIGGER_SRC_SELECT_0_TO_CONFIG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x1F83; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* regmap cpy trigger_0 overrule. The dma copy will be triggered as long as this bit is set to 1 */
#define GP_WB_READ_DMAS_CPY_TRIGGER_BY_REGMAP_0() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1210), 7)

#define GP_WB_GET_DMAS_CPY_TRIGGER_BY_REGMAP_0_FROM_CONFIG_0(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_DMAS_CPY_TRIGGER_BY_REGMAP_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1210), 7, (val)); \
        } while (0)

#define GP_WB_SET_DMAS_CPY_TRIGGER_BY_REGMAP_0_TO_CONFIG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* If set to error_mode then the buffer_complete interrupt indicates overflow/underrun conditions. Otherwise (status_mode) full/empty conditions are reported. */
#define GP_WB_READ_DMAS_BUFFER_COMPLETE_INTERRUPT_MODE_0() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1211), 0)

#define GP_WB_GET_DMAS_BUFFER_COMPLETE_INTERRUPT_MODE_0_FROM_CONFIG_0(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_DMAS_BUFFER_COMPLETE_INTERRUPT_MODE_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1211), 0, (val)); \
        } while (0)

#define GP_WB_SET_DMAS_BUFFER_COMPLETE_INTERRUPT_MODE_0_TO_CONFIG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1EFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* Minimum number of idle cycles between accesses to the same dma channel. Should be increased for slowly responding cpy_triggers. */
#define GP_WB_READ_DMAS_ACCESS_LATENCY_0() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1211)) >> 1) & 0x0F)

#define GP_WB_GET_DMAS_ACCESS_LATENCY_0_FROM_CONFIG_0(tmp) \
        (((tmp) >> 9) & 0x0F)

#define GP_WB_WRITE_DMAS_ACCESS_LATENCY_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1211), 0x1E, (val) << 1); \
        } while (0)

#define GP_WB_SET_DMAS_ACCESS_LATENCY_0_TO_CONFIG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x01FF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)


/* When enabled, the buffer_0's completeness is ignored when triggering a dma copy action */
#define GP_WB_READ_DMAS_CPY_TRIGGER_IGNORE_BUFFER_COMPLETE_0() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1212), 0)

#define GP_WB_WRITE_DMAS_CPY_TRIGGER_IGNORE_BUFFER_COMPLETE_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1212), (val)); \
        } while (0)


/* Selects between source and destination as circular buffer locatio. */
#define GP_WB_READ_DMAS_CIRCULAR_BUFFER_SELECT_0() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1213), 0)

#define GP_WB_WRITE_DMAS_CIRCULAR_BUFFER_SELECT_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1213), (val)); \
        } while (0)


#define GP_WB_WRITE_DMAS_BUFFER_PTR_CONTROL_0(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1214), (val))

/* Sets the internal circular buffer write pointer_0 by buffer_ptr_value / wrap value_0.  Provides atomic way for updating buffer_0 write pointer_0 */
#define GP_WB_DMAS_SET_WRITE_PTR_0() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1214), 0x01)

#define GP_WB_SET_DMAS_SET_WRITE_PTR_0_TO_BUFFER_PTR_CONTROL_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Sets the internal circular buffer read pointer_0 by buffer_ptr_value / wrap value_0.  Provides atomic way to initialize the buffer_0 read pointer_0 */
#define GP_WB_DMAS_SET_READ_PTR_0() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1214), 0x02)

#define GP_WB_SET_DMAS_SET_READ_PTR_0_TO_BUFFER_PTR_CONTROL_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Resets all buffer_0 pointers to 0 */
#define GP_WB_DMAS_RESET_POINTERS_0() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1214), 0x04)

#define GP_WB_SET_DMAS_RESET_POINTERS_0_TO_BUFFER_PTR_CONTROL_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* clears the buffer_complete interrupt_0 */
#define GP_WB_DMAS_CLR_BUFFER_COMPLETE_INTERRUPT_0() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1215), 0x01)


/* Actual read offset ptr_0 that is being used internally to access the circular buffer_0. Allows atomic read out (data is latched when internal_ptr_0_l is read). */
#define GP_WB_READ_DMAS_INTERNAL_PTR_0() \
        (GP_WB_READ_SER_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1216)) & 0x0FFF)

/* When circular_buffer_select_0 = src_buffer, toggle signal that is toggled each time the dma internal read_ptr_0 wraps around (for underrun detection). When circular_buffer_select_0 = dest_buffer, it is toggled each time the dma internal write_ptr_0 wraps around (for overflow detection). Allows atomic read out (data is latched when internal_ptr_0_l is read). */
#define GP_WB_READ_DMAS_INTERNAL_PTR_WRAP_0() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1217), 4)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_DMAS_STATUS_0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1218))

/* Refers to the selected circular buffer. In buffer_complete_interrupt_mode_0 = error_mode overflow (for circular_buffer_select_0 = dest_buffer) or underrun (for circular_buffer_select_0 = src_buffer) errors are indicated. In buffer_complete_interrupt_mode_0 = status_mode it indicates full (for circular_buffer_select_0 = dest_buffer) or empty (for circular_buffer_select_0 = src_buffer) status. */
#define GP_WB_READ_DMAS_UNMASKED_BUFFER_COMPLETE_0_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1218), 0)

#define GP_WB_GET_DMAS_UNMASKED_BUFFER_COMPLETE_0_INTERRUPT_FROM_STATUS_0(tmp) \
        ((tmp) & 0x01)

/* Indicates that the almost complete threshold has been reached, actual level depends on the circular_buffer_select_0. See threshold setting for more info */
#define GP_WB_READ_DMAS_UNMASKED_BUFFER_ALMOST_COMPLETE_0_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1218), 1)

#define GP_WB_GET_DMAS_UNMASKED_BUFFER_ALMOST_COMPLETE_0_INTERRUPT_FROM_STATUS_0(tmp) \
        (((tmp) >> 1) & 0x01)


/* Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode) */
#define GP_WB_READ_DMAS_SRC_ADDR_1() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x121c))

#define GP_WB_WRITE_DMAS_SRC_ADDR_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFFFF); \
          GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x121c), (val)); \
        } while (0)


/* Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode) */
#define GP_WB_READ_DMAS_DEST_ADDR_1() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1220))

#define GP_WB_WRITE_DMAS_DEST_ADDR_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFFFF); \
          GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1220), (val)); \
        } while (0)


/* Size of either the source or destination buffer_1, depending on circular_buffer_select_1. Expressed as a multiple of the DMA memory access unit. buffer_size_1=n_units-1 */
#define GP_WB_READ_DMAS_BUFFER_SIZE_1() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1224))

#define GP_WB_WRITE_DMAS_BUFFER_SIZE_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1224), (val)); \
        } while (0)


/* Threshold to be used for generating either an almost empty or almost full interrupt, depending on circular_buffer_select_1. If SRC_BUFFER, interrupt is triggered when there are only (threshold-1) units left in the src buffer_1. If DEST_BUFFER, interrupt is triggered when there are (threshold+1) units written in the dest buffer_1. */
#define GP_WB_READ_DMAS_BUFFER_ALMOST_COMPLETE_THRESHOLD_1() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1226))

#define GP_WB_WRITE_DMAS_BUFFER_ALMOST_COMPLETE_THRESHOLD_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1226), (val)); \
        } while (0)


/* Pointer value to be used when triggering the different pointer sets (allows for atomic pointer set) */
#define GP_WB_READ_DMAS_BUFFER_PTR_VALUE_1() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1228))

#define GP_WB_WRITE_DMAS_BUFFER_PTR_VALUE_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1228), (val)); \
        } while (0)


/* Pointer wrap value to be used when triggering the different pointer sets (allows for atomic pointer set) */
#define GP_WB_READ_DMAS_BUFFER_PTR_WRAP_VALUE_1() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x122a), 0)

#define GP_WB_WRITE_DMAS_BUFFER_PTR_WRAP_VALUE_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x122a), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_DMAS_CONFIG_1() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x122c))

#define GP_WB_WRITE_DMAS_CONFIG_1(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x122c), (val))

/* Sets the size of the memory access unit. DMA supports 8/16/32-bit memory access. byte = 8 bits, half_word = 16 bits, word = 32 bits */
#define GP_WB_READ_DMAS_WORD_MODE_1() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x122c)) & 0x03)

#define GP_WB_GET_DMAS_WORD_MODE_1_FROM_CONFIG_1(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_DMAS_WORD_MODE_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x122c), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_DMAS_WORD_MODE_1_TO_CONFIG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x1FFC; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Selects the slave interface that will be the source for triggering the dma copy action */
#define GP_WB_READ_DMAS_CPY_TRIGGER_SRC_SELECT_1() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x122c)) >> 2) & 0x1F)

#define GP_WB_GET_DMAS_CPY_TRIGGER_SRC_SELECT_1_FROM_CONFIG_1(tmp) \
        (((tmp) >> 2) & 0x1F)

#define GP_WB_WRITE_DMAS_CPY_TRIGGER_SRC_SELECT_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x122c), 0x7C, (val) << 2); \
        } while (0)

#define GP_WB_SET_DMAS_CPY_TRIGGER_SRC_SELECT_1_TO_CONFIG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x1F83; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* regmap cpy trigger_1 overrule. The dma copy will be triggered as long as this bit is set to 1 */
#define GP_WB_READ_DMAS_CPY_TRIGGER_BY_REGMAP_1() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x122c), 7)

#define GP_WB_GET_DMAS_CPY_TRIGGER_BY_REGMAP_1_FROM_CONFIG_1(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_DMAS_CPY_TRIGGER_BY_REGMAP_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x122c), 7, (val)); \
        } while (0)

#define GP_WB_SET_DMAS_CPY_TRIGGER_BY_REGMAP_1_TO_CONFIG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* If set to error_mode then the buffer_complete interrupt indicates overflow/underrun conditions. Otherwise (status_mode) full/empty conditions are reported. */
#define GP_WB_READ_DMAS_BUFFER_COMPLETE_INTERRUPT_MODE_1() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x122d), 0)

#define GP_WB_GET_DMAS_BUFFER_COMPLETE_INTERRUPT_MODE_1_FROM_CONFIG_1(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_DMAS_BUFFER_COMPLETE_INTERRUPT_MODE_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x122d), 0, (val)); \
        } while (0)

#define GP_WB_SET_DMAS_BUFFER_COMPLETE_INTERRUPT_MODE_1_TO_CONFIG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1EFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* Minimum number of idle cycles between accesses to the same dma channel. Should be increased for slowly responding cpy_triggers. */
#define GP_WB_READ_DMAS_ACCESS_LATENCY_1() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x122d)) >> 1) & 0x0F)

#define GP_WB_GET_DMAS_ACCESS_LATENCY_1_FROM_CONFIG_1(tmp) \
        (((tmp) >> 9) & 0x0F)

#define GP_WB_WRITE_DMAS_ACCESS_LATENCY_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x122d), 0x1E, (val) << 1); \
        } while (0)

#define GP_WB_SET_DMAS_ACCESS_LATENCY_1_TO_CONFIG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x01FF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)


/* When enabled, the buffer_1's completeness is ignored when triggering a dma copy action */
#define GP_WB_READ_DMAS_CPY_TRIGGER_IGNORE_BUFFER_COMPLETE_1() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x122e), 0)

#define GP_WB_WRITE_DMAS_CPY_TRIGGER_IGNORE_BUFFER_COMPLETE_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x122e), (val)); \
        } while (0)


/* Selects between source and destination as circular buffer locatio. */
#define GP_WB_READ_DMAS_CIRCULAR_BUFFER_SELECT_1() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x122f), 0)

#define GP_WB_WRITE_DMAS_CIRCULAR_BUFFER_SELECT_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x122f), (val)); \
        } while (0)


#define GP_WB_WRITE_DMAS_BUFFER_PTR_CONTROL_1(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1230), (val))

/* Sets the internal circular buffer write pointer_1 by buffer_ptr_value / wrap value_1.  Provides atomic way for updating buffer_1 write pointer_1 */
#define GP_WB_DMAS_SET_WRITE_PTR_1() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1230), 0x01)

#define GP_WB_SET_DMAS_SET_WRITE_PTR_1_TO_BUFFER_PTR_CONTROL_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Sets the internal circular buffer read pointer_1 by buffer_ptr_value / wrap value_1.  Provides atomic way to initialize the buffer_1 read pointer_1 */
#define GP_WB_DMAS_SET_READ_PTR_1() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1230), 0x02)

#define GP_WB_SET_DMAS_SET_READ_PTR_1_TO_BUFFER_PTR_CONTROL_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Resets all buffer_1 pointers to 0 */
#define GP_WB_DMAS_RESET_POINTERS_1() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1230), 0x04)

#define GP_WB_SET_DMAS_RESET_POINTERS_1_TO_BUFFER_PTR_CONTROL_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* clears the buffer_complete interrupt_1 */
#define GP_WB_DMAS_CLR_BUFFER_COMPLETE_INTERRUPT_1() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1231), 0x01)


/* Actual read offset ptr_1 that is being used internally to access the circular buffer_1. Allows atomic read out (data is latched when internal_ptr_1_l is read). */
#define GP_WB_READ_DMAS_INTERNAL_PTR_1() \
        (GP_WB_READ_SER_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1232)) & 0x0FFF)

/* When circular_buffer_select_1 = src_buffer, toggle signal that is toggled each time the dma internal read_ptr_1 wraps around (for underrun detection). When circular_buffer_select_1 = dest_buffer, it is toggled each time the dma internal write_ptr_1 wraps around (for overflow detection). Allows atomic read out (data is latched when internal_ptr_1_l is read). */
#define GP_WB_READ_DMAS_INTERNAL_PTR_WRAP_1() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1233), 4)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_DMAS_STATUS_1() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1234))

/* Refers to the selected circular buffer. In buffer_complete_interrupt_mode_1 = error_mode overflow (for circular_buffer_select_1 = dest_buffer) or underrun (for circular_buffer_select_1 = src_buffer) errors are indicated. In buffer_complete_interrupt_mode_1 = status_mode it indicates full (for circular_buffer_select_1 = dest_buffer) or empty (for circular_buffer_select_1 = src_buffer) status. */
#define GP_WB_READ_DMAS_UNMASKED_BUFFER_COMPLETE_1_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1234), 0)

#define GP_WB_GET_DMAS_UNMASKED_BUFFER_COMPLETE_1_INTERRUPT_FROM_STATUS_1(tmp) \
        ((tmp) & 0x01)

/* Indicates that the almost complete threshold has been reached, actual level depends on the circular_buffer_select_1. See threshold setting for more info */
#define GP_WB_READ_DMAS_UNMASKED_BUFFER_ALMOST_COMPLETE_1_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1234), 1)

#define GP_WB_GET_DMAS_UNMASKED_BUFFER_ALMOST_COMPLETE_1_INTERRUPT_FROM_STATUS_1(tmp) \
        (((tmp) >> 1) & 0x01)


/* Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode) */
#define GP_WB_READ_DMAS_SRC_ADDR_2() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1238))

#define GP_WB_WRITE_DMAS_SRC_ADDR_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFFFF); \
          GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1238), (val)); \
        } while (0)


/* Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode) */
#define GP_WB_READ_DMAS_DEST_ADDR_2() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x123c))

#define GP_WB_WRITE_DMAS_DEST_ADDR_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFFFF); \
          GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x123c), (val)); \
        } while (0)


/* Size of either the source or destination buffer_2, depending on circular_buffer_select_2. Expressed as a multiple of the DMA memory access unit. buffer_size_2=n_units-1 */
#define GP_WB_READ_DMAS_BUFFER_SIZE_2() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1240))

#define GP_WB_WRITE_DMAS_BUFFER_SIZE_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1240), (val)); \
        } while (0)


/* Threshold to be used for generating either an almost empty or almost full interrupt, depending on circular_buffer_select_2. If SRC_BUFFER, interrupt is triggered when there are only (threshold-1) units left in the src buffer_2. If DEST_BUFFER, interrupt is triggered when there are (threshold+1) units written in the dest buffer_2. */
#define GP_WB_READ_DMAS_BUFFER_ALMOST_COMPLETE_THRESHOLD_2() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1242))

#define GP_WB_WRITE_DMAS_BUFFER_ALMOST_COMPLETE_THRESHOLD_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1242), (val)); \
        } while (0)


/* Pointer value to be used when triggering the different pointer sets (allows for atomic pointer set) */
#define GP_WB_READ_DMAS_BUFFER_PTR_VALUE_2() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1244))

#define GP_WB_WRITE_DMAS_BUFFER_PTR_VALUE_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1244), (val)); \
        } while (0)


/* Pointer wrap value to be used when triggering the different pointer sets (allows for atomic pointer set) */
#define GP_WB_READ_DMAS_BUFFER_PTR_WRAP_VALUE_2() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1246), 0)

#define GP_WB_WRITE_DMAS_BUFFER_PTR_WRAP_VALUE_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1246), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_DMAS_CONFIG_2() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1248))

#define GP_WB_WRITE_DMAS_CONFIG_2(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1248), (val))

/* Sets the size of the memory access unit. DMA supports 8/16/32-bit memory access. byte = 8 bits, half_word = 16 bits, word = 32 bits */
#define GP_WB_READ_DMAS_WORD_MODE_2() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1248)) & 0x03)

#define GP_WB_GET_DMAS_WORD_MODE_2_FROM_CONFIG_2(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_DMAS_WORD_MODE_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1248), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_DMAS_WORD_MODE_2_TO_CONFIG_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x1FFC; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Selects the slave interface that will be the source for triggering the dma copy action */
#define GP_WB_READ_DMAS_CPY_TRIGGER_SRC_SELECT_2() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1248)) >> 2) & 0x1F)

#define GP_WB_GET_DMAS_CPY_TRIGGER_SRC_SELECT_2_FROM_CONFIG_2(tmp) \
        (((tmp) >> 2) & 0x1F)

#define GP_WB_WRITE_DMAS_CPY_TRIGGER_SRC_SELECT_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1248), 0x7C, (val) << 2); \
        } while (0)

#define GP_WB_SET_DMAS_CPY_TRIGGER_SRC_SELECT_2_TO_CONFIG_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x1F83; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* regmap cpy trigger_2 overrule. The dma copy will be triggered as long as this bit is set to 1 */
#define GP_WB_READ_DMAS_CPY_TRIGGER_BY_REGMAP_2() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1248), 7)

#define GP_WB_GET_DMAS_CPY_TRIGGER_BY_REGMAP_2_FROM_CONFIG_2(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_DMAS_CPY_TRIGGER_BY_REGMAP_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1248), 7, (val)); \
        } while (0)

#define GP_WB_SET_DMAS_CPY_TRIGGER_BY_REGMAP_2_TO_CONFIG_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* If set to error_mode then the buffer_complete interrupt indicates overflow/underrun conditions. Otherwise (status_mode) full/empty conditions are reported. */
#define GP_WB_READ_DMAS_BUFFER_COMPLETE_INTERRUPT_MODE_2() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1249), 0)

#define GP_WB_GET_DMAS_BUFFER_COMPLETE_INTERRUPT_MODE_2_FROM_CONFIG_2(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_DMAS_BUFFER_COMPLETE_INTERRUPT_MODE_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1249), 0, (val)); \
        } while (0)

#define GP_WB_SET_DMAS_BUFFER_COMPLETE_INTERRUPT_MODE_2_TO_CONFIG_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1EFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* Minimum number of idle cycles between accesses to the same dma channel. Should be increased for slowly responding cpy_triggers. */
#define GP_WB_READ_DMAS_ACCESS_LATENCY_2() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1249)) >> 1) & 0x0F)

#define GP_WB_GET_DMAS_ACCESS_LATENCY_2_FROM_CONFIG_2(tmp) \
        (((tmp) >> 9) & 0x0F)

#define GP_WB_WRITE_DMAS_ACCESS_LATENCY_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1249), 0x1E, (val) << 1); \
        } while (0)

#define GP_WB_SET_DMAS_ACCESS_LATENCY_2_TO_CONFIG_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x01FF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)


/* When enabled, the buffer_2's completeness is ignored when triggering a dma copy action */
#define GP_WB_READ_DMAS_CPY_TRIGGER_IGNORE_BUFFER_COMPLETE_2() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x124a), 0)

#define GP_WB_WRITE_DMAS_CPY_TRIGGER_IGNORE_BUFFER_COMPLETE_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x124a), (val)); \
        } while (0)


/* Selects between source and destination as circular buffer locatio. */
#define GP_WB_READ_DMAS_CIRCULAR_BUFFER_SELECT_2() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x124b), 0)

#define GP_WB_WRITE_DMAS_CIRCULAR_BUFFER_SELECT_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x124b), (val)); \
        } while (0)


#define GP_WB_WRITE_DMAS_BUFFER_PTR_CONTROL_2(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x124c), (val))

/* Sets the internal circular buffer write pointer_2 by buffer_ptr_value / wrap value_2.  Provides atomic way for updating buffer_2 write pointer_2 */
#define GP_WB_DMAS_SET_WRITE_PTR_2() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x124c), 0x01)

#define GP_WB_SET_DMAS_SET_WRITE_PTR_2_TO_BUFFER_PTR_CONTROL_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Sets the internal circular buffer read pointer_2 by buffer_ptr_value / wrap value_2.  Provides atomic way to initialize the buffer_2 read pointer_2 */
#define GP_WB_DMAS_SET_READ_PTR_2() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x124c), 0x02)

#define GP_WB_SET_DMAS_SET_READ_PTR_2_TO_BUFFER_PTR_CONTROL_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Resets all buffer_2 pointers to 0 */
#define GP_WB_DMAS_RESET_POINTERS_2() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x124c), 0x04)

#define GP_WB_SET_DMAS_RESET_POINTERS_2_TO_BUFFER_PTR_CONTROL_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* clears the buffer_complete interrupt_2 */
#define GP_WB_DMAS_CLR_BUFFER_COMPLETE_INTERRUPT_2() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x124d), 0x01)


/* Actual read offset ptr_2 that is being used internally to access the circular buffer_2. Allows atomic read out (data is latched when internal_ptr_2_l is read). */
#define GP_WB_READ_DMAS_INTERNAL_PTR_2() \
        (GP_WB_READ_SER_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x124e)) & 0x0FFF)

/* When circular_buffer_select_2 = src_buffer, toggle signal that is toggled each time the dma internal read_ptr_2 wraps around (for underrun detection). When circular_buffer_select_2 = dest_buffer, it is toggled each time the dma internal write_ptr_2 wraps around (for overflow detection). Allows atomic read out (data is latched when internal_ptr_2_l is read). */
#define GP_WB_READ_DMAS_INTERNAL_PTR_WRAP_2() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x124f), 4)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_DMAS_STATUS_2() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1250))

/* Refers to the selected circular buffer. In buffer_complete_interrupt_mode_2 = error_mode overflow (for circular_buffer_select_2 = dest_buffer) or underrun (for circular_buffer_select_2 = src_buffer) errors are indicated. In buffer_complete_interrupt_mode_2 = status_mode it indicates full (for circular_buffer_select_2 = dest_buffer) or empty (for circular_buffer_select_2 = src_buffer) status. */
#define GP_WB_READ_DMAS_UNMASKED_BUFFER_COMPLETE_2_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1250), 0)

#define GP_WB_GET_DMAS_UNMASKED_BUFFER_COMPLETE_2_INTERRUPT_FROM_STATUS_2(tmp) \
        ((tmp) & 0x01)

/* Indicates that the almost complete threshold has been reached, actual level depends on the circular_buffer_select_2. See threshold setting for more info */
#define GP_WB_READ_DMAS_UNMASKED_BUFFER_ALMOST_COMPLETE_2_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1250), 1)

#define GP_WB_GET_DMAS_UNMASKED_BUFFER_ALMOST_COMPLETE_2_INTERRUPT_FROM_STATUS_2(tmp) \
        (((tmp) >> 1) & 0x01)


/* Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode) */
#define GP_WB_READ_DMAS_SRC_ADDR_3() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1254))

#define GP_WB_WRITE_DMAS_SRC_ADDR_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFFFF); \
          GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1254), (val)); \
        } while (0)


/* Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode) */
#define GP_WB_READ_DMAS_DEST_ADDR_3() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1258))

#define GP_WB_WRITE_DMAS_DEST_ADDR_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFFFF); \
          GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1258), (val)); \
        } while (0)


/* Size of either the source or destination buffer_3, depending on circular_buffer_select_3. Expressed as a multiple of the DMA memory access unit. buffer_size_3=n_units-1 */
#define GP_WB_READ_DMAS_BUFFER_SIZE_3() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x125c))

#define GP_WB_WRITE_DMAS_BUFFER_SIZE_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x125c), (val)); \
        } while (0)


/* Threshold to be used for generating either an almost empty or almost full interrupt, depending on circular_buffer_select_3. If SRC_BUFFER, interrupt is triggered when there are only (threshold-1) units left in the src buffer_3. If DEST_BUFFER, interrupt is triggered when there are (threshold+1) units written in the dest buffer_3. */
#define GP_WB_READ_DMAS_BUFFER_ALMOST_COMPLETE_THRESHOLD_3() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x125e))

#define GP_WB_WRITE_DMAS_BUFFER_ALMOST_COMPLETE_THRESHOLD_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x125e), (val)); \
        } while (0)


/* Pointer value to be used when triggering the different pointer sets (allows for atomic pointer set) */
#define GP_WB_READ_DMAS_BUFFER_PTR_VALUE_3() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1260))

#define GP_WB_WRITE_DMAS_BUFFER_PTR_VALUE_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1260), (val)); \
        } while (0)


/* Pointer wrap value to be used when triggering the different pointer sets (allows for atomic pointer set) */
#define GP_WB_READ_DMAS_BUFFER_PTR_WRAP_VALUE_3() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1262), 0)

#define GP_WB_WRITE_DMAS_BUFFER_PTR_WRAP_VALUE_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1262), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_DMAS_CONFIG_3() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1264))

#define GP_WB_WRITE_DMAS_CONFIG_3(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1264), (val))

/* Sets the size of the memory access unit. DMA supports 8/16/32-bit memory access. byte = 8 bits, half_word = 16 bits, word = 32 bits */
#define GP_WB_READ_DMAS_WORD_MODE_3() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1264)) & 0x03)

#define GP_WB_GET_DMAS_WORD_MODE_3_FROM_CONFIG_3(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_DMAS_WORD_MODE_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1264), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_DMAS_WORD_MODE_3_TO_CONFIG_3(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x1FFC; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Selects the slave interface that will be the source for triggering the dma copy action */
#define GP_WB_READ_DMAS_CPY_TRIGGER_SRC_SELECT_3() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1264)) >> 2) & 0x1F)

#define GP_WB_GET_DMAS_CPY_TRIGGER_SRC_SELECT_3_FROM_CONFIG_3(tmp) \
        (((tmp) >> 2) & 0x1F)

#define GP_WB_WRITE_DMAS_CPY_TRIGGER_SRC_SELECT_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1264), 0x7C, (val) << 2); \
        } while (0)

#define GP_WB_SET_DMAS_CPY_TRIGGER_SRC_SELECT_3_TO_CONFIG_3(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x1F83; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* regmap cpy trigger_3 overrule. The dma copy will be triggered as long as this bit is set to 1 */
#define GP_WB_READ_DMAS_CPY_TRIGGER_BY_REGMAP_3() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1264), 7)

#define GP_WB_GET_DMAS_CPY_TRIGGER_BY_REGMAP_3_FROM_CONFIG_3(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_DMAS_CPY_TRIGGER_BY_REGMAP_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1264), 7, (val)); \
        } while (0)

#define GP_WB_SET_DMAS_CPY_TRIGGER_BY_REGMAP_3_TO_CONFIG_3(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* If set to error_mode then the buffer_complete interrupt indicates overflow/underrun conditions. Otherwise (status_mode) full/empty conditions are reported. */
#define GP_WB_READ_DMAS_BUFFER_COMPLETE_INTERRUPT_MODE_3() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1265), 0)

#define GP_WB_GET_DMAS_BUFFER_COMPLETE_INTERRUPT_MODE_3_FROM_CONFIG_3(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_DMAS_BUFFER_COMPLETE_INTERRUPT_MODE_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1265), 0, (val)); \
        } while (0)

#define GP_WB_SET_DMAS_BUFFER_COMPLETE_INTERRUPT_MODE_3_TO_CONFIG_3(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1EFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* Minimum number of idle cycles between accesses to the same dma channel. Should be increased for slowly responding cpy_triggers. */
#define GP_WB_READ_DMAS_ACCESS_LATENCY_3() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1265)) >> 1) & 0x0F)

#define GP_WB_GET_DMAS_ACCESS_LATENCY_3_FROM_CONFIG_3(tmp) \
        (((tmp) >> 9) & 0x0F)

#define GP_WB_WRITE_DMAS_ACCESS_LATENCY_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1265), 0x1E, (val) << 1); \
        } while (0)

#define GP_WB_SET_DMAS_ACCESS_LATENCY_3_TO_CONFIG_3(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x01FF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)


/* When enabled, the buffer_3's completeness is ignored when triggering a dma copy action */
#define GP_WB_READ_DMAS_CPY_TRIGGER_IGNORE_BUFFER_COMPLETE_3() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1266), 0)

#define GP_WB_WRITE_DMAS_CPY_TRIGGER_IGNORE_BUFFER_COMPLETE_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1266), (val)); \
        } while (0)


/* Selects between source and destination as circular buffer locatio. */
#define GP_WB_READ_DMAS_CIRCULAR_BUFFER_SELECT_3() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1267), 0)

#define GP_WB_WRITE_DMAS_CIRCULAR_BUFFER_SELECT_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1267), (val)); \
        } while (0)


#define GP_WB_WRITE_DMAS_BUFFER_PTR_CONTROL_3(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1268), (val))

/* Sets the internal circular buffer write pointer_3 by buffer_ptr_value / wrap value_3.  Provides atomic way for updating buffer_3 write pointer_3 */
#define GP_WB_DMAS_SET_WRITE_PTR_3() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1268), 0x01)

#define GP_WB_SET_DMAS_SET_WRITE_PTR_3_TO_BUFFER_PTR_CONTROL_3(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Sets the internal circular buffer read pointer_3 by buffer_ptr_value / wrap value_3.  Provides atomic way to initialize the buffer_3 read pointer_3 */
#define GP_WB_DMAS_SET_READ_PTR_3() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1268), 0x02)

#define GP_WB_SET_DMAS_SET_READ_PTR_3_TO_BUFFER_PTR_CONTROL_3(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Resets all buffer_3 pointers to 0 */
#define GP_WB_DMAS_RESET_POINTERS_3() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1268), 0x04)

#define GP_WB_SET_DMAS_RESET_POINTERS_3_TO_BUFFER_PTR_CONTROL_3(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* clears the buffer_complete interrupt_3 */
#define GP_WB_DMAS_CLR_BUFFER_COMPLETE_INTERRUPT_3() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1269), 0x01)


/* Actual read offset ptr_3 that is being used internally to access the circular buffer_3. Allows atomic read out (data is latched when internal_ptr_3_l is read). */
#define GP_WB_READ_DMAS_INTERNAL_PTR_3() \
        (GP_WB_READ_SER_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x126a)) & 0x0FFF)

/* When circular_buffer_select_3 = src_buffer, toggle signal that is toggled each time the dma internal read_ptr_3 wraps around (for underrun detection). When circular_buffer_select_3 = dest_buffer, it is toggled each time the dma internal write_ptr_3 wraps around (for overflow detection). Allows atomic read out (data is latched when internal_ptr_3_l is read). */
#define GP_WB_READ_DMAS_INTERNAL_PTR_WRAP_3() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x126b), 4)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_DMAS_STATUS_3() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x126c))

/* Refers to the selected circular buffer. In buffer_complete_interrupt_mode_3 = error_mode overflow (for circular_buffer_select_3 = dest_buffer) or underrun (for circular_buffer_select_3 = src_buffer) errors are indicated. In buffer_complete_interrupt_mode_3 = status_mode it indicates full (for circular_buffer_select_3 = dest_buffer) or empty (for circular_buffer_select_3 = src_buffer) status. */
#define GP_WB_READ_DMAS_UNMASKED_BUFFER_COMPLETE_3_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x126c), 0)

#define GP_WB_GET_DMAS_UNMASKED_BUFFER_COMPLETE_3_INTERRUPT_FROM_STATUS_3(tmp) \
        ((tmp) & 0x01)

/* Indicates that the almost complete threshold has been reached, actual level depends on the circular_buffer_select_3. See threshold setting for more info */
#define GP_WB_READ_DMAS_UNMASKED_BUFFER_ALMOST_COMPLETE_3_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x126c), 1)

#define GP_WB_GET_DMAS_UNMASKED_BUFFER_ALMOST_COMPLETE_3_INTERRUPT_FROM_STATUS_3(tmp) \
        (((tmp) >> 1) & 0x01)


/* Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode) */
#define GP_WB_READ_DMAS_SRC_ADDR_4() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1270))

#define GP_WB_WRITE_DMAS_SRC_ADDR_4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFFFF); \
          GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1270), (val)); \
        } while (0)


/* Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode) */
#define GP_WB_READ_DMAS_DEST_ADDR_4() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1274))

#define GP_WB_WRITE_DMAS_DEST_ADDR_4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFFFF); \
          GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1274), (val)); \
        } while (0)


/* Size of either the source or destination buffer_4, depending on circular_buffer_select_4. Expressed as a multiple of the DMA memory access unit. buffer_size_4=n_units-1 */
#define GP_WB_READ_DMAS_BUFFER_SIZE_4() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1278))

#define GP_WB_WRITE_DMAS_BUFFER_SIZE_4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1278), (val)); \
        } while (0)


/* Threshold to be used for generating either an almost empty or almost full interrupt, depending on circular_buffer_select_4. If SRC_BUFFER, interrupt is triggered when there are only (threshold-1) units left in the src buffer_4. If DEST_BUFFER, interrupt is triggered when there are (threshold+1) units written in the dest buffer_4. */
#define GP_WB_READ_DMAS_BUFFER_ALMOST_COMPLETE_THRESHOLD_4() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x127a))

#define GP_WB_WRITE_DMAS_BUFFER_ALMOST_COMPLETE_THRESHOLD_4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x127a), (val)); \
        } while (0)


/* Pointer value to be used when triggering the different pointer sets (allows for atomic pointer set) */
#define GP_WB_READ_DMAS_BUFFER_PTR_VALUE_4() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x127c))

#define GP_WB_WRITE_DMAS_BUFFER_PTR_VALUE_4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x127c), (val)); \
        } while (0)


/* Pointer wrap value to be used when triggering the different pointer sets (allows for atomic pointer set) */
#define GP_WB_READ_DMAS_BUFFER_PTR_WRAP_VALUE_4() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x127e), 0)

#define GP_WB_WRITE_DMAS_BUFFER_PTR_WRAP_VALUE_4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x127e), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_DMAS_CONFIG_4() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1280))

#define GP_WB_WRITE_DMAS_CONFIG_4(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1280), (val))

/* Sets the size of the memory access unit. DMA supports 8/16/32-bit memory access. byte = 8 bits, half_word = 16 bits, word = 32 bits */
#define GP_WB_READ_DMAS_WORD_MODE_4() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1280)) & 0x03)

#define GP_WB_GET_DMAS_WORD_MODE_4_FROM_CONFIG_4(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_DMAS_WORD_MODE_4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1280), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_DMAS_WORD_MODE_4_TO_CONFIG_4(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x1FFC; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Selects the slave interface that will be the source for triggering the dma copy action */
#define GP_WB_READ_DMAS_CPY_TRIGGER_SRC_SELECT_4() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1280)) >> 2) & 0x1F)

#define GP_WB_GET_DMAS_CPY_TRIGGER_SRC_SELECT_4_FROM_CONFIG_4(tmp) \
        (((tmp) >> 2) & 0x1F)

#define GP_WB_WRITE_DMAS_CPY_TRIGGER_SRC_SELECT_4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1280), 0x7C, (val) << 2); \
        } while (0)

#define GP_WB_SET_DMAS_CPY_TRIGGER_SRC_SELECT_4_TO_CONFIG_4(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x1F83; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* regmap cpy trigger_4 overrule. The dma copy will be triggered as long as this bit is set to 1 */
#define GP_WB_READ_DMAS_CPY_TRIGGER_BY_REGMAP_4() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1280), 7)

#define GP_WB_GET_DMAS_CPY_TRIGGER_BY_REGMAP_4_FROM_CONFIG_4(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_DMAS_CPY_TRIGGER_BY_REGMAP_4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1280), 7, (val)); \
        } while (0)

#define GP_WB_SET_DMAS_CPY_TRIGGER_BY_REGMAP_4_TO_CONFIG_4(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* If set to error_mode then the buffer_complete interrupt indicates overflow/underrun conditions. Otherwise (status_mode) full/empty conditions are reported. */
#define GP_WB_READ_DMAS_BUFFER_COMPLETE_INTERRUPT_MODE_4() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1281), 0)

#define GP_WB_GET_DMAS_BUFFER_COMPLETE_INTERRUPT_MODE_4_FROM_CONFIG_4(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_DMAS_BUFFER_COMPLETE_INTERRUPT_MODE_4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1281), 0, (val)); \
        } while (0)

#define GP_WB_SET_DMAS_BUFFER_COMPLETE_INTERRUPT_MODE_4_TO_CONFIG_4(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1EFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* Minimum number of idle cycles between accesses to the same dma channel. Should be increased for slowly responding cpy_triggers. */
#define GP_WB_READ_DMAS_ACCESS_LATENCY_4() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1281)) >> 1) & 0x0F)

#define GP_WB_GET_DMAS_ACCESS_LATENCY_4_FROM_CONFIG_4(tmp) \
        (((tmp) >> 9) & 0x0F)

#define GP_WB_WRITE_DMAS_ACCESS_LATENCY_4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1281), 0x1E, (val) << 1); \
        } while (0)

#define GP_WB_SET_DMAS_ACCESS_LATENCY_4_TO_CONFIG_4(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x01FF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)


/* When enabled, the buffer_4's completeness is ignored when triggering a dma copy action */
#define GP_WB_READ_DMAS_CPY_TRIGGER_IGNORE_BUFFER_COMPLETE_4() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1282), 0)

#define GP_WB_WRITE_DMAS_CPY_TRIGGER_IGNORE_BUFFER_COMPLETE_4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1282), (val)); \
        } while (0)


/* Selects between source and destination as circular buffer locatio. */
#define GP_WB_READ_DMAS_CIRCULAR_BUFFER_SELECT_4() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1283), 0)

#define GP_WB_WRITE_DMAS_CIRCULAR_BUFFER_SELECT_4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1283), (val)); \
        } while (0)


#define GP_WB_WRITE_DMAS_BUFFER_PTR_CONTROL_4(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1284), (val))

/* Sets the internal circular buffer write pointer_4 by buffer_ptr_value / wrap value_4.  Provides atomic way for updating buffer_4 write pointer_4 */
#define GP_WB_DMAS_SET_WRITE_PTR_4() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1284), 0x01)

#define GP_WB_SET_DMAS_SET_WRITE_PTR_4_TO_BUFFER_PTR_CONTROL_4(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Sets the internal circular buffer read pointer_4 by buffer_ptr_value / wrap value_4.  Provides atomic way to initialize the buffer_4 read pointer_4 */
#define GP_WB_DMAS_SET_READ_PTR_4() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1284), 0x02)

#define GP_WB_SET_DMAS_SET_READ_PTR_4_TO_BUFFER_PTR_CONTROL_4(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Resets all buffer_4 pointers to 0 */
#define GP_WB_DMAS_RESET_POINTERS_4() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1284), 0x04)

#define GP_WB_SET_DMAS_RESET_POINTERS_4_TO_BUFFER_PTR_CONTROL_4(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* clears the buffer_complete interrupt_4 */
#define GP_WB_DMAS_CLR_BUFFER_COMPLETE_INTERRUPT_4() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1285), 0x01)


/* Actual read offset ptr_4 that is being used internally to access the circular buffer_4. Allows atomic read out (data is latched when internal_ptr_4_l is read). */
#define GP_WB_READ_DMAS_INTERNAL_PTR_4() \
        (GP_WB_READ_SER_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1286)) & 0x0FFF)

/* When circular_buffer_select_4 = src_buffer, toggle signal that is toggled each time the dma internal read_ptr_4 wraps around (for underrun detection). When circular_buffer_select_4 = dest_buffer, it is toggled each time the dma internal write_ptr_4 wraps around (for overflow detection). Allows atomic read out (data is latched when internal_ptr_4_l is read). */
#define GP_WB_READ_DMAS_INTERNAL_PTR_WRAP_4() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1287), 4)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_DMAS_STATUS_4() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1288))

/* Refers to the selected circular buffer. In buffer_complete_interrupt_mode_4 = error_mode overflow (for circular_buffer_select_4 = dest_buffer) or underrun (for circular_buffer_select_4 = src_buffer) errors are indicated. In buffer_complete_interrupt_mode_4 = status_mode it indicates full (for circular_buffer_select_4 = dest_buffer) or empty (for circular_buffer_select_4 = src_buffer) status. */
#define GP_WB_READ_DMAS_UNMASKED_BUFFER_COMPLETE_4_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1288), 0)

#define GP_WB_GET_DMAS_UNMASKED_BUFFER_COMPLETE_4_INTERRUPT_FROM_STATUS_4(tmp) \
        ((tmp) & 0x01)

/* Indicates that the almost complete threshold has been reached, actual level depends on the circular_buffer_select_4. See threshold setting for more info */
#define GP_WB_READ_DMAS_UNMASKED_BUFFER_ALMOST_COMPLETE_4_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1288), 1)

#define GP_WB_GET_DMAS_UNMASKED_BUFFER_ALMOST_COMPLETE_4_INTERRUPT_FROM_STATUS_4(tmp) \
        (((tmp) >> 1) & 0x01)


/* Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode) */
#define GP_WB_READ_DMAS_SRC_ADDR_5() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x128c))

#define GP_WB_WRITE_DMAS_SRC_ADDR_5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFFFF); \
          GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x128c), (val)); \
        } while (0)


/* Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode) */
#define GP_WB_READ_DMAS_DEST_ADDR_5() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1290))

#define GP_WB_WRITE_DMAS_DEST_ADDR_5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFFFF); \
          GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1290), (val)); \
        } while (0)


/* Size of either the source or destination buffer_5, depending on circular_buffer_select_5. Expressed as a multiple of the DMA memory access unit. buffer_size_5=n_units-1 */
#define GP_WB_READ_DMAS_BUFFER_SIZE_5() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1294))

#define GP_WB_WRITE_DMAS_BUFFER_SIZE_5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1294), (val)); \
        } while (0)


/* Threshold to be used for generating either an almost empty or almost full interrupt, depending on circular_buffer_select_5. If SRC_BUFFER, interrupt is triggered when there are only (threshold-1) units left in the src buffer_5. If DEST_BUFFER, interrupt is triggered when there are (threshold+1) units written in the dest buffer_5. */
#define GP_WB_READ_DMAS_BUFFER_ALMOST_COMPLETE_THRESHOLD_5() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1296))

#define GP_WB_WRITE_DMAS_BUFFER_ALMOST_COMPLETE_THRESHOLD_5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1296), (val)); \
        } while (0)


/* Pointer value to be used when triggering the different pointer sets (allows for atomic pointer set) */
#define GP_WB_READ_DMAS_BUFFER_PTR_VALUE_5() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1298))

#define GP_WB_WRITE_DMAS_BUFFER_PTR_VALUE_5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1298), (val)); \
        } while (0)


/* Pointer wrap value to be used when triggering the different pointer sets (allows for atomic pointer set) */
#define GP_WB_READ_DMAS_BUFFER_PTR_WRAP_VALUE_5() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x129a), 0)

#define GP_WB_WRITE_DMAS_BUFFER_PTR_WRAP_VALUE_5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x129a), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_DMAS_CONFIG_5() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x129c))

#define GP_WB_WRITE_DMAS_CONFIG_5(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x129c), (val))

/* Sets the size of the memory access unit. DMA supports 8/16/32-bit memory access. byte = 8 bits, half_word = 16 bits, word = 32 bits */
#define GP_WB_READ_DMAS_WORD_MODE_5() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x129c)) & 0x03)

#define GP_WB_GET_DMAS_WORD_MODE_5_FROM_CONFIG_5(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_DMAS_WORD_MODE_5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x129c), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_DMAS_WORD_MODE_5_TO_CONFIG_5(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x1FFC; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Selects the slave interface that will be the source for triggering the dma copy action */
#define GP_WB_READ_DMAS_CPY_TRIGGER_SRC_SELECT_5() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x129c)) >> 2) & 0x1F)

#define GP_WB_GET_DMAS_CPY_TRIGGER_SRC_SELECT_5_FROM_CONFIG_5(tmp) \
        (((tmp) >> 2) & 0x1F)

#define GP_WB_WRITE_DMAS_CPY_TRIGGER_SRC_SELECT_5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x129c), 0x7C, (val) << 2); \
        } while (0)

#define GP_WB_SET_DMAS_CPY_TRIGGER_SRC_SELECT_5_TO_CONFIG_5(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x1F83; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* regmap cpy trigger_5 overrule. The dma copy will be triggered as long as this bit is set to 1 */
#define GP_WB_READ_DMAS_CPY_TRIGGER_BY_REGMAP_5() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x129c), 7)

#define GP_WB_GET_DMAS_CPY_TRIGGER_BY_REGMAP_5_FROM_CONFIG_5(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_DMAS_CPY_TRIGGER_BY_REGMAP_5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x129c), 7, (val)); \
        } while (0)

#define GP_WB_SET_DMAS_CPY_TRIGGER_BY_REGMAP_5_TO_CONFIG_5(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* If set to error_mode then the buffer_complete interrupt indicates overflow/underrun conditions. Otherwise (status_mode) full/empty conditions are reported. */
#define GP_WB_READ_DMAS_BUFFER_COMPLETE_INTERRUPT_MODE_5() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x129d), 0)

#define GP_WB_GET_DMAS_BUFFER_COMPLETE_INTERRUPT_MODE_5_FROM_CONFIG_5(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_DMAS_BUFFER_COMPLETE_INTERRUPT_MODE_5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x129d), 0, (val)); \
        } while (0)

#define GP_WB_SET_DMAS_BUFFER_COMPLETE_INTERRUPT_MODE_5_TO_CONFIG_5(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1EFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* Minimum number of idle cycles between accesses to the same dma channel. Should be increased for slowly responding cpy_triggers. */
#define GP_WB_READ_DMAS_ACCESS_LATENCY_5() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x129d)) >> 1) & 0x0F)

#define GP_WB_GET_DMAS_ACCESS_LATENCY_5_FROM_CONFIG_5(tmp) \
        (((tmp) >> 9) & 0x0F)

#define GP_WB_WRITE_DMAS_ACCESS_LATENCY_5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x129d), 0x1E, (val) << 1); \
        } while (0)

#define GP_WB_SET_DMAS_ACCESS_LATENCY_5_TO_CONFIG_5(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x01FF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)


/* When enabled, the buffer_5's completeness is ignored when triggering a dma copy action */
#define GP_WB_READ_DMAS_CPY_TRIGGER_IGNORE_BUFFER_COMPLETE_5() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x129e), 0)

#define GP_WB_WRITE_DMAS_CPY_TRIGGER_IGNORE_BUFFER_COMPLETE_5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x129e), (val)); \
        } while (0)


/* Selects between source and destination as circular buffer locatio. */
#define GP_WB_READ_DMAS_CIRCULAR_BUFFER_SELECT_5() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x129f), 0)

#define GP_WB_WRITE_DMAS_CIRCULAR_BUFFER_SELECT_5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x129f), (val)); \
        } while (0)


#define GP_WB_WRITE_DMAS_BUFFER_PTR_CONTROL_5(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12a0), (val))

/* Sets the internal circular buffer write pointer_5 by buffer_ptr_value / wrap value_5.  Provides atomic way for updating buffer_5 write pointer_5 */
#define GP_WB_DMAS_SET_WRITE_PTR_5() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12a0), 0x01)

#define GP_WB_SET_DMAS_SET_WRITE_PTR_5_TO_BUFFER_PTR_CONTROL_5(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Sets the internal circular buffer read pointer_5 by buffer_ptr_value / wrap value_5.  Provides atomic way to initialize the buffer_5 read pointer_5 */
#define GP_WB_DMAS_SET_READ_PTR_5() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12a0), 0x02)

#define GP_WB_SET_DMAS_SET_READ_PTR_5_TO_BUFFER_PTR_CONTROL_5(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Resets all buffer_5 pointers to 0 */
#define GP_WB_DMAS_RESET_POINTERS_5() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12a0), 0x04)

#define GP_WB_SET_DMAS_RESET_POINTERS_5_TO_BUFFER_PTR_CONTROL_5(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* clears the buffer_complete interrupt_5 */
#define GP_WB_DMAS_CLR_BUFFER_COMPLETE_INTERRUPT_5() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12a1), 0x01)


/* Actual read offset ptr_5 that is being used internally to access the circular buffer_5. Allows atomic read out (data is latched when internal_ptr_5_l is read). */
#define GP_WB_READ_DMAS_INTERNAL_PTR_5() \
        (GP_WB_READ_SER_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12a2)) & 0x0FFF)

/* When circular_buffer_select_5 = src_buffer, toggle signal that is toggled each time the dma internal read_ptr_5 wraps around (for underrun detection). When circular_buffer_select_5 = dest_buffer, it is toggled each time the dma internal write_ptr_5 wraps around (for overflow detection). Allows atomic read out (data is latched when internal_ptr_5_l is read). */
#define GP_WB_READ_DMAS_INTERNAL_PTR_WRAP_5() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12a3), 4)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_DMAS_STATUS_5() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12a4))

/* Refers to the selected circular buffer. In buffer_complete_interrupt_mode_5 = error_mode overflow (for circular_buffer_select_5 = dest_buffer) or underrun (for circular_buffer_select_5 = src_buffer) errors are indicated. In buffer_complete_interrupt_mode_5 = status_mode it indicates full (for circular_buffer_select_5 = dest_buffer) or empty (for circular_buffer_select_5 = src_buffer) status. */
#define GP_WB_READ_DMAS_UNMASKED_BUFFER_COMPLETE_5_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12a4), 0)

#define GP_WB_GET_DMAS_UNMASKED_BUFFER_COMPLETE_5_INTERRUPT_FROM_STATUS_5(tmp) \
        ((tmp) & 0x01)

/* Indicates that the almost complete threshold has been reached, actual level depends on the circular_buffer_select_5. See threshold setting for more info */
#define GP_WB_READ_DMAS_UNMASKED_BUFFER_ALMOST_COMPLETE_5_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12a4), 1)

#define GP_WB_GET_DMAS_UNMASKED_BUFFER_ALMOST_COMPLETE_5_INTERRUPT_FROM_STATUS_5(tmp) \
        (((tmp) >> 1) & 0x01)


/* Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode) */
#define GP_WB_READ_DMAS_SRC_ADDR_6() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12a8))

#define GP_WB_WRITE_DMAS_SRC_ADDR_6(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFFFF); \
          GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12a8), (val)); \
        } while (0)


/* Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode) */
#define GP_WB_READ_DMAS_DEST_ADDR_6() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12ac))

#define GP_WB_WRITE_DMAS_DEST_ADDR_6(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFFFF); \
          GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12ac), (val)); \
        } while (0)


/* Size of either the source or destination buffer_6, depending on circular_buffer_select_6. Expressed as a multiple of the DMA memory access unit. buffer_size_6=n_units-1 */
#define GP_WB_READ_DMAS_BUFFER_SIZE_6() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12b0))

#define GP_WB_WRITE_DMAS_BUFFER_SIZE_6(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12b0), (val)); \
        } while (0)


/* Threshold to be used for generating either an almost empty or almost full interrupt, depending on circular_buffer_select_6. If SRC_BUFFER, interrupt is triggered when there are only (threshold-1) units left in the src buffer_6. If DEST_BUFFER, interrupt is triggered when there are (threshold+1) units written in the dest buffer_6. */
#define GP_WB_READ_DMAS_BUFFER_ALMOST_COMPLETE_THRESHOLD_6() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12b2))

#define GP_WB_WRITE_DMAS_BUFFER_ALMOST_COMPLETE_THRESHOLD_6(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12b2), (val)); \
        } while (0)


/* Pointer value to be used when triggering the different pointer sets (allows for atomic pointer set) */
#define GP_WB_READ_DMAS_BUFFER_PTR_VALUE_6() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12b4))

#define GP_WB_WRITE_DMAS_BUFFER_PTR_VALUE_6(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12b4), (val)); \
        } while (0)


/* Pointer wrap value to be used when triggering the different pointer sets (allows for atomic pointer set) */
#define GP_WB_READ_DMAS_BUFFER_PTR_WRAP_VALUE_6() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12b6), 0)

#define GP_WB_WRITE_DMAS_BUFFER_PTR_WRAP_VALUE_6(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12b6), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_DMAS_CONFIG_6() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12b8))

#define GP_WB_WRITE_DMAS_CONFIG_6(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12b8), (val))

/* Sets the size of the memory access unit. DMA supports 8/16/32-bit memory access. byte = 8 bits, half_word = 16 bits, word = 32 bits */
#define GP_WB_READ_DMAS_WORD_MODE_6() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12b8)) & 0x03)

#define GP_WB_GET_DMAS_WORD_MODE_6_FROM_CONFIG_6(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_DMAS_WORD_MODE_6(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12b8), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_DMAS_WORD_MODE_6_TO_CONFIG_6(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x1FFC; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Selects the slave interface that will be the source for triggering the dma copy action */
#define GP_WB_READ_DMAS_CPY_TRIGGER_SRC_SELECT_6() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12b8)) >> 2) & 0x1F)

#define GP_WB_GET_DMAS_CPY_TRIGGER_SRC_SELECT_6_FROM_CONFIG_6(tmp) \
        (((tmp) >> 2) & 0x1F)

#define GP_WB_WRITE_DMAS_CPY_TRIGGER_SRC_SELECT_6(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12b8), 0x7C, (val) << 2); \
        } while (0)

#define GP_WB_SET_DMAS_CPY_TRIGGER_SRC_SELECT_6_TO_CONFIG_6(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x1F83; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* regmap cpy trigger_6 overrule. The dma copy will be triggered as long as this bit is set to 1 */
#define GP_WB_READ_DMAS_CPY_TRIGGER_BY_REGMAP_6() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12b8), 7)

#define GP_WB_GET_DMAS_CPY_TRIGGER_BY_REGMAP_6_FROM_CONFIG_6(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_DMAS_CPY_TRIGGER_BY_REGMAP_6(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12b8), 7, (val)); \
        } while (0)

#define GP_WB_SET_DMAS_CPY_TRIGGER_BY_REGMAP_6_TO_CONFIG_6(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* If set to error_mode then the buffer_complete interrupt indicates overflow/underrun conditions. Otherwise (status_mode) full/empty conditions are reported. */
#define GP_WB_READ_DMAS_BUFFER_COMPLETE_INTERRUPT_MODE_6() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12b9), 0)

#define GP_WB_GET_DMAS_BUFFER_COMPLETE_INTERRUPT_MODE_6_FROM_CONFIG_6(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_DMAS_BUFFER_COMPLETE_INTERRUPT_MODE_6(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12b9), 0, (val)); \
        } while (0)

#define GP_WB_SET_DMAS_BUFFER_COMPLETE_INTERRUPT_MODE_6_TO_CONFIG_6(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1EFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* Minimum number of idle cycles between accesses to the same dma channel. Should be increased for slowly responding cpy_triggers. */
#define GP_WB_READ_DMAS_ACCESS_LATENCY_6() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12b9)) >> 1) & 0x0F)

#define GP_WB_GET_DMAS_ACCESS_LATENCY_6_FROM_CONFIG_6(tmp) \
        (((tmp) >> 9) & 0x0F)

#define GP_WB_WRITE_DMAS_ACCESS_LATENCY_6(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12b9), 0x1E, (val) << 1); \
        } while (0)

#define GP_WB_SET_DMAS_ACCESS_LATENCY_6_TO_CONFIG_6(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x01FF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)


/* When enabled, the buffer_6's completeness is ignored when triggering a dma copy action */
#define GP_WB_READ_DMAS_CPY_TRIGGER_IGNORE_BUFFER_COMPLETE_6() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12ba), 0)

#define GP_WB_WRITE_DMAS_CPY_TRIGGER_IGNORE_BUFFER_COMPLETE_6(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12ba), (val)); \
        } while (0)


/* Selects between source and destination as circular buffer locatio. */
#define GP_WB_READ_DMAS_CIRCULAR_BUFFER_SELECT_6() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12bb), 0)

#define GP_WB_WRITE_DMAS_CIRCULAR_BUFFER_SELECT_6(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12bb), (val)); \
        } while (0)


#define GP_WB_WRITE_DMAS_BUFFER_PTR_CONTROL_6(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12bc), (val))

/* Sets the internal circular buffer write pointer_6 by buffer_ptr_value / wrap value_6.  Provides atomic way for updating buffer_6 write pointer_6 */
#define GP_WB_DMAS_SET_WRITE_PTR_6() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12bc), 0x01)

#define GP_WB_SET_DMAS_SET_WRITE_PTR_6_TO_BUFFER_PTR_CONTROL_6(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Sets the internal circular buffer read pointer_6 by buffer_ptr_value / wrap value_6.  Provides atomic way to initialize the buffer_6 read pointer_6 */
#define GP_WB_DMAS_SET_READ_PTR_6() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12bc), 0x02)

#define GP_WB_SET_DMAS_SET_READ_PTR_6_TO_BUFFER_PTR_CONTROL_6(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Resets all buffer_6 pointers to 0 */
#define GP_WB_DMAS_RESET_POINTERS_6() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12bc), 0x04)

#define GP_WB_SET_DMAS_RESET_POINTERS_6_TO_BUFFER_PTR_CONTROL_6(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* clears the buffer_complete interrupt_6 */
#define GP_WB_DMAS_CLR_BUFFER_COMPLETE_INTERRUPT_6() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12bd), 0x01)


/* Actual read offset ptr_6 that is being used internally to access the circular buffer_6. Allows atomic read out (data is latched when internal_ptr_6_l is read). */
#define GP_WB_READ_DMAS_INTERNAL_PTR_6() \
        (GP_WB_READ_SER_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12be)) & 0x0FFF)

/* When circular_buffer_select_6 = src_buffer, toggle signal that is toggled each time the dma internal read_ptr_6 wraps around (for underrun detection). When circular_buffer_select_6 = dest_buffer, it is toggled each time the dma internal write_ptr_6 wraps around (for overflow detection). Allows atomic read out (data is latched when internal_ptr_6_l is read). */
#define GP_WB_READ_DMAS_INTERNAL_PTR_WRAP_6() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12bf), 4)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_DMAS_STATUS_6() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12c0))

/* Refers to the selected circular buffer. In buffer_complete_interrupt_mode_6 = error_mode overflow (for circular_buffer_select_6 = dest_buffer) or underrun (for circular_buffer_select_6 = src_buffer) errors are indicated. In buffer_complete_interrupt_mode_6 = status_mode it indicates full (for circular_buffer_select_6 = dest_buffer) or empty (for circular_buffer_select_6 = src_buffer) status. */
#define GP_WB_READ_DMAS_UNMASKED_BUFFER_COMPLETE_6_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12c0), 0)

#define GP_WB_GET_DMAS_UNMASKED_BUFFER_COMPLETE_6_INTERRUPT_FROM_STATUS_6(tmp) \
        ((tmp) & 0x01)

/* Indicates that the almost complete threshold has been reached, actual level depends on the circular_buffer_select_6. See threshold setting for more info */
#define GP_WB_READ_DMAS_UNMASKED_BUFFER_ALMOST_COMPLETE_6_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12c0), 1)

#define GP_WB_GET_DMAS_UNMASKED_BUFFER_ALMOST_COMPLETE_6_INTERRUPT_FROM_STATUS_6(tmp) \
        (((tmp) >> 1) & 0x01)


/* Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode) */
#define GP_WB_READ_DMAS_SRC_ADDR_7() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12c4))

#define GP_WB_WRITE_DMAS_SRC_ADDR_7(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFFFF); \
          GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12c4), (val)); \
        } while (0)


/* Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode) */
#define GP_WB_READ_DMAS_DEST_ADDR_7() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12c8))

#define GP_WB_WRITE_DMAS_DEST_ADDR_7(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFFFF); \
          GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12c8), (val)); \
        } while (0)


/* Size of either the source or destination buffer_7, depending on circular_buffer_select_7. Expressed as a multiple of the DMA memory access unit. buffer_size_7=n_units-1 */
#define GP_WB_READ_DMAS_BUFFER_SIZE_7() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12cc))

#define GP_WB_WRITE_DMAS_BUFFER_SIZE_7(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12cc), (val)); \
        } while (0)


/* Threshold to be used for generating either an almost empty or almost full interrupt, depending on circular_buffer_select_7. If SRC_BUFFER, interrupt is triggered when there are only (threshold-1) units left in the src buffer_7. If DEST_BUFFER, interrupt is triggered when there are (threshold+1) units written in the dest buffer_7. */
#define GP_WB_READ_DMAS_BUFFER_ALMOST_COMPLETE_THRESHOLD_7() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12ce))

#define GP_WB_WRITE_DMAS_BUFFER_ALMOST_COMPLETE_THRESHOLD_7(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12ce), (val)); \
        } while (0)


/* Pointer value to be used when triggering the different pointer sets (allows for atomic pointer set) */
#define GP_WB_READ_DMAS_BUFFER_PTR_VALUE_7() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12d0))

#define GP_WB_WRITE_DMAS_BUFFER_PTR_VALUE_7(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12d0), (val)); \
        } while (0)


/* Pointer wrap value to be used when triggering the different pointer sets (allows for atomic pointer set) */
#define GP_WB_READ_DMAS_BUFFER_PTR_WRAP_VALUE_7() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12d2), 0)

#define GP_WB_WRITE_DMAS_BUFFER_PTR_WRAP_VALUE_7(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12d2), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_DMAS_CONFIG_7() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12d4))

#define GP_WB_WRITE_DMAS_CONFIG_7(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12d4), (val))

/* Sets the size of the memory access unit. DMA supports 8/16/32-bit memory access. byte = 8 bits, half_word = 16 bits, word = 32 bits */
#define GP_WB_READ_DMAS_WORD_MODE_7() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12d4)) & 0x03)

#define GP_WB_GET_DMAS_WORD_MODE_7_FROM_CONFIG_7(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_DMAS_WORD_MODE_7(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12d4), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_DMAS_WORD_MODE_7_TO_CONFIG_7(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x1FFC; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Selects the slave interface that will be the source for triggering the dma copy action */
#define GP_WB_READ_DMAS_CPY_TRIGGER_SRC_SELECT_7() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12d4)) >> 2) & 0x1F)

#define GP_WB_GET_DMAS_CPY_TRIGGER_SRC_SELECT_7_FROM_CONFIG_7(tmp) \
        (((tmp) >> 2) & 0x1F)

#define GP_WB_WRITE_DMAS_CPY_TRIGGER_SRC_SELECT_7(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12d4), 0x7C, (val) << 2); \
        } while (0)

#define GP_WB_SET_DMAS_CPY_TRIGGER_SRC_SELECT_7_TO_CONFIG_7(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x1F83; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* regmap cpy trigger_7 overrule. The dma copy will be triggered as long as this bit is set to 1 */
#define GP_WB_READ_DMAS_CPY_TRIGGER_BY_REGMAP_7() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12d4), 7)

#define GP_WB_GET_DMAS_CPY_TRIGGER_BY_REGMAP_7_FROM_CONFIG_7(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_DMAS_CPY_TRIGGER_BY_REGMAP_7(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12d4), 7, (val)); \
        } while (0)

#define GP_WB_SET_DMAS_CPY_TRIGGER_BY_REGMAP_7_TO_CONFIG_7(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* If set to error_mode then the buffer_complete interrupt indicates overflow/underrun conditions. Otherwise (status_mode) full/empty conditions are reported. */
#define GP_WB_READ_DMAS_BUFFER_COMPLETE_INTERRUPT_MODE_7() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12d5), 0)

#define GP_WB_GET_DMAS_BUFFER_COMPLETE_INTERRUPT_MODE_7_FROM_CONFIG_7(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_DMAS_BUFFER_COMPLETE_INTERRUPT_MODE_7(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12d5), 0, (val)); \
        } while (0)

#define GP_WB_SET_DMAS_BUFFER_COMPLETE_INTERRUPT_MODE_7_TO_CONFIG_7(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1EFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* Minimum number of idle cycles between accesses to the same dma channel. Should be increased for slowly responding cpy_triggers. */
#define GP_WB_READ_DMAS_ACCESS_LATENCY_7() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12d5)) >> 1) & 0x0F)

#define GP_WB_GET_DMAS_ACCESS_LATENCY_7_FROM_CONFIG_7(tmp) \
        (((tmp) >> 9) & 0x0F)

#define GP_WB_WRITE_DMAS_ACCESS_LATENCY_7(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12d5), 0x1E, (val) << 1); \
        } while (0)

#define GP_WB_SET_DMAS_ACCESS_LATENCY_7_TO_CONFIG_7(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x01FF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)


/* When enabled, the buffer_7's completeness is ignored when triggering a dma copy action */
#define GP_WB_READ_DMAS_CPY_TRIGGER_IGNORE_BUFFER_COMPLETE_7() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12d6), 0)

#define GP_WB_WRITE_DMAS_CPY_TRIGGER_IGNORE_BUFFER_COMPLETE_7(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12d6), (val)); \
        } while (0)


/* Selects between source and destination as circular buffer locatio. */
#define GP_WB_READ_DMAS_CIRCULAR_BUFFER_SELECT_7() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12d7), 0)

#define GP_WB_WRITE_DMAS_CIRCULAR_BUFFER_SELECT_7(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12d7), (val)); \
        } while (0)


#define GP_WB_WRITE_DMAS_BUFFER_PTR_CONTROL_7(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12d8), (val))

/* Sets the internal circular buffer write pointer_7 by buffer_ptr_value / wrap value_7.  Provides atomic way for updating buffer_7 write pointer_7 */
#define GP_WB_DMAS_SET_WRITE_PTR_7() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12d8), 0x01)

#define GP_WB_SET_DMAS_SET_WRITE_PTR_7_TO_BUFFER_PTR_CONTROL_7(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Sets the internal circular buffer read pointer_7 by buffer_ptr_value / wrap value_7.  Provides atomic way to initialize the buffer_7 read pointer_7 */
#define GP_WB_DMAS_SET_READ_PTR_7() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12d8), 0x02)

#define GP_WB_SET_DMAS_SET_READ_PTR_7_TO_BUFFER_PTR_CONTROL_7(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Resets all buffer_7 pointers to 0 */
#define GP_WB_DMAS_RESET_POINTERS_7() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12d8), 0x04)

#define GP_WB_SET_DMAS_RESET_POINTERS_7_TO_BUFFER_PTR_CONTROL_7(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* clears the buffer_complete interrupt_7 */
#define GP_WB_DMAS_CLR_BUFFER_COMPLETE_INTERRUPT_7() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12d9), 0x01)


/* Actual read offset ptr_7 that is being used internally to access the circular buffer_7. Allows atomic read out (data is latched when internal_ptr_7_l is read). */
#define GP_WB_READ_DMAS_INTERNAL_PTR_7() \
        (GP_WB_READ_SER_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12da)) & 0x0FFF)

/* When circular_buffer_select_7 = src_buffer, toggle signal that is toggled each time the dma internal read_ptr_7 wraps around (for underrun detection). When circular_buffer_select_7 = dest_buffer, it is toggled each time the dma internal write_ptr_7 wraps around (for overflow detection). Allows atomic read out (data is latched when internal_ptr_7_l is read). */
#define GP_WB_READ_DMAS_INTERNAL_PTR_WRAP_7() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12db), 4)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_DMAS_STATUS_7() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12dc))

/* Refers to the selected circular buffer. In buffer_complete_interrupt_mode_7 = error_mode overflow (for circular_buffer_select_7 = dest_buffer) or underrun (for circular_buffer_select_7 = src_buffer) errors are indicated. In buffer_complete_interrupt_mode_7 = status_mode it indicates full (for circular_buffer_select_7 = dest_buffer) or empty (for circular_buffer_select_7 = src_buffer) status. */
#define GP_WB_READ_DMAS_UNMASKED_BUFFER_COMPLETE_7_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12dc), 0)

#define GP_WB_GET_DMAS_UNMASKED_BUFFER_COMPLETE_7_INTERRUPT_FROM_STATUS_7(tmp) \
        ((tmp) & 0x01)

/* Indicates that the almost complete threshold has been reached, actual level depends on the circular_buffer_select_7. See threshold setting for more info */
#define GP_WB_READ_DMAS_UNMASKED_BUFFER_ALMOST_COMPLETE_7_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12dc), 1)

#define GP_WB_GET_DMAS_UNMASKED_BUFFER_ALMOST_COMPLETE_7_INTERRUPT_FROM_STATUS_7(tmp) \
        (((tmp) >> 1) & 0x01)


/* Enables the clock to the dma block when '1' */
#define GP_WB_READ_DMAS_CLK_ENA() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12dd), 0)

#define GP_WB_WRITE_DMAS_CLK_ENA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12dd), 0, (val)); \
        } while (0)

/* Minimum number of idle cycles between accesses to different dma channels. Should be used to reduce the dma memory bandwidth quota. */
#define GP_WB_READ_DMAS_CHANNEL_SWITCH_LATENCY() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12dd)) >> 1) & 0x0F)

#define GP_WB_WRITE_DMAS_CHANNEL_SWITCH_LATENCY(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12dd), 0x1E, (val) << 1); \
        } while (0)


/* clears the copy err interrupt. This is really needed for the dma to continue when an err-or occurred */
#define GP_WB_DMAS_CLR_CPY_ERR_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12de), 0x01)


/* Indicates that a memory acces failed during dma operation. This STOPS the dma operation. Dma can only be unlocked by clearing this interrupt */
#define GP_WB_READ_DMAS_UNMASKED_CPY_ERR_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x12df), 0)

/***************************
 * layout: i2s_m
 ***************************/

/* TX data FIFO. Data to be transmitted over SDO. Make sure the first databyte is already available in tx_data before enabling the interface.  Otherwise, the data will get out of sync with the WS. */
#define GP_WB_WRITE_I2S_M_TX_DATA(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1300), (val)); \
        } while (0)


/* RX data FIFO. Data received over SDI. Reading this will clear the data from the RX data FIFO. */
#define GP_WB_READ_I2S_M_RX_DATA() \
        GP_WB_READ_SER_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1301))


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_I2S_M_CONFIG_0() \
        GP_WB_READ_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1304))

#define GP_WB_WRITE_I2S_M_CONFIG_0(val) \
      GP_WB_WRITE_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1304), (val))

/* Starts the interface. Make sure the first databyte is already available in tx_data before enabling the interface. */
#define GP_WB_READ_I2S_M_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1304), 0)

#define GP_WB_GET_I2S_M_ENABLE_FROM_CONFIG_0(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_I2S_M_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1304), 0, (val)); \
        } while (0)

#define GP_WB_SET_I2S_M_ENABLE_TO_CONFIG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3FFFFF7E; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Selects the processing clock of the interface. */
#define GP_WB_READ_I2S_M_SELECT_CLK() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1304)) >> 1) & 0x03)

#define GP_WB_GET_I2S_M_SELECT_CLK_FROM_CONFIG_0(tmp) \
        (((tmp) >> 1) & 0x03)

#define GP_WB_WRITE_I2S_M_SELECT_CLK(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1304), 0x06, (val) << 1); \
        } while (0)

#define GP_WB_SET_I2S_M_SELECT_CLK_TO_CONFIG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3FFFFF79; \
          (tmp) |= (((UInt32)(val)) << 1); \
        } while (0)

/* Enables the slave mode. When false, the interface is in master mode. */
#define GP_WB_READ_I2S_M_SLAVE_MODE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1304), 3)

#define GP_WB_GET_I2S_M_SLAVE_MODE_FROM_CONFIG_0(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_I2S_M_SLAVE_MODE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1304), 3, (val)); \
        } while (0)

#define GP_WB_SET_I2S_M_SLAVE_MODE_TO_CONFIG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3FFFFF77; \
          (tmp) |= (((UInt32)(val)) << 3); \
        } while (0)

/* Offset in SCK cycles between the WS toggle and the first data bit. For real I2S mode, this should be 1. */
#define GP_WB_READ_I2S_M_WS_OFFSET() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1304)) >> 4) & 0x07)

#define GP_WB_GET_I2S_M_WS_OFFSET_FROM_CONFIG_0(tmp) \
        (((tmp) >> 4) & 0x07)

#define GP_WB_WRITE_I2S_M_WS_OFFSET(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1304), 0x70, (val) << 4); \
        } while (0)

#define GP_WB_SET_I2S_M_WS_OFFSET_TO_CONFIG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x3FFFFF0F; \
          (tmp) |= (((UInt32)(val)) << 4); \
        } while (0)

/* SCK bit clock frequency prescaler: processing_clk_freq / 2*(sck_freq + 1) */
#define GP_WB_READ_I2S_M_SCK_FREQ() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1305))

#define GP_WB_GET_I2S_M_SCK_FREQ_FROM_CONFIG_0(tmp) \
        (((tmp) >> 8) & 0xFF)

#define GP_WB_WRITE_I2S_M_SCK_FREQ(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1305), (val)); \
        } while (0)

#define GP_WB_SET_I2S_M_SCK_FREQ_TO_CONFIG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x3FFF007F; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* Length in SCK cycles between two consecutive WS toggles. */
#define GP_WB_READ_I2S_M_WORD_LEN() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1306))

#define GP_WB_GET_I2S_M_WORD_LEN_FROM_CONFIG_0(tmp) \
        (((tmp) >> 16) & 0xFF)

#define GP_WB_WRITE_I2S_M_WORD_LEN(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1306), (val)); \
        } while (0)

#define GP_WB_SET_I2S_M_WORD_LEN_TO_CONFIG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x3F00FF7F; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* Number of data bytes (8-bit) to be transmitted on SDO for the left channel (WS=0). When word_len > 8*tx_bytes_left, SDO will be padded with 0. When word_len < 8*tx_bytes_left, the remaining bits (lsbs) will be ignored. If tx_bytes_left = 0, SDO will be 0 for this channel. */
#define GP_WB_READ_I2S_M_TX_BYTES_LEFT() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1307)) & 0x07)

#define GP_WB_GET_I2S_M_TX_BYTES_LEFT_FROM_CONFIG_0(tmp) \
        (((tmp) >> 24) & 0x07)

#define GP_WB_WRITE_I2S_M_TX_BYTES_LEFT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1307), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_I2S_M_TX_BYTES_LEFT_TO_CONFIG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x38FFFF7F; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)

/* Number of data bytes to be transmitted on SDO for the right channel (WS=1). Same remarks as for tx_bytes_left. */
#define GP_WB_READ_I2S_M_TX_BYTES_RIGHT() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1307)) >> 3) & 0x07)

#define GP_WB_GET_I2S_M_TX_BYTES_RIGHT_FROM_CONFIG_0(tmp) \
        (((tmp) >> 27) & 0x07)

#define GP_WB_WRITE_I2S_M_TX_BYTES_RIGHT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1307), 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_I2S_M_TX_BYTES_RIGHT_TO_CONFIG_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x07FFFF7F; \
          (tmp) |= (((UInt32)(val)) << 27); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_I2S_M_CONFIG_1() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1308))

#define GP_WB_WRITE_I2S_M_CONFIG_1(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1308), (val))

/* Number of data bytes (8-bit) to be received on SDI for the left channel (WS=0). When word_len > 8*tx_bytes_left, the remaining bits on SDI will be ignored. When word_len < 8*tx_bytes_left, the remaining bits (lsbs) will be zero. If tx_bytes_left = 0, no data will be received for this channel. */
#define GP_WB_READ_I2S_M_RX_BYTES_LEFT() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1308)) & 0x07)

#define GP_WB_GET_I2S_M_RX_BYTES_LEFT_FROM_CONFIG_1(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_I2S_M_RX_BYTES_LEFT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1308), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_I2S_M_RX_BYTES_LEFT_TO_CONFIG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x78; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Number of data bytes (8-bit) to be received on SDI for the right channel (WS=1). Same remarks as for rx_bytes_left. */
#define GP_WB_READ_I2S_M_RX_BYTES_RIGHT() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1308)) >> 3) & 0x07)

#define GP_WB_GET_I2S_M_RX_BYTES_RIGHT_FROM_CONFIG_1(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_I2S_M_RX_BYTES_RIGHT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1308), 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_I2S_M_RX_BYTES_RIGHT_TO_CONFIG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x47; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Enables the SCK clock prescaler. Only applicable when select_clk /= MAIN_CLK. The prescaler is always enabled when select_clk = MAIN_CLK. */
#define GP_WB_READ_I2S_M_ENABLE_PRESCALER() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1308), 6)

#define GP_WB_GET_I2S_M_ENABLE_PRESCALER_FROM_CONFIG_1(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_I2S_M_ENABLE_PRESCALER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1308), 6, (val)); \
        } while (0)

#define GP_WB_SET_I2S_M_ENABLE_PRESCALER_TO_CONFIG_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_I2S_M_UNMASKED_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1309))

/* Status and unmasked interrupt flag for TX buffer not full. The interrupt is cleared implicitly when writing new TX data fills the buffer. */
#define GP_WB_READ_I2S_M_UNMASKED_TX_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1309), 0)

#define GP_WB_GET_I2S_M_UNMASKED_TX_NOT_FULL_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* Status and unmasked interrupt flag for RX buffer not empty. The interrupt is cleared implicitly when reading the last RX data from the buffer. */
#define GP_WB_READ_I2S_M_UNMASKED_RX_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1309), 1)

#define GP_WB_GET_I2S_M_UNMASKED_RX_NOT_EMPTY_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/***************************
 * layout: asp
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ASP_CONFIG() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1320))

#define GP_WB_WRITE_ASP_CONFIG(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1320), (val))

/* Factor-1 with which the incoming pdm signal should be downsampled (actual decimation factor = value+1) */
#define GP_WB_READ_ASP_DECIMATION_FACTOR() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1320)) & 0x7F)

#define GP_WB_GET_ASP_DECIMATION_FACTOR_FROM_CONFIG(tmp) \
        ((tmp) & 0x7F)

#define GP_WB_WRITE_ASP_DECIMATION_FACTOR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1320), 0x7F, (val)); \
        } while (0)

#define GP_WB_SET_ASP_DECIMATION_FACTOR_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          (tmp) &= 0x7F80; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Don't filter the streams but convert them into a 16-bit word stream that can be read from the data register (lsb is the bit first received) */
#define GP_WB_READ_ASP_BYPASS_CIC() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1320), 7)

#define GP_WB_GET_ASP_BYPASS_CIC_FROM_CONFIG(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ASP_BYPASS_CIC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1320), 7, (val)); \
        } while (0)

#define GP_WB_SET_ASP_BYPASS_CIC_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* Number of 16 MHz periods after a rising/falling edge before the data is stable (nr_periods = value + 1) */
#define GP_WB_READ_ASP_DATA_SETUP_TIME() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1321)) & 0x03)

#define GP_WB_GET_ASP_DATA_SETUP_TIME_FROM_CONFIG(tmp) \
        (((tmp) >> 8) & 0x03)

#define GP_WB_WRITE_ASP_DATA_SETUP_TIME(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1321), 0x03, (val)); \
        } while (0)

#define GP_WB_SET_ASP_DATA_SETUP_TIME_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x7CFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* Enable capturing data on specified mode on the dut */
#define GP_WB_READ_ASP_SAMPLE_DATASTREAM_0_SETTING() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1321)) >> 2) & 0x03)

#define GP_WB_GET_ASP_SAMPLE_DATASTREAM_0_SETTING_FROM_CONFIG(tmp) \
        (((tmp) >> 10) & 0x03)

#define GP_WB_WRITE_ASP_SAMPLE_DATASTREAM_0_SETTING(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1321), 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_ASP_SAMPLE_DATASTREAM_0_SETTING_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x73FF; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)

/* Enable capturing data on specified mode on the dut */
#define GP_WB_READ_ASP_SAMPLE_DATASTREAM_1_SETTING() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1321)) >> 4) & 0x03)

#define GP_WB_GET_ASP_SAMPLE_DATASTREAM_1_SETTING_FROM_CONFIG(tmp) \
        (((tmp) >> 12) & 0x03)

#define GP_WB_WRITE_ASP_SAMPLE_DATASTREAM_1_SETTING(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1321), 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_ASP_SAMPLE_DATASTREAM_1_SETTING_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x4FFF; \
          (tmp) |= (((UInt16)(val)) << 12); \
        } while (0)

/* If set: use the fractional clock (see bbpll regmap). If not set: a 2MHz clk will be generated */
#define GP_WB_READ_ASP_USE_FRACT_CLOCK() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1321), 6)

#define GP_WB_GET_ASP_USE_FRACT_CLOCK_FROM_CONFIG(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_ASP_USE_FRACT_CLOCK(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1321), 6, (val)); \
        } while (0)

#define GP_WB_SET_ASP_USE_FRACT_CLOCK_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3FFF; \
          (tmp) |= (((UInt16)(val)) << 14); \
        } while (0)


/* Sets the 16 bits to shift out of the (24 bit) pcm stream coming from the cic filter and into the data_out registers, when not overruled this is the value determined of theoretical max value */
#define GP_WB_READ_ASP_PCM_LSB_OVERRULE() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1322)) & 0x0F)

#define GP_WB_WRITE_ASP_PCM_LSB_OVERRULE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1322), 0x0F, (val)); \
        } while (0)

/* Use pcm_lsb_overrule value */
#define GP_WB_READ_ASP_PCM_LSB_OVERRULE_EN() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1322), 4)

#define GP_WB_WRITE_ASP_PCM_LSB_OVERRULE_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1322), 4, (val)); \
        } while (0)


/* Data is available from the data_0 register, is indirectly cleared by reading out the data */
#define GP_WB_READ_ASP_UNMASKED_DATASTREAM_0_VALID_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1323), 0)

/* Data is available from the data_1 register, is indirectly cleared by reading out the data */
#define GP_WB_READ_ASP_UNMASKED_DATASTREAM_1_VALID_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1323), 1)


/* 16 bit PCM output of the filter. Not a fifo, data is overwritten when new data is available */
#define GP_WB_READ_ASP_DATASTREAM_0() \
        (GP_WB_S16(GP_WB_READ_SER_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1324)), 16))

/* 32 bit PCM output of the filter. Not a fifo, data is overwritten when new data is available */
#define GP_WB_READ_ASP_DATASTREAM_EXTENDED_0() \
        (GP_WB_S32(GP_WB_READ_SER_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1324)), 32))


/* 16 bit PCM output of the filter. Not a fifo, data is overwritten when new data is available */
#define GP_WB_READ_ASP_DATASTREAM_1() \
        (GP_WB_S16(GP_WB_READ_SER_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1328)), 16))

/* 32 bit PCM output of the filter. Not a fifo, data is overwritten when new data is available */
#define GP_WB_READ_ASP_DATASTREAM_EXTENDED_1() \
        (GP_WB_S32(GP_WB_READ_SER_U32(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1328)), 32))


/* Enable the 2MHz clock. */
#define GP_WB_READ_ASP_CLK_2M_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x132c), 0)

#define GP_WB_WRITE_ASP_CLK_2M_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x132c), (val)); \
        } while (0)


/* Clear cic diagnostics flags */
#define GP_WB_ASP_CIC_DIAGNOSTICS_CLR() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x132d), 0x01)


/* Flag indicating that the CIC filter went out of range at least once since the last time the flags were cleared */
#define GP_WB_READ_ASP_CIC_DIAGNOSTICS_OUT_OF_RANGE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x132e), 0)

/* Flag indicating that the CIC filter was using its full range at least once since the last time the flags were cleared */
#define GP_WB_READ_ASP_CIC_DIAGNOSTICS_FULL_RANGE_USED() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x132e), 1)

/***************************
 * layout: sec_proc_ctrl
 ***************************/

/* Clears the err_interrupt */
#define GP_WB_SEC_PROC_CTRL_CLR_ERR_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1330), 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SEC_PROC_CTRL_UNMASKED_INTERRUPTS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1331))

/* Unmasked interrupt triggered by the CryptoMaster submodule, i.e. the symmetric cryptographic operations engine */
#define GP_WB_READ_SEC_PROC_CTRL_UNMASKED_CRYPTO_MASTER_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1331), 0)

#define GP_WB_GET_SEC_PROC_CTRL_UNMASKED_CRYPTO_MASTER_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        ((tmp) & 0x01)

/* Unmasked interrupt triggered by the NDRNG submodule, i.e. the Non-Deterministic Random Number Generator */
#define GP_WB_READ_SEC_PROC_CTRL_UNMASKED_TRNG_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1331), 1)

#define GP_WB_GET_SEC_PROC_CTRL_UNMASKED_TRNG_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 1) & 0x01)

/* Unmasked interrupt triggered by the Public Key submodule, i.e. the asymmetric cryptographic operations engine */
#define GP_WB_READ_SEC_PROC_CTRL_UNMASKED_PKE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1331), 2)

#define GP_WB_GET_SEC_PROC_CTRL_UNMASKED_PKE_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 2) & 0x01)

/* Unmasked interrupt triggered when the internal DMA runs into a memory bus error */
#define GP_WB_READ_SEC_PROC_CTRL_UNMASKED_ERR_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1331), 3)

#define GP_WB_GET_SEC_PROC_CTRL_UNMASKED_ERR_INTERRUPT_FROM_UNMASKED_INTERRUPTS(tmp) \
        (((tmp) >> 3) & 0x01)


/* uses internal secret key when '1'; only works with AES-128 operations */
#define GP_WB_READ_SEC_PROC_CTRL_USE_SKEY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1332), 0)

#define GP_WB_WRITE_SEC_PROC_CTRL_USE_SKEY(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1332), 0, (val)); \
        } while (0)

/* general enable for the Security Processor */
#define GP_WB_READ_SEC_PROC_CTRL_SEC_PROC_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1332), 1)

#define GP_WB_WRITE_SEC_PROC_CTRL_SEC_PROC_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1332), 1, (val)); \
        } while (0)


/* When set to '1', the BIST is allowed to take control of the Data RAM interface. */
#define GP_WB_READ_SEC_PROC_CTRL_DATARAM_BIST_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1333), 0)

#define GP_WB_WRITE_SEC_PROC_CTRL_DATARAM_BIST_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1333), 0, (val)); \
        } while (0)

/* When set to '1', the BIST is allowed to take control of the Code ROM interface. */
#define GP_WB_READ_SEC_PROC_CTRL_CODEROM_BIST_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1333), 1)

#define GP_WB_WRITE_SEC_PROC_CTRL_CODEROM_BIST_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1333), 1, (val)); \
        } while (0)


/* Triggers the Data RAM BIST test (when enabled !). Beware ... this will block all other Data RAM accesses and overwrite ALL memory content !!! */
#define GP_WB_SEC_PROC_CTRL_DATARAM_BIST_START() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1334), 0x01)

/* Triggers the Code ROM BIST test (when enabled !). Beware ... this will block all other Code ROM accesses !!! */
#define GP_WB_SEC_PROC_CTRL_CODEROM_BIST_START() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1334), 0x02)


/* Indicates that the BIST test is finished */
#define GP_WB_READ_SEC_PROC_CTRL_DATARAM_BIST_RDY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1335), 0)

/* Indicates that the BIST test passed or failed */
#define GP_WB_READ_SEC_PROC_CTRL_DATARAM_BIST_OK() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1335), 1)

/* Indicates that the BIST test is finished */
#define GP_WB_READ_SEC_PROC_CTRL_CODEROM_BIST_RDY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1335), 2)

/* Indicates that the BIST test passed or failed */
#define GP_WB_READ_SEC_PROC_CTRL_CODEROM_BIST_OK() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1335), 3)

/***************************
 * layout: rpa_acc
 ***************************/

/* key table pointer for the keys that need to be used for RPA. 128 bit address */
#define GP_WB_READ_RPA_ACC_KEY_TABLE_PTR() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1340))

#define GP_WB_WRITE_RPA_ACC_KEY_TABLE_PTR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03FFFF); \
          GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1340), (val)); \
        } while (0)


/* number of rpa key entries-1 (so 0 means 1 entry) */
#define GP_WB_READ_RPA_ACC_NUM_KEY_ENTRIES() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1343))

#define GP_WB_WRITE_RPA_ACC_NUM_KEY_ENTRIES(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1343), (val)); \
        } while (0)


/* random input data thet needs to be put through tha AES block cipher */
#define GP_WB_READ_RPA_ACC_PRAND_DATA() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1344))

#define GP_WB_WRITE_RPA_ACC_PRAND_DATA(val) do { \
          GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1344), (val)); \
        } while (0)


/* compare data that needs to be matched */
#define GP_WB_READ_RPA_ACC_AH_DATA() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1348))

#define GP_WB_WRITE_RPA_ACC_AH_DATA(val) do { \
          GP_WB_WRITE_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1348), (val)); \
        } while (0)


#define GP_WB_WRITE_RPA_ACC_START_SEARCH(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x134b), (val))

/* Starts a RPA search */
#define GP_WB_RPA_ACC_START_SEARCH() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x134b), 0x01)

#define GP_WB_SET_RPA_ACC_START_SEARCH_TO_START_SEARCH(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* stops an ongoing RPA search */
#define GP_WB_RPA_ACC_STOP_SEARCH() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x134b), 0x02)

#define GP_WB_SET_RPA_ACC_STOP_SEARCH_TO_START_SEARCH(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Clears the interrupt */
#define GP_WB_RPA_ACC_CLR_DONE_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x134b), 0x04)

#define GP_WB_SET_RPA_ACC_CLR_DONE_INTERRUPT_TO_START_SEARCH(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RPA_ACC_SEARCH_STATUS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x134c))

/* Indicates the rpa search cycle is busy */
#define GP_WB_READ_RPA_ACC_BUSY() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x134c), 0)

#define GP_WB_GET_RPA_ACC_BUSY_FROM_SEARCH_STATUS(tmp) \
        ((tmp) & 0x01)

/* Set when an error occurred while accessing the memory */
#define GP_WB_READ_RPA_ACC_MEM_ERR() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x134c), 1)

#define GP_WB_GET_RPA_ACC_MEM_ERR_FROM_SEARCH_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* Indicates that the search did fined a match */
#define GP_WB_READ_RPA_ACC_MATCH_FOUND() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x134c), 2)

#define GP_WB_GET_RPA_ACC_MATCH_FOUND_FROM_SEARCH_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)

/* Indicates what key idx was used to find the match */
#define GP_WB_READ_RPA_ACC_MATCH_IDX() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x134c)) >> 3) & 0x1F)

#define GP_WB_GET_RPA_ACC_MATCH_IDX_FROM_SEARCH_STATUS(tmp) \
        (((tmp) >> 3) & 0x1F)


/* interrupt status for search done */
#define GP_WB_READ_RPA_ACC_UNMASKED_DONE_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x134d), 0)


/* hashing result */
#define GP_WB_READ_RPA_ACC_HASH_DATA_OUT() \
        GP_WB_READ_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1350))

/***************************
 * layout: timers
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TIMERS_TMR0_CFG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1380))

#define GP_WB_WRITE_TIMERS_TMR0_CFG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1380), (val))

/* Prescaler divider selector for tmr0, scales down the input clock by a factor of 2**tmr0_prescaler_div */
#define GP_WB_READ_TIMERS_TMR0_PRESCALER_DIV() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1380)) & 0x0F)

#define GP_WB_GET_TIMERS_TMR0_PRESCALER_DIV_FROM_TMR0_CFG(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_TIMERS_TMR0_PRESCALER_DIV(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1380), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_TIMERS_TMR0_PRESCALER_DIV_TO_TMR0_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x10; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* input clock selection for tmr0 */
#define GP_WB_READ_TIMERS_TMR0_CLK_SEL() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1380), 4)

#define GP_WB_GET_TIMERS_TMR0_CLK_SEL_FROM_TMR0_CFG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_TIMERS_TMR0_CLK_SEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1380), 4, (val)); \
        } while (0)

#define GP_WB_SET_TIMERS_TMR0_CLK_SEL_TO_TMR0_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* threshold at which the tmr0 counter should wrap at */
#define GP_WB_READ_TIMERS_TMR0_THRESHOLD() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1382))

#define GP_WB_WRITE_TIMERS_TMR0_THRESHOLD(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1382), (val)); \
        } while (0)


/* current value of the tmr0 counter */
#define GP_WB_READ_TIMERS_TMR0_VALUE() \
        GP_WB_READ_SER_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1384))


/* sets the immediate value of timer 0 counter to tmr_preset_value */
#define GP_WB_TIMERS_TMR0_PRESET() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1386), 0x01)


/* interrupt indicating that tmr0 counter has wrapped (has reached the tmr0_threshold) */
#define GP_WB_READ_TIMERS_UNMASKED_TMR0_WRAP_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1387), 0)


/* clear for the tmr0_wrap_interrupt */
#define GP_WB_TIMERS_CLR_TMR0_WRAP_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1388), 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TIMERS_TMR1_CFG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x138c))

#define GP_WB_WRITE_TIMERS_TMR1_CFG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x138c), (val))

/* Prescaler divider selector for tmr1, scales down the input clock by a factor of 2**tmr1_prescaler_div */
#define GP_WB_READ_TIMERS_TMR1_PRESCALER_DIV() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x138c)) & 0x0F)

#define GP_WB_GET_TIMERS_TMR1_PRESCALER_DIV_FROM_TMR1_CFG(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_TIMERS_TMR1_PRESCALER_DIV(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x138c), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_TIMERS_TMR1_PRESCALER_DIV_TO_TMR1_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x10; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* input clock selection for tmr1 */
#define GP_WB_READ_TIMERS_TMR1_CLK_SEL() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x138c), 4)

#define GP_WB_GET_TIMERS_TMR1_CLK_SEL_FROM_TMR1_CFG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_TIMERS_TMR1_CLK_SEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x138c), 4, (val)); \
        } while (0)

#define GP_WB_SET_TIMERS_TMR1_CLK_SEL_TO_TMR1_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* threshold at which the tmr1 counter should wrap at */
#define GP_WB_READ_TIMERS_TMR1_THRESHOLD() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x138e))

#define GP_WB_WRITE_TIMERS_TMR1_THRESHOLD(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x138e), (val)); \
        } while (0)


/* current value of the tmr1 counter */
#define GP_WB_READ_TIMERS_TMR1_VALUE() \
        GP_WB_READ_SER_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1390))


/* sets the immediate value of timer 1 counter to tmr_preset_value */
#define GP_WB_TIMERS_TMR1_PRESET() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1392), 0x01)


/* interrupt indicating that tmr1 counter has wrapped (has reached the tmr1_threshold) */
#define GP_WB_READ_TIMERS_UNMASKED_TMR1_WRAP_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1393), 0)


/* clear for the tmr1_wrap_interrupt */
#define GP_WB_TIMERS_CLR_TMR1_WRAP_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1394), 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TIMERS_TMR2_CFG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1398))

#define GP_WB_WRITE_TIMERS_TMR2_CFG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1398), (val))

/* Prescaler divider selector for tmr2, scales down the input clock by a factor of 2**tmr2_prescaler_div */
#define GP_WB_READ_TIMERS_TMR2_PRESCALER_DIV() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1398)) & 0x0F)

#define GP_WB_GET_TIMERS_TMR2_PRESCALER_DIV_FROM_TMR2_CFG(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_TIMERS_TMR2_PRESCALER_DIV(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1398), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_TIMERS_TMR2_PRESCALER_DIV_TO_TMR2_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x30; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* input clock selection for tmr2 */
#define GP_WB_READ_TIMERS_TMR2_CLK_SEL() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1398)) >> 4) & 0x03)

#define GP_WB_GET_TIMERS_TMR2_CLK_SEL_FROM_TMR2_CFG(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_TIMERS_TMR2_CLK_SEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1398), 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_TIMERS_TMR2_CLK_SEL_TO_TMR2_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* threshold at which the tmr2 counter should wrap at */
#define GP_WB_READ_TIMERS_TMR2_THRESHOLD() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x139a))

#define GP_WB_WRITE_TIMERS_TMR2_THRESHOLD(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x139a), (val)); \
        } while (0)


/* current value of the tmr2 counter */
#define GP_WB_READ_TIMERS_TMR2_VALUE() \
        GP_WB_READ_SER_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x139c))


/* sets the immediate value of timer 2 counter to tmr_preset_value */
#define GP_WB_TIMERS_TMR2_PRESET() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x139e), 0x01)


/* interrupt indicating that tmr2 counter has wrapped (has reached the tmr2_threshold) */
#define GP_WB_READ_TIMERS_UNMASKED_TMR2_WRAP_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x139f), 0)


/* clear for the tmr2_wrap_interrupt */
#define GP_WB_TIMERS_CLR_TMR2_WRAP_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13a0), 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TIMERS_TMR3_CFG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13a4))

#define GP_WB_WRITE_TIMERS_TMR3_CFG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13a4), (val))

/* Prescaler divider selector for tmr3, scales down the input clock by a factor of 2**tmr3_prescaler_div */
#define GP_WB_READ_TIMERS_TMR3_PRESCALER_DIV() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13a4)) & 0x0F)

#define GP_WB_GET_TIMERS_TMR3_PRESCALER_DIV_FROM_TMR3_CFG(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_TIMERS_TMR3_PRESCALER_DIV(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13a4), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_TIMERS_TMR3_PRESCALER_DIV_TO_TMR3_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x30; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* input clock selection for tmr3 */
#define GP_WB_READ_TIMERS_TMR3_CLK_SEL() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13a4)) >> 4) & 0x03)

#define GP_WB_GET_TIMERS_TMR3_CLK_SEL_FROM_TMR3_CFG(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_TIMERS_TMR3_CLK_SEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13a4), 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_TIMERS_TMR3_CLK_SEL_TO_TMR3_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* threshold at which the tmr3 counter should wrap at */
#define GP_WB_READ_TIMERS_TMR3_THRESHOLD() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13a6))

#define GP_WB_WRITE_TIMERS_TMR3_THRESHOLD(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13a6), (val)); \
        } while (0)


/* current value of the tmr3 counter */
#define GP_WB_READ_TIMERS_TMR3_VALUE() \
        GP_WB_READ_SER_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13a8))


/* sets the immediate value of timer 3 counter to tmr_preset_value */
#define GP_WB_TIMERS_TMR3_PRESET() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13aa), 0x01)


/* interrupt indicating that tmr3 counter has wrapped (has reached the tmr3_threshold) */
#define GP_WB_READ_TIMERS_UNMASKED_TMR3_WRAP_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13ab), 0)


/* clear for the tmr3_wrap_interrupt */
#define GP_WB_TIMERS_CLR_TMR3_WRAP_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13ac), 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TIMERS_TMR4_CFG() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13b0))

#define GP_WB_WRITE_TIMERS_TMR4_CFG(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13b0), (val))

/* Prescaler divider selector for tmr4, scales down the input clock by a factor of 2**tmr4_prescaler_div */
#define GP_WB_READ_TIMERS_TMR4_PRESCALER_DIV() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13b0)) & 0x0F)

#define GP_WB_GET_TIMERS_TMR4_PRESCALER_DIV_FROM_TMR4_CFG(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_TIMERS_TMR4_PRESCALER_DIV(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13b0), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_TIMERS_TMR4_PRESCALER_DIV_TO_TMR4_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x70; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* input clock selection for tmr4 */
#define GP_WB_READ_TIMERS_TMR4_CLK_SEL() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13b0)) >> 4) & 0x07)

#define GP_WB_GET_TIMERS_TMR4_CLK_SEL_FROM_TMR4_CFG(tmp) \
        (((tmp) >> 4) & 0x07)

#define GP_WB_WRITE_TIMERS_TMR4_CLK_SEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13b0), 0x70, (val) << 4); \
        } while (0)

#define GP_WB_SET_TIMERS_TMR4_CLK_SEL_TO_TMR4_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* threshold at which the tmr4 counter should wrap at */
#define GP_WB_READ_TIMERS_TMR4_THRESHOLD() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13b2))

#define GP_WB_WRITE_TIMERS_TMR4_THRESHOLD(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13b2), (val)); \
        } while (0)


/* current value of the tmr4 counter */
#define GP_WB_READ_TIMERS_TMR4_VALUE() \
        GP_WB_READ_SER_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13b4))


/* sets the immediate value of timer 4 counter to tmr_preset_value */
#define GP_WB_TIMERS_TMR4_PRESET() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13b6), 0x01)


/* interrupt indicating that tmr4 counter has wrapped (has reached the tmr4_threshold) */
#define GP_WB_READ_TIMERS_UNMASKED_TMR4_WRAP_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13b7), 0)


/* clear for the tmr4_wrap_interrupt */
#define GP_WB_TIMERS_CLR_TMR4_WRAP_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13b8), 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TIMERS_TMR_ENABLES() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13b9))

#define GP_WB_WRITE_TIMERS_TMR_ENABLES(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13b9), (val))

/* when 1, tmr0 starts counting. When 0, tmr{0} is halted */
#define GP_WB_READ_TIMERS_TMR0_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13b9), 0)

#define GP_WB_GET_TIMERS_TMR0_ENABLE_FROM_TMR_ENABLES(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_TIMERS_TMR0_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13b9), 0, (val)); \
        } while (0)

#define GP_WB_SET_TIMERS_TMR0_ENABLE_TO_TMR_ENABLES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* when 1, tmr1 starts counting. When 0, tmr{1} is halted */
#define GP_WB_READ_TIMERS_TMR1_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13b9), 1)

#define GP_WB_GET_TIMERS_TMR1_ENABLE_FROM_TMR_ENABLES(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_TIMERS_TMR1_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13b9), 1, (val)); \
        } while (0)

#define GP_WB_SET_TIMERS_TMR1_ENABLE_TO_TMR_ENABLES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* when 1, tmr2 starts counting. When 0, tmr{2} is halted */
#define GP_WB_READ_TIMERS_TMR2_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13b9), 2)

#define GP_WB_GET_TIMERS_TMR2_ENABLE_FROM_TMR_ENABLES(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_TIMERS_TMR2_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13b9), 2, (val)); \
        } while (0)

#define GP_WB_SET_TIMERS_TMR2_ENABLE_TO_TMR_ENABLES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* when 1, tmr3 starts counting. When 0, tmr{3} is halted */
#define GP_WB_READ_TIMERS_TMR3_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13b9), 3)

#define GP_WB_GET_TIMERS_TMR3_ENABLE_FROM_TMR_ENABLES(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_TIMERS_TMR3_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13b9), 3, (val)); \
        } while (0)

#define GP_WB_SET_TIMERS_TMR3_ENABLE_TO_TMR_ENABLES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* when 1, tmr4 starts counting. When 0, tmr{4} is halted */
#define GP_WB_READ_TIMERS_TMR4_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13b9), 4)

#define GP_WB_GET_TIMERS_TMR4_ENABLE_FROM_TMR_ENABLES(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_TIMERS_TMR4_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13b9), 4, (val)); \
        } while (0)

#define GP_WB_SET_TIMERS_TMR4_ENABLE_TO_TMR_ENABLES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* value that will be applied on a tmr_x_preset */
#define GP_WB_READ_TIMERS_TMR_PRESET_VALUE() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13ba))

#define GP_WB_WRITE_TIMERS_TMR_PRESET_VALUE(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x13ba), (val)); \
        } while (0)

/***************************
 * layout: pwms
 ***************************/

/* Enables the timestamp0 functinality. */
#define GP_WB_READ_PWMS_TIMESTAMP0_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1400), 0)

#define GP_WB_WRITE_PWMS_TIMESTAMP0_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1400), 0, (val)); \
        } while (0)

/* When set to 1, the timestamp0 fifos works in 16-bit word mode. In this mode, reading the timestamp0_main property, pops an entry from the FIFO. When set to 0, the timestamp0 fifo works in byte mode. In this mode, writing the timestamp0 property pops an entry from the fifo. */
#define GP_WB_READ_PWMS_TIMESTAMP0_FIFO_SIZE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1400)) >> 1) & 0x03)

#define GP_WB_WRITE_PWMS_TIMESTAMP0_FIFO_SIZE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1400), 0x06, (val) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PWMS_TIMESTAMP0_STABLE_POWERS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1401))

#define GP_WB_WRITE_PWMS_TIMESTAMP0_STABLE_POWERS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1401), (val))

/* The amount of timestamp0 input signal processing clock cycles that the input signal has to be low before the processed signal becomes low is (2**timestamp0_stable_low_power)-1 */
#define GP_WB_READ_PWMS_TIMESTAMP0_STABLE_LOW_POWER() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1401)) & 0x07)

#define GP_WB_GET_PWMS_TIMESTAMP0_STABLE_LOW_POWER_FROM_TIMESTAMP0_STABLE_POWERS(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_PWMS_TIMESTAMP0_STABLE_LOW_POWER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1401), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_PWMS_TIMESTAMP0_STABLE_LOW_POWER_TO_TIMESTAMP0_STABLE_POWERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x70; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* The amount of timestamp0 input signal processing clock cycles that the input signal has to be high before the processed signal becomes high is (2**timestamp0_stable_high_power)-1 */
#define GP_WB_READ_PWMS_TIMESTAMP0_STABLE_HIGH_POWER() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1401)) >> 4) & 0x07)

#define GP_WB_GET_PWMS_TIMESTAMP0_STABLE_HIGH_POWER_FROM_TIMESTAMP0_STABLE_POWERS(tmp) \
        (((tmp) >> 4) & 0x07)

#define GP_WB_WRITE_PWMS_TIMESTAMP0_STABLE_HIGH_POWER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1401), 0x70, (val) << 4); \
        } while (0)

#define GP_WB_SET_PWMS_TIMESTAMP0_STABLE_HIGH_POWER_TO_TIMESTAMP0_STABLE_POWERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PWMS_STATUS_0() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1402))

/* The current value of the timestamp0 input */
#define GP_WB_READ_PWMS_TIMESTAMP0_INPUT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1402), 0)

#define GP_WB_GET_PWMS_TIMESTAMP0_INPUT_FROM_STATUS_0(tmp) \
        ((tmp) & 0x01)

/* The unmasked interrupt status of the timestamp0 not empty interrupt */
#define GP_WB_READ_PWMS_UNMASKED_TIMESTAMP0_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1402), 1)

#define GP_WB_GET_PWMS_UNMASKED_TIMESTAMP0_NOT_EMPTY_INTERRUPT_FROM_STATUS_0(tmp) \
        (((tmp) >> 1) & 0x01)

/* The unmasked interrupt status of the timestamp0 overrun interrupt */
#define GP_WB_READ_PWMS_UNMASKED_TIMESTAMP0_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1402), 2)

#define GP_WB_GET_PWMS_UNMASKED_TIMESTAMP0_OVERRUN_INTERRUPT_FROM_STATUS_0(tmp) \
        (((tmp) >> 2) & 0x01)


/* Updates the timestamp0 with the current value main counter */
#define GP_WB_PWMS_TIMESTAMP0_UPDATE() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1403), 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PWMS_TIMESTAMP0_VALUES() \
        GP_WB_READ_SER_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1404))

/* The LSB of the timestamp0 of the main counter */
#define GP_WB_READ_PWMS_TIMESTAMP0_MAIN_0() \
        GP_WB_READ_SER_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1404))

#define GP_WB_GET_PWMS_TIMESTAMP0_MAIN_0_FROM_TIMESTAMP0_VALUES(tmp) \
        ((tmp) & 0xFF)

/* The (16-bit) timestamp0 of the main counter */
#define GP_WB_READ_PWMS_TIMESTAMP0_MAIN() \
        GP_WB_READ_SER_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1404))

#define GP_WB_GET_PWMS_TIMESTAMP0_MAIN_FROM_TIMESTAMP0_VALUES(tmp) \
        ((tmp) & 0xFFFF)

/* The full (23-bit) timestamp0 value (main+carrier) */
#define GP_WB_READ_PWMS_TIMESTAMP0_FULL_COUNTER() \
        (GP_WB_READ_SER_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1404)) & 0x7FFFFF)

#define GP_WB_GET_PWMS_TIMESTAMP0_FULL_COUNTER_FROM_TIMESTAMP0_VALUES(tmp) \
        ((tmp) & 0x7FFFFF)

/* The timestamp0 of the carrier counter */
#define GP_WB_READ_PWMS_TIMESTAMP0_CARRIER() \
        (GP_WB_READ_SER_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1406)) & 0x7F)

#define GP_WB_GET_PWMS_TIMESTAMP0_CARRIER_FROM_TIMESTAMP0_VALUES(tmp) \
        (((tmp) >> 16) & 0x7F)

/* The stable value of the input at the moment the timestamp0 is taken */
#define GP_WB_READ_PWMS_TIMESTAMP0_INPUT_ON_PREVIOUS_UPDATE() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1406), 7)

#define GP_WB_GET_PWMS_TIMESTAMP0_INPUT_ON_PREVIOUS_UPDATE_FROM_TIMESTAMP0_VALUES(tmp) \
        (((tmp) >> 23) & 0x01)


/* Clears the timestamp0 overrun interrupt, NOTE: also clears the threshold match interrupt of pwm0 */
#define GP_WB_PWMS_CLR_TIMESTAMP0_OVERRUN_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1407), 0x01)


/* Enables the timestamp1 functinality. */
#define GP_WB_READ_PWMS_TIMESTAMP1_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1408), 0)

#define GP_WB_WRITE_PWMS_TIMESTAMP1_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1408), 0, (val)); \
        } while (0)

/* When set to 1, the timestamp1 fifos works in 16-bit word mode. In this mode, reading the timestamp1_main property, pops an entry from the FIFO. When set to 0, the timestamp1 fifo works in byte mode. In this mode, writing the timestamp1 property pops an entry from the fifo. */
#define GP_WB_READ_PWMS_TIMESTAMP1_FIFO_SIZE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1408)) >> 1) & 0x03)

#define GP_WB_WRITE_PWMS_TIMESTAMP1_FIFO_SIZE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1408), 0x06, (val) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PWMS_TIMESTAMP1_STABLE_POWERS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1409))

#define GP_WB_WRITE_PWMS_TIMESTAMP1_STABLE_POWERS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1409), (val))

/* The amount of timestamp1 input signal processing clock cycles that the input signal has to be low before the processed signal becomes low is (2**timestamp1_stable_low_power)-1 */
#define GP_WB_READ_PWMS_TIMESTAMP1_STABLE_LOW_POWER() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1409)) & 0x07)

#define GP_WB_GET_PWMS_TIMESTAMP1_STABLE_LOW_POWER_FROM_TIMESTAMP1_STABLE_POWERS(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_PWMS_TIMESTAMP1_STABLE_LOW_POWER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1409), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_PWMS_TIMESTAMP1_STABLE_LOW_POWER_TO_TIMESTAMP1_STABLE_POWERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x70; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* The amount of timestamp1 input signal processing clock cycles that the input signal has to be high before the processed signal becomes high is (2**timestamp1_stable_high_power)-1 */
#define GP_WB_READ_PWMS_TIMESTAMP1_STABLE_HIGH_POWER() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1409)) >> 4) & 0x07)

#define GP_WB_GET_PWMS_TIMESTAMP1_STABLE_HIGH_POWER_FROM_TIMESTAMP1_STABLE_POWERS(tmp) \
        (((tmp) >> 4) & 0x07)

#define GP_WB_WRITE_PWMS_TIMESTAMP1_STABLE_HIGH_POWER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1409), 0x70, (val) << 4); \
        } while (0)

#define GP_WB_SET_PWMS_TIMESTAMP1_STABLE_HIGH_POWER_TO_TIMESTAMP1_STABLE_POWERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PWMS_STATUS_1() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x140a))

/* The current value of the timestamp1 input */
#define GP_WB_READ_PWMS_TIMESTAMP1_INPUT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x140a), 0)

#define GP_WB_GET_PWMS_TIMESTAMP1_INPUT_FROM_STATUS_1(tmp) \
        ((tmp) & 0x01)

/* The unmasked interrupt status of the timestamp1 not empty interrupt */
#define GP_WB_READ_PWMS_UNMASKED_TIMESTAMP1_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x140a), 1)

#define GP_WB_GET_PWMS_UNMASKED_TIMESTAMP1_NOT_EMPTY_INTERRUPT_FROM_STATUS_1(tmp) \
        (((tmp) >> 1) & 0x01)

/* The unmasked interrupt status of the timestamp1 overrun interrupt */
#define GP_WB_READ_PWMS_UNMASKED_TIMESTAMP1_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x140a), 2)

#define GP_WB_GET_PWMS_UNMASKED_TIMESTAMP1_OVERRUN_INTERRUPT_FROM_STATUS_1(tmp) \
        (((tmp) >> 2) & 0x01)


/* Updates the timestamp1 with the current value main counter */
#define GP_WB_PWMS_TIMESTAMP1_UPDATE() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x140b), 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PWMS_TIMESTAMP1_VALUES() \
        GP_WB_READ_SER_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x140c))

/* The LSB of the timestamp1 of the main counter */
#define GP_WB_READ_PWMS_TIMESTAMP1_MAIN_0() \
        GP_WB_READ_SER_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x140c))

#define GP_WB_GET_PWMS_TIMESTAMP1_MAIN_0_FROM_TIMESTAMP1_VALUES(tmp) \
        ((tmp) & 0xFF)

/* The (16-bit) timestamp1 of the main counter */
#define GP_WB_READ_PWMS_TIMESTAMP1_MAIN() \
        GP_WB_READ_SER_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x140c))

#define GP_WB_GET_PWMS_TIMESTAMP1_MAIN_FROM_TIMESTAMP1_VALUES(tmp) \
        ((tmp) & 0xFFFF)

/* The full (23-bit) timestamp1 value (main+carrier) */
#define GP_WB_READ_PWMS_TIMESTAMP1_FULL_COUNTER() \
        (GP_WB_READ_SER_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x140c)) & 0x7FFFFF)

#define GP_WB_GET_PWMS_TIMESTAMP1_FULL_COUNTER_FROM_TIMESTAMP1_VALUES(tmp) \
        ((tmp) & 0x7FFFFF)

/* The timestamp1 of the carrier counter */
#define GP_WB_READ_PWMS_TIMESTAMP1_CARRIER() \
        (GP_WB_READ_SER_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x140e)) & 0x7F)

#define GP_WB_GET_PWMS_TIMESTAMP1_CARRIER_FROM_TIMESTAMP1_VALUES(tmp) \
        (((tmp) >> 16) & 0x7F)

/* The stable value of the input at the moment the timestamp1 is taken */
#define GP_WB_READ_PWMS_TIMESTAMP1_INPUT_ON_PREVIOUS_UPDATE() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x140e), 7)

#define GP_WB_GET_PWMS_TIMESTAMP1_INPUT_ON_PREVIOUS_UPDATE_FROM_TIMESTAMP1_VALUES(tmp) \
        (((tmp) >> 23) & 0x01)


/* Clears the timestamp1 overrun interrupt, NOTE: also clears the threshold match interrupt of pwm1 */
#define GP_WB_PWMS_CLR_TIMESTAMP1_OVERRUN_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x140f), 0x01)


/* Enables the timestamp2 functinality. */
#define GP_WB_READ_PWMS_TIMESTAMP2_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1410), 0)

#define GP_WB_WRITE_PWMS_TIMESTAMP2_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1410), 0, (val)); \
        } while (0)

/* When set to 1, the timestamp2 fifos works in 16-bit word mode. In this mode, reading the timestamp2_main property, pops an entry from the FIFO. When set to 0, the timestamp2 fifo works in byte mode. In this mode, writing the timestamp2 property pops an entry from the fifo. */
#define GP_WB_READ_PWMS_TIMESTAMP2_FIFO_SIZE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1410)) >> 1) & 0x03)

#define GP_WB_WRITE_PWMS_TIMESTAMP2_FIFO_SIZE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1410), 0x06, (val) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PWMS_TIMESTAMP2_STABLE_POWERS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1411))

#define GP_WB_WRITE_PWMS_TIMESTAMP2_STABLE_POWERS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1411), (val))

/* The amount of timestamp2 input signal processing clock cycles that the input signal has to be low before the processed signal becomes low is (2**timestamp2_stable_low_power)-1 */
#define GP_WB_READ_PWMS_TIMESTAMP2_STABLE_LOW_POWER() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1411)) & 0x07)

#define GP_WB_GET_PWMS_TIMESTAMP2_STABLE_LOW_POWER_FROM_TIMESTAMP2_STABLE_POWERS(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_PWMS_TIMESTAMP2_STABLE_LOW_POWER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1411), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_PWMS_TIMESTAMP2_STABLE_LOW_POWER_TO_TIMESTAMP2_STABLE_POWERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x70; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* The amount of timestamp2 input signal processing clock cycles that the input signal has to be high before the processed signal becomes high is (2**timestamp2_stable_high_power)-1 */
#define GP_WB_READ_PWMS_TIMESTAMP2_STABLE_HIGH_POWER() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1411)) >> 4) & 0x07)

#define GP_WB_GET_PWMS_TIMESTAMP2_STABLE_HIGH_POWER_FROM_TIMESTAMP2_STABLE_POWERS(tmp) \
        (((tmp) >> 4) & 0x07)

#define GP_WB_WRITE_PWMS_TIMESTAMP2_STABLE_HIGH_POWER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1411), 0x70, (val) << 4); \
        } while (0)

#define GP_WB_SET_PWMS_TIMESTAMP2_STABLE_HIGH_POWER_TO_TIMESTAMP2_STABLE_POWERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PWMS_STATUS_2() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1412))

/* The current value of the timestamp2 input */
#define GP_WB_READ_PWMS_TIMESTAMP2_INPUT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1412), 0)

#define GP_WB_GET_PWMS_TIMESTAMP2_INPUT_FROM_STATUS_2(tmp) \
        ((tmp) & 0x01)

/* The unmasked interrupt status of the timestamp2 not empty interrupt */
#define GP_WB_READ_PWMS_UNMASKED_TIMESTAMP2_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1412), 1)

#define GP_WB_GET_PWMS_UNMASKED_TIMESTAMP2_NOT_EMPTY_INTERRUPT_FROM_STATUS_2(tmp) \
        (((tmp) >> 1) & 0x01)

/* The unmasked interrupt status of the timestamp2 overrun interrupt */
#define GP_WB_READ_PWMS_UNMASKED_TIMESTAMP2_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1412), 2)

#define GP_WB_GET_PWMS_UNMASKED_TIMESTAMP2_OVERRUN_INTERRUPT_FROM_STATUS_2(tmp) \
        (((tmp) >> 2) & 0x01)


/* Updates the timestamp2 with the current value main counter */
#define GP_WB_PWMS_TIMESTAMP2_UPDATE() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1413), 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PWMS_TIMESTAMP2_VALUES() \
        GP_WB_READ_SER_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1414))

/* The LSB of the timestamp2 of the main counter */
#define GP_WB_READ_PWMS_TIMESTAMP2_MAIN_0() \
        GP_WB_READ_SER_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1414))

#define GP_WB_GET_PWMS_TIMESTAMP2_MAIN_0_FROM_TIMESTAMP2_VALUES(tmp) \
        ((tmp) & 0xFF)

/* The (16-bit) timestamp2 of the main counter */
#define GP_WB_READ_PWMS_TIMESTAMP2_MAIN() \
        GP_WB_READ_SER_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1414))

#define GP_WB_GET_PWMS_TIMESTAMP2_MAIN_FROM_TIMESTAMP2_VALUES(tmp) \
        ((tmp) & 0xFFFF)

/* The full (23-bit) timestamp2 value (main+carrier) */
#define GP_WB_READ_PWMS_TIMESTAMP2_FULL_COUNTER() \
        (GP_WB_READ_SER_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1414)) & 0x7FFFFF)

#define GP_WB_GET_PWMS_TIMESTAMP2_FULL_COUNTER_FROM_TIMESTAMP2_VALUES(tmp) \
        ((tmp) & 0x7FFFFF)

/* The timestamp2 of the carrier counter */
#define GP_WB_READ_PWMS_TIMESTAMP2_CARRIER() \
        (GP_WB_READ_SER_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1416)) & 0x7F)

#define GP_WB_GET_PWMS_TIMESTAMP2_CARRIER_FROM_TIMESTAMP2_VALUES(tmp) \
        (((tmp) >> 16) & 0x7F)

/* The stable value of the input at the moment the timestamp2 is taken */
#define GP_WB_READ_PWMS_TIMESTAMP2_INPUT_ON_PREVIOUS_UPDATE() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1416), 7)

#define GP_WB_GET_PWMS_TIMESTAMP2_INPUT_ON_PREVIOUS_UPDATE_FROM_TIMESTAMP2_VALUES(tmp) \
        (((tmp) >> 23) & 0x01)


/* Clears the timestamp2 overrun interrupt, NOTE: also clears the threshold match interrupt of pwm2 */
#define GP_WB_PWMS_CLR_TIMESTAMP2_OVERRUN_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1417), 0x01)


/* Enables the timestamp3 functinality. */
#define GP_WB_READ_PWMS_TIMESTAMP3_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1418), 0)

#define GP_WB_WRITE_PWMS_TIMESTAMP3_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1418), 0, (val)); \
        } while (0)

/* When set to 1, the timestamp3 fifos works in 16-bit word mode. In this mode, reading the timestamp3_main property, pops an entry from the FIFO. When set to 0, the timestamp3 fifo works in byte mode. In this mode, writing the timestamp3 property pops an entry from the fifo. */
#define GP_WB_READ_PWMS_TIMESTAMP3_FIFO_SIZE() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1418)) >> 1) & 0x03)

#define GP_WB_WRITE_PWMS_TIMESTAMP3_FIFO_SIZE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1418), 0x06, (val) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PWMS_TIMESTAMP3_STABLE_POWERS() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1419))

#define GP_WB_WRITE_PWMS_TIMESTAMP3_STABLE_POWERS(val) \
      GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1419), (val))

/* The amount of timestamp3 input signal processing clock cycles that the input signal has to be low before the processed signal becomes low is (2**timestamp3_stable_low_power)-1 */
#define GP_WB_READ_PWMS_TIMESTAMP3_STABLE_LOW_POWER() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1419)) & 0x07)

#define GP_WB_GET_PWMS_TIMESTAMP3_STABLE_LOW_POWER_FROM_TIMESTAMP3_STABLE_POWERS(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_PWMS_TIMESTAMP3_STABLE_LOW_POWER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1419), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_PWMS_TIMESTAMP3_STABLE_LOW_POWER_TO_TIMESTAMP3_STABLE_POWERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x70; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* The amount of timestamp3 input signal processing clock cycles that the input signal has to be high before the processed signal becomes high is (2**timestamp3_stable_high_power)-1 */
#define GP_WB_READ_PWMS_TIMESTAMP3_STABLE_HIGH_POWER() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1419)) >> 4) & 0x07)

#define GP_WB_GET_PWMS_TIMESTAMP3_STABLE_HIGH_POWER_FROM_TIMESTAMP3_STABLE_POWERS(tmp) \
        (((tmp) >> 4) & 0x07)

#define GP_WB_WRITE_PWMS_TIMESTAMP3_STABLE_HIGH_POWER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1419), 0x70, (val) << 4); \
        } while (0)

#define GP_WB_SET_PWMS_TIMESTAMP3_STABLE_HIGH_POWER_TO_TIMESTAMP3_STABLE_POWERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PWMS_STATUS_3() \
        GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x141a))

/* The current value of the timestamp3 input */
#define GP_WB_READ_PWMS_TIMESTAMP3_INPUT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x141a), 0)

#define GP_WB_GET_PWMS_TIMESTAMP3_INPUT_FROM_STATUS_3(tmp) \
        ((tmp) & 0x01)

/* The unmasked interrupt status of the timestamp3 not empty interrupt */
#define GP_WB_READ_PWMS_UNMASKED_TIMESTAMP3_NOT_EMPTY_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x141a), 1)

#define GP_WB_GET_PWMS_UNMASKED_TIMESTAMP3_NOT_EMPTY_INTERRUPT_FROM_STATUS_3(tmp) \
        (((tmp) >> 1) & 0x01)

/* The unmasked interrupt status of the timestamp3 overrun interrupt */
#define GP_WB_READ_PWMS_UNMASKED_TIMESTAMP3_OVERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x141a), 2)

#define GP_WB_GET_PWMS_UNMASKED_TIMESTAMP3_OVERRUN_INTERRUPT_FROM_STATUS_3(tmp) \
        (((tmp) >> 2) & 0x01)


/* Updates the timestamp3 with the current value main counter */
#define GP_WB_PWMS_TIMESTAMP3_UPDATE() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x141b), 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PWMS_TIMESTAMP3_VALUES() \
        GP_WB_READ_SER_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x141c))

/* The LSB of the timestamp3 of the main counter */
#define GP_WB_READ_PWMS_TIMESTAMP3_MAIN_0() \
        GP_WB_READ_SER_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x141c))

#define GP_WB_GET_PWMS_TIMESTAMP3_MAIN_0_FROM_TIMESTAMP3_VALUES(tmp) \
        ((tmp) & 0xFF)

/* The (16-bit) timestamp3 of the main counter */
#define GP_WB_READ_PWMS_TIMESTAMP3_MAIN() \
        GP_WB_READ_SER_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x141c))

#define GP_WB_GET_PWMS_TIMESTAMP3_MAIN_FROM_TIMESTAMP3_VALUES(tmp) \
        ((tmp) & 0xFFFF)

/* The full (23-bit) timestamp3 value (main+carrier) */
#define GP_WB_READ_PWMS_TIMESTAMP3_FULL_COUNTER() \
        (GP_WB_READ_SER_U24(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x141c)) & 0x7FFFFF)

#define GP_WB_GET_PWMS_TIMESTAMP3_FULL_COUNTER_FROM_TIMESTAMP3_VALUES(tmp) \
        ((tmp) & 0x7FFFFF)

/* The timestamp3 of the carrier counter */
#define GP_WB_READ_PWMS_TIMESTAMP3_CARRIER() \
        (GP_WB_READ_SER_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x141e)) & 0x7F)

#define GP_WB_GET_PWMS_TIMESTAMP3_CARRIER_FROM_TIMESTAMP3_VALUES(tmp) \
        (((tmp) >> 16) & 0x7F)

/* The stable value of the input at the moment the timestamp3 is taken */
#define GP_WB_READ_PWMS_TIMESTAMP3_INPUT_ON_PREVIOUS_UPDATE() \
        GP_WB_READ_SER_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x141e), 7)

#define GP_WB_GET_PWMS_TIMESTAMP3_INPUT_ON_PREVIOUS_UPDATE_FROM_TIMESTAMP3_VALUES(tmp) \
        (((tmp) >> 23) & 0x01)


/* Clears the timestamp3 overrun interrupt, NOTE: also clears the threshold match interrupt of pwm3 */
#define GP_WB_PWMS_CLR_TIMESTAMP3_OVERRUN_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x141f), 0x01)


/* Enables the up/down mode of pwm3 */
#define GP_WB_READ_PWMS_PWM0_UP_DOWN_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1420), 0)

#define GP_WB_WRITE_PWMS_PWM0_UP_DOWN_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1420), 0, (val)); \
        } while (0)

/* Sets the drive type for the output of pwm3 */
#define GP_WB_READ_PWMS_PWM0_OUTPUT_DRIVE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1420), 1)

#define GP_WB_WRITE_PWMS_PWM0_OUTPUT_DRIVE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1420), 1, (val)); \
        } while (0)

/* Inverts the output of pwm3 */
#define GP_WB_READ_PWMS_PWM0_OUTPUT_INVERT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1420), 2)

#define GP_WB_WRITE_PWMS_PWM0_OUTPUT_INVERT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1420), 2, (val)); \
        } while (0)


/* When set to 1, a wrap of the carrier counter will trigger an update of the threshold of pwm3. */
#define GP_WB_READ_PWMS_PWM0_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1421), 0)

#define GP_WB_WRITE_PWMS_PWM0_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1421), (val)); \
        } while (0)


/* The current value of the threshold of pwm3 */
#define GP_WB_READ_PWMS_PWM0_THRESHOLD() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1422))


/* The unmasked interrupt status of the threshold match interrupt of pwm3 */
#define GP_WB_READ_PWMS_UNMASKED_PWM0_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1424), 0)


/* Updates the threshold with the next threshold of pwm3 */
#define GP_WB_PWMS_PWM0_THRESHOLD_UPDATE() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1425), 0x01)


/* Clears the threshold match interrupt of pwm3, NOTE: also clears the timestamp3 overrun interrupt */
#define GP_WB_PWMS_CLR_PWM0_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1426), 0x01)


/* Enables the up/down mode of pwm3 */
#define GP_WB_READ_PWMS_PWM1_UP_DOWN_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1428), 0)

#define GP_WB_WRITE_PWMS_PWM1_UP_DOWN_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1428), 0, (val)); \
        } while (0)

/* Sets the drive type for the output of pwm3 */
#define GP_WB_READ_PWMS_PWM1_OUTPUT_DRIVE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1428), 1)

#define GP_WB_WRITE_PWMS_PWM1_OUTPUT_DRIVE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1428), 1, (val)); \
        } while (0)

/* Inverts the output of pwm3 */
#define GP_WB_READ_PWMS_PWM1_OUTPUT_INVERT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1428), 2)

#define GP_WB_WRITE_PWMS_PWM1_OUTPUT_INVERT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1428), 2, (val)); \
        } while (0)


/* When set to 1, a wrap of the carrier counter will trigger an update of the threshold of pwm3. */
#define GP_WB_READ_PWMS_PWM1_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1429), 0)

#define GP_WB_WRITE_PWMS_PWM1_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1429), (val)); \
        } while (0)


/* The current value of the threshold of pwm3 */
#define GP_WB_READ_PWMS_PWM1_THRESHOLD() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x142a))


/* The unmasked interrupt status of the threshold match interrupt of pwm3 */
#define GP_WB_READ_PWMS_UNMASKED_PWM1_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x142c), 0)


/* Updates the threshold with the next threshold of pwm3 */
#define GP_WB_PWMS_PWM1_THRESHOLD_UPDATE() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x142d), 0x01)


/* Clears the threshold match interrupt of pwm3, NOTE: also clears the timestamp3 overrun interrupt */
#define GP_WB_PWMS_CLR_PWM1_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x142e), 0x01)


/* Enables the up/down mode of pwm3 */
#define GP_WB_READ_PWMS_PWM2_UP_DOWN_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1430), 0)

#define GP_WB_WRITE_PWMS_PWM2_UP_DOWN_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1430), 0, (val)); \
        } while (0)

/* Sets the drive type for the output of pwm3 */
#define GP_WB_READ_PWMS_PWM2_OUTPUT_DRIVE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1430), 1)

#define GP_WB_WRITE_PWMS_PWM2_OUTPUT_DRIVE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1430), 1, (val)); \
        } while (0)

/* Inverts the output of pwm3 */
#define GP_WB_READ_PWMS_PWM2_OUTPUT_INVERT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1430), 2)

#define GP_WB_WRITE_PWMS_PWM2_OUTPUT_INVERT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1430), 2, (val)); \
        } while (0)


/* When set to 1, a wrap of the carrier counter will trigger an update of the threshold of pwm3. */
#define GP_WB_READ_PWMS_PWM2_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1431), 0)

#define GP_WB_WRITE_PWMS_PWM2_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1431), (val)); \
        } while (0)


/* The current value of the threshold of pwm3 */
#define GP_WB_READ_PWMS_PWM2_THRESHOLD() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1432))


/* The unmasked interrupt status of the threshold match interrupt of pwm3 */
#define GP_WB_READ_PWMS_UNMASKED_PWM2_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1434), 0)


/* Updates the threshold with the next threshold of pwm3 */
#define GP_WB_PWMS_PWM2_THRESHOLD_UPDATE() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1435), 0x01)


/* Clears the threshold match interrupt of pwm3, NOTE: also clears the timestamp3 overrun interrupt */
#define GP_WB_PWMS_CLR_PWM2_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1436), 0x01)


/* Enables the up/down mode of pwm3 */
#define GP_WB_READ_PWMS_PWM3_UP_DOWN_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1438), 0)

#define GP_WB_WRITE_PWMS_PWM3_UP_DOWN_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1438), 0, (val)); \
        } while (0)

/* Sets the drive type for the output of pwm3 */
#define GP_WB_READ_PWMS_PWM3_OUTPUT_DRIVE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1438), 1)

#define GP_WB_WRITE_PWMS_PWM3_OUTPUT_DRIVE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1438), 1, (val)); \
        } while (0)

/* Inverts the output of pwm3 */
#define GP_WB_READ_PWMS_PWM3_OUTPUT_INVERT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1438), 2)

#define GP_WB_WRITE_PWMS_PWM3_OUTPUT_INVERT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1438), 2, (val)); \
        } while (0)


/* When set to 1, a wrap of the carrier counter will trigger an update of the threshold of pwm3. */
#define GP_WB_READ_PWMS_PWM3_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1439), 0)

#define GP_WB_WRITE_PWMS_PWM3_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1439), (val)); \
        } while (0)


/* The current value of the threshold of pwm3 */
#define GP_WB_READ_PWMS_PWM3_THRESHOLD() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x143a))


/* The unmasked interrupt status of the threshold match interrupt of pwm3 */
#define GP_WB_READ_PWMS_UNMASKED_PWM3_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x143c), 0)


/* Updates the threshold with the next threshold of pwm3 */
#define GP_WB_PWMS_PWM3_THRESHOLD_UPDATE() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x143d), 0x01)


/* Clears the threshold match interrupt of pwm3, NOTE: also clears the timestamp3 overrun interrupt */
#define GP_WB_PWMS_CLR_PWM3_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x143e), 0x01)


/* Enables the up/down mode of pwm3 */
#define GP_WB_READ_PWMS_PWM4_UP_DOWN_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1440), 0)

#define GP_WB_WRITE_PWMS_PWM4_UP_DOWN_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1440), 0, (val)); \
        } while (0)

/* Sets the drive type for the output of pwm3 */
#define GP_WB_READ_PWMS_PWM4_OUTPUT_DRIVE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1440), 1)

#define GP_WB_WRITE_PWMS_PWM4_OUTPUT_DRIVE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1440), 1, (val)); \
        } while (0)

/* Inverts the output of pwm3 */
#define GP_WB_READ_PWMS_PWM4_OUTPUT_INVERT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1440), 2)

#define GP_WB_WRITE_PWMS_PWM4_OUTPUT_INVERT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1440), 2, (val)); \
        } while (0)


/* When set to 1, a wrap of the carrier counter will trigger an update of the threshold of pwm3. */
#define GP_WB_READ_PWMS_PWM4_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1441), 0)

#define GP_WB_WRITE_PWMS_PWM4_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1441), (val)); \
        } while (0)


/* The current value of the threshold of pwm3 */
#define GP_WB_READ_PWMS_PWM4_THRESHOLD() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1442))


/* The unmasked interrupt status of the threshold match interrupt of pwm3 */
#define GP_WB_READ_PWMS_UNMASKED_PWM4_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1444), 0)


/* Updates the threshold with the next threshold of pwm3 */
#define GP_WB_PWMS_PWM4_THRESHOLD_UPDATE() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1445), 0x01)


/* Clears the threshold match interrupt of pwm3, NOTE: also clears the timestamp3 overrun interrupt */
#define GP_WB_PWMS_CLR_PWM4_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1446), 0x01)


/* Enables the up/down mode of pwm3 */
#define GP_WB_READ_PWMS_PWM5_UP_DOWN_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1448), 0)

#define GP_WB_WRITE_PWMS_PWM5_UP_DOWN_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1448), 0, (val)); \
        } while (0)

/* Sets the drive type for the output of pwm3 */
#define GP_WB_READ_PWMS_PWM5_OUTPUT_DRIVE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1448), 1)

#define GP_WB_WRITE_PWMS_PWM5_OUTPUT_DRIVE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1448), 1, (val)); \
        } while (0)

/* Inverts the output of pwm3 */
#define GP_WB_READ_PWMS_PWM5_OUTPUT_INVERT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1448), 2)

#define GP_WB_WRITE_PWMS_PWM5_OUTPUT_INVERT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1448), 2, (val)); \
        } while (0)


/* When set to 1, a wrap of the carrier counter will trigger an update of the threshold of pwm3. */
#define GP_WB_READ_PWMS_PWM5_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1449), 0)

#define GP_WB_WRITE_PWMS_PWM5_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1449), (val)); \
        } while (0)


/* The current value of the threshold of pwm3 */
#define GP_WB_READ_PWMS_PWM5_THRESHOLD() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x144a))


/* The unmasked interrupt status of the threshold match interrupt of pwm3 */
#define GP_WB_READ_PWMS_UNMASKED_PWM5_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x144c), 0)


/* Updates the threshold with the next threshold of pwm3 */
#define GP_WB_PWMS_PWM5_THRESHOLD_UPDATE() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x144d), 0x01)


/* Clears the threshold match interrupt of pwm3, NOTE: also clears the timestamp3 overrun interrupt */
#define GP_WB_PWMS_CLR_PWM5_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x144e), 0x01)


/* Enables the up/down mode of pwm3 */
#define GP_WB_READ_PWMS_PWM6_UP_DOWN_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1450), 0)

#define GP_WB_WRITE_PWMS_PWM6_UP_DOWN_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1450), 0, (val)); \
        } while (0)

/* Sets the drive type for the output of pwm3 */
#define GP_WB_READ_PWMS_PWM6_OUTPUT_DRIVE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1450), 1)

#define GP_WB_WRITE_PWMS_PWM6_OUTPUT_DRIVE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1450), 1, (val)); \
        } while (0)

/* Inverts the output of pwm3 */
#define GP_WB_READ_PWMS_PWM6_OUTPUT_INVERT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1450), 2)

#define GP_WB_WRITE_PWMS_PWM6_OUTPUT_INVERT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1450), 2, (val)); \
        } while (0)


/* When set to 1, a wrap of the carrier counter will trigger an update of the threshold of pwm3. */
#define GP_WB_READ_PWMS_PWM6_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1451), 0)

#define GP_WB_WRITE_PWMS_PWM6_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1451), (val)); \
        } while (0)


/* The current value of the threshold of pwm3 */
#define GP_WB_READ_PWMS_PWM6_THRESHOLD() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1452))


/* The unmasked interrupt status of the threshold match interrupt of pwm3 */
#define GP_WB_READ_PWMS_UNMASKED_PWM6_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1454), 0)


/* Updates the threshold with the next threshold of pwm3 */
#define GP_WB_PWMS_PWM6_THRESHOLD_UPDATE() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1455), 0x01)


/* Clears the threshold match interrupt of pwm3, NOTE: also clears the timestamp3 overrun interrupt */
#define GP_WB_PWMS_CLR_PWM6_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1456), 0x01)


/* Enables the up/down mode of pwm3 */
#define GP_WB_READ_PWMS_PWM7_UP_DOWN_ENABLE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1458), 0)

#define GP_WB_WRITE_PWMS_PWM7_UP_DOWN_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1458), 0, (val)); \
        } while (0)

/* Sets the drive type for the output of pwm3 */
#define GP_WB_READ_PWMS_PWM7_OUTPUT_DRIVE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1458), 1)

#define GP_WB_WRITE_PWMS_PWM7_OUTPUT_DRIVE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1458), 1, (val)); \
        } while (0)

/* Inverts the output of pwm3 */
#define GP_WB_READ_PWMS_PWM7_OUTPUT_INVERT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1458), 2)

#define GP_WB_WRITE_PWMS_PWM7_OUTPUT_INVERT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1458), 2, (val)); \
        } while (0)


/* When set to 1, a wrap of the carrier counter will trigger an update of the threshold of pwm3. */
#define GP_WB_READ_PWMS_PWM7_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1459), 0)

#define GP_WB_WRITE_PWMS_PWM7_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1459), (val)); \
        } while (0)


/* The current value of the threshold of pwm3 */
#define GP_WB_READ_PWMS_PWM7_THRESHOLD() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x145a))


/* The unmasked interrupt status of the threshold match interrupt of pwm3 */
#define GP_WB_READ_PWMS_UNMASKED_PWM7_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x145c), 0)


/* Updates the threshold with the next threshold of pwm3 */
#define GP_WB_PWMS_PWM7_THRESHOLD_UPDATE() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x145d), 0x01)


/* Clears the threshold match interrupt of pwm3, NOTE: also clears the timestamp3 overrun interrupt */
#define GP_WB_PWMS_CLR_PWM7_THRESHOLD_MATCH_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x145e), 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PWMS_CONFIG() \
        GP_WB_READ_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1460))

#define GP_WB_WRITE_PWMS_CONFIG(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1460), (val))

/* timer counter value to use as main counter value (16 bit) */
#define GP_WB_READ_PWMS_MAIN_TMR() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1460)) & 0x07)

#define GP_WB_GET_PWMS_MAIN_TMR_FROM_CONFIG(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_PWMS_MAIN_TMR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1460), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_PWMS_MAIN_TMR_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x3770; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* timer counter value to use as carrier counter value, only lower 7 bits are used */
#define GP_WB_READ_PWMS_CARRIER_TMR() \
        ((GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1460)) >> 4) & 0x07)

#define GP_WB_GET_PWMS_CARRIER_TMR_FROM_CONFIG(tmp) \
        (((tmp) >> 4) & 0x07)

#define GP_WB_WRITE_PWMS_CARRIER_TMR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1460), 0x70, (val) << 4); \
        } while (0)

#define GP_WB_SET_PWMS_CARRIER_TMR_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x3707; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* timer wrap to use as trigger to check the timestamp input value for the timestamp stable logic */
#define GP_WB_READ_PWMS_TIMESTAMP_TMR() \
        (GP_WB_READ_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1461)) & 0x07)

#define GP_WB_GET_PWMS_TIMESTAMP_TMR_FROM_CONFIG(tmp) \
        (((tmp) >> 8) & 0x07)

#define GP_WB_WRITE_PWMS_TIMESTAMP_TMR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1461), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_PWMS_TIMESTAMP_TMR_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x3077; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* When set to 1, the next threshold fifo works in 16-bit word mode. In this mode, writing the next_threshold property, pushes an entry in the FIFO. When set to 0, the next threshold fifo works in byte mode. In this mode, writing the next_threshold_0 property pushes an entry in the fifo. */
#define GP_WB_READ_PWMS_NEXT_THRESHOLD_FIFO_SIZE() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1461), 4)

#define GP_WB_GET_PWMS_NEXT_THRESHOLD_FIFO_SIZE_FROM_CONFIG(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_PWMS_NEXT_THRESHOLD_FIFO_SIZE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1461), 4, (val)); \
        } while (0)

#define GP_WB_SET_PWMS_NEXT_THRESHOLD_FIFO_SIZE_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2777; \
          (tmp) |= (((UInt16)(val)) << 12); \
        } while (0)

/* Automatically perform a logical shift on the 'threshold update on carrier counter wrap' value, on each carrier counter wrap. */
#define GP_WB_READ_PWMS_AUTO_SHIFT_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1461), 5)

#define GP_WB_GET_PWMS_AUTO_SHIFT_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP_FROM_CONFIG(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_PWMS_AUTO_SHIFT_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1461), 5, (val)); \
        } while (0)

#define GP_WB_SET_PWMS_AUTO_SHIFT_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1777; \
          (tmp) |= (((UInt16)(val)) << 13); \
        } while (0)


#define GP_WB_WRITE_PWMS_NEXT_THRESHOLD_PB(val) \
      GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1462), (val))

/* The LSB of the next threshold */
#define GP_WB_WRITE_PWMS_NEXT_THRESHOLD_0(val) do { \
          GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1462), (val)); \
        } while (0)

#define GP_WB_SET_PWMS_NEXT_THRESHOLD_0_TO_NEXT_THRESHOLD_PB(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          (tmp) &= 0xFF00; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* The next threshold */
#define GP_WB_WRITE_PWMS_NEXT_THRESHOLD(val) do { \
          GP_WB_WRITE_U16(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1462), (val)); \
        } while (0)

#define GP_WB_SET_PWMS_NEXT_THRESHOLD_TO_NEXT_THRESHOLD_PB(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          (tmp) &= 0x0000; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)


/* The unmasked interrupt status of the next threshold underrun interrupt */
#define GP_WB_READ_PWMS_UNMASKED_NEXT_THRESHOLD_UNDERRUN_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1464), 0)

/* The unmasked interrupt status of the next threshold not full interrupt */
#define GP_WB_READ_PWMS_UNMASKED_NEXT_THRESHOLD_NOT_FULL_INTERRUPT() \
        GP_WB_READ_U1(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1464), 1)


/* Clears the next threshold underrun interrupt */
#define GP_WB_PWMS_CLR_NEXT_THRESHOLD_UNDERRUN_INTERRUPT() \
        GP_WB_WRITE_U8(GP_MM_WISHB_ADDR_FROM_COMPRESSED(0x1465), 0x01)

/***************************
 * layout: fll_table
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_FLL_TABLE_CHIDX_0_0() \
        GP_WB_READ_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2600))

#define GP_WB_WRITE_FLL_TABLE_CHIDX_0_0(val) \
      GP_WB_WRITE_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2600), (val))

/* lf preload value for channel idx 0 */
#define GP_WB_READ_FLL_TABLE_LF_PRELOAD_0() \
        (GP_WB_S24((GP_WB_READ_U24(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2600)) & 0x3FFFFF), 22))

#define GP_WB_GET_FLL_TABLE_LF_PRELOAD_0_FROM_CHIDX_0_0(tmp) \
        (GP_WB_S24(((tmp) & 0x3FFFFF), 22))

#define GP_WB_WRITE_FLL_TABLE_LF_PRELOAD_0(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -2097152, 2097151); \
          GP_WB_MWRITE_U24(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2600), 0x3FFFFF, (UInt32)((val))); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_LF_PRELOAD_0_TO_CHIDX_0_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK_SIGNED(val, -2097152, 2097151); \
          (tmp) &= 0x7FC00000; \
          (tmp) |= (((Int32)(val)) & 0x003FFFFF); \
        } while (0)

/* Loop gain setting for channel idx 0 */
#define GP_WB_READ_FLL_TABLE_LOOP_GAIN_0() \
        ((GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2602)) >> 6) & 0x01FF)

#define GP_WB_GET_FLL_TABLE_LOOP_GAIN_0_FROM_CHIDX_0_0(tmp) \
        (((tmp) >> 22) & 0x01FF)

#define GP_WB_WRITE_FLL_TABLE_LOOP_GAIN_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          GP_WB_MWRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2602), 0x7FC0, (UInt16)(val) << 6); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_LOOP_GAIN_0_TO_CHIDX_0_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          (tmp) &= 0x003FFFFF; \
          (tmp) |= (((UInt32)(val)) << 22); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_FLL_TABLE_CHIDX_0_1() \
        GP_WB_READ_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2604))

#define GP_WB_WRITE_FLL_TABLE_CHIDX_0_1(val) \
      GP_WB_WRITE_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2604), (val))

/* Target frequency setting for tx on channel idx 0 */
#define GP_WB_READ_FLL_TABLE_F_TARGET_TX_0() \
        (GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2604)) & 0x01FF)

#define GP_WB_GET_FLL_TABLE_F_TARGET_TX_0_FROM_CHIDX_0_1(tmp) \
        ((tmp) & 0x01FF)

#define GP_WB_WRITE_FLL_TABLE_F_TARGET_TX_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          GP_WB_MWRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2604), 0x01FF, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_F_TARGET_TX_0_TO_CHIDX_0_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          (tmp) &= 0x7FFFFE00; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Fine tx capbank setting for channel idx 0 */
#define GP_WB_READ_FLL_TABLE_CAPBANK_FINE_TX_0() \
        ((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2605)) >> 1) & 0x7F)

#define GP_WB_GET_FLL_TABLE_CAPBANK_FINE_TX_0_FROM_CHIDX_0_1(tmp) \
        (((tmp) >> 9) & 0x7F)

#define GP_WB_WRITE_FLL_TABLE_CAPBANK_FINE_TX_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2605), 0xFE, (val) << 1); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_CAPBANK_FINE_TX_0_TO_CHIDX_0_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          (tmp) &= 0x7FFF01FF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* DTC step size for TX on for channel idx 0 */
#define GP_WB_READ_FLL_TABLE_DTC_STEP_TX_0() \
        (GP_WB_S8((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2606)) & 0x7F), 7))

#define GP_WB_GET_FLL_TABLE_DTC_STEP_TX_0_FROM_CHIDX_0_1(tmp) \
        (GP_WB_S8((((tmp) >> 16) & 0x7F), 7))

#define GP_WB_WRITE_FLL_TABLE_DTC_STEP_TX_0(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -64, 63); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2606), 0x7F, (UInt8)((val))); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_DTC_STEP_TX_0_TO_CHIDX_0_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK_SIGNED(val, -64, 63); \
          (tmp) &= 0x7F80FFFF; \
          (tmp) |= ((((Int32)(val)) << 16) & 0x007F0000); \
        } while (0)

/* Loop sign for TX on for channel idx 0 is negative */
#define GP_WB_READ_FLL_TABLE_LOOP_SIGN_NEG_TX_0() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2606), 7)

#define GP_WB_GET_FLL_TABLE_LOOP_SIGN_NEG_TX_0_FROM_CHIDX_0_1(tmp) \
        (((tmp) >> 23) & 0x01)

#define GP_WB_WRITE_FLL_TABLE_LOOP_SIGN_NEG_TX_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2606), 7, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_LOOP_SIGN_NEG_TX_0_TO_CHIDX_0_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F7FFFFF; \
          (tmp) |= (((UInt32)(val)) << 23); \
        } while (0)

/* Error corrector patterns for TX on for channel idx 0 */
#define GP_WB_READ_FLL_TABLE_ERR_CORR_TX_0() \
        (GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2607)) & 0x07)

#define GP_WB_GET_FLL_TABLE_ERR_CORR_TX_0_FROM_CHIDX_0_1(tmp) \
        (((tmp) >> 24) & 0x07)

#define GP_WB_WRITE_FLL_TABLE_ERR_CORR_TX_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2607), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_ERR_CORR_TX_0_TO_CHIDX_0_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x78FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)

/* Mode ctrl bits for channel idx 0 */
#define GP_WB_READ_FLL_TABLE_CHANNEL_CTRL_0() \
        ((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2607)) >> 3) & 0x0F)

#define GP_WB_GET_FLL_TABLE_CHANNEL_CTRL_0_FROM_CHIDX_0_1(tmp) \
        (((tmp) >> 27) & 0x0F)

#define GP_WB_WRITE_FLL_TABLE_CHANNEL_CTRL_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2607), 0x78, (val) << 3); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_CHANNEL_CTRL_0_TO_CHIDX_0_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x07FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 27); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_FLL_TABLE_CHIDX_0_2() \
        GP_WB_READ_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2608))

#define GP_WB_WRITE_FLL_TABLE_CHIDX_0_2(val) \
      GP_WB_WRITE_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2608), (val))

/* Target frequency setting for rx on channel idx 0 */
#define GP_WB_READ_FLL_TABLE_F_TARGET_RX_0() \
        (GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2608)) & 0x01FF)

#define GP_WB_GET_FLL_TABLE_F_TARGET_RX_0_FROM_CHIDX_0_2(tmp) \
        ((tmp) & 0x01FF)

#define GP_WB_WRITE_FLL_TABLE_F_TARGET_RX_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          GP_WB_MWRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2608), 0x01FF, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_F_TARGET_RX_0_TO_CHIDX_0_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          (tmp) &= 0x3FFFFE00; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* fine rx  capbank setting for channel idx 0 */
#define GP_WB_READ_FLL_TABLE_CAPBANK_FINE_RX_0() \
        ((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2609)) >> 1) & 0x7F)

#define GP_WB_GET_FLL_TABLE_CAPBANK_FINE_RX_0_FROM_CHIDX_0_2(tmp) \
        (((tmp) >> 9) & 0x7F)

#define GP_WB_WRITE_FLL_TABLE_CAPBANK_FINE_RX_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2609), 0xFE, (val) << 1); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_CAPBANK_FINE_RX_0_TO_CHIDX_0_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          (tmp) &= 0x3FFF01FF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* DTC step size for RX on for channel idx 0 */
#define GP_WB_READ_FLL_TABLE_DTC_STEP_RX_0() \
        (GP_WB_S8((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc260a)) & 0x7F), 7))

#define GP_WB_GET_FLL_TABLE_DTC_STEP_RX_0_FROM_CHIDX_0_2(tmp) \
        (GP_WB_S8((((tmp) >> 16) & 0x7F), 7))

#define GP_WB_WRITE_FLL_TABLE_DTC_STEP_RX_0(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -64, 63); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc260a), 0x7F, (UInt8)((val))); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_DTC_STEP_RX_0_TO_CHIDX_0_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK_SIGNED(val, -64, 63); \
          (tmp) &= 0x3F80FFFF; \
          (tmp) |= ((((Int32)(val)) << 16) & 0x007F0000); \
        } while (0)

/* Loop sign for rx on for channel idx 0 is negative */
#define GP_WB_READ_FLL_TABLE_LOOP_SIGN_NEG_RX_0() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc260a), 7)

#define GP_WB_GET_FLL_TABLE_LOOP_SIGN_NEG_RX_0_FROM_CHIDX_0_2(tmp) \
        (((tmp) >> 23) & 0x01)

#define GP_WB_WRITE_FLL_TABLE_LOOP_SIGN_NEG_RX_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc260a), 7, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_LOOP_SIGN_NEG_RX_0_TO_CHIDX_0_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F7FFFFF; \
          (tmp) |= (((UInt32)(val)) << 23); \
        } while (0)

/* Error corrector patterns for RX on for channel idx 0 */
#define GP_WB_READ_FLL_TABLE_ERR_CORR_RX_0() \
        (GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc260b)) & 0x07)

#define GP_WB_GET_FLL_TABLE_ERR_CORR_RX_0_FROM_CHIDX_0_2(tmp) \
        (((tmp) >> 24) & 0x07)

#define GP_WB_WRITE_FLL_TABLE_ERR_CORR_RX_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc260b), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_ERR_CORR_RX_0_TO_CHIDX_0_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x38FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)

/* DCDC frequency choice for channel idx 0 */
#define GP_WB_READ_FLL_TABLE_DCDC_0() \
        ((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc260b)) >> 3) & 0x07)

#define GP_WB_GET_FLL_TABLE_DCDC_0_FROM_CHIDX_0_2(tmp) \
        (((tmp) >> 27) & 0x07)

#define GP_WB_WRITE_FLL_TABLE_DCDC_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc260b), 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_DCDC_0_TO_CHIDX_0_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x07FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 27); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_FLL_TABLE_CHIDX_1_0() \
        GP_WB_READ_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2610))

#define GP_WB_WRITE_FLL_TABLE_CHIDX_1_0(val) \
      GP_WB_WRITE_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2610), (val))

/* lf preload value for channel idx 1 */
#define GP_WB_READ_FLL_TABLE_LF_PRELOAD_1() \
        (GP_WB_S24((GP_WB_READ_U24(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2610)) & 0x3FFFFF), 22))

#define GP_WB_GET_FLL_TABLE_LF_PRELOAD_1_FROM_CHIDX_1_0(tmp) \
        (GP_WB_S24(((tmp) & 0x3FFFFF), 22))

#define GP_WB_WRITE_FLL_TABLE_LF_PRELOAD_1(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -2097152, 2097151); \
          GP_WB_MWRITE_U24(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2610), 0x3FFFFF, (UInt32)((val))); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_LF_PRELOAD_1_TO_CHIDX_1_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK_SIGNED(val, -2097152, 2097151); \
          (tmp) &= 0x7FC00000; \
          (tmp) |= (((Int32)(val)) & 0x003FFFFF); \
        } while (0)

/* Loop gain setting for channel idx 1 */
#define GP_WB_READ_FLL_TABLE_LOOP_GAIN_1() \
        ((GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2612)) >> 6) & 0x01FF)

#define GP_WB_GET_FLL_TABLE_LOOP_GAIN_1_FROM_CHIDX_1_0(tmp) \
        (((tmp) >> 22) & 0x01FF)

#define GP_WB_WRITE_FLL_TABLE_LOOP_GAIN_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          GP_WB_MWRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2612), 0x7FC0, (UInt16)(val) << 6); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_LOOP_GAIN_1_TO_CHIDX_1_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          (tmp) &= 0x003FFFFF; \
          (tmp) |= (((UInt32)(val)) << 22); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_FLL_TABLE_CHIDX_1_1() \
        GP_WB_READ_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2614))

#define GP_WB_WRITE_FLL_TABLE_CHIDX_1_1(val) \
      GP_WB_WRITE_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2614), (val))

/* Target frequency setting for tx on channel idx 1 */
#define GP_WB_READ_FLL_TABLE_F_TARGET_TX_1() \
        (GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2614)) & 0x01FF)

#define GP_WB_GET_FLL_TABLE_F_TARGET_TX_1_FROM_CHIDX_1_1(tmp) \
        ((tmp) & 0x01FF)

#define GP_WB_WRITE_FLL_TABLE_F_TARGET_TX_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          GP_WB_MWRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2614), 0x01FF, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_F_TARGET_TX_1_TO_CHIDX_1_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          (tmp) &= 0x7FFFFE00; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Fine tx capbank setting for channel idx 1 */
#define GP_WB_READ_FLL_TABLE_CAPBANK_FINE_TX_1() \
        ((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2615)) >> 1) & 0x7F)

#define GP_WB_GET_FLL_TABLE_CAPBANK_FINE_TX_1_FROM_CHIDX_1_1(tmp) \
        (((tmp) >> 9) & 0x7F)

#define GP_WB_WRITE_FLL_TABLE_CAPBANK_FINE_TX_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2615), 0xFE, (val) << 1); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_CAPBANK_FINE_TX_1_TO_CHIDX_1_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          (tmp) &= 0x7FFF01FF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* DTC step size for TX on for channel idx 1 */
#define GP_WB_READ_FLL_TABLE_DTC_STEP_TX_1() \
        (GP_WB_S8((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2616)) & 0x7F), 7))

#define GP_WB_GET_FLL_TABLE_DTC_STEP_TX_1_FROM_CHIDX_1_1(tmp) \
        (GP_WB_S8((((tmp) >> 16) & 0x7F), 7))

#define GP_WB_WRITE_FLL_TABLE_DTC_STEP_TX_1(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -64, 63); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2616), 0x7F, (UInt8)((val))); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_DTC_STEP_TX_1_TO_CHIDX_1_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK_SIGNED(val, -64, 63); \
          (tmp) &= 0x7F80FFFF; \
          (tmp) |= ((((Int32)(val)) << 16) & 0x007F0000); \
        } while (0)

/* Loop sign for TX on for channel idx 1 is negative */
#define GP_WB_READ_FLL_TABLE_LOOP_SIGN_NEG_TX_1() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2616), 7)

#define GP_WB_GET_FLL_TABLE_LOOP_SIGN_NEG_TX_1_FROM_CHIDX_1_1(tmp) \
        (((tmp) >> 23) & 0x01)

#define GP_WB_WRITE_FLL_TABLE_LOOP_SIGN_NEG_TX_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2616), 7, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_LOOP_SIGN_NEG_TX_1_TO_CHIDX_1_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F7FFFFF; \
          (tmp) |= (((UInt32)(val)) << 23); \
        } while (0)

/* Error corrector patterns for TX on for channel idx 1 */
#define GP_WB_READ_FLL_TABLE_ERR_CORR_TX_1() \
        (GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2617)) & 0x07)

#define GP_WB_GET_FLL_TABLE_ERR_CORR_TX_1_FROM_CHIDX_1_1(tmp) \
        (((tmp) >> 24) & 0x07)

#define GP_WB_WRITE_FLL_TABLE_ERR_CORR_TX_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2617), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_ERR_CORR_TX_1_TO_CHIDX_1_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x78FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)

/* Mode ctrl bits for channel idx 1 */
#define GP_WB_READ_FLL_TABLE_CHANNEL_CTRL_1() \
        ((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2617)) >> 3) & 0x0F)

#define GP_WB_GET_FLL_TABLE_CHANNEL_CTRL_1_FROM_CHIDX_1_1(tmp) \
        (((tmp) >> 27) & 0x0F)

#define GP_WB_WRITE_FLL_TABLE_CHANNEL_CTRL_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2617), 0x78, (val) << 3); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_CHANNEL_CTRL_1_TO_CHIDX_1_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x07FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 27); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_FLL_TABLE_CHIDX_1_2() \
        GP_WB_READ_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2618))

#define GP_WB_WRITE_FLL_TABLE_CHIDX_1_2(val) \
      GP_WB_WRITE_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2618), (val))

/* Target frequency setting for rx on channel idx 1 */
#define GP_WB_READ_FLL_TABLE_F_TARGET_RX_1() \
        (GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2618)) & 0x01FF)

#define GP_WB_GET_FLL_TABLE_F_TARGET_RX_1_FROM_CHIDX_1_2(tmp) \
        ((tmp) & 0x01FF)

#define GP_WB_WRITE_FLL_TABLE_F_TARGET_RX_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          GP_WB_MWRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2618), 0x01FF, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_F_TARGET_RX_1_TO_CHIDX_1_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          (tmp) &= 0x3FFFFE00; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* fine rx  capbank setting for channel idx 1 */
#define GP_WB_READ_FLL_TABLE_CAPBANK_FINE_RX_1() \
        ((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2619)) >> 1) & 0x7F)

#define GP_WB_GET_FLL_TABLE_CAPBANK_FINE_RX_1_FROM_CHIDX_1_2(tmp) \
        (((tmp) >> 9) & 0x7F)

#define GP_WB_WRITE_FLL_TABLE_CAPBANK_FINE_RX_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2619), 0xFE, (val) << 1); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_CAPBANK_FINE_RX_1_TO_CHIDX_1_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          (tmp) &= 0x3FFF01FF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* DTC step size for RX on for channel idx 1 */
#define GP_WB_READ_FLL_TABLE_DTC_STEP_RX_1() \
        (GP_WB_S8((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc261a)) & 0x7F), 7))

#define GP_WB_GET_FLL_TABLE_DTC_STEP_RX_1_FROM_CHIDX_1_2(tmp) \
        (GP_WB_S8((((tmp) >> 16) & 0x7F), 7))

#define GP_WB_WRITE_FLL_TABLE_DTC_STEP_RX_1(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -64, 63); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc261a), 0x7F, (UInt8)((val))); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_DTC_STEP_RX_1_TO_CHIDX_1_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK_SIGNED(val, -64, 63); \
          (tmp) &= 0x3F80FFFF; \
          (tmp) |= ((((Int32)(val)) << 16) & 0x007F0000); \
        } while (0)

/* Loop sign for rx on for channel idx 1 is negative */
#define GP_WB_READ_FLL_TABLE_LOOP_SIGN_NEG_RX_1() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc261a), 7)

#define GP_WB_GET_FLL_TABLE_LOOP_SIGN_NEG_RX_1_FROM_CHIDX_1_2(tmp) \
        (((tmp) >> 23) & 0x01)

#define GP_WB_WRITE_FLL_TABLE_LOOP_SIGN_NEG_RX_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc261a), 7, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_LOOP_SIGN_NEG_RX_1_TO_CHIDX_1_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F7FFFFF; \
          (tmp) |= (((UInt32)(val)) << 23); \
        } while (0)

/* Error corrector patterns for RX on for channel idx 1 */
#define GP_WB_READ_FLL_TABLE_ERR_CORR_RX_1() \
        (GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc261b)) & 0x07)

#define GP_WB_GET_FLL_TABLE_ERR_CORR_RX_1_FROM_CHIDX_1_2(tmp) \
        (((tmp) >> 24) & 0x07)

#define GP_WB_WRITE_FLL_TABLE_ERR_CORR_RX_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc261b), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_ERR_CORR_RX_1_TO_CHIDX_1_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x38FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)

/* DCDC frequency choice for channel idx 1 */
#define GP_WB_READ_FLL_TABLE_DCDC_1() \
        ((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc261b)) >> 3) & 0x07)

#define GP_WB_GET_FLL_TABLE_DCDC_1_FROM_CHIDX_1_2(tmp) \
        (((tmp) >> 27) & 0x07)

#define GP_WB_WRITE_FLL_TABLE_DCDC_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc261b), 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_DCDC_1_TO_CHIDX_1_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x07FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 27); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_FLL_TABLE_CHIDX_2_0() \
        GP_WB_READ_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2620))

#define GP_WB_WRITE_FLL_TABLE_CHIDX_2_0(val) \
      GP_WB_WRITE_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2620), (val))

/* lf preload value for channel idx 2 */
#define GP_WB_READ_FLL_TABLE_LF_PRELOAD_2() \
        (GP_WB_S24((GP_WB_READ_U24(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2620)) & 0x3FFFFF), 22))

#define GP_WB_GET_FLL_TABLE_LF_PRELOAD_2_FROM_CHIDX_2_0(tmp) \
        (GP_WB_S24(((tmp) & 0x3FFFFF), 22))

#define GP_WB_WRITE_FLL_TABLE_LF_PRELOAD_2(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -2097152, 2097151); \
          GP_WB_MWRITE_U24(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2620), 0x3FFFFF, (UInt32)((val))); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_LF_PRELOAD_2_TO_CHIDX_2_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK_SIGNED(val, -2097152, 2097151); \
          (tmp) &= 0x7FC00000; \
          (tmp) |= (((Int32)(val)) & 0x003FFFFF); \
        } while (0)

/* Loop gain setting for channel idx 2 */
#define GP_WB_READ_FLL_TABLE_LOOP_GAIN_2() \
        ((GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2622)) >> 6) & 0x01FF)

#define GP_WB_GET_FLL_TABLE_LOOP_GAIN_2_FROM_CHIDX_2_0(tmp) \
        (((tmp) >> 22) & 0x01FF)

#define GP_WB_WRITE_FLL_TABLE_LOOP_GAIN_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          GP_WB_MWRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2622), 0x7FC0, (UInt16)(val) << 6); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_LOOP_GAIN_2_TO_CHIDX_2_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          (tmp) &= 0x003FFFFF; \
          (tmp) |= (((UInt32)(val)) << 22); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_FLL_TABLE_CHIDX_2_1() \
        GP_WB_READ_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2624))

#define GP_WB_WRITE_FLL_TABLE_CHIDX_2_1(val) \
      GP_WB_WRITE_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2624), (val))

/* Target frequency setting for tx on channel idx 2 */
#define GP_WB_READ_FLL_TABLE_F_TARGET_TX_2() \
        (GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2624)) & 0x01FF)

#define GP_WB_GET_FLL_TABLE_F_TARGET_TX_2_FROM_CHIDX_2_1(tmp) \
        ((tmp) & 0x01FF)

#define GP_WB_WRITE_FLL_TABLE_F_TARGET_TX_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          GP_WB_MWRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2624), 0x01FF, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_F_TARGET_TX_2_TO_CHIDX_2_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          (tmp) &= 0x7FFFFE00; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Fine tx capbank setting for channel idx 2 */
#define GP_WB_READ_FLL_TABLE_CAPBANK_FINE_TX_2() \
        ((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2625)) >> 1) & 0x7F)

#define GP_WB_GET_FLL_TABLE_CAPBANK_FINE_TX_2_FROM_CHIDX_2_1(tmp) \
        (((tmp) >> 9) & 0x7F)

#define GP_WB_WRITE_FLL_TABLE_CAPBANK_FINE_TX_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2625), 0xFE, (val) << 1); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_CAPBANK_FINE_TX_2_TO_CHIDX_2_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          (tmp) &= 0x7FFF01FF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* DTC step size for TX on for channel idx 2 */
#define GP_WB_READ_FLL_TABLE_DTC_STEP_TX_2() \
        (GP_WB_S8((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2626)) & 0x7F), 7))

#define GP_WB_GET_FLL_TABLE_DTC_STEP_TX_2_FROM_CHIDX_2_1(tmp) \
        (GP_WB_S8((((tmp) >> 16) & 0x7F), 7))

#define GP_WB_WRITE_FLL_TABLE_DTC_STEP_TX_2(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -64, 63); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2626), 0x7F, (UInt8)((val))); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_DTC_STEP_TX_2_TO_CHIDX_2_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK_SIGNED(val, -64, 63); \
          (tmp) &= 0x7F80FFFF; \
          (tmp) |= ((((Int32)(val)) << 16) & 0x007F0000); \
        } while (0)

/* Loop sign for TX on for channel idx 2 is negative */
#define GP_WB_READ_FLL_TABLE_LOOP_SIGN_NEG_TX_2() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2626), 7)

#define GP_WB_GET_FLL_TABLE_LOOP_SIGN_NEG_TX_2_FROM_CHIDX_2_1(tmp) \
        (((tmp) >> 23) & 0x01)

#define GP_WB_WRITE_FLL_TABLE_LOOP_SIGN_NEG_TX_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2626), 7, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_LOOP_SIGN_NEG_TX_2_TO_CHIDX_2_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F7FFFFF; \
          (tmp) |= (((UInt32)(val)) << 23); \
        } while (0)

/* Error corrector patterns for TX on for channel idx 2 */
#define GP_WB_READ_FLL_TABLE_ERR_CORR_TX_2() \
        (GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2627)) & 0x07)

#define GP_WB_GET_FLL_TABLE_ERR_CORR_TX_2_FROM_CHIDX_2_1(tmp) \
        (((tmp) >> 24) & 0x07)

#define GP_WB_WRITE_FLL_TABLE_ERR_CORR_TX_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2627), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_ERR_CORR_TX_2_TO_CHIDX_2_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x78FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)

/* Mode ctrl bits for channel idx 2 */
#define GP_WB_READ_FLL_TABLE_CHANNEL_CTRL_2() \
        ((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2627)) >> 3) & 0x0F)

#define GP_WB_GET_FLL_TABLE_CHANNEL_CTRL_2_FROM_CHIDX_2_1(tmp) \
        (((tmp) >> 27) & 0x0F)

#define GP_WB_WRITE_FLL_TABLE_CHANNEL_CTRL_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2627), 0x78, (val) << 3); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_CHANNEL_CTRL_2_TO_CHIDX_2_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x07FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 27); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_FLL_TABLE_CHIDX_2_2() \
        GP_WB_READ_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2628))

#define GP_WB_WRITE_FLL_TABLE_CHIDX_2_2(val) \
      GP_WB_WRITE_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2628), (val))

/* Target frequency setting for rx on channel idx 2 */
#define GP_WB_READ_FLL_TABLE_F_TARGET_RX_2() \
        (GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2628)) & 0x01FF)

#define GP_WB_GET_FLL_TABLE_F_TARGET_RX_2_FROM_CHIDX_2_2(tmp) \
        ((tmp) & 0x01FF)

#define GP_WB_WRITE_FLL_TABLE_F_TARGET_RX_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          GP_WB_MWRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2628), 0x01FF, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_F_TARGET_RX_2_TO_CHIDX_2_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          (tmp) &= 0x3FFFFE00; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* fine rx  capbank setting for channel idx 2 */
#define GP_WB_READ_FLL_TABLE_CAPBANK_FINE_RX_2() \
        ((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2629)) >> 1) & 0x7F)

#define GP_WB_GET_FLL_TABLE_CAPBANK_FINE_RX_2_FROM_CHIDX_2_2(tmp) \
        (((tmp) >> 9) & 0x7F)

#define GP_WB_WRITE_FLL_TABLE_CAPBANK_FINE_RX_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2629), 0xFE, (val) << 1); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_CAPBANK_FINE_RX_2_TO_CHIDX_2_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          (tmp) &= 0x3FFF01FF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* DTC step size for RX on for channel idx 2 */
#define GP_WB_READ_FLL_TABLE_DTC_STEP_RX_2() \
        (GP_WB_S8((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc262a)) & 0x7F), 7))

#define GP_WB_GET_FLL_TABLE_DTC_STEP_RX_2_FROM_CHIDX_2_2(tmp) \
        (GP_WB_S8((((tmp) >> 16) & 0x7F), 7))

#define GP_WB_WRITE_FLL_TABLE_DTC_STEP_RX_2(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -64, 63); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc262a), 0x7F, (UInt8)((val))); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_DTC_STEP_RX_2_TO_CHIDX_2_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK_SIGNED(val, -64, 63); \
          (tmp) &= 0x3F80FFFF; \
          (tmp) |= ((((Int32)(val)) << 16) & 0x007F0000); \
        } while (0)

/* Loop sign for rx on for channel idx 2 is negative */
#define GP_WB_READ_FLL_TABLE_LOOP_SIGN_NEG_RX_2() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc262a), 7)

#define GP_WB_GET_FLL_TABLE_LOOP_SIGN_NEG_RX_2_FROM_CHIDX_2_2(tmp) \
        (((tmp) >> 23) & 0x01)

#define GP_WB_WRITE_FLL_TABLE_LOOP_SIGN_NEG_RX_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc262a), 7, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_LOOP_SIGN_NEG_RX_2_TO_CHIDX_2_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F7FFFFF; \
          (tmp) |= (((UInt32)(val)) << 23); \
        } while (0)

/* Error corrector patterns for RX on for channel idx 2 */
#define GP_WB_READ_FLL_TABLE_ERR_CORR_RX_2() \
        (GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc262b)) & 0x07)

#define GP_WB_GET_FLL_TABLE_ERR_CORR_RX_2_FROM_CHIDX_2_2(tmp) \
        (((tmp) >> 24) & 0x07)

#define GP_WB_WRITE_FLL_TABLE_ERR_CORR_RX_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc262b), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_ERR_CORR_RX_2_TO_CHIDX_2_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x38FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)

/* DCDC frequency choice for channel idx 2 */
#define GP_WB_READ_FLL_TABLE_DCDC_2() \
        ((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc262b)) >> 3) & 0x07)

#define GP_WB_GET_FLL_TABLE_DCDC_2_FROM_CHIDX_2_2(tmp) \
        (((tmp) >> 27) & 0x07)

#define GP_WB_WRITE_FLL_TABLE_DCDC_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc262b), 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_DCDC_2_TO_CHIDX_2_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x07FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 27); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_FLL_TABLE_CHIDX_3_0() \
        GP_WB_READ_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2630))

#define GP_WB_WRITE_FLL_TABLE_CHIDX_3_0(val) \
      GP_WB_WRITE_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2630), (val))

/* lf preload value for channel idx 3 */
#define GP_WB_READ_FLL_TABLE_LF_PRELOAD_3() \
        (GP_WB_S24((GP_WB_READ_U24(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2630)) & 0x3FFFFF), 22))

#define GP_WB_GET_FLL_TABLE_LF_PRELOAD_3_FROM_CHIDX_3_0(tmp) \
        (GP_WB_S24(((tmp) & 0x3FFFFF), 22))

#define GP_WB_WRITE_FLL_TABLE_LF_PRELOAD_3(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -2097152, 2097151); \
          GP_WB_MWRITE_U24(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2630), 0x3FFFFF, (UInt32)((val))); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_LF_PRELOAD_3_TO_CHIDX_3_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK_SIGNED(val, -2097152, 2097151); \
          (tmp) &= 0x7FC00000; \
          (tmp) |= (((Int32)(val)) & 0x003FFFFF); \
        } while (0)

/* Loop gain setting for channel idx 3 */
#define GP_WB_READ_FLL_TABLE_LOOP_GAIN_3() \
        ((GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2632)) >> 6) & 0x01FF)

#define GP_WB_GET_FLL_TABLE_LOOP_GAIN_3_FROM_CHIDX_3_0(tmp) \
        (((tmp) >> 22) & 0x01FF)

#define GP_WB_WRITE_FLL_TABLE_LOOP_GAIN_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          GP_WB_MWRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2632), 0x7FC0, (UInt16)(val) << 6); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_LOOP_GAIN_3_TO_CHIDX_3_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          (tmp) &= 0x003FFFFF; \
          (tmp) |= (((UInt32)(val)) << 22); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_FLL_TABLE_CHIDX_3_1() \
        GP_WB_READ_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2634))

#define GP_WB_WRITE_FLL_TABLE_CHIDX_3_1(val) \
      GP_WB_WRITE_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2634), (val))

/* Target frequency setting for tx on channel idx 3 */
#define GP_WB_READ_FLL_TABLE_F_TARGET_TX_3() \
        (GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2634)) & 0x01FF)

#define GP_WB_GET_FLL_TABLE_F_TARGET_TX_3_FROM_CHIDX_3_1(tmp) \
        ((tmp) & 0x01FF)

#define GP_WB_WRITE_FLL_TABLE_F_TARGET_TX_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          GP_WB_MWRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2634), 0x01FF, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_F_TARGET_TX_3_TO_CHIDX_3_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          (tmp) &= 0x7FFFFE00; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Fine tx capbank setting for channel idx 3 */
#define GP_WB_READ_FLL_TABLE_CAPBANK_FINE_TX_3() \
        ((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2635)) >> 1) & 0x7F)

#define GP_WB_GET_FLL_TABLE_CAPBANK_FINE_TX_3_FROM_CHIDX_3_1(tmp) \
        (((tmp) >> 9) & 0x7F)

#define GP_WB_WRITE_FLL_TABLE_CAPBANK_FINE_TX_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2635), 0xFE, (val) << 1); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_CAPBANK_FINE_TX_3_TO_CHIDX_3_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          (tmp) &= 0x7FFF01FF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* DTC step size for TX on for channel idx 3 */
#define GP_WB_READ_FLL_TABLE_DTC_STEP_TX_3() \
        (GP_WB_S8((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2636)) & 0x7F), 7))

#define GP_WB_GET_FLL_TABLE_DTC_STEP_TX_3_FROM_CHIDX_3_1(tmp) \
        (GP_WB_S8((((tmp) >> 16) & 0x7F), 7))

#define GP_WB_WRITE_FLL_TABLE_DTC_STEP_TX_3(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -64, 63); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2636), 0x7F, (UInt8)((val))); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_DTC_STEP_TX_3_TO_CHIDX_3_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK_SIGNED(val, -64, 63); \
          (tmp) &= 0x7F80FFFF; \
          (tmp) |= ((((Int32)(val)) << 16) & 0x007F0000); \
        } while (0)

/* Loop sign for TX on for channel idx 3 is negative */
#define GP_WB_READ_FLL_TABLE_LOOP_SIGN_NEG_TX_3() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2636), 7)

#define GP_WB_GET_FLL_TABLE_LOOP_SIGN_NEG_TX_3_FROM_CHIDX_3_1(tmp) \
        (((tmp) >> 23) & 0x01)

#define GP_WB_WRITE_FLL_TABLE_LOOP_SIGN_NEG_TX_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2636), 7, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_LOOP_SIGN_NEG_TX_3_TO_CHIDX_3_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F7FFFFF; \
          (tmp) |= (((UInt32)(val)) << 23); \
        } while (0)

/* Error corrector patterns for TX on for channel idx 3 */
#define GP_WB_READ_FLL_TABLE_ERR_CORR_TX_3() \
        (GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2637)) & 0x07)

#define GP_WB_GET_FLL_TABLE_ERR_CORR_TX_3_FROM_CHIDX_3_1(tmp) \
        (((tmp) >> 24) & 0x07)

#define GP_WB_WRITE_FLL_TABLE_ERR_CORR_TX_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2637), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_ERR_CORR_TX_3_TO_CHIDX_3_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x78FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)

/* Mode ctrl bits for channel idx 3 */
#define GP_WB_READ_FLL_TABLE_CHANNEL_CTRL_3() \
        ((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2637)) >> 3) & 0x0F)

#define GP_WB_GET_FLL_TABLE_CHANNEL_CTRL_3_FROM_CHIDX_3_1(tmp) \
        (((tmp) >> 27) & 0x0F)

#define GP_WB_WRITE_FLL_TABLE_CHANNEL_CTRL_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2637), 0x78, (val) << 3); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_CHANNEL_CTRL_3_TO_CHIDX_3_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x07FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 27); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_FLL_TABLE_CHIDX_3_2() \
        GP_WB_READ_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2638))

#define GP_WB_WRITE_FLL_TABLE_CHIDX_3_2(val) \
      GP_WB_WRITE_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2638), (val))

/* Target frequency setting for rx on channel idx 3 */
#define GP_WB_READ_FLL_TABLE_F_TARGET_RX_3() \
        (GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2638)) & 0x01FF)

#define GP_WB_GET_FLL_TABLE_F_TARGET_RX_3_FROM_CHIDX_3_2(tmp) \
        ((tmp) & 0x01FF)

#define GP_WB_WRITE_FLL_TABLE_F_TARGET_RX_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          GP_WB_MWRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2638), 0x01FF, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_F_TARGET_RX_3_TO_CHIDX_3_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          (tmp) &= 0x3FFFFE00; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* fine rx  capbank setting for channel idx 3 */
#define GP_WB_READ_FLL_TABLE_CAPBANK_FINE_RX_3() \
        ((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2639)) >> 1) & 0x7F)

#define GP_WB_GET_FLL_TABLE_CAPBANK_FINE_RX_3_FROM_CHIDX_3_2(tmp) \
        (((tmp) >> 9) & 0x7F)

#define GP_WB_WRITE_FLL_TABLE_CAPBANK_FINE_RX_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2639), 0xFE, (val) << 1); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_CAPBANK_FINE_RX_3_TO_CHIDX_3_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          (tmp) &= 0x3FFF01FF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* DTC step size for RX on for channel idx 3 */
#define GP_WB_READ_FLL_TABLE_DTC_STEP_RX_3() \
        (GP_WB_S8((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc263a)) & 0x7F), 7))

#define GP_WB_GET_FLL_TABLE_DTC_STEP_RX_3_FROM_CHIDX_3_2(tmp) \
        (GP_WB_S8((((tmp) >> 16) & 0x7F), 7))

#define GP_WB_WRITE_FLL_TABLE_DTC_STEP_RX_3(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -64, 63); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc263a), 0x7F, (UInt8)((val))); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_DTC_STEP_RX_3_TO_CHIDX_3_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK_SIGNED(val, -64, 63); \
          (tmp) &= 0x3F80FFFF; \
          (tmp) |= ((((Int32)(val)) << 16) & 0x007F0000); \
        } while (0)

/* Loop sign for rx on for channel idx 3 is negative */
#define GP_WB_READ_FLL_TABLE_LOOP_SIGN_NEG_RX_3() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc263a), 7)

#define GP_WB_GET_FLL_TABLE_LOOP_SIGN_NEG_RX_3_FROM_CHIDX_3_2(tmp) \
        (((tmp) >> 23) & 0x01)

#define GP_WB_WRITE_FLL_TABLE_LOOP_SIGN_NEG_RX_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc263a), 7, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_LOOP_SIGN_NEG_RX_3_TO_CHIDX_3_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F7FFFFF; \
          (tmp) |= (((UInt32)(val)) << 23); \
        } while (0)

/* Error corrector patterns for RX on for channel idx 3 */
#define GP_WB_READ_FLL_TABLE_ERR_CORR_RX_3() \
        (GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc263b)) & 0x07)

#define GP_WB_GET_FLL_TABLE_ERR_CORR_RX_3_FROM_CHIDX_3_2(tmp) \
        (((tmp) >> 24) & 0x07)

#define GP_WB_WRITE_FLL_TABLE_ERR_CORR_RX_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc263b), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_ERR_CORR_RX_3_TO_CHIDX_3_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x38FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)

/* DCDC frequency choice for channel idx 3 */
#define GP_WB_READ_FLL_TABLE_DCDC_3() \
        ((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc263b)) >> 3) & 0x07)

#define GP_WB_GET_FLL_TABLE_DCDC_3_FROM_CHIDX_3_2(tmp) \
        (((tmp) >> 27) & 0x07)

#define GP_WB_WRITE_FLL_TABLE_DCDC_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc263b), 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_DCDC_3_TO_CHIDX_3_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x07FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 27); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_FLL_TABLE_CHIDX_4_0() \
        GP_WB_READ_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2640))

#define GP_WB_WRITE_FLL_TABLE_CHIDX_4_0(val) \
      GP_WB_WRITE_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2640), (val))

/* lf preload value for channel idx 4 */
#define GP_WB_READ_FLL_TABLE_LF_PRELOAD_4() \
        (GP_WB_S24((GP_WB_READ_U24(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2640)) & 0x3FFFFF), 22))

#define GP_WB_GET_FLL_TABLE_LF_PRELOAD_4_FROM_CHIDX_4_0(tmp) \
        (GP_WB_S24(((tmp) & 0x3FFFFF), 22))

#define GP_WB_WRITE_FLL_TABLE_LF_PRELOAD_4(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -2097152, 2097151); \
          GP_WB_MWRITE_U24(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2640), 0x3FFFFF, (UInt32)((val))); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_LF_PRELOAD_4_TO_CHIDX_4_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK_SIGNED(val, -2097152, 2097151); \
          (tmp) &= 0x7FC00000; \
          (tmp) |= (((Int32)(val)) & 0x003FFFFF); \
        } while (0)

/* Loop gain setting for channel idx 4 */
#define GP_WB_READ_FLL_TABLE_LOOP_GAIN_4() \
        ((GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2642)) >> 6) & 0x01FF)

#define GP_WB_GET_FLL_TABLE_LOOP_GAIN_4_FROM_CHIDX_4_0(tmp) \
        (((tmp) >> 22) & 0x01FF)

#define GP_WB_WRITE_FLL_TABLE_LOOP_GAIN_4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          GP_WB_MWRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2642), 0x7FC0, (UInt16)(val) << 6); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_LOOP_GAIN_4_TO_CHIDX_4_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          (tmp) &= 0x003FFFFF; \
          (tmp) |= (((UInt32)(val)) << 22); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_FLL_TABLE_CHIDX_4_1() \
        GP_WB_READ_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2644))

#define GP_WB_WRITE_FLL_TABLE_CHIDX_4_1(val) \
      GP_WB_WRITE_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2644), (val))

/* Target frequency setting for tx on channel idx 4 */
#define GP_WB_READ_FLL_TABLE_F_TARGET_TX_4() \
        (GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2644)) & 0x01FF)

#define GP_WB_GET_FLL_TABLE_F_TARGET_TX_4_FROM_CHIDX_4_1(tmp) \
        ((tmp) & 0x01FF)

#define GP_WB_WRITE_FLL_TABLE_F_TARGET_TX_4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          GP_WB_MWRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2644), 0x01FF, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_F_TARGET_TX_4_TO_CHIDX_4_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          (tmp) &= 0x7FFFFE00; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Fine tx capbank setting for channel idx 4 */
#define GP_WB_READ_FLL_TABLE_CAPBANK_FINE_TX_4() \
        ((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2645)) >> 1) & 0x7F)

#define GP_WB_GET_FLL_TABLE_CAPBANK_FINE_TX_4_FROM_CHIDX_4_1(tmp) \
        (((tmp) >> 9) & 0x7F)

#define GP_WB_WRITE_FLL_TABLE_CAPBANK_FINE_TX_4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2645), 0xFE, (val) << 1); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_CAPBANK_FINE_TX_4_TO_CHIDX_4_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          (tmp) &= 0x7FFF01FF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* DTC step size for TX on for channel idx 4 */
#define GP_WB_READ_FLL_TABLE_DTC_STEP_TX_4() \
        (GP_WB_S8((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2646)) & 0x7F), 7))

#define GP_WB_GET_FLL_TABLE_DTC_STEP_TX_4_FROM_CHIDX_4_1(tmp) \
        (GP_WB_S8((((tmp) >> 16) & 0x7F), 7))

#define GP_WB_WRITE_FLL_TABLE_DTC_STEP_TX_4(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -64, 63); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2646), 0x7F, (UInt8)((val))); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_DTC_STEP_TX_4_TO_CHIDX_4_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK_SIGNED(val, -64, 63); \
          (tmp) &= 0x7F80FFFF; \
          (tmp) |= ((((Int32)(val)) << 16) & 0x007F0000); \
        } while (0)

/* Loop sign for TX on for channel idx 4 is negative */
#define GP_WB_READ_FLL_TABLE_LOOP_SIGN_NEG_TX_4() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2646), 7)

#define GP_WB_GET_FLL_TABLE_LOOP_SIGN_NEG_TX_4_FROM_CHIDX_4_1(tmp) \
        (((tmp) >> 23) & 0x01)

#define GP_WB_WRITE_FLL_TABLE_LOOP_SIGN_NEG_TX_4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2646), 7, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_LOOP_SIGN_NEG_TX_4_TO_CHIDX_4_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F7FFFFF; \
          (tmp) |= (((UInt32)(val)) << 23); \
        } while (0)

/* Error corrector patterns for TX on for channel idx 4 */
#define GP_WB_READ_FLL_TABLE_ERR_CORR_TX_4() \
        (GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2647)) & 0x07)

#define GP_WB_GET_FLL_TABLE_ERR_CORR_TX_4_FROM_CHIDX_4_1(tmp) \
        (((tmp) >> 24) & 0x07)

#define GP_WB_WRITE_FLL_TABLE_ERR_CORR_TX_4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2647), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_ERR_CORR_TX_4_TO_CHIDX_4_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x78FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)

/* Mode ctrl bits for channel idx 4 */
#define GP_WB_READ_FLL_TABLE_CHANNEL_CTRL_4() \
        ((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2647)) >> 3) & 0x0F)

#define GP_WB_GET_FLL_TABLE_CHANNEL_CTRL_4_FROM_CHIDX_4_1(tmp) \
        (((tmp) >> 27) & 0x0F)

#define GP_WB_WRITE_FLL_TABLE_CHANNEL_CTRL_4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2647), 0x78, (val) << 3); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_CHANNEL_CTRL_4_TO_CHIDX_4_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x07FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 27); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_FLL_TABLE_CHIDX_4_2() \
        GP_WB_READ_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2648))

#define GP_WB_WRITE_FLL_TABLE_CHIDX_4_2(val) \
      GP_WB_WRITE_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2648), (val))

/* Target frequency setting for rx on channel idx 4 */
#define GP_WB_READ_FLL_TABLE_F_TARGET_RX_4() \
        (GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2648)) & 0x01FF)

#define GP_WB_GET_FLL_TABLE_F_TARGET_RX_4_FROM_CHIDX_4_2(tmp) \
        ((tmp) & 0x01FF)

#define GP_WB_WRITE_FLL_TABLE_F_TARGET_RX_4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          GP_WB_MWRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2648), 0x01FF, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_F_TARGET_RX_4_TO_CHIDX_4_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          (tmp) &= 0x3FFFFE00; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* fine rx  capbank setting for channel idx 4 */
#define GP_WB_READ_FLL_TABLE_CAPBANK_FINE_RX_4() \
        ((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2649)) >> 1) & 0x7F)

#define GP_WB_GET_FLL_TABLE_CAPBANK_FINE_RX_4_FROM_CHIDX_4_2(tmp) \
        (((tmp) >> 9) & 0x7F)

#define GP_WB_WRITE_FLL_TABLE_CAPBANK_FINE_RX_4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2649), 0xFE, (val) << 1); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_CAPBANK_FINE_RX_4_TO_CHIDX_4_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          (tmp) &= 0x3FFF01FF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* DTC step size for RX on for channel idx 4 */
#define GP_WB_READ_FLL_TABLE_DTC_STEP_RX_4() \
        (GP_WB_S8((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc264a)) & 0x7F), 7))

#define GP_WB_GET_FLL_TABLE_DTC_STEP_RX_4_FROM_CHIDX_4_2(tmp) \
        (GP_WB_S8((((tmp) >> 16) & 0x7F), 7))

#define GP_WB_WRITE_FLL_TABLE_DTC_STEP_RX_4(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -64, 63); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc264a), 0x7F, (UInt8)((val))); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_DTC_STEP_RX_4_TO_CHIDX_4_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK_SIGNED(val, -64, 63); \
          (tmp) &= 0x3F80FFFF; \
          (tmp) |= ((((Int32)(val)) << 16) & 0x007F0000); \
        } while (0)

/* Loop sign for rx on for channel idx 4 is negative */
#define GP_WB_READ_FLL_TABLE_LOOP_SIGN_NEG_RX_4() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc264a), 7)

#define GP_WB_GET_FLL_TABLE_LOOP_SIGN_NEG_RX_4_FROM_CHIDX_4_2(tmp) \
        (((tmp) >> 23) & 0x01)

#define GP_WB_WRITE_FLL_TABLE_LOOP_SIGN_NEG_RX_4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc264a), 7, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_LOOP_SIGN_NEG_RX_4_TO_CHIDX_4_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F7FFFFF; \
          (tmp) |= (((UInt32)(val)) << 23); \
        } while (0)

/* Error corrector patterns for RX on for channel idx 4 */
#define GP_WB_READ_FLL_TABLE_ERR_CORR_RX_4() \
        (GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc264b)) & 0x07)

#define GP_WB_GET_FLL_TABLE_ERR_CORR_RX_4_FROM_CHIDX_4_2(tmp) \
        (((tmp) >> 24) & 0x07)

#define GP_WB_WRITE_FLL_TABLE_ERR_CORR_RX_4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc264b), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_ERR_CORR_RX_4_TO_CHIDX_4_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x38FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)

/* DCDC frequency choice for channel idx 4 */
#define GP_WB_READ_FLL_TABLE_DCDC_4() \
        ((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc264b)) >> 3) & 0x07)

#define GP_WB_GET_FLL_TABLE_DCDC_4_FROM_CHIDX_4_2(tmp) \
        (((tmp) >> 27) & 0x07)

#define GP_WB_WRITE_FLL_TABLE_DCDC_4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc264b), 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_DCDC_4_TO_CHIDX_4_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x07FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 27); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_FLL_TABLE_CHIDX_5_0() \
        GP_WB_READ_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2650))

#define GP_WB_WRITE_FLL_TABLE_CHIDX_5_0(val) \
      GP_WB_WRITE_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2650), (val))

/* lf preload value for channel idx 5 */
#define GP_WB_READ_FLL_TABLE_LF_PRELOAD_5() \
        (GP_WB_S24((GP_WB_READ_U24(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2650)) & 0x3FFFFF), 22))

#define GP_WB_GET_FLL_TABLE_LF_PRELOAD_5_FROM_CHIDX_5_0(tmp) \
        (GP_WB_S24(((tmp) & 0x3FFFFF), 22))

#define GP_WB_WRITE_FLL_TABLE_LF_PRELOAD_5(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -2097152, 2097151); \
          GP_WB_MWRITE_U24(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2650), 0x3FFFFF, (UInt32)((val))); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_LF_PRELOAD_5_TO_CHIDX_5_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK_SIGNED(val, -2097152, 2097151); \
          (tmp) &= 0x7FC00000; \
          (tmp) |= (((Int32)(val)) & 0x003FFFFF); \
        } while (0)

/* Loop gain setting for channel idx 5 */
#define GP_WB_READ_FLL_TABLE_LOOP_GAIN_5() \
        ((GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2652)) >> 6) & 0x01FF)

#define GP_WB_GET_FLL_TABLE_LOOP_GAIN_5_FROM_CHIDX_5_0(tmp) \
        (((tmp) >> 22) & 0x01FF)

#define GP_WB_WRITE_FLL_TABLE_LOOP_GAIN_5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          GP_WB_MWRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2652), 0x7FC0, (UInt16)(val) << 6); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_LOOP_GAIN_5_TO_CHIDX_5_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          (tmp) &= 0x003FFFFF; \
          (tmp) |= (((UInt32)(val)) << 22); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_FLL_TABLE_CHIDX_5_1() \
        GP_WB_READ_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2654))

#define GP_WB_WRITE_FLL_TABLE_CHIDX_5_1(val) \
      GP_WB_WRITE_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2654), (val))

/* Target frequency setting for tx on channel idx 5 */
#define GP_WB_READ_FLL_TABLE_F_TARGET_TX_5() \
        (GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2654)) & 0x01FF)

#define GP_WB_GET_FLL_TABLE_F_TARGET_TX_5_FROM_CHIDX_5_1(tmp) \
        ((tmp) & 0x01FF)

#define GP_WB_WRITE_FLL_TABLE_F_TARGET_TX_5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          GP_WB_MWRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2654), 0x01FF, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_F_TARGET_TX_5_TO_CHIDX_5_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          (tmp) &= 0x7FFFFE00; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Fine tx capbank setting for channel idx 5 */
#define GP_WB_READ_FLL_TABLE_CAPBANK_FINE_TX_5() \
        ((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2655)) >> 1) & 0x7F)

#define GP_WB_GET_FLL_TABLE_CAPBANK_FINE_TX_5_FROM_CHIDX_5_1(tmp) \
        (((tmp) >> 9) & 0x7F)

#define GP_WB_WRITE_FLL_TABLE_CAPBANK_FINE_TX_5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2655), 0xFE, (val) << 1); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_CAPBANK_FINE_TX_5_TO_CHIDX_5_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          (tmp) &= 0x7FFF01FF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* DTC step size for TX on for channel idx 5 */
#define GP_WB_READ_FLL_TABLE_DTC_STEP_TX_5() \
        (GP_WB_S8((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2656)) & 0x7F), 7))

#define GP_WB_GET_FLL_TABLE_DTC_STEP_TX_5_FROM_CHIDX_5_1(tmp) \
        (GP_WB_S8((((tmp) >> 16) & 0x7F), 7))

#define GP_WB_WRITE_FLL_TABLE_DTC_STEP_TX_5(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -64, 63); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2656), 0x7F, (UInt8)((val))); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_DTC_STEP_TX_5_TO_CHIDX_5_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK_SIGNED(val, -64, 63); \
          (tmp) &= 0x7F80FFFF; \
          (tmp) |= ((((Int32)(val)) << 16) & 0x007F0000); \
        } while (0)

/* Loop sign for TX on for channel idx 5 is negative */
#define GP_WB_READ_FLL_TABLE_LOOP_SIGN_NEG_TX_5() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2656), 7)

#define GP_WB_GET_FLL_TABLE_LOOP_SIGN_NEG_TX_5_FROM_CHIDX_5_1(tmp) \
        (((tmp) >> 23) & 0x01)

#define GP_WB_WRITE_FLL_TABLE_LOOP_SIGN_NEG_TX_5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2656), 7, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_LOOP_SIGN_NEG_TX_5_TO_CHIDX_5_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F7FFFFF; \
          (tmp) |= (((UInt32)(val)) << 23); \
        } while (0)

/* Error corrector patterns for TX on for channel idx 5 */
#define GP_WB_READ_FLL_TABLE_ERR_CORR_TX_5() \
        (GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2657)) & 0x07)

#define GP_WB_GET_FLL_TABLE_ERR_CORR_TX_5_FROM_CHIDX_5_1(tmp) \
        (((tmp) >> 24) & 0x07)

#define GP_WB_WRITE_FLL_TABLE_ERR_CORR_TX_5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2657), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_ERR_CORR_TX_5_TO_CHIDX_5_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x78FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)

/* Mode ctrl bits for channel idx 5 */
#define GP_WB_READ_FLL_TABLE_CHANNEL_CTRL_5() \
        ((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2657)) >> 3) & 0x0F)

#define GP_WB_GET_FLL_TABLE_CHANNEL_CTRL_5_FROM_CHIDX_5_1(tmp) \
        (((tmp) >> 27) & 0x0F)

#define GP_WB_WRITE_FLL_TABLE_CHANNEL_CTRL_5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2657), 0x78, (val) << 3); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_CHANNEL_CTRL_5_TO_CHIDX_5_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x07FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 27); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_FLL_TABLE_CHIDX_5_2() \
        GP_WB_READ_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2658))

#define GP_WB_WRITE_FLL_TABLE_CHIDX_5_2(val) \
      GP_WB_WRITE_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2658), (val))

/* Target frequency setting for rx on channel idx 5 */
#define GP_WB_READ_FLL_TABLE_F_TARGET_RX_5() \
        (GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2658)) & 0x01FF)

#define GP_WB_GET_FLL_TABLE_F_TARGET_RX_5_FROM_CHIDX_5_2(tmp) \
        ((tmp) & 0x01FF)

#define GP_WB_WRITE_FLL_TABLE_F_TARGET_RX_5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          GP_WB_MWRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2658), 0x01FF, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_F_TARGET_RX_5_TO_CHIDX_5_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          (tmp) &= 0x3FFFFE00; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* fine rx  capbank setting for channel idx 5 */
#define GP_WB_READ_FLL_TABLE_CAPBANK_FINE_RX_5() \
        ((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2659)) >> 1) & 0x7F)

#define GP_WB_GET_FLL_TABLE_CAPBANK_FINE_RX_5_FROM_CHIDX_5_2(tmp) \
        (((tmp) >> 9) & 0x7F)

#define GP_WB_WRITE_FLL_TABLE_CAPBANK_FINE_RX_5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2659), 0xFE, (val) << 1); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_CAPBANK_FINE_RX_5_TO_CHIDX_5_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          (tmp) &= 0x3FFF01FF; \
          (tmp) |= (((UInt32)(val)) << 9); \
        } while (0)

/* DTC step size for RX on for channel idx 5 */
#define GP_WB_READ_FLL_TABLE_DTC_STEP_RX_5() \
        (GP_WB_S8((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc265a)) & 0x7F), 7))

#define GP_WB_GET_FLL_TABLE_DTC_STEP_RX_5_FROM_CHIDX_5_2(tmp) \
        (GP_WB_S8((((tmp) >> 16) & 0x7F), 7))

#define GP_WB_WRITE_FLL_TABLE_DTC_STEP_RX_5(val) do { \
          GP_WB_RANGE_CHECK_SIGNED(val, -64, 63); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc265a), 0x7F, (UInt8)((val))); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_DTC_STEP_RX_5_TO_CHIDX_5_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK_SIGNED(val, -64, 63); \
          (tmp) &= 0x3F80FFFF; \
          (tmp) |= ((((Int32)(val)) << 16) & 0x007F0000); \
        } while (0)

/* Loop sign for rx on for channel idx 5 is negative */
#define GP_WB_READ_FLL_TABLE_LOOP_SIGN_NEG_RX_5() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc265a), 7)

#define GP_WB_GET_FLL_TABLE_LOOP_SIGN_NEG_RX_5_FROM_CHIDX_5_2(tmp) \
        (((tmp) >> 23) & 0x01)

#define GP_WB_WRITE_FLL_TABLE_LOOP_SIGN_NEG_RX_5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc265a), 7, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_LOOP_SIGN_NEG_RX_5_TO_CHIDX_5_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F7FFFFF; \
          (tmp) |= (((UInt32)(val)) << 23); \
        } while (0)

/* Error corrector patterns for RX on for channel idx 5 */
#define GP_WB_READ_FLL_TABLE_ERR_CORR_RX_5() \
        (GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc265b)) & 0x07)

#define GP_WB_GET_FLL_TABLE_ERR_CORR_RX_5_FROM_CHIDX_5_2(tmp) \
        (((tmp) >> 24) & 0x07)

#define GP_WB_WRITE_FLL_TABLE_ERR_CORR_RX_5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc265b), 0x07, (val)); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_ERR_CORR_RX_5_TO_CHIDX_5_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x38FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)

/* DCDC frequency choice for channel idx 5 */
#define GP_WB_READ_FLL_TABLE_DCDC_5() \
        ((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc265b)) >> 3) & 0x07)

#define GP_WB_GET_FLL_TABLE_DCDC_5_FROM_CHIDX_5_2(tmp) \
        (((tmp) >> 27) & 0x07)

#define GP_WB_WRITE_FLL_TABLE_DCDC_5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc265b), 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_FLL_TABLE_DCDC_5_TO_CHIDX_5_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x07FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 27); \
        } while (0)

/***************************
 * layout: cal_mgr
 ***************************/

/* Pointer to the channel definition LUT. channel_lut_ptr=0 will use the DEFAULT_CHANNEL_LUT in ROM. */
#define GP_WB_READ_CAL_MGR_CHANNEL_LUT_PTR() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2660))

#define GP_WB_WRITE_CAL_MGR_CHANNEL_LUT_PTR(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2660), (val)); \
        } while (0)


/* Coarse gain value to be used. Actually, it is 256/coarse_gain. Unit is 256*LSB/640kHz. 0.048*256 = 12. */
#define GP_WB_READ_CAL_MGR_COARSE_GAIN() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2662))

#define GP_WB_WRITE_CAL_MGR_COARSE_GAIN(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2662), (val)); \
        } while (0)


/* Calibrated fine_gain value. Actually, it is 256/fine_gain. Unit is 256*LSB/160kHz. */
#define GP_WB_READ_CAL_MGR_FINE_GAIN() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2664))

#define GP_WB_WRITE_CAL_MGR_FINE_GAIN(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2664), (val)); \
        } while (0)


#define GP_WB_READ_CAL_MGR_CAL_DTC_MSB() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2666), 0)

#define GP_WB_WRITE_CAL_MGR_CAL_DTC_MSB(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2666), 0, (val)); \
        } while (0)

#define GP_WB_READ_CAL_MGR_CAL_DTC_LSB() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2666), 1)

#define GP_WB_WRITE_CAL_MGR_CAL_DTC_LSB(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2666), 1, (val)); \
        } while (0)

#define GP_WB_READ_CAL_MGR_CAL_COARSE() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2666), 2)

#define GP_WB_WRITE_CAL_MGR_CAL_COARSE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2666), 2, (val)); \
        } while (0)

#define GP_WB_READ_CAL_MGR_CAL_FINE_GAIN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2666), 3)

#define GP_WB_WRITE_CAL_MGR_CAL_FINE_GAIN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2666), 3, (val)); \
        } while (0)

#define GP_WB_READ_CAL_MGR_CAL_FINE() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2666), 4)

#define GP_WB_WRITE_CAL_MGR_CAL_FINE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2666), 4, (val)); \
        } while (0)

#define GP_WB_READ_CAL_MGR_CAL_LOOP_GAIN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2666), 5)

#define GP_WB_WRITE_CAL_MGR_CAL_LOOP_GAIN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2666), 5, (val)); \
        } while (0)

#define GP_WB_READ_CAL_MGR_CB_FINE_SWEEP() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2666), 6)

#define GP_WB_WRITE_CAL_MGR_CB_FINE_SWEEP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2666), 6, (val)); \
        } while (0)


#define GP_WB_READ_CAL_MGR_DEBUG() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2667))

#define GP_WB_WRITE_CAL_MGR_DEBUG(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2667), (val)); \
        } while (0)


#define GP_WB_READ_CAL_MGR_DEBUG_VAL() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2668))

#define GP_WB_WRITE_CAL_MGR_DEBUG_VAL(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2668), (val)); \
        } while (0)


#define GP_WB_READ_CAL_MGR_DTC_CORNER() \
        (GP_WB_S16(GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc266a)), 16))

#define GP_WB_WRITE_CAL_MGR_DTC_CORNER(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc266a), (UInt16)((val))); \
        } while (0)


#define GP_WB_READ_CAL_MGR_DTC_MSB_GAIN() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc266c))

#define GP_WB_WRITE_CAL_MGR_DTC_MSB_GAIN(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc266c), (val)); \
        } while (0)


#define GP_WB_READ_CAL_MGR_DTC_LSB_GAIN() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc266e))

#define GP_WB_WRITE_CAL_MGR_DTC_LSB_GAIN(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc266e), (val)); \
        } while (0)

/***************************
 * layout: macfilt
 ***************************/

/* Channel idx mask for which the pan_id/src_addr pair is is valid */
#define GP_WB_READ_MACFILT_CHANNEL_IDX() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2680))

#define GP_WB_WRITE_MACFILT_CHANNEL_IDX(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2680), (val)); \
        } while (0)


/* Set to 2 if device if pan coordinator for primary pan. Set to 1 if not */
#define GP_WB_READ_MACFILT_PAN_COORDINATOR() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2681))

#define GP_WB_WRITE_MACFILT_PAN_COORDINATOR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2681), (val)); \
        } while (0)


/* Short address for the device within its primary PAN */
#define GP_WB_READ_MACFILT_SHORT_ADDRESS() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2682))

#define GP_WB_WRITE_MACFILT_SHORT_ADDRESS(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2682), (val)); \
        } while (0)


/* primary pan id the device operates in */
#define GP_WB_READ_MACFILT_PAN_ID() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2684))

#define GP_WB_WRITE_MACFILT_PAN_ID(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2684), (val)); \
        } while (0)


/* 64 bit mac address for the device */
#define GP_WB_READ_MACFILT_EXTENDED_ADDRESS() \
        GP_WB_READ_U64(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2686))

#define GP_WB_WRITE_MACFILT_EXTENDED_ADDRESS(val) do { \
          GP_WB_WRITE_U64(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2686), (val)); \
        } while (0)


/* Channel idx mask for which the pan_id/src_addr pair is is valid */
#define GP_WB_READ_MACFILT_CHANNEL_IDX_ALT_A() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc268e))

#define GP_WB_WRITE_MACFILT_CHANNEL_IDX_ALT_A(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc268e), (val)); \
        } while (0)


/* Set to 2 if device if pan coordinator for secondary pan. Set to 1 if not */
#define GP_WB_READ_MACFILT_PAN_COORDINATOR_ALT_A() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc268f))

#define GP_WB_WRITE_MACFILT_PAN_COORDINATOR_ALT_A(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc268f), (val)); \
        } while (0)


/* Short address for the device within its secondary PAN */
#define GP_WB_READ_MACFILT_SHORT_ADDRESS_ALT_A() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2690))

#define GP_WB_WRITE_MACFILT_SHORT_ADDRESS_ALT_A(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2690), (val)); \
        } while (0)


/* secondary pan id the device operates in */
#define GP_WB_READ_MACFILT_PAN_ID_ALT_A() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2692))

#define GP_WB_WRITE_MACFILT_PAN_ID_ALT_A(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2692), (val)); \
        } while (0)


/* 64 bit secondary mac address for the device */
#define GP_WB_READ_MACFILT_EXTENDED_ADDRESS_ALT_A() \
        GP_WB_READ_U64(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2694))

#define GP_WB_WRITE_MACFILT_EXTENDED_ADDRESS_ALT_A(val) do { \
          GP_WB_WRITE_U64(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2694), (val)); \
        } while (0)


/* Channel idx mask for which the pan_id/src_addr pair is is valid */
#define GP_WB_READ_MACFILT_CHANNEL_IDX_ALT_B() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc269c))

#define GP_WB_WRITE_MACFILT_CHANNEL_IDX_ALT_B(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc269c), (val)); \
        } while (0)


/* Set to 2 if device if pan coordinator for tertiary pan.. Set to 1 if not */
#define GP_WB_READ_MACFILT_PAN_COORDINATOR_ALT_B() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc269d))

#define GP_WB_WRITE_MACFILT_PAN_COORDINATOR_ALT_B(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc269d), (val)); \
        } while (0)


/* Short address for the device within third PAN */
#define GP_WB_READ_MACFILT_SHORT_ADDRESS_ALT_B() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc269e))

#define GP_WB_WRITE_MACFILT_SHORT_ADDRESS_ALT_B(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc269e), (val)); \
        } while (0)


/* third pan id the device operates in */
#define GP_WB_READ_MACFILT_PAN_ID_ALT_B() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26a0))

#define GP_WB_WRITE_MACFILT_PAN_ID_ALT_B(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26a0), (val)); \
        } while (0)


/* 64 bit tertiary mac address for the device */
#define GP_WB_READ_MACFILT_EXTENDED_ADDRESS_ALT_B() \
        GP_WB_READ_U64(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26a2))

#define GP_WB_WRITE_MACFILT_EXTENDED_ADDRESS_ALT_B(val) do { \
          GP_WB_WRITE_U64(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26a2), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MACFILT_ACK_POWER_CFG_PAN() \
        GP_WB_READ_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26ac))

#define GP_WB_WRITE_MACFILT_ACK_POWER_CFG_PAN(val) \
      GP_WB_WRITE_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26ac), (val))

/* ack tx power if rssi is lower than threshold(thr), this is used when incomming frame does belongs to this pan/short/ch_idx combo */
#define GP_WB_READ_MACFILT_ACK_POWER_L() \
        (GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26ac)) & 0x3F)

#define GP_WB_GET_MACFILT_ACK_POWER_L_FROM_ACK_POWER_CFG_PAN(tmp) \
        ((tmp) & 0x3F)

#define GP_WB_WRITE_MACFILT_ACK_POWER_L(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26ac), 0x3F, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_POWER_L_TO_ACK_POWER_CFG_PAN(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0xFFFFFFC0; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

#define GP_WB_READ_MACFILT_ACK_PA_LOW_L() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26ac), 6)

#define GP_WB_GET_MACFILT_ACK_PA_LOW_L_FROM_ACK_POWER_CFG_PAN(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_MACFILT_ACK_PA_LOW_L(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26ac), 6, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_PA_LOW_L_TO_ACK_POWER_CFG_PAN(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFBF; \
          (tmp) |= (((UInt32)(val)) << 6); \
        } while (0)

#define GP_WB_READ_MACFILT_ACK_PA_ULTRA_LOW_L() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26ac), 7)

#define GP_WB_GET_MACFILT_ACK_PA_ULTRA_LOW_L_FROM_ACK_POWER_CFG_PAN(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_MACFILT_ACK_PA_ULTRA_LOW_L(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26ac), 7, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_PA_ULTRA_LOW_L_TO_ACK_POWER_CFG_PAN(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFF7F; \
          (tmp) |= (((UInt32)(val)) << 7); \
        } while (0)

/* ack tx power if rssi is higher or equal to threshold(thr), this is used when incomming frame does belongs to this pan/short/ch_idx combo */
#define GP_WB_READ_MACFILT_ACK_POWER_H() \
        (GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26ad)) & 0x3F)

#define GP_WB_GET_MACFILT_ACK_POWER_H_FROM_ACK_POWER_CFG_PAN(tmp) \
        (((tmp) >> 8) & 0x3F)

#define GP_WB_WRITE_MACFILT_ACK_POWER_H(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26ad), 0x3F, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_POWER_H_TO_ACK_POWER_CFG_PAN(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0xFFFFC0FF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

#define GP_WB_READ_MACFILT_ACK_PA_LOW_H() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26ad), 6)

#define GP_WB_GET_MACFILT_ACK_PA_LOW_H_FROM_ACK_POWER_CFG_PAN(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_MACFILT_ACK_PA_LOW_H(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26ad), 6, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_PA_LOW_H_TO_ACK_POWER_CFG_PAN(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFBFFF; \
          (tmp) |= (((UInt32)(val)) << 14); \
        } while (0)

#define GP_WB_READ_MACFILT_ACK_PA_ULTRA_LOW_H() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26ad), 7)

#define GP_WB_GET_MACFILT_ACK_PA_ULTRA_LOW_H_FROM_ACK_POWER_CFG_PAN(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_MACFILT_ACK_PA_ULTRA_LOW_H(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26ad), 7, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_PA_ULTRA_LOW_H_TO_ACK_POWER_CFG_PAN(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFF7FFF; \
          (tmp) |= (((UInt32)(val)) << 15); \
        } while (0)

/* threshold which will be compared to the rssi of the incomming frame, this is used when incomming frame does belongs to this pan/short/ch_idx combo */
#define GP_WB_READ_MACFILT_ACK_POWER_RSSI_THR() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26ae))

#define GP_WB_GET_MACFILT_ACK_POWER_RSSI_THR_FROM_ACK_POWER_CFG_PAN(tmp) \
        (((tmp) >> 16) & 0xFF)

#define GP_WB_WRITE_MACFILT_ACK_POWER_RSSI_THR(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26ae), (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_POWER_RSSI_THR_TO_ACK_POWER_CFG_PAN(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0xFF00FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* this has no meaning, just a placeholder for this address so the table is correctly structured */
#define GP_WB_READ_MACFILT_ACK_POWER_SPACING() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26af))

#define GP_WB_GET_MACFILT_ACK_POWER_SPACING_FROM_ACK_POWER_CFG_PAN(tmp) \
        (((tmp) >> 24) & 0xFF)

#define GP_WB_WRITE_MACFILT_ACK_POWER_SPACING(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26af), (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_POWER_SPACING_TO_ACK_POWER_CFG_PAN(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x00FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MACFILT_ACK_POWER_CFG_PAN_ALT_A() \
        GP_WB_READ_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b0))

#define GP_WB_WRITE_MACFILT_ACK_POWER_CFG_PAN_ALT_A(val) \
      GP_WB_WRITE_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b0), (val))

/* ack tx power if rssi is lower than threshold(thr), this is used when incomming frame does belongs to this pan/short/ch_idx combo */
#define GP_WB_READ_MACFILT_ACK_POWER_L_ALT_A() \
        (GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b0)) & 0x3F)

#define GP_WB_GET_MACFILT_ACK_POWER_L_ALT_A_FROM_ACK_POWER_CFG_PAN_ALT_A(tmp) \
        ((tmp) & 0x3F)

#define GP_WB_WRITE_MACFILT_ACK_POWER_L_ALT_A(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b0), 0x3F, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_POWER_L_ALT_A_TO_ACK_POWER_CFG_PAN_ALT_A(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0xFFFFFFC0; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

#define GP_WB_READ_MACFILT_ACK_PA_LOW_L_ALT_A() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b0), 6)

#define GP_WB_GET_MACFILT_ACK_PA_LOW_L_ALT_A_FROM_ACK_POWER_CFG_PAN_ALT_A(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_MACFILT_ACK_PA_LOW_L_ALT_A(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b0), 6, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_PA_LOW_L_ALT_A_TO_ACK_POWER_CFG_PAN_ALT_A(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFBF; \
          (tmp) |= (((UInt32)(val)) << 6); \
        } while (0)

#define GP_WB_READ_MACFILT_ACK_PA_ULTRA_LOW_L_ALT_A() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b0), 7)

#define GP_WB_GET_MACFILT_ACK_PA_ULTRA_LOW_L_ALT_A_FROM_ACK_POWER_CFG_PAN_ALT_A(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_MACFILT_ACK_PA_ULTRA_LOW_L_ALT_A(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b0), 7, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_PA_ULTRA_LOW_L_ALT_A_TO_ACK_POWER_CFG_PAN_ALT_A(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFF7F; \
          (tmp) |= (((UInt32)(val)) << 7); \
        } while (0)

/* ack tx power if rssi is higher or equal to threshold(thr), this is used when incomming frame does belongs to this pan/short/ch_idx combo */
#define GP_WB_READ_MACFILT_ACK_POWER_H_ALT_A() \
        (GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b1)) & 0x3F)

#define GP_WB_GET_MACFILT_ACK_POWER_H_ALT_A_FROM_ACK_POWER_CFG_PAN_ALT_A(tmp) \
        (((tmp) >> 8) & 0x3F)

#define GP_WB_WRITE_MACFILT_ACK_POWER_H_ALT_A(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b1), 0x3F, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_POWER_H_ALT_A_TO_ACK_POWER_CFG_PAN_ALT_A(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0xFFFFC0FF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

#define GP_WB_READ_MACFILT_ACK_PA_LOW_H_ALT_A() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b1), 6)

#define GP_WB_GET_MACFILT_ACK_PA_LOW_H_ALT_A_FROM_ACK_POWER_CFG_PAN_ALT_A(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_MACFILT_ACK_PA_LOW_H_ALT_A(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b1), 6, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_PA_LOW_H_ALT_A_TO_ACK_POWER_CFG_PAN_ALT_A(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFBFFF; \
          (tmp) |= (((UInt32)(val)) << 14); \
        } while (0)

#define GP_WB_READ_MACFILT_ACK_PA_ULTRA_LOW_H_ALT_A() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b1), 7)

#define GP_WB_GET_MACFILT_ACK_PA_ULTRA_LOW_H_ALT_A_FROM_ACK_POWER_CFG_PAN_ALT_A(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_MACFILT_ACK_PA_ULTRA_LOW_H_ALT_A(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b1), 7, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_PA_ULTRA_LOW_H_ALT_A_TO_ACK_POWER_CFG_PAN_ALT_A(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFF7FFF; \
          (tmp) |= (((UInt32)(val)) << 15); \
        } while (0)

/* threshold which will be compared to the rssi of the incomming frame, this is used when incomming frame does belongs to this pan/short/ch_idx combo */
#define GP_WB_READ_MACFILT_ACK_POWER_RSSI_THR_ALT_A() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b2))

#define GP_WB_GET_MACFILT_ACK_POWER_RSSI_THR_ALT_A_FROM_ACK_POWER_CFG_PAN_ALT_A(tmp) \
        (((tmp) >> 16) & 0xFF)

#define GP_WB_WRITE_MACFILT_ACK_POWER_RSSI_THR_ALT_A(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b2), (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_POWER_RSSI_THR_ALT_A_TO_ACK_POWER_CFG_PAN_ALT_A(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0xFF00FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* this has no meaning, just a placeholder for this address so the table is correctly structured */
#define GP_WB_READ_MACFILT_ACK_POWER_SPACING_ALT_A() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b3))

#define GP_WB_GET_MACFILT_ACK_POWER_SPACING_ALT_A_FROM_ACK_POWER_CFG_PAN_ALT_A(tmp) \
        (((tmp) >> 24) & 0xFF)

#define GP_WB_WRITE_MACFILT_ACK_POWER_SPACING_ALT_A(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b3), (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_POWER_SPACING_ALT_A_TO_ACK_POWER_CFG_PAN_ALT_A(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x00FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MACFILT_ACK_POWER_CFG_PAN_ALT_B() \
        GP_WB_READ_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b4))

#define GP_WB_WRITE_MACFILT_ACK_POWER_CFG_PAN_ALT_B(val) \
      GP_WB_WRITE_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b4), (val))

/* ack tx power if rssi is lower than threshold(thr), this is used when incomming frame does belongs to this pan/short/ch_idx combo */
#define GP_WB_READ_MACFILT_ACK_POWER_L_ALT_B() \
        (GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b4)) & 0x3F)

#define GP_WB_GET_MACFILT_ACK_POWER_L_ALT_B_FROM_ACK_POWER_CFG_PAN_ALT_B(tmp) \
        ((tmp) & 0x3F)

#define GP_WB_WRITE_MACFILT_ACK_POWER_L_ALT_B(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b4), 0x3F, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_POWER_L_ALT_B_TO_ACK_POWER_CFG_PAN_ALT_B(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0xFFFFFFC0; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

#define GP_WB_READ_MACFILT_ACK_PA_LOW_L_ALT_B() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b4), 6)

#define GP_WB_GET_MACFILT_ACK_PA_LOW_L_ALT_B_FROM_ACK_POWER_CFG_PAN_ALT_B(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_MACFILT_ACK_PA_LOW_L_ALT_B(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b4), 6, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_PA_LOW_L_ALT_B_TO_ACK_POWER_CFG_PAN_ALT_B(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFFBF; \
          (tmp) |= (((UInt32)(val)) << 6); \
        } while (0)

#define GP_WB_READ_MACFILT_ACK_PA_ULTRA_LOW_L_ALT_B() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b4), 7)

#define GP_WB_GET_MACFILT_ACK_PA_ULTRA_LOW_L_ALT_B_FROM_ACK_POWER_CFG_PAN_ALT_B(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_MACFILT_ACK_PA_ULTRA_LOW_L_ALT_B(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b4), 7, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_PA_ULTRA_LOW_L_ALT_B_TO_ACK_POWER_CFG_PAN_ALT_B(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFFF7F; \
          (tmp) |= (((UInt32)(val)) << 7); \
        } while (0)

/* ack tx power if rssi is higher or equal to threshold(thr), this is used when incomming frame does belongs to this pan/short/ch_idx combo */
#define GP_WB_READ_MACFILT_ACK_POWER_H_ALT_B() \
        (GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b5)) & 0x3F)

#define GP_WB_GET_MACFILT_ACK_POWER_H_ALT_B_FROM_ACK_POWER_CFG_PAN_ALT_B(tmp) \
        (((tmp) >> 8) & 0x3F)

#define GP_WB_WRITE_MACFILT_ACK_POWER_H_ALT_B(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b5), 0x3F, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_POWER_H_ALT_B_TO_ACK_POWER_CFG_PAN_ALT_B(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0xFFFFC0FF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

#define GP_WB_READ_MACFILT_ACK_PA_LOW_H_ALT_B() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b5), 6)

#define GP_WB_GET_MACFILT_ACK_PA_LOW_H_ALT_B_FROM_ACK_POWER_CFG_PAN_ALT_B(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_MACFILT_ACK_PA_LOW_H_ALT_B(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b5), 6, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_PA_LOW_H_ALT_B_TO_ACK_POWER_CFG_PAN_ALT_B(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFBFFF; \
          (tmp) |= (((UInt32)(val)) << 14); \
        } while (0)

#define GP_WB_READ_MACFILT_ACK_PA_ULTRA_LOW_H_ALT_B() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b5), 7)

#define GP_WB_GET_MACFILT_ACK_PA_ULTRA_LOW_H_ALT_B_FROM_ACK_POWER_CFG_PAN_ALT_B(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_MACFILT_ACK_PA_ULTRA_LOW_H_ALT_B(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b5), 7, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_PA_ULTRA_LOW_H_ALT_B_TO_ACK_POWER_CFG_PAN_ALT_B(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFF7FFF; \
          (tmp) |= (((UInt32)(val)) << 15); \
        } while (0)

/* threshold which will be compared to the rssi of the incomming frame, this is used when incomming frame does belongs to this pan/short/ch_idx combo */
#define GP_WB_READ_MACFILT_ACK_POWER_RSSI_THR_ALT_B() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b6))

#define GP_WB_GET_MACFILT_ACK_POWER_RSSI_THR_ALT_B_FROM_ACK_POWER_CFG_PAN_ALT_B(tmp) \
        (((tmp) >> 16) & 0xFF)

#define GP_WB_WRITE_MACFILT_ACK_POWER_RSSI_THR_ALT_B(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b6), (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_POWER_RSSI_THR_ALT_B_TO_ACK_POWER_CFG_PAN_ALT_B(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0xFF00FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* this has no meaning, just a placeholder for this address so the table is correctly structured */
#define GP_WB_READ_MACFILT_ACK_POWER_SPACING_ALT_B() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b7))

#define GP_WB_GET_MACFILT_ACK_POWER_SPACING_ALT_B_FROM_ACK_POWER_CFG_PAN_ALT_B(tmp) \
        (((tmp) >> 24) & 0xFF)

#define GP_WB_WRITE_MACFILT_ACK_POWER_SPACING_ALT_B(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b7), (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_POWER_SPACING_ALT_B_TO_ACK_POWER_CFG_PAN_ALT_B(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x00FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MACFILT_ACK_POWER_CFG_DEFAULT() \
        GP_WB_READ_U24(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b8))

#define GP_WB_WRITE_MACFILT_ACK_POWER_CFG_DEFAULT(val) \
      GP_WB_WRITE_U24(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b8), (val))

/* ack tx power if rssi is lower than threshold(thr), this is used when incomming frame does not belong to a pan/short/ch_idx combo */
#define GP_WB_READ_MACFILT_ACK_POWER_L_DEFAULT() \
        (GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b8)) & 0x3F)

#define GP_WB_GET_MACFILT_ACK_POWER_L_DEFAULT_FROM_ACK_POWER_CFG_DEFAULT(tmp) \
        ((tmp) & 0x3F)

#define GP_WB_WRITE_MACFILT_ACK_POWER_L_DEFAULT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b8), 0x3F, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_POWER_L_DEFAULT_TO_ACK_POWER_CFG_DEFAULT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0xFFFFC0; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

#define GP_WB_READ_MACFILT_ACK_PA_LOW_L_DEFAULT() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b8), 6)

#define GP_WB_GET_MACFILT_ACK_PA_LOW_L_DEFAULT_FROM_ACK_POWER_CFG_DEFAULT(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_MACFILT_ACK_PA_LOW_L_DEFAULT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b8), 6, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_PA_LOW_L_DEFAULT_TO_ACK_POWER_CFG_DEFAULT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFFBF; \
          (tmp) |= (((UInt32)(val)) << 6); \
        } while (0)

#define GP_WB_READ_MACFILT_ACK_PA_ULTRA_LOW_L_DEFAULT() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b8), 7)

#define GP_WB_GET_MACFILT_ACK_PA_ULTRA_LOW_L_DEFAULT_FROM_ACK_POWER_CFG_DEFAULT(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_MACFILT_ACK_PA_ULTRA_LOW_L_DEFAULT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b8), 7, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_PA_ULTRA_LOW_L_DEFAULT_TO_ACK_POWER_CFG_DEFAULT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFF7F; \
          (tmp) |= (((UInt32)(val)) << 7); \
        } while (0)

/* ack tx power if rssi is higher or equal to threshold(thr), this is used when incomming frame does not belong to a pan/short/ch_idx combo */
#define GP_WB_READ_MACFILT_ACK_POWER_H_DEFAULT() \
        (GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b9)) & 0x3F)

#define GP_WB_GET_MACFILT_ACK_POWER_H_DEFAULT_FROM_ACK_POWER_CFG_DEFAULT(tmp) \
        (((tmp) >> 8) & 0x3F)

#define GP_WB_WRITE_MACFILT_ACK_POWER_H_DEFAULT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b9), 0x3F, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_POWER_H_DEFAULT_TO_ACK_POWER_CFG_DEFAULT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0xFFC0FF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

#define GP_WB_READ_MACFILT_ACK_PA_LOW_H_DEFAULT() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b9), 6)

#define GP_WB_GET_MACFILT_ACK_PA_LOW_H_DEFAULT_FROM_ACK_POWER_CFG_DEFAULT(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_MACFILT_ACK_PA_LOW_H_DEFAULT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b9), 6, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_PA_LOW_H_DEFAULT_TO_ACK_POWER_CFG_DEFAULT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFBFFF; \
          (tmp) |= (((UInt32)(val)) << 14); \
        } while (0)

#define GP_WB_READ_MACFILT_ACK_PA_ULTRA_LOW_H_DEFAULT() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b9), 7)

#define GP_WB_GET_MACFILT_ACK_PA_ULTRA_LOW_H_DEFAULT_FROM_ACK_POWER_CFG_DEFAULT(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_MACFILT_ACK_PA_ULTRA_LOW_H_DEFAULT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26b9), 7, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_PA_ULTRA_LOW_H_DEFAULT_TO_ACK_POWER_CFG_DEFAULT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7FFF; \
          (tmp) |= (((UInt32)(val)) << 15); \
        } while (0)

/* threshold which will be compared to the rssi of the incomming frame, this is used when incomming frame does not belong to a pan/short/ch_idx combo */
#define GP_WB_READ_MACFILT_ACK_POWER_RSSI_THR_DEFAULT() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26ba))

#define GP_WB_GET_MACFILT_ACK_POWER_RSSI_THR_DEFAULT_FROM_ACK_POWER_CFG_DEFAULT(tmp) \
        (((tmp) >> 16) & 0xFF)

#define GP_WB_WRITE_MACFILT_ACK_POWER_RSSI_THR_DEFAULT(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26ba), (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_POWER_RSSI_THR_DEFAULT_TO_ACK_POWER_CFG_DEFAULT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x00FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)


/* Nr of  ext address table entries */
#define GP_WB_READ_MACFILT_EXT_ADDR_TABLE_SIZE() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26bb))

#define GP_WB_WRITE_MACFILT_EXT_ADDR_TABLE_SIZE(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26bb), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MACFILT_SHORT_SRC_ADDRESS_TABLE_CONFIG() \
        GP_WB_READ_U24(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26bc))

#define GP_WB_WRITE_MACFILT_SHORT_SRC_ADDRESS_TABLE_CONFIG(val) \
      GP_WB_WRITE_U24(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26bc), (val))

/* short source address table base address ( = offset added to SM_linear start address). Resolution 1 byte - Caution must be 16 bit alligned! */
#define GP_WB_READ_MACFILT_SHORT_SRC_ADDRESS_TABLE_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26bc))

#define GP_WB_GET_MACFILT_SHORT_SRC_ADDRESS_TABLE_BASE_ADDRESS_FROM_SHORT_SRC_ADDRESS_TABLE_CONFIG(tmp) \
        ((tmp) & 0xFFFF)

#define GP_WB_WRITE_MACFILT_SHORT_SRC_ADDRESS_TABLE_BASE_ADDRESS(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26bc), (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_SHORT_SRC_ADDRESS_TABLE_BASE_ADDRESS_TO_SHORT_SRC_ADDRESS_TABLE_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0xFF0000; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Indicates the nr of short src address table entries */
#define GP_WB_READ_MACFILT_SHORT_SRC_ADDRESS_TABLE_SIZE() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26be))

#define GP_WB_GET_MACFILT_SHORT_SRC_ADDRESS_TABLE_SIZE_FROM_SHORT_SRC_ADDRESS_TABLE_CONFIG(tmp) \
        (((tmp) >> 16) & 0xFF)

#define GP_WB_WRITE_MACFILT_SHORT_SRC_ADDRESS_TABLE_SIZE(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26be), (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_SHORT_SRC_ADDRESS_TABLE_SIZE_TO_SHORT_SRC_ADDRESS_TABLE_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x00FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MACFILT_LONG_SRC_ADDRESS_TABLE_CONFIG() \
        GP_WB_READ_U24(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c0))

#define GP_WB_WRITE_MACFILT_LONG_SRC_ADDRESS_TABLE_CONFIG(val) \
      GP_WB_WRITE_U24(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c0), (val))

/* long source address table base address ( = offset added to SM_linear start address). Resolution 1 byte - Caution must be 16 bit alligned! */
#define GP_WB_READ_MACFILT_LONG_SRC_ADDRESS_TABLE_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c0))

#define GP_WB_GET_MACFILT_LONG_SRC_ADDRESS_TABLE_BASE_ADDRESS_FROM_LONG_SRC_ADDRESS_TABLE_CONFIG(tmp) \
        ((tmp) & 0xFFFF)

#define GP_WB_WRITE_MACFILT_LONG_SRC_ADDRESS_TABLE_BASE_ADDRESS(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c0), (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_LONG_SRC_ADDRESS_TABLE_BASE_ADDRESS_TO_LONG_SRC_ADDRESS_TABLE_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0xFF0000; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Indicates the nr of long src address table entries */
#define GP_WB_READ_MACFILT_LONG_SRC_ADDRESS_TABLE_SIZE() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c2))

#define GP_WB_GET_MACFILT_LONG_SRC_ADDRESS_TABLE_SIZE_FROM_LONG_SRC_ADDRESS_TABLE_CONFIG(tmp) \
        (((tmp) >> 16) & 0xFF)

#define GP_WB_WRITE_MACFILT_LONG_SRC_ADDRESS_TABLE_SIZE(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c2), (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_LONG_SRC_ADDRESS_TABLE_SIZE_TO_LONG_SRC_ADDRESS_TABLE_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x00FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MACFILT_GENERIC_CONTROL() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c4))

#define GP_WB_WRITE_MACFILT_GENERIC_CONTROL(val) \
      GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c4), (val))

/* This sets the polarity of the src address search. When set to 0, the fp in the ack will be set to 0 when no match is found, and to 1 when a match is found. When set to 1, the opposite behavior is obtained */
#define GP_WB_READ_MACFILT_FP_VALUE_WHEN_NO_MATCH_FOUND() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c4), 0)

#define GP_WB_GET_MACFILT_FP_VALUE_WHEN_NO_MATCH_FOUND_FROM_GENERIC_CONTROL(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_MACFILT_FP_VALUE_WHEN_NO_MATCH_FOUND(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c4), 0, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_FP_VALUE_WHEN_NO_MATCH_FOUND_TO_GENERIC_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFE; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* When enabled, all packets will be queued even if the macfilter would normally drop the frame. The pbm will indicate in the drop_reason field if the frame was dropped or not */
#define GP_WB_READ_MACFILT_ENABLE_SNIFFING() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c4), 1)

#define GP_WB_GET_MACFILT_ENABLE_SNIFFING_FROM_GENERIC_CONTROL(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_MACFILT_ENABLE_SNIFFING(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c4), 1, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ENABLE_SNIFFING_TO_GENERIC_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFD; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

/* When 1 the macfilter will be disabled and will accept every packet that comes in (needed for BLE) */
#define GP_WB_READ_MACFILT_DISABLE() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c4), 2)

#define GP_WB_GET_MACFILT_DISABLE_FROM_GENERIC_CONTROL(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_MACFILT_DISABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c4), 2, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_DISABLE_TO_GENERIC_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FFB; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* When enabled, the src address search will be done for every frame. Can be set per PAN ID. Index 0 corresponds to pan_id, index 1 -> pan_id_alt_a, index 2 -> pan_id_alt_b. */
#define GP_WB_READ_MACFILT_EVERY_FRAME_IS_DATAREQ() \
        ((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c4)) >> 3) & 0x07)

#define GP_WB_GET_MACFILT_EVERY_FRAME_IS_DATAREQ_FROM_GENERIC_CONTROL(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_MACFILT_EVERY_FRAME_IS_DATAREQ(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c4), 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_MACFILT_EVERY_FRAME_IS_DATAREQ_TO_GENERIC_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x0FC7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

/* When enabled, the src address search will be done for every frame. Default setting, used when a frame cannot be matched with one of the PAN IDs, e.g. broadcast PAN ID. */
#define GP_WB_READ_MACFILT_EVERY_FRAME_IS_DATAREQ_DEFAULT() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c4), 6)

#define GP_WB_GET_MACFILT_EVERY_FRAME_IS_DATAREQ_DEFAULT_FROM_GENERIC_CONTROL(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_MACFILT_EVERY_FRAME_IS_DATAREQ_DEFAULT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c4), 6, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_EVERY_FRAME_IS_DATAREQ_DEFAULT_TO_GENERIC_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0FBF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

/* When enabled, no ack will be sent if the src address is not in the src list */
#define GP_WB_READ_MACFILT_DONT_ACK_IF_NOT_IN_SRC_LIST() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c4), 7)

#define GP_WB_GET_MACFILT_DONT_ACK_IF_NOT_IN_SRC_LIST_FROM_GENERIC_CONTROL(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_MACFILT_DONT_ACK_IF_NOT_IN_SRC_LIST(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c4), 7, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_DONT_ACK_IF_NOT_IN_SRC_LIST_TO_GENERIC_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* When enabled, frames will be dropped when the src address is not in the src list */
#define GP_WB_READ_MACFILT_DROP_IF_NOT_IN_SRC_LIST() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c5), 0)

#define GP_WB_GET_MACFILT_DROP_IF_NOT_IN_SRC_LIST_FROM_GENERIC_CONTROL(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_MACFILT_DROP_IF_NOT_IN_SRC_LIST(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c5), 0, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_DROP_IF_NOT_IN_SRC_LIST_TO_GENERIC_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0EFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* when enabled the macfilter will claim the radio for zigbee as soon as the header is received. When disabled, the radio is only claimed for packets on which an ACK respose is to be sent. */
#define GP_WB_READ_MACFILT_CLAIM_RADIO_ON_EVERY_RX() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c5), 1)

#define GP_WB_GET_MACFILT_CLAIM_RADIO_ON_EVERY_RX_FROM_GENERIC_CONTROL(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_MACFILT_CLAIM_RADIO_ON_EVERY_RX(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c5), 1, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_CLAIM_RADIO_ON_EVERY_RX_TO_GENERIC_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0DFF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)

/* when enabled, the CSL IE will be inserted into the Enhanced-Ack */
#define GP_WB_READ_MACFILT_ENH_ACK_INSERT_CSL_IE() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c5), 2)

#define GP_WB_GET_MACFILT_ENH_ACK_INSERT_CSL_IE_FROM_GENERIC_CONTROL(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_MACFILT_ENH_ACK_INSERT_CSL_IE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c5), 2, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ENH_ACK_INSERT_CSL_IE_TO_GENERIC_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0BFF; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)

/* When enabled, the macfilter will support 2015 spec frames. Not all features are implemented yet. */
#define GP_WB_READ_MACFILT_ENABLE_2015_SUPPORT() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c5), 3)

#define GP_WB_GET_MACFILT_ENABLE_2015_SUPPORT_FROM_GENERIC_CONTROL(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_MACFILT_ENABLE_2015_SUPPORT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c5), 3, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ENABLE_2015_SUPPORT_TO_GENERIC_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FF; \
          (tmp) |= (((UInt16)(val)) << 11); \
        } while (0)


/* Cmd type that can be filtered on */
#define GP_WB_READ_MACFILT_CMD_TYPE() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c6))

#define GP_WB_WRITE_MACFILT_CMD_TYPE(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c6), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MACFILT_FRAME_TYPE_ACCEPT() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c7))

#define GP_WB_WRITE_MACFILT_FRAME_TYPE_ACCEPT(val) \
      GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c7), (val))

/* When 1, frames of type beacon will be accepted by mac filter, and will be acked if needed and other filters also match */
#define GP_WB_READ_MACFILT_ACCEPT_FT_BCN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c7), 0)

#define GP_WB_GET_MACFILT_ACCEPT_FT_BCN_FROM_FRAME_TYPE_ACCEPT(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_FT_BCN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c7), 0, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_FT_BCN_TO_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When 1, frames of type data will be accepted by mac filter, and will be acked if needed and other filters also match */
#define GP_WB_READ_MACFILT_ACCEPT_FT_DATA() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c7), 1)

#define GP_WB_GET_MACFILT_ACCEPT_FT_DATA_FROM_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_FT_DATA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c7), 1, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_FT_DATA_TO_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* When 1, frames of type ack will not be dropped by mac filter, and will be acked if needed and other filters also match */
#define GP_WB_READ_MACFILT_ACCEPT_FT_ACK() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c7), 2)

#define GP_WB_GET_MACFILT_ACCEPT_FT_ACK_FROM_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_FT_ACK(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c7), 2, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_FT_ACK_TO_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* When 1, frames of type beacon will not be dropped by mac filter, and will be acked if needed and other filters also match */
#define GP_WB_READ_MACFILT_ACCEPT_FT_CMD() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c7), 3)

#define GP_WB_GET_MACFILT_ACCEPT_FT_CMD_FROM_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_FT_CMD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c7), 3, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_FT_CMD_TO_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* When 1, frames of reserved frame type(s) will not be dropped by mac filter, and will be acked if needed and other filters also match */
#define GP_WB_READ_MACFILT_ACCEPT_FT_RSV_4() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c7), 4)

#define GP_WB_GET_MACFILT_ACCEPT_FT_RSV_4_FROM_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_FT_RSV_4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c7), 4, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_FT_RSV_4_TO_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* When 1, frames of Multipurpose frame type(s) will not be dropped by mac filter, and will be acked if needed and other filters also match */
#define GP_WB_READ_MACFILT_ACCEPT_FT_MP() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c7), 5)

#define GP_WB_GET_MACFILT_ACCEPT_FT_MP_FROM_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_FT_MP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c7), 5, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_FT_MP_TO_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* When 1, frames of fragment or frak frame type(s) will not be dropped by mac filter, and will be acked if needed and other filters also match */
#define GP_WB_READ_MACFILT_ACCEPT_FT_FRA() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c7), 6)

#define GP_WB_GET_MACFILT_ACCEPT_FT_FRA_FROM_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_FT_FRA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c7), 6, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_FT_FRA_TO_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* When 1, frames of extended frame type(s) will not be dropped by mac filter, and will be acked if needed and other filters also match */
#define GP_WB_READ_MACFILT_ACCEPT_FT_EXT() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c7), 7)

#define GP_WB_GET_MACFILT_ACCEPT_FT_EXT_FROM_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_FT_EXT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c7), 7, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_FT_EXT_TO_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MACFILT_FRAME_VERSION_ACCEPT() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c8))

#define GP_WB_WRITE_MACFILT_FRAME_VERSION_ACCEPT(val) \
      GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c8), (val))

/* When 1, frames of frames using the 2003 mac version will be accepted and acked if needed and other filters also match */
#define GP_WB_READ_MACFILT_ACCEPT_FV_2003() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c8), 0)

#define GP_WB_GET_MACFILT_ACCEPT_FV_2003_FROM_FRAME_VERSION_ACCEPT(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_FV_2003(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c8), 0, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_FV_2003_TO_FRAME_VERSION_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When 1, frames of frames using the 2006 mac version will be accepted and acked if needed and other filters also match */
#define GP_WB_READ_MACFILT_ACCEPT_FV_2006() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c8), 1)

#define GP_WB_GET_MACFILT_ACCEPT_FV_2006_FROM_FRAME_VERSION_ACCEPT(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_FV_2006(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c8), 1, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_FV_2006_TO_FRAME_VERSION_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* When 1, frames of frames using the 2010 mac version will be accepted and acked if needed and other filters also match */
#define GP_WB_READ_MACFILT_ACCEPT_FV_2015() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c8), 2)

#define GP_WB_GET_MACFILT_ACCEPT_FV_2015_FROM_FRAME_VERSION_ACCEPT(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_FV_2015(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c8), 2, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_FV_2015_TO_FRAME_VERSION_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* When 1, frames of frames using the unknown mac version will be accepted and acked if needed and other filters also match */
#define GP_WB_READ_MACFILT_ACCEPT_FV_RSV_3() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c8), 3)

#define GP_WB_GET_MACFILT_ACCEPT_FV_RSV_3_FROM_FRAME_VERSION_ACCEPT(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_FV_RSV_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c8), 3, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_FV_RSV_3_TO_FRAME_VERSION_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MACFILT_FRAME_ADDRESSING_ACCEPT() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c9))

#define GP_WB_WRITE_MACFILT_FRAME_ADDRESSING_ACCEPT(val) \
      GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c9), (val))

/* When 1, beacon frames with src address mode set to 0 will be accepted. Default is 0, used to filter out all zero packets */
#define GP_WB_READ_MACFILT_ACCEPT_FT_BCN_SRC_ADDR_MODE_00() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c9), 0)

#define GP_WB_GET_MACFILT_ACCEPT_FT_BCN_SRC_ADDR_MODE_00_FROM_FRAME_ADDRESSING_ACCEPT(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_FT_BCN_SRC_ADDR_MODE_00(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c9), 0, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_FT_BCN_SRC_ADDR_MODE_00_TO_FRAME_ADDRESSING_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When 1 (=default), broadcast destination addressing will be accepted. Use this setting to filter out broadcast packets */
#define GP_WB_READ_MACFILT_ACCEPT_BCAST_DADDR() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c9), 1)

#define GP_WB_GET_MACFILT_ACCEPT_BCAST_DADDR_FROM_FRAME_ADDRESSING_ACCEPT(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_BCAST_DADDR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c9), 1, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_BCAST_DADDR_TO_FRAME_ADDRESSING_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* When 1 (=default), broadcast pan id-s will be accepted. Use this setting to filter out packets using broadcast */
#define GP_WB_READ_MACFILT_ACCEPT_BCAST_PAN_ID() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c9), 2)

#define GP_WB_GET_MACFILT_ACCEPT_BCAST_PAN_ID_FROM_FRAME_ADDRESSING_ACCEPT(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_MACFILT_ACCEPT_BCAST_PAN_ID(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26c9), 2, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACCEPT_BCAST_PAN_ID_TO_FRAME_ADDRESSING_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MACFILT_FRAME_CHECKS() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26ca))

#define GP_WB_WRITE_MACFILT_FRAME_CHECKS(val) \
      GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26ca), (val))

/* When 1, the src pan id is checked for beacon frames, and the frame is accepted when the pan id matches */
#define GP_WB_READ_MACFILT_SRC_PAN_ID_BEACON_CHECK_ON() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26ca), 0)

#define GP_WB_GET_MACFILT_SRC_PAN_ID_BEACON_CHECK_ON_FROM_FRAME_CHECKS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_MACFILT_SRC_PAN_ID_BEACON_CHECK_ON(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26ca), 0, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_SRC_PAN_ID_BEACON_CHECK_ON_TO_FRAME_CHECKS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When 1, the src pan id is checked for data/cmd frames, and the frame is accepted when the pan id matches */
#define GP_WB_READ_MACFILT_SRC_PAN_ID_DATA_COMMAND_CHECK_ON() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26ca), 1)

#define GP_WB_GET_MACFILT_SRC_PAN_ID_DATA_COMMAND_CHECK_ON_FROM_FRAME_CHECKS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_MACFILT_SRC_PAN_ID_DATA_COMMAND_CHECK_ON(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26ca), 1, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_SRC_PAN_ID_DATA_COMMAND_CHECK_ON_TO_FRAME_CHECKS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* When 1, the destination pan id is checked and the frame is accepted when the pan id matches */
#define GP_WB_READ_MACFILT_DST_PAN_ID_CHECK_ON() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26ca), 2)

#define GP_WB_GET_MACFILT_DST_PAN_ID_CHECK_ON_FROM_FRAME_CHECKS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_MACFILT_DST_PAN_ID_CHECK_ON(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26ca), 2, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_DST_PAN_ID_CHECK_ON_TO_FRAME_CHECKS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* When 1, the src addr is checked and the frame is accepted when the src address matches the address set by short_addr (or extended addresss) */
#define GP_WB_READ_MACFILT_DST_ADDR_CHECK_ON() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26ca), 3)

#define GP_WB_GET_MACFILT_DST_ADDR_CHECK_ON_FROM_FRAME_CHECKS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_MACFILT_DST_ADDR_CHECK_ON(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26ca), 3, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_DST_ADDR_CHECK_ON_TO_FRAME_CHECKS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* When 1, the cmd type is checked and the frame is accepted when the command type matches */
#define GP_WB_READ_MACFILT_CMD_TYPE_CHECK_ON() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26ca), 4)

#define GP_WB_GET_MACFILT_CMD_TYPE_CHECK_ON_FROM_FRAME_CHECKS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_MACFILT_CMD_TYPE_CHECK_ON(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26ca), 4, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_CMD_TYPE_CHECK_ON_TO_FRAME_CHECKS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MACFILT_FRAME_TO_QUEUE_ENABLES() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cb))

#define GP_WB_WRITE_MACFILT_FRAME_TO_QUEUE_ENABLES(val) \
      GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cb), (val))

/* When 1, beacon frames will be passed to the queue */
#define GP_WB_READ_MACFILT_FT_BCN_TO_QUEUE() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cb), 0)

#define GP_WB_GET_MACFILT_FT_BCN_TO_QUEUE_FROM_FRAME_TO_QUEUE_ENABLES(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_MACFILT_FT_BCN_TO_QUEUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cb), 0, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_FT_BCN_TO_QUEUE_TO_FRAME_TO_QUEUE_ENABLES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When 1, data frames will be passed to the queue */
#define GP_WB_READ_MACFILT_FT_DATA_TO_QUEUE() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cb), 1)

#define GP_WB_GET_MACFILT_FT_DATA_TO_QUEUE_FROM_FRAME_TO_QUEUE_ENABLES(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_MACFILT_FT_DATA_TO_QUEUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cb), 1, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_FT_DATA_TO_QUEUE_TO_FRAME_TO_QUEUE_ENABLES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* When 1, ack frames will be passed to the queue */
#define GP_WB_READ_MACFILT_FT_ACK_TO_QUEUE() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cb), 2)

#define GP_WB_GET_MACFILT_FT_ACK_TO_QUEUE_FROM_FRAME_TO_QUEUE_ENABLES(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_MACFILT_FT_ACK_TO_QUEUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cb), 2, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_FT_ACK_TO_QUEUE_TO_FRAME_TO_QUEUE_ENABLES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* When 1, cmd frames will be passed to the queue */
#define GP_WB_READ_MACFILT_FT_CMD_TO_QUEUE() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cb), 3)

#define GP_WB_GET_MACFILT_FT_CMD_TO_QUEUE_FROM_FRAME_TO_QUEUE_ENABLES(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_MACFILT_FT_CMD_TO_QUEUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cb), 3, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_FT_CMD_TO_QUEUE_TO_FRAME_TO_QUEUE_ENABLES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* When 1, reserved frames will be passed to the queue */
#define GP_WB_READ_MACFILT_FT_RSV_4_TO_QUEUE() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cb), 4)

#define GP_WB_GET_MACFILT_FT_RSV_4_TO_QUEUE_FROM_FRAME_TO_QUEUE_ENABLES(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_MACFILT_FT_RSV_4_TO_QUEUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cb), 4, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_FT_RSV_4_TO_QUEUE_TO_FRAME_TO_QUEUE_ENABLES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* When 1, Multipurpose frames will be passed to the queue */
#define GP_WB_READ_MACFILT_FT_MP_TO_QUEUE() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cb), 5)

#define GP_WB_GET_MACFILT_FT_MP_TO_QUEUE_FROM_FRAME_TO_QUEUE_ENABLES(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_MACFILT_FT_MP_TO_QUEUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cb), 5, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_FT_MP_TO_QUEUE_TO_FRAME_TO_QUEUE_ENABLES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* When 1, fragment or frak frames will be passed to the queue */
#define GP_WB_READ_MACFILT_FT_FRA_TO_QUEUE() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cb), 6)

#define GP_WB_GET_MACFILT_FT_FRA_TO_QUEUE_FROM_FRAME_TO_QUEUE_ENABLES(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_MACFILT_FT_FRA_TO_QUEUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cb), 6, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_FT_FRA_TO_QUEUE_TO_FRAME_TO_QUEUE_ENABLES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* When 1, extended frames will be passed to the queue */
#define GP_WB_READ_MACFILT_FT_EXT_TO_QUEUE() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cb), 7)

#define GP_WB_GET_MACFILT_FT_EXT_TO_QUEUE_FROM_FRAME_TO_QUEUE_ENABLES(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_MACFILT_FT_EXT_TO_QUEUE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cb), 7, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_FT_EXT_TO_QUEUE_TO_FRAME_TO_QUEUE_ENABLES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_MACFILT_ACK_REQUEST_ENABLES() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cc))

#define GP_WB_WRITE_MACFILT_ACK_REQUEST_ENABLES(val) \
      GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cc), (val))

/* enable ack request for channel index 0 */
#define GP_WB_READ_MACFILT_ACK_REQUEST_ENABLE_CH_IDX_0() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cc), 0)

#define GP_WB_GET_MACFILT_ACK_REQUEST_ENABLE_CH_IDX_0_FROM_ACK_REQUEST_ENABLES(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_MACFILT_ACK_REQUEST_ENABLE_CH_IDX_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cc), 0, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_REQUEST_ENABLE_CH_IDX_0_TO_ACK_REQUEST_ENABLES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* enable ack request for channel index 1 */
#define GP_WB_READ_MACFILT_ACK_REQUEST_ENABLE_CH_IDX_1() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cc), 1)

#define GP_WB_GET_MACFILT_ACK_REQUEST_ENABLE_CH_IDX_1_FROM_ACK_REQUEST_ENABLES(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_MACFILT_ACK_REQUEST_ENABLE_CH_IDX_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cc), 1, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_REQUEST_ENABLE_CH_IDX_1_TO_ACK_REQUEST_ENABLES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* enable ack request for channel index 2 */
#define GP_WB_READ_MACFILT_ACK_REQUEST_ENABLE_CH_IDX_2() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cc), 2)

#define GP_WB_GET_MACFILT_ACK_REQUEST_ENABLE_CH_IDX_2_FROM_ACK_REQUEST_ENABLES(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_MACFILT_ACK_REQUEST_ENABLE_CH_IDX_2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cc), 2, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_REQUEST_ENABLE_CH_IDX_2_TO_ACK_REQUEST_ENABLES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* enable ack request for channel index 3 */
#define GP_WB_READ_MACFILT_ACK_REQUEST_ENABLE_CH_IDX_3() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cc), 3)

#define GP_WB_GET_MACFILT_ACK_REQUEST_ENABLE_CH_IDX_3_FROM_ACK_REQUEST_ENABLES(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_MACFILT_ACK_REQUEST_ENABLE_CH_IDX_3(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cc), 3, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_REQUEST_ENABLE_CH_IDX_3_TO_ACK_REQUEST_ENABLES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* enable ack request for channel index 4 */
#define GP_WB_READ_MACFILT_ACK_REQUEST_ENABLE_CH_IDX_4() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cc), 4)

#define GP_WB_GET_MACFILT_ACK_REQUEST_ENABLE_CH_IDX_4_FROM_ACK_REQUEST_ENABLES(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_MACFILT_ACK_REQUEST_ENABLE_CH_IDX_4(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cc), 4, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_REQUEST_ENABLE_CH_IDX_4_TO_ACK_REQUEST_ENABLES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* enable ack request for channel index 5 */
#define GP_WB_READ_MACFILT_ACK_REQUEST_ENABLE_CH_IDX_5() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cc), 5)

#define GP_WB_GET_MACFILT_ACK_REQUEST_ENABLE_CH_IDX_5_FROM_ACK_REQUEST_ENABLES(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_MACFILT_ACK_REQUEST_ENABLE_CH_IDX_5(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cc), 5, (val)); \
        } while (0)

#define GP_WB_SET_MACFILT_ACK_REQUEST_ENABLE_CH_IDX_5_TO_ACK_REQUEST_ENABLES(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* Sequence number place holder register for the sequence number of ongoing transmission */
#define GP_WB_READ_MACFILT_TX_SEQ_NUMBER() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cd))

#define GP_WB_WRITE_MACFILT_TX_SEQ_NUMBER(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26cd), (val)); \
        } while (0)


/* placeholder to put a broadcast mask (so 0xFFFF) - needs to be inited */
#define GP_WB_READ_MACFILT_BROADCAST_MASK() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26ce))

#define GP_WB_WRITE_MACFILT_BROADCAST_MASK(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26ce), (val)); \
        } while (0)


#define GP_WB_READ_MACFILT_DEBUG() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26d0))

#define GP_WB_WRITE_MACFILT_DEBUG(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26d0), (val)); \
        } while (0)


#define GP_WB_READ_MACFILT_STATE() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26d1))

#define GP_WB_WRITE_MACFILT_STATE(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26d1), (val)); \
        } while (0)


/* value in microseconds of the next sample time. */
#define GP_WB_READ_MACFILT_CSL_SAMPLETIME() \
        GP_WB_READ_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26d4))

#define GP_WB_WRITE_MACFILT_CSL_SAMPLETIME(val) do { \
          GP_WB_WRITE_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26d4), (val)); \
        } while (0)


/* value in 10*symbol units of the CSL period. */
#define GP_WB_READ_MACFILT_CSL_PERIOD() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26d8))

#define GP_WB_WRITE_MACFILT_CSL_PERIOD(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26d8), (val)); \
        } while (0)


/* selects the internal antenna to use for ack transmission. (from_design=same antenna as packet was received on) */
#define GP_WB_READ_MACFILT_ACK_ANTSEL_INT() \
        (GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26db)) & 0x03)

#define GP_WB_WRITE_MACFILT_ACK_ANTSEL_INT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26db), 0x03, (val)); \
        } while (0)

/* selects the external antenna to use for ack transmission. (from_design=same antenna as packet was received on, uses rx_ant_ext_0|1) */
#define GP_WB_READ_MACFILT_ACK_ANTSEL_EXT() \
        ((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26db)) >> 2) & 0x03)

#define GP_WB_WRITE_MACFILT_ACK_ANTSEL_EXT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26db), 0x0C, (val) << 2); \
        } while (0)

/* mode_ctrl bit to use for ack transmission. */
#define GP_WB_READ_MACFILT_ACK_MODE_CTRL() \
        ((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26db)) >> 4) & 0x0F)

#define GP_WB_WRITE_MACFILT_ACK_MODE_CTRL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26db), 0xF0, (val) << 4); \
        } while (0)


/* A pointer to a struct with security info be used in the transmit frames that are encrypted by the RT code (for a stack in Raw mode). */
#define GP_WB_READ_MACFILT_RAWMODE_NONCE_PTR() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26dc))

#define GP_WB_WRITE_MACFILT_RAWMODE_NONCE_PTR(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26dc), (val)); \
        } while (0)


/* A pointer to a struct containing the key identifier and key values to be used in the transmit frames that are encrypted by the RT code (for a stack in Raw mode). */
#define GP_WB_READ_MACFILT_RAWMODE_KEY_INFO_PTR() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26de))

#define GP_WB_WRITE_MACFILT_RAWMODE_KEY_INFO_PTR(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26de), (val)); \
        } while (0)


/* A pointer to the vsie struct which containst the info to insert the VS IE in enhanced ack frames. */
#define GP_WB_READ_MACFILT_RAWMODE_VSIE_PTR() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26e0))

#define GP_WB_WRITE_MACFILT_RAWMODE_VSIE_PTR(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc26e0), (val)); \
        } while (0)

/***************************
 * layout: ble_mgr
 ***************************/

#define GP_WB_READ_BLE_MGR_STATE() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2700))

#define GP_WB_WRITE_BLE_MGR_STATE(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2700), (val)); \
        } while (0)


#define GP_WB_READ_BLE_MGR_DEBUG() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2701))

#define GP_WB_WRITE_BLE_MGR_DEBUG(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2701), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BLE_MGR_CURRENT_EVENT() \
        GP_WB_READ_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2704))

#define GP_WB_WRITE_BLE_MGR_CURRENT_EVENT(val) \
      GP_WB_WRITE_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2704), (val))

/* nr of skipped events priority state of the ble_mgr */
#define GP_WB_READ_BLE_MGR_CURRENT_PRIO_NR_SKIPPED() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2704))

#define GP_WB_GET_BLE_MGR_CURRENT_PRIO_NR_SKIPPED_FROM_CURRENT_EVENT(tmp) \
        ((tmp) & 0xFFFF)

#define GP_WB_WRITE_BLE_MGR_CURRENT_PRIO_NR_SKIPPED(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2704), (val)); \
        } while (0)

#define GP_WB_SET_BLE_MGR_CURRENT_PRIO_NR_SKIPPED_TO_CURRENT_EVENT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0xFFFF0000; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* base priority state of the ble_mgr */
#define GP_WB_READ_BLE_MGR_CURRENT_PRIO_BASE() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2706))

#define GP_WB_GET_BLE_MGR_CURRENT_PRIO_BASE_FROM_CURRENT_EVENT(tmp) \
        (((tmp) >> 16) & 0xFF)

#define GP_WB_WRITE_BLE_MGR_CURRENT_PRIO_BASE(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2706), (val)); \
        } while (0)

#define GP_WB_SET_BLE_MGR_CURRENT_PRIO_BASE_TO_CURRENT_EVENT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0xFF00FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* current event number being executed */
#define GP_WB_READ_BLE_MGR_CURRENT_EVENT_NR() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2707))

#define GP_WB_GET_BLE_MGR_CURRENT_EVENT_NR_FROM_CURRENT_EVENT(tmp) \
        (((tmp) >> 24) & 0xFF)

#define GP_WB_WRITE_BLE_MGR_CURRENT_EVENT_NR(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2707), (val)); \
        } while (0)

#define GP_WB_SET_BLE_MGR_CURRENT_EVENT_NR_TO_CURRENT_EVENT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x00FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BLE_MGR_NEXT_EVENT() \
        GP_WB_READ_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2708))

#define GP_WB_WRITE_BLE_MGR_NEXT_EVENT(val) \
      GP_WB_WRITE_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2708), (val))

/* nr of skipped events priority state of the next event */
#define GP_WB_READ_BLE_MGR_NEXT_PRIO_NR_SKIPPED() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2708))

#define GP_WB_GET_BLE_MGR_NEXT_PRIO_NR_SKIPPED_FROM_NEXT_EVENT(tmp) \
        ((tmp) & 0xFFFF)

#define GP_WB_WRITE_BLE_MGR_NEXT_PRIO_NR_SKIPPED(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2708), (val)); \
        } while (0)

#define GP_WB_SET_BLE_MGR_NEXT_PRIO_NR_SKIPPED_TO_NEXT_EVENT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0xFFFF0000; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* base priority of next event */
#define GP_WB_READ_BLE_MGR_NEXT_PRIO_BASE() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc270a))

#define GP_WB_GET_BLE_MGR_NEXT_PRIO_BASE_FROM_NEXT_EVENT(tmp) \
        (((tmp) >> 16) & 0xFF)

#define GP_WB_WRITE_BLE_MGR_NEXT_PRIO_BASE(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc270a), (val)); \
        } while (0)

#define GP_WB_SET_BLE_MGR_NEXT_PRIO_BASE_TO_NEXT_EVENT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0xFF00FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* next event number waiting to be executed */
#define GP_WB_READ_BLE_MGR_NEXT_EVENT_NR() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc270b))

#define GP_WB_GET_BLE_MGR_NEXT_EVENT_NR_FROM_NEXT_EVENT(tmp) \
        (((tmp) >> 24) & 0xFF)

#define GP_WB_WRITE_BLE_MGR_NEXT_EVENT_NR(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc270b), (val)); \
        } while (0)

#define GP_WB_SET_BLE_MGR_NEXT_EVENT_NR_TO_NEXT_EVENT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x00FFFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)


#define GP_WB_READ_BLE_MGR_ABORT_CURRENT_EVENT() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc270c), 0)

#define GP_WB_WRITE_BLE_MGR_ABORT_CURRENT_EVENT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc270c), (val)); \
        } while (0)


/* internal state to keep the atomic depth */
#define GP_WB_READ_BLE_MGR_ATOMIC_CNT() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc270d))

#define GP_WB_WRITE_BLE_MGR_ATOMIC_CNT(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc270d), (val)); \
        } while (0)


/* How much time the cleanup event should be generated before the actual event. */
#define GP_WB_READ_BLE_MGR_CLEANUP_TIME() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc270e))

#define GP_WB_WRITE_BLE_MGR_CLEANUP_TIME(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc270e), (val)); \
        } while (0)


/* The amount of time the ble_ev_mgr should wakeup before the first actual event action (TX, RX WINDOW) */
#define GP_WB_READ_BLE_MGR_EVENT_PROCESSING_DELAY() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2710))

#define GP_WB_WRITE_BLE_MGR_EVENT_PROCESSING_DELAY(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2710), (val)); \
        } while (0)


/* Additional offset for opening the rx window after a tx. Resolution 1 us */
#define GP_WB_READ_BLE_MGR_RESPONSE_WD_OFFSET() \
        (GP_WB_S8(GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2712)), 8))

#define GP_WB_WRITE_BLE_MGR_RESPONSE_WD_OFFSET(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2712), (UInt8)((val))); \
        } while (0)

/* Additional duration of the response listen window. Resolution 1 us */
#define GP_WB_READ_BLE_MGR_RESPONSE_WD_EXTRA_DURATION() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2713))

#define GP_WB_WRITE_BLE_MGR_RESPONSE_WD_EXTRA_DURATION(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2713), (val)); \
        } while (0)


/* Tmp debug setting to override T_IFS. Resolution 1 us */
#define GP_WB_READ_BLE_MGR_T_IFS() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2714))

#define GP_WB_WRITE_BLE_MGR_T_IFS(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2714), (val)); \
        } while (0)


/* The total jitter (in us) RT needs to take into account when scheduling relative RX windows */
#define GP_WB_READ_BLE_MGR_TOTAL_JITTER_US() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2715))

#define GP_WB_WRITE_BLE_MGR_TOTAL_JITTER_US(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2715), (val)); \
        } while (0)


/* Correction to be done on the first tx timestamp in an event (so for a tx with calibration in fact). Resolution 1 us */
#define GP_WB_READ_BLE_MGR_FIRST_TX_TIMESTAMP_COR() \
        (GP_WB_S16(GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2718)), 16))

#define GP_WB_WRITE_BLE_MGR_FIRST_TX_TIMESTAMP_COR(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2718), (UInt16)((val))); \
        } while (0)

/* Correction to be done on a response tx timestamp in an event (tx without calibration). Resolution 1 us */
#define GP_WB_READ_BLE_MGR_RESPONSE_TX_TIMESTAMP_COR() \
        (GP_WB_S16(GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc271a)), 16))

#define GP_WB_WRITE_BLE_MGR_RESPONSE_TX_TIMESTAMP_COR(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc271a), (UInt16)((val))); \
        } while (0)


#define GP_WB_READ_BLE_MGR_DISABLE_RX_WHITENING() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc271c), 0)

#define GP_WB_WRITE_BLE_MGR_DISABLE_RX_WHITENING(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc271c), 0, (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CLAIM_RADIO_ON_CLEANUP() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc271c), 1)

#define GP_WB_WRITE_BLE_MGR_CLAIM_RADIO_ON_CLEANUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc271c), 1, (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_SHUTDOWN_DURING_CLEANUP() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc271c), 2)

#define GP_WB_WRITE_BLE_MGR_SHUTDOWN_DURING_CLEANUP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc271c), 2, (val)); \
        } while (0)

/* flag to enable multi-standard listening, if 1 events using the ADV access address and that have the ms_allowed flag to 1, can listen in multi-standard */
#define GP_WB_READ_BLE_MGR_MS_ENABLED() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc271c), 3)

#define GP_WB_WRITE_BLE_MGR_MS_ENABLED(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc271c), 3, (val)); \
        } while (0)


/* Indicates wheter a gpmicro shutdown is pending. */
#define GP_WB_READ_BLE_MGR_SHUTDOWN_PENDING() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc271d), 0)

#define GP_WB_WRITE_BLE_MGR_SHUTDOWN_PENDING(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc271d), (val)); \
        } while (0)


/* pointer to the tx power configuration regmap */
#define GP_WB_READ_BLE_MGR_TX_POWER_CONFIG_PTR() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc271e))

#define GP_WB_WRITE_BLE_MGR_TX_POWER_CONFIG_PTR(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc271e), (val)); \
        } while (0)


/* The BLE MAC device address of the chip */
#define GP_WB_READ_BLE_MGR_DEVICE_ADDRESS() \
        GP_WB_READ_U48(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2720))

#define GP_WB_WRITE_BLE_MGR_DEVICE_ADDRESS(val) do { \
          GP_WB_WRITE_U48(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2720), (val)); \
        } while (0)


/* Pointer to the list of register updates(in gpmicro memory map space), needed to differentiate between ble and ble_hdr RX */
#define GP_WB_READ_BLE_MGR_PRE_RX_UPDATE_LIST_PTR() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2726))

#define GP_WB_WRITE_BLE_MGR_PRE_RX_UPDATE_LIST_PTR(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2726), (val)); \
        } while (0)


/* The number of preambles the RT system should take into account for 1 Mbit frames */
#define GP_WB_READ_BLE_MGR_PREAMBLE_LEN() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2728))

#define GP_WB_WRITE_BLE_MGR_PREAMBLE_LEN(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2728), (val)); \
        } while (0)

/* The number of preambles the RT system should take into account for 2 Mbit frames */
#define GP_WB_READ_BLE_MGR_HDR_PREAMBLE_LEN() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2729))

#define GP_WB_WRITE_BLE_MGR_HDR_PREAMBLE_LEN(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2729), (val)); \
        } while (0)


/* The access address for the advertising channels */
#define GP_WB_READ_BLE_MGR_ADV_ACCESS_ADDRESS() \
        GP_WB_READ_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc272c))

#define GP_WB_WRITE_BLE_MGR_ADV_ACCESS_ADDRESS(val) do { \
          GP_WB_WRITE_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc272c), (val)); \
        } while (0)


/* Threshold for BLE preamble detect */
#define GP_WB_READ_BLE_MGR_ADV_PREAMBLE_THRESH() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2730))

#define GP_WB_WRITE_BLE_MGR_ADV_PREAMBLE_THRESH(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2730), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BLE_MGR_ADV_VALIDATION_SETTINGS() \
        GP_WB_READ_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2734))

#define GP_WB_WRITE_BLE_MGR_ADV_VALIDATION_SETTINGS(val) \
      GP_WB_WRITE_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2734), (val))

/* Threshold for BLE preamble validation */
#define GP_WB_READ_BLE_MGR_ADV_VALIDATION_THRESH() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2734))

#define GP_WB_GET_BLE_MGR_ADV_VALIDATION_THRESH_FROM_ADV_VALIDATION_SETTINGS(tmp) \
        ((tmp) & 0xFFFF)

#define GP_WB_WRITE_BLE_MGR_ADV_VALIDATION_THRESH(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2734), (val)); \
        } while (0)

#define GP_WB_SET_BLE_MGR_ADV_VALIDATION_THRESH_TO_ADV_VALIDATION_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x9F1F0000; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Amount of symbols inside the access code the validation is going to start */
#define GP_WB_READ_BLE_MGR_ADV_VALIDATION_START_IDX() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2736))

#define GP_WB_GET_BLE_MGR_ADV_VALIDATION_START_IDX_FROM_ADV_VALIDATION_SETTINGS(tmp) \
        (((tmp) >> 16) & 0x1F)

#define GP_WB_WRITE_BLE_MGR_ADV_VALIDATION_START_IDX(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2736), (val)); \
        } while (0)

#define GP_WB_SET_BLE_MGR_ADV_VALIDATION_START_IDX_TO_ADV_VALIDATION_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x9F00FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* The index inside the access code where a fake preamble starts */
#define GP_WB_READ_BLE_MGR_ADV_FAKE_PREAMBLE_START_IDX() \
        (GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2737)) & 0x1F)

#define GP_WB_GET_BLE_MGR_ADV_FAKE_PREAMBLE_START_IDX_FROM_ADV_VALIDATION_SETTINGS(tmp) \
        (((tmp) >> 24) & 0x1F)

#define GP_WB_WRITE_BLE_MGR_ADV_FAKE_PREAMBLE_START_IDX(val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2737), 0x1F, (val)); \
        } while (0)

#define GP_WB_SET_BLE_MGR_ADV_FAKE_PREAMBLE_START_IDX_TO_ADV_VALIDATION_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x801FFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)

/* Indicates wheter a fake preamble is present in the access code or not (valid flag for adv_fake_preamble_start_idx) */
#define GP_WB_READ_BLE_MGR_ADV_FAKE_PREAMBLE_PRESENT() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2737), 7)

#define GP_WB_GET_BLE_MGR_ADV_FAKE_PREAMBLE_PRESENT_FROM_ADV_VALIDATION_SETTINGS(tmp) \
        (((tmp) >> 31) & 0x01)

#define GP_WB_WRITE_BLE_MGR_ADV_FAKE_PREAMBLE_PRESENT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2737), 7, (val)); \
        } while (0)

#define GP_WB_SET_BLE_MGR_ADV_FAKE_PREAMBLE_PRESENT_TO_ADV_VALIDATION_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F1FFFFF; \
          (tmp) |= (((UInt32)(val)) << 31); \
        } while (0)


/* The preamble symbol for advertising channels */
#define GP_WB_READ_BLE_MGR_ADV_PREAMBLE() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2738))

#define GP_WB_WRITE_BLE_MGR_ADV_PREAMBLE(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2738), (val)); \
        } while (0)


/* The accuracy of the current clock source that is used (in ppm) */
#define GP_WB_READ_BLE_MGR_OWN_CLOCK_ACCURACY_PPM() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc273a))

#define GP_WB_WRITE_BLE_MGR_OWN_CLOCK_ACCURACY_PPM(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc273a), (val)); \
        } while (0)


/* The crc init for the advertising channels */
#define GP_WB_READ_BLE_MGR_ADV_CRC_INIT() \
        GP_WB_READ_U24(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc273c))

#define GP_WB_WRITE_BLE_MGR_ADV_CRC_INIT(val) do { \
          GP_WB_WRITE_U24(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc273c), (val)); \
        } while (0)


#define GP_WB_READ_BLE_MGR_EMPTY_PBM_NR() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc273f))

#define GP_WB_WRITE_BLE_MGR_EMPTY_PBM_NR(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc273f), (val)); \
        } while (0)


/* The channel index / stack index to use for all BLE events */
#define GP_WB_READ_BLE_MGR_BLE_CHANNEL_IDX() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2740))

#define GP_WB_WRITE_BLE_MGR_BLE_CHANNEL_IDX(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2740), (val)); \
        } while (0)


/* pointer to a an area of 256 bytes where debug loging has to be written out. if 0 no logging will be written out */
#define GP_WB_READ_BLE_MGR_DEBUG_LOG_PTR() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2742))

#define GP_WB_WRITE_BLE_MGR_DEBUG_LOG_PTR(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2742), (val)); \
        } while (0)


/* resolvable private address table compressed address (16 byte alligned). Contains IRKs. */
#define GP_WB_READ_BLE_MGR_RES_PR_LOCAL_IRK_LIST_BASE_ADDRESS() \
        GP_WB_READ_U24(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2744))

#define GP_WB_WRITE_BLE_MGR_RES_PR_LOCAL_IRK_LIST_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03FFFF); \
          GP_WB_WRITE_U24(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2744), (val)); \
        } while (0)


/* Random part of the to-be generated RPA address */
#define GP_WB_READ_BLE_MGR_RES_PR_PRAND() \
        GP_WB_READ_U24(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2748))

#define GP_WB_WRITE_BLE_MGR_RES_PR_PRAND(val) do { \
          GP_WB_WRITE_U24(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2748), (val)); \
        } while (0)


/* Pointer to a table with calibration information for all BLE channels */
#define GP_WB_READ_BLE_MGR_RF_PRE_CALIBRATION_TABLE_PTR() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc274c))

#define GP_WB_WRITE_BLE_MGR_RF_PRE_CALIBRATION_TABLE_PTR(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc274c), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BLE_MGR_CH_CONVERSION_MAP() \
        GP_WB_READ_U64(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2750))

#define GP_WB_WRITE_BLE_MGR_CH_CONVERSION_MAP(val) \
      GP_WB_WRITE_U64(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2750), (val))

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_0() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2750))

#define GP_WB_GET_BLE_MGR_CH_CONV_BLE_CHANNEL_0_FROM_CH_CONVERSION_MAP(tmp) \
        ((tmp) & 0xFF)

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_0(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2750), (val)); \
        } while (0)

#define GP_WB_SET_BLE_MGR_CH_CONV_BLE_CHANNEL_0_TO_CH_CONVERSION_MAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFFFFFFFFFF00; \
          (tmp) |= ((UInt64)(val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_1() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2751))

#define GP_WB_GET_BLE_MGR_CH_CONV_BLE_CHANNEL_1_FROM_CH_CONVERSION_MAP(tmp) \
        (((tmp) >> 8) & 0xFF)

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_1(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2751), (val)); \
        } while (0)

#define GP_WB_SET_BLE_MGR_CH_CONV_BLE_CHANNEL_1_TO_CH_CONVERSION_MAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFFFFFFFF00FF; \
          (tmp) |= (((UInt64)(val)) << 8); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_2() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2752))

#define GP_WB_GET_BLE_MGR_CH_CONV_BLE_CHANNEL_2_FROM_CH_CONVERSION_MAP(tmp) \
        (((tmp) >> 16) & 0xFF)

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_2(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2752), (val)); \
        } while (0)

#define GP_WB_SET_BLE_MGR_CH_CONV_BLE_CHANNEL_2_TO_CH_CONVERSION_MAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFFFFFF00FFFF; \
          (tmp) |= (((UInt64)(val)) << 16); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_3() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2753))

#define GP_WB_GET_BLE_MGR_CH_CONV_BLE_CHANNEL_3_FROM_CH_CONVERSION_MAP(tmp) \
        (((tmp) >> 24) & 0xFF)

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_3(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2753), (val)); \
        } while (0)

#define GP_WB_SET_BLE_MGR_CH_CONV_BLE_CHANNEL_3_TO_CH_CONVERSION_MAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFFFF00FFFFFF; \
          (tmp) |= (((UInt64)(val)) << 24); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_4() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2754))

#define GP_WB_GET_BLE_MGR_CH_CONV_BLE_CHANNEL_4_FROM_CH_CONVERSION_MAP(tmp) \
        (((tmp) >> 32) & 0xFF)

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_4(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2754), (val)); \
        } while (0)

#define GP_WB_SET_BLE_MGR_CH_CONV_BLE_CHANNEL_4_TO_CH_CONVERSION_MAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFF00FFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 32); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_5() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2755))

#define GP_WB_GET_BLE_MGR_CH_CONV_BLE_CHANNEL_5_FROM_CH_CONVERSION_MAP(tmp) \
        (((tmp) >> 40) & 0xFF)

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_5(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2755), (val)); \
        } while (0)

#define GP_WB_SET_BLE_MGR_CH_CONV_BLE_CHANNEL_5_TO_CH_CONVERSION_MAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFF00FFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 40); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_6() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2756))

#define GP_WB_GET_BLE_MGR_CH_CONV_BLE_CHANNEL_6_FROM_CH_CONVERSION_MAP(tmp) \
        (((tmp) >> 48) & 0xFF)

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_6(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2756), (val)); \
        } while (0)

#define GP_WB_SET_BLE_MGR_CH_CONV_BLE_CHANNEL_6_TO_CH_CONVERSION_MAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFF00FFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 48); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_7() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2757))

#define GP_WB_GET_BLE_MGR_CH_CONV_BLE_CHANNEL_7_FROM_CH_CONVERSION_MAP(tmp) \
        (((tmp) >> 56) & 0xFF)

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_7(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2757), (val)); \
        } while (0)

#define GP_WB_SET_BLE_MGR_CH_CONV_BLE_CHANNEL_7_TO_CH_CONVERSION_MAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0x00FFFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 56); \
        } while (0)


#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_8() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2758))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_8(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2758), (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_9() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2759))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_9(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2759), (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_10() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc275a))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_10(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc275a), (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_11() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc275b))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_11(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc275b), (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_12() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc275c))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_12(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc275c), (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_13() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc275d))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_13(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc275d), (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_14() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc275e))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_14(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc275e), (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_15() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc275f))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_15(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc275f), (val)); \
        } while (0)


#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_16() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2760))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_16(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2760), (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_17() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2761))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_17(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2761), (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_18() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2762))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_18(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2762), (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_19() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2763))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_19(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2763), (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_20() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2764))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_20(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2764), (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_21() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2765))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_21(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2765), (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_22() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2766))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_22(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2766), (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_23() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2767))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_23(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2767), (val)); \
        } while (0)


#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_24() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2768))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_24(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2768), (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_25() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2769))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_25(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2769), (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_26() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc276a))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_26(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc276a), (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_27() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc276b))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_27(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc276b), (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_28() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc276c))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_28(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc276c), (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_29() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc276d))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_29(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc276d), (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_30() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc276e))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_30(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc276e), (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_31() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc276f))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_31(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc276f), (val)); \
        } while (0)


#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_32() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2770))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_32(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2770), (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_33() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2771))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_33(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2771), (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_34() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2772))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_34(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2772), (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_35() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2773))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_35(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2773), (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_36() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2774))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_36(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2774), (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_37() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2775))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_37(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2775), (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_38() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2776))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_38(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2776), (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_CHANNEL_39() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2777))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_CHANNEL_39(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2777), (val)); \
        } while (0)


/* extension of the channel conversion table to allow direct control with PHY channel numbers (used by ble_mgr) */
#define GP_WB_READ_BLE_MGR_CH_CONV_BLE_TEST_CHANNEL() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2778))

#define GP_WB_WRITE_BLE_MGR_CH_CONV_BLE_TEST_CHANNEL(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2778), (val)); \
        } while (0)


/* linear ram offset for the init_ext_info structure */
#define GP_WB_READ_BLE_MGR_INIT_EXT_INFO_BASE_PTR() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc277a))

#define GP_WB_WRITE_BLE_MGR_INIT_EXT_INFO_BASE_PTR(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc277a), (val)); \
        } while (0)


/* time the receive windows should be opened earlier to be able to apply the dsfix */
#define GP_WB_READ_BLE_MGR_DSFIX_RX_WD_OFFSET() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc277c))

#define GP_WB_WRITE_BLE_MGR_DSFIX_RX_WD_OFFSET(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc277c), (val)); \
        } while (0)

/* time in nr_cycles (0.1875 us) to wait until sampling the RSSI after the receiver is opened */
#define GP_WB_READ_BLE_MGR_DSFIX_RSSI_SAMPLE_HOLDOFF() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc277e))

#define GP_WB_WRITE_BLE_MGR_DSFIX_RSSI_SAMPLE_HOLDOFF(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc277e), (val)); \
        } while (0)

/* nr of param0 wraps needed for the lowest_rssi to be incremented by 1 */
#define GP_WB_READ_BLE_MGR_DSFIX_RSSI_AGEING_THRESHOLD() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc277f))

#define GP_WB_WRITE_BLE_MGR_DSFIX_RSSI_AGEING_THRESHOLD(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc277f), (val)); \
        } while (0)

/* the number of measurements after which best param combination will be checked/polled. (so determines the frequency with which the best params are polled) */
#define GP_WB_READ_BLE_MGR_DSFIX_BEST_POLL_THRESHOLD() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2780))

#define GP_WB_WRITE_BLE_MGR_DSFIX_BEST_POLL_THRESHOLD(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2780), (val)); \
        } while (0)


/* when 1 the rssi measurements are skipped and only the current parameters are applied (so no tracking, using a fixed setting) */
#define GP_WB_READ_BLE_MGR_DSFIX_ALG_DISABLED() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2781), 0)

#define GP_WB_WRITE_BLE_MGR_DSFIX_ALG_DISABLED(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2781), (val)); \
        } while (0)


/* nominal value of parameter 0, applied when the channel does not need to be fixed */
#define GP_WB_READ_BLE_MGR_DSFIX_NOM_PARAM0() \
        (GP_WB_S8(GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2784)), 8))

#define GP_WB_WRITE_BLE_MGR_DSFIX_NOM_PARAM0(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2784), (UInt8)((val))); \
        } while (0)

/* nominal value of parameter 1, applied when the channel does not need to be fixed */
#define GP_WB_READ_BLE_MGR_DSFIX_NOM_PARAM1() \
        (GP_WB_S8(GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2785)), 8))

#define GP_WB_WRITE_BLE_MGR_DSFIX_NOM_PARAM1(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2785), (UInt8)((val))); \
        } while (0)

/* nominal value of parameter 2, applied when the channel does not need to be fixed */
#define GP_WB_READ_BLE_MGR_DSFIX_NOM_PARAM2() \
        (GP_WB_S8(GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2786)), 8))

#define GP_WB_WRITE_BLE_MGR_DSFIX_NOM_PARAM2(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2786), (UInt8)((val))); \
        } while (0)

/* nominal value of parameter 3, applied when the channel does not need to be fixed */
#define GP_WB_READ_BLE_MGR_DSFIX_NOM_PARAM3() \
        (GP_WB_S8(GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2787)), 8))

#define GP_WB_WRITE_BLE_MGR_DSFIX_NOM_PARAM3(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2787), (UInt8)((val))); \
        } while (0)


/* pointer to the list containing the to be fixed channels dsfix_ch entries */
#define GP_WB_READ_BLE_MGR_DSFIX_CHANNEL_LIST_PTR() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2788))

#define GP_WB_WRITE_BLE_MGR_DSFIX_CHANNEL_LIST_PTR(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2788), (val)); \
        } while (0)

/* number of channels in the list */
#define GP_WB_READ_BLE_MGR_DSFIX_CHANNEL_LIST_SIZE() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc278a))

#define GP_WB_WRITE_BLE_MGR_DSFIX_CHANNEL_LIST_SIZE(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc278a), (val)); \
        } while (0)


/* pointer to the list containing the parameter descriptions (dsfix_param entries) */
#define GP_WB_READ_BLE_MGR_DSFIX_PARAM_LIST_PTR() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc278c))

#define GP_WB_WRITE_BLE_MGR_DSFIX_PARAM_LIST_PTR(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc278c), (val)); \
        } while (0)

/* the number of dsfix_param entries in the list */
#define GP_WB_READ_BLE_MGR_DSFIX_PARAM_LIST_SIZE() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc278e))

#define GP_WB_WRITE_BLE_MGR_DSFIX_PARAM_LIST_SIZE(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc278e), (val)); \
        } while (0)


/* pointer to the list that contains the settings to be applied before doing the RSSI measurements */
#define GP_WB_READ_BLE_MGR_DSFIX_PRE_LIST_PTR() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2790))

#define GP_WB_WRITE_BLE_MGR_DSFIX_PRE_LIST_PTR(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2790), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BLE_MGR_TX_ANT_EXT() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2792))

#define GP_WB_WRITE_BLE_MGR_TX_ANT_EXT(val) \
      GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2792), (val))

#define GP_WB_READ_BLE_MGR_TX_ANT_EXT_0() \
        (GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2792)) & 0x0F)

#define GP_WB_GET_BLE_MGR_TX_ANT_EXT_0_FROM_TX_ANT_EXT(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_BLE_MGR_TX_ANT_EXT_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2792), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_BLE_MGR_TX_ANT_EXT_0_TO_TX_ANT_EXT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0xF0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_TX_ANT_EXT_1() \
        ((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2792)) >> 4) & 0x0F)

#define GP_WB_GET_BLE_MGR_TX_ANT_EXT_1_FROM_TX_ANT_EXT(tmp) \
        (((tmp) >> 4) & 0x0F)

#define GP_WB_WRITE_BLE_MGR_TX_ANT_EXT_1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2792), 0xF0, (val) << 4); \
        } while (0)

#define GP_WB_SET_BLE_MGR_TX_ANT_EXT_1_TO_TX_ANT_EXT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


#define GP_WB_READ_BLE_MGR_TX_ANTSEL_INT() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2793))

#define GP_WB_WRITE_BLE_MGR_TX_ANTSEL_INT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2793), (val)); \
        } while (0)


#define GP_WB_READ_BLE_MGR_BGSCAN_EV_NR() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2794))

#define GP_WB_WRITE_BLE_MGR_BGSCAN_EV_NR(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2794), (val)); \
        } while (0)


/* When set to 1, all activities will use precalibrated RF channel info (this requires rf_pre_calibration_table_ptr to be set correctly). */
#define GP_WB_READ_BLE_MGR_ALWAYS_USE_RF_PRECALIBRATION() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2795))

#define GP_WB_WRITE_BLE_MGR_ALWAYS_USE_RF_PRECALIBRATION(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2795), (val)); \
        } while (0)


/* The maximum allowed length field for BLE PDUs. In case we receive a longer packet, we need to drop it. */
#define GP_WB_READ_BLE_MGR_MAX_ALLOWED_PDU_PAYLOAD_LENGTH() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2796))

#define GP_WB_WRITE_BLE_MGR_MAX_ALLOWED_PDU_PAYLOAD_LENGTH(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2796), (val)); \
        } while (0)


/* Linear ram offset for the scan_common_ext_info structure. */
#define GP_WB_READ_BLE_MGR_SCAN_EXT_INFO_BASE_PTR() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2798))

#define GP_WB_WRITE_BLE_MGR_SCAN_EXT_INFO_BASE_PTR(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc2798), (val)); \
        } while (0)


#define GP_WB_READ_BLE_MGR_CHMAP_LIST_BASE_PTR() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc279a))

#define GP_WB_WRITE_BLE_MGR_CHMAP_LIST_BASE_PTR(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc279a), (val)); \
        } while (0)


#define GP_WB_READ_BLE_MGR_ITEM_OFFSET_CHMAP() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc279c))

#define GP_WB_WRITE_BLE_MGR_ITEM_OFFSET_CHMAP(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc279c), (val)); \
        } while (0)


/* first (in time) PDL to be processed next, i.e. the first PDL from the linked list */
#define GP_WB_READ_BLE_MGR_PDL_HEAD_IDX() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc279d))

#define GP_WB_WRITE_BLE_MGR_PDL_HEAD_IDX(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc279d), (val)); \
        } while (0)


/* the first available PDL entry: top of the stack of available PDL entries */
#define GP_WB_READ_BLE_MGR_PDL_FIRST_FREE_IDX() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc279e))

#define GP_WB_WRITE_BLE_MGR_PDL_FIRST_FREE_IDX(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc279e), (val)); \
        } while (0)


#define GP_WB_READ_BLE_MGR_ACTIVE_SUBEV() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc279f))

#define GP_WB_WRITE_BLE_MGR_ACTIVE_SUBEV(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc279f), (val)); \
        } while (0)


/* the maximum number of subev_dsc available for the RT */
#define GP_WB_READ_BLE_MGR_NR_RT_SUBEV_DSCS() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27a0))

#define GP_WB_WRITE_BLE_MGR_NR_RT_SUBEV_DSCS(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27a0), (val)); \
        } while (0)


#define GP_WB_READ_BLE_MGR_PDL_BASE_PTR() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27a2))

#define GP_WB_WRITE_BLE_MGR_PDL_BASE_PTR(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27a2), (val)); \
        } while (0)


#define GP_WB_READ_BLE_MGR_SUBEV_DSC_BASE_PTR() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27a4))

#define GP_WB_WRITE_BLE_MGR_SUBEV_DSC_BASE_PTR(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27a4), (val)); \
        } while (0)


#define GP_WB_READ_BLE_MGR_SUBEV_COMPLETED_BASE_PTR() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27a6))

#define GP_WB_WRITE_BLE_MGR_SUBEV_COMPLETED_BASE_PTR(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27a6), (val)); \
        } while (0)


/* mask that shows the claimed subev_dsc indexes. */
#define GP_WB_READ_BLE_MGR_SUBEV_DSC_ENTRY_RT_CLAIMED() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27a8))

#define GP_WB_WRITE_BLE_MGR_SUBEV_DSC_ENTRY_RT_CLAIMED(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27a8), (val)); \
        } while (0)


/* number of the ES event that handles the subevents */
#define GP_WB_READ_BLE_MGR_SUBEV_EV_NR() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27aa))

#define GP_WB_WRITE_BLE_MGR_SUBEV_EV_NR(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27aa), (val)); \
        } while (0)


/* the maximum number of subev_dsc in total */
#define GP_WB_READ_BLE_MGR_NR_TOT_SUBEV_DSCS() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ab))

#define GP_WB_WRITE_BLE_MGR_NR_TOT_SUBEV_DSCS(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ab), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BLE_MGR_SUBEV_COMPLETED_PTRS() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ac))

#define GP_WB_WRITE_BLE_MGR_SUBEV_COMPLETED_PTRS(val) \
      GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ac), (val))

#define GP_WB_READ_BLE_MGR_SUBEV_COMPLETED_WR_PTR() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ac))

#define GP_WB_GET_BLE_MGR_SUBEV_COMPLETED_WR_PTR_FROM_SUBEV_COMPLETED_PTRS(tmp) \
        ((tmp) & 0xFF)

#define GP_WB_WRITE_BLE_MGR_SUBEV_COMPLETED_WR_PTR(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ac), (val)); \
        } while (0)

#define GP_WB_SET_BLE_MGR_SUBEV_COMPLETED_WR_PTR_TO_SUBEV_COMPLETED_PTRS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          (tmp) &= 0xFF00; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_SUBEV_COMPLETED_RD_PTR() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ad))

#define GP_WB_GET_BLE_MGR_SUBEV_COMPLETED_RD_PTR_FROM_SUBEV_COMPLETED_PTRS(tmp) \
        (((tmp) >> 8) & 0xFF)

#define GP_WB_WRITE_BLE_MGR_SUBEV_COMPLETED_RD_PTR(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ad), (val)); \
        } while (0)

#define GP_WB_SET_BLE_MGR_SUBEV_COMPLETED_RD_PTR_TO_SUBEV_COMPLETED_PTRS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          (tmp) &= 0x00FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)


#define GP_WB_READ_BLE_MGR_ADV_ASC_LIST_BASE_PTR() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ae))

#define GP_WB_WRITE_BLE_MGR_ADV_ASC_LIST_BASE_PTR(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ae), (val)); \
        } while (0)


#define GP_WB_READ_BLE_MGR_SCAN_ASC_LIST_BASE_PTR() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27b0))

#define GP_WB_WRITE_BLE_MGR_SCAN_ASC_LIST_BASE_PTR(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27b0), (val)); \
        } while (0)


/* pointer to the sync context list */
#define GP_WB_READ_BLE_MGR_SYNCC_LIST_BASE_PTR() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27b2))

#define GP_WB_WRITE_BLE_MGR_SYNCC_LIST_BASE_PTR(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27b2), (val)); \
        } while (0)


#define GP_WB_READ_BLE_MGR_ITEM_OFFSET_SYNCC() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27b4))

#define GP_WB_WRITE_BLE_MGR_ITEM_OFFSET_SYNCC(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27b4), (val)); \
        } while (0)


/* the maximum number of scan_asc */
#define GP_WB_READ_BLE_MGR_NR_SCAN_ASC() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27b5))

#define GP_WB_WRITE_BLE_MGR_NR_SCAN_ASC(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27b5), (val)); \
        } while (0)


#define GP_WB_READ_BLE_MGR_ITEM_OFFSET_SUBEV_DSC() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27b8))

#define GP_WB_WRITE_BLE_MGR_ITEM_OFFSET_SUBEV_DSC(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27b8), (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_ITEM_OFFSET_PDL() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27b9))

#define GP_WB_WRITE_BLE_MGR_ITEM_OFFSET_PDL(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27b9), (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_ITEM_OFFSET_ADV_ASC() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ba))

#define GP_WB_WRITE_BLE_MGR_ITEM_OFFSET_ADV_ASC(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ba), (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_ITEM_OFFSET_SCAN_ASC() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27bb))

#define GP_WB_WRITE_BLE_MGR_ITEM_OFFSET_SCAN_ASC(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27bb), (val)); \
        } while (0)

#define GP_WB_READ_BLE_MGR_ITEM_OFFSET_PER_ASC() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27bc))

#define GP_WB_WRITE_BLE_MGR_ITEM_OFFSET_PER_ASC(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27bc), (val)); \
        } while (0)


#define GP_WB_READ_BLE_MGR_PER_ASC_LIST_BASE_PTR() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27be))

#define GP_WB_WRITE_BLE_MGR_PER_ASC_LIST_BASE_PTR(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27be), (val)); \
        } while (0)

/***************************
 * layout: blefilt
 ***************************/

#define GP_WB_READ_BLEFILT_STATE() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27c0))

#define GP_WB_WRITE_BLEFILT_STATE(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27c0), (val)); \
        } while (0)


#define GP_WB_READ_BLEFILT_DEBUG() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27c1))

#define GP_WB_WRITE_BLEFILT_DEBUG(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27c1), (val)); \
        } while (0)


#define GP_WB_READ_BLEFILT_FRAME_TYPE_MASK_PADDING() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27c2))

#define GP_WB_WRITE_BLEFILT_FRAME_TYPE_MASK_PADDING(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27c2), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BLEFILT_PACKET_STATUS() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27c3))

#define GP_WB_WRITE_BLEFILT_PACKET_STATUS(val) \
      GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27c3), (val))

#define GP_WB_READ_BLEFILT_DROP_REASON() \
        (GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27c3)) & 0x0F)

#define GP_WB_GET_BLEFILT_DROP_REASON_FROM_PACKET_STATUS(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_BLEFILT_DROP_REASON(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27c3), 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_DROP_REASON_TO_PACKET_STATUS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x10; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_BLEFILT_DROP_REASON_VALID() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27c3), 4)

#define GP_WB_GET_BLEFILT_DROP_REASON_VALID_FROM_PACKET_STATUS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_BLEFILT_DROP_REASON_VALID(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27c3), 4, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_DROP_REASON_VALID_TO_PACKET_STATUS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* Provides the resolving list idx, for the use case where AdvA and TargetA are not in the same pdu */
#define GP_WB_READ_BLEFILT_IRK_IDX() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27c4))

#define GP_WB_WRITE_BLEFILT_IRK_IDX(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27c4), (val)); \
        } while (0)


#define GP_WB_READ_BLEFILT_SUBFILT_0_FRAME_TYPE_ACCEPT_PADDING() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27c5))

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_FRAME_TYPE_ACCEPT_PADDING(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27c5), (val)); \
        } while (0)


/* whitelist state mask */
#define GP_WB_READ_BLEFILT_SUBFILT_0_WL_VALID_STATE_MASK() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27c6))

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_WL_VALID_STATE_MASK(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27c6), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BLEFILT_SUBFILT_0_ADV_MODE_MASK() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27c7))

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ADV_MODE_MASK(val) \
      GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27c7), (val))

#define GP_WB_READ_BLEFILT_SUBFILT_0_MASK_NONCONN_NONSCAN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27c7), 0)

#define GP_WB_GET_BLEFILT_SUBFILT_0_MASK_NONCONN_NONSCAN_FROM_SUBFILT_0_ADV_MODE_MASK(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_MASK_NONCONN_NONSCAN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27c7), 0, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_MASK_NONCONN_NONSCAN_TO_SUBFILT_0_ADV_MODE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_MASK_CONNECTABLE() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27c7), 1)

#define GP_WB_GET_BLEFILT_SUBFILT_0_MASK_CONNECTABLE_FROM_SUBFILT_0_ADV_MODE_MASK(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_MASK_CONNECTABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27c7), 1, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_MASK_CONNECTABLE_TO_SUBFILT_0_ADV_MODE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_MASK_SCANNABLE() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27c7), 2)

#define GP_WB_GET_BLEFILT_SUBFILT_0_MASK_SCANNABLE_FROM_SUBFILT_0_ADV_MODE_MASK(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_MASK_SCANNABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27c7), 2, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_MASK_SCANNABLE_TO_SUBFILT_0_ADV_MODE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_MASK_RFU() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27c7), 3)

#define GP_WB_GET_BLEFILT_SUBFILT_0_MASK_RFU_FROM_SUBFILT_0_ADV_MODE_MASK(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_MASK_RFU(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27c7), 3, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_MASK_RFU_TO_SUBFILT_0_ADV_MODE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BLEFILT_SUBFILT_0_ADDR_CONFIG() \
        GP_WB_READ_U56(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27c8))

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ADDR_CONFIG(val) \
      GP_WB_WRITE_U56(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27c8), (val))

/* The current device address, used by the RX filter to accept/reject a frame with a destination device address in it */
#define GP_WB_READ_BLEFILT_SUBFILT_0_DST_DEVICE_ADDRESS() \
        GP_WB_READ_U48(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27c8))

#define GP_WB_GET_BLEFILT_SUBFILT_0_DST_DEVICE_ADDRESS_FROM_SUBFILT_0_ADDR_CONFIG(tmp) \
        ((tmp) & 0xFFFFFFFFFFFF)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_DST_DEVICE_ADDRESS(val) do { \
          GP_WB_WRITE_U48(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27c8), (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_DST_DEVICE_ADDRESS_TO_SUBFILT_0_ADDR_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0x7F000000000000; \
          (tmp) |= ((UInt64)(val)); \
        } while (0)

/* The current device address type, used by the RX filter to accept/reject a frame with a destination device address in it */
#define GP_WB_READ_BLEFILT_SUBFILT_0_DST_DEVICE_ADDRESS_TYPE() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ce), 0)

#define GP_WB_GET_BLEFILT_SUBFILT_0_DST_DEVICE_ADDRESS_TYPE_FROM_SUBFILT_0_ADDR_CONFIG(tmp) \
        (((tmp) >> 48) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_DST_DEVICE_ADDRESS_TYPE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ce), 0, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_DST_DEVICE_ADDRESS_TYPE_TO_SUBFILT_0_ADDR_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7EFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 48); \
        } while (0)

/* Wether to enable/disable the frame destination address check */
#define GP_WB_READ_BLEFILT_SUBFILT_0_ENABLE_DST_ADDR_CHECK() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ce), 1)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ENABLE_DST_ADDR_CHECK_FROM_SUBFILT_0_ADDR_CONFIG(tmp) \
        (((tmp) >> 49) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ENABLE_DST_ADDR_CHECK(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ce), 1, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ENABLE_DST_ADDR_CHECK_TO_SUBFILT_0_ADDR_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7DFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 49); \
        } while (0)

/* when 1, don't drop packets with an unresolved dst address. */
#define GP_WB_READ_BLEFILT_SUBFILT_0_ACCEPT_UNRESOLVED_RPA_DST() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ce), 2)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ACCEPT_UNRESOLVED_RPA_DST_FROM_SUBFILT_0_ADDR_CONFIG(tmp) \
        (((tmp) >> 50) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ACCEPT_UNRESOLVED_RPA_DST(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ce), 2, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ACCEPT_UNRESOLVED_RPA_DST_TO_SUBFILT_0_ADDR_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7BFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 50); \
        } while (0)

/* when 1, the destination address must be an RPA address, an public or static random address will be dropped */
#define GP_WB_READ_BLEFILT_SUBFILT_0_DST_RPA_REQUIRED() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ce), 3)

#define GP_WB_GET_BLEFILT_SUBFILT_0_DST_RPA_REQUIRED_FROM_SUBFILT_0_ADDR_CONFIG(tmp) \
        (((tmp) >> 51) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_DST_RPA_REQUIRED(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ce), 3, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_DST_RPA_REQUIRED_TO_SUBFILT_0_ADDR_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x77FFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 51); \
        } while (0)

/* when 1, even successfully resolved RPA addresses must still match dst_device_address (used for advertising). */
#define GP_WB_READ_BLEFILT_SUBFILT_0_RESOLVED_RPA_MUST_MATCH() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ce), 4)

#define GP_WB_GET_BLEFILT_SUBFILT_0_RESOLVED_RPA_MUST_MATCH_FROM_SUBFILT_0_ADDR_CONFIG(tmp) \
        (((tmp) >> 52) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_RESOLVED_RPA_MUST_MATCH(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ce), 4, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_RESOLVED_RPA_MUST_MATCH_TO_SUBFILT_0_ADDR_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x6FFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 52); \
        } while (0)

/* when 1, don't drop packets with an unresolved src address. */
#define GP_WB_READ_BLEFILT_SUBFILT_0_ACCEPT_UNRESOLVED_RPA_SRC() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ce), 5)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ACCEPT_UNRESOLVED_RPA_SRC_FROM_SUBFILT_0_ADDR_CONFIG(tmp) \
        (((tmp) >> 53) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ACCEPT_UNRESOLVED_RPA_SRC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ce), 5, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ACCEPT_UNRESOLVED_RPA_SRC_TO_SUBFILT_0_ADDR_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x5FFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 53); \
        } while (0)

/* when 1, don't drop packets with an unresolved identity (non-rpa) address. */
#define GP_WB_READ_BLEFILT_SUBFILT_0_ACCEPT_UNRESOLVED_ID_SRC() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ce), 6)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ACCEPT_UNRESOLVED_ID_SRC_FROM_SUBFILT_0_ADDR_CONFIG(tmp) \
        (((tmp) >> 54) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ACCEPT_UNRESOLVED_ID_SRC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ce), 6, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ACCEPT_UNRESOLVED_ID_SRC_TO_SUBFILT_0_ADDR_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3FFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 54); \
        } while (0)


#define GP_WB_READ_BLEFILT_SUBFILT_0_FT_WHITELIST_ENABLE_PADDING() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27cf))

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_FT_WHITELIST_ENABLE_PADDING(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27cf), (val)); \
        } while (0)


#define GP_WB_READ_BLEFILT_SUBFILT_1_FRAME_TYPE_ACCEPT_PADDING() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27d0))

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_FRAME_TYPE_ACCEPT_PADDING(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27d0), (val)); \
        } while (0)


/* whitelist state mask */
#define GP_WB_READ_BLEFILT_SUBFILT_1_WL_VALID_STATE_MASK() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27d1))

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_WL_VALID_STATE_MASK(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27d1), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BLEFILT_SUBFILT_1_ADV_MODE_MASK() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27d2))

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ADV_MODE_MASK(val) \
      GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27d2), (val))

#define GP_WB_READ_BLEFILT_SUBFILT_1_MASK_NONCONN_NONSCAN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27d2), 0)

#define GP_WB_GET_BLEFILT_SUBFILT_1_MASK_NONCONN_NONSCAN_FROM_SUBFILT_1_ADV_MODE_MASK(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_MASK_NONCONN_NONSCAN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27d2), 0, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_MASK_NONCONN_NONSCAN_TO_SUBFILT_1_ADV_MODE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_MASK_CONNECTABLE() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27d2), 1)

#define GP_WB_GET_BLEFILT_SUBFILT_1_MASK_CONNECTABLE_FROM_SUBFILT_1_ADV_MODE_MASK(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_MASK_CONNECTABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27d2), 1, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_MASK_CONNECTABLE_TO_SUBFILT_1_ADV_MODE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_MASK_SCANNABLE() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27d2), 2)

#define GP_WB_GET_BLEFILT_SUBFILT_1_MASK_SCANNABLE_FROM_SUBFILT_1_ADV_MODE_MASK(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_MASK_SCANNABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27d2), 2, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_MASK_SCANNABLE_TO_SUBFILT_1_ADV_MODE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_MASK_RFU() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27d2), 3)

#define GP_WB_GET_BLEFILT_SUBFILT_1_MASK_RFU_FROM_SUBFILT_1_ADV_MODE_MASK(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_MASK_RFU(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27d2), 3, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_MASK_RFU_TO_SUBFILT_1_ADV_MODE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BLEFILT_SUBFILT_1_ADDR_CONFIG() \
        GP_WB_READ_U56(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27d4))

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ADDR_CONFIG(val) \
      GP_WB_WRITE_U56(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27d4), (val))

/* The current device address, used by the RX filter to accept/reject a frame with a destination device address in it */
#define GP_WB_READ_BLEFILT_SUBFILT_1_DST_DEVICE_ADDRESS() \
        GP_WB_READ_U48(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27d4))

#define GP_WB_GET_BLEFILT_SUBFILT_1_DST_DEVICE_ADDRESS_FROM_SUBFILT_1_ADDR_CONFIG(tmp) \
        ((tmp) & 0xFFFFFFFFFFFF)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_DST_DEVICE_ADDRESS(val) do { \
          GP_WB_WRITE_U48(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27d4), (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_DST_DEVICE_ADDRESS_TO_SUBFILT_1_ADDR_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0x7F000000000000; \
          (tmp) |= ((UInt64)(val)); \
        } while (0)

/* The current device address type, used by the RX filter to accept/reject a frame with a destination device address in it */
#define GP_WB_READ_BLEFILT_SUBFILT_1_DST_DEVICE_ADDRESS_TYPE() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27da), 0)

#define GP_WB_GET_BLEFILT_SUBFILT_1_DST_DEVICE_ADDRESS_TYPE_FROM_SUBFILT_1_ADDR_CONFIG(tmp) \
        (((tmp) >> 48) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_DST_DEVICE_ADDRESS_TYPE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27da), 0, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_DST_DEVICE_ADDRESS_TYPE_TO_SUBFILT_1_ADDR_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7EFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 48); \
        } while (0)

/* Wether to enable/disable the frame destination address check */
#define GP_WB_READ_BLEFILT_SUBFILT_1_ENABLE_DST_ADDR_CHECK() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27da), 1)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ENABLE_DST_ADDR_CHECK_FROM_SUBFILT_1_ADDR_CONFIG(tmp) \
        (((tmp) >> 49) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ENABLE_DST_ADDR_CHECK(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27da), 1, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ENABLE_DST_ADDR_CHECK_TO_SUBFILT_1_ADDR_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7DFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 49); \
        } while (0)

/* when 1, don't drop packets with an unresolved dst address. */
#define GP_WB_READ_BLEFILT_SUBFILT_1_ACCEPT_UNRESOLVED_RPA_DST() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27da), 2)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ACCEPT_UNRESOLVED_RPA_DST_FROM_SUBFILT_1_ADDR_CONFIG(tmp) \
        (((tmp) >> 50) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ACCEPT_UNRESOLVED_RPA_DST(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27da), 2, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ACCEPT_UNRESOLVED_RPA_DST_TO_SUBFILT_1_ADDR_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7BFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 50); \
        } while (0)

/* when 1, the destination address must be an RPA address, an public or static random address will be dropped */
#define GP_WB_READ_BLEFILT_SUBFILT_1_DST_RPA_REQUIRED() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27da), 3)

#define GP_WB_GET_BLEFILT_SUBFILT_1_DST_RPA_REQUIRED_FROM_SUBFILT_1_ADDR_CONFIG(tmp) \
        (((tmp) >> 51) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_DST_RPA_REQUIRED(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27da), 3, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_DST_RPA_REQUIRED_TO_SUBFILT_1_ADDR_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x77FFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 51); \
        } while (0)

/* when 1, even successfully resolved RPA addresses must still match dst_device_address (used for advertising). */
#define GP_WB_READ_BLEFILT_SUBFILT_1_RESOLVED_RPA_MUST_MATCH() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27da), 4)

#define GP_WB_GET_BLEFILT_SUBFILT_1_RESOLVED_RPA_MUST_MATCH_FROM_SUBFILT_1_ADDR_CONFIG(tmp) \
        (((tmp) >> 52) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_RESOLVED_RPA_MUST_MATCH(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27da), 4, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_RESOLVED_RPA_MUST_MATCH_TO_SUBFILT_1_ADDR_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x6FFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 52); \
        } while (0)

/* when 1, don't drop packets with an unresolved src address. */
#define GP_WB_READ_BLEFILT_SUBFILT_1_ACCEPT_UNRESOLVED_RPA_SRC() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27da), 5)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ACCEPT_UNRESOLVED_RPA_SRC_FROM_SUBFILT_1_ADDR_CONFIG(tmp) \
        (((tmp) >> 53) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ACCEPT_UNRESOLVED_RPA_SRC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27da), 5, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ACCEPT_UNRESOLVED_RPA_SRC_TO_SUBFILT_1_ADDR_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x5FFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 53); \
        } while (0)

/* when 1, don't drop packets with an unresolved identity (non-rpa) address. */
#define GP_WB_READ_BLEFILT_SUBFILT_1_ACCEPT_UNRESOLVED_ID_SRC() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27da), 6)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ACCEPT_UNRESOLVED_ID_SRC_FROM_SUBFILT_1_ADDR_CONFIG(tmp) \
        (((tmp) >> 54) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ACCEPT_UNRESOLVED_ID_SRC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27da), 6, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ACCEPT_UNRESOLVED_ID_SRC_TO_SUBFILT_1_ADDR_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3FFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 54); \
        } while (0)


#define GP_WB_READ_BLEFILT_SUBFILT_1_FT_WHITELIST_ENABLE_PADDING() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27db))

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_FT_WHITELIST_ENABLE_PADDING(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27db), (val)); \
        } while (0)


/* when 1, the rx filter will enable the coex SW overrule in RIB, This makes it possible to keep the coex_req alive. */
#define GP_WB_READ_BLEFILT_ENABLE_COEX_SW_OVERRULE_ON_ACCEPT() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27dc), 2)

#define GP_WB_WRITE_BLEFILT_ENABLE_COEX_SW_OVERRULE_ON_ACCEPT(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27dc), 2, (val)); \
        } while (0)

/* when 1 the ble rx filter will accept all packets */
#define GP_WB_READ_BLEFILT_DISABLE() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27dc), 3)

#define GP_WB_WRITE_BLEFILT_DISABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27dc), 3, (val)); \
        } while (0)

/* resolve the src address and use the resolved address in filtering */
#define GP_WB_READ_BLEFILT_RESOLVE_RES_PR_SRC() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27dc), 4)

#define GP_WB_WRITE_BLEFILT_RESOLVE_RES_PR_SRC(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27dc), 4, (val)); \
        } while (0)

/* If 1, and if src addr is RPA don't check the whitelist in parallel with RPA resolving during. */
#define GP_WB_READ_BLEFILT_WHITELIST_SKIP_RPA_CHECK() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27dc), 5)

#define GP_WB_WRITE_BLEFILT_WHITELIST_SKIP_RPA_CHECK(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27dc), 5, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BLEFILT_WHITELIST_CONFIG() \
        GP_WB_READ_U24(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27e0))

#define GP_WB_WRITE_BLEFILT_WHITELIST_CONFIG(val) \
      GP_WB_WRITE_U24(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27e0), (val))

/* whitelist table base address ( = offset added to SM_linear start address). Resolution 1 byte - Caution must be 16 bit alligned! */
#define GP_WB_READ_BLEFILT_WHITELIST_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27e0))

#define GP_WB_GET_BLEFILT_WHITELIST_BASE_ADDRESS_FROM_WHITELIST_CONFIG(tmp) \
        ((tmp) & 0xFFFF)

#define GP_WB_WRITE_BLEFILT_WHITELIST_BASE_ADDRESS(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27e0), (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_WHITELIST_BASE_ADDRESS_TO_WHITELIST_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0xFF0000; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* length of the whitelist in nr of entries */
#define GP_WB_READ_BLEFILT_WHITELIST_LENGTH() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27e2))

#define GP_WB_GET_BLEFILT_WHITELIST_LENGTH_FROM_WHITELIST_CONFIG(tmp) \
        (((tmp) >> 16) & 0xFF)

#define GP_WB_WRITE_BLEFILT_WHITELIST_LENGTH(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27e2), (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_WHITELIST_LENGTH_TO_WHITELIST_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x00FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)


/* stores the next subev dsc index if an auxptr is present */
#define GP_WB_READ_BLEFILT_NEXT_SUBEV_DSC_IDX() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27e3))

#define GP_WB_WRITE_BLEFILT_NEXT_SUBEV_DSC_IDX(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27e3), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BLEFILT_RES_PR_LIST_CONFIG() \
        GP_WB_READ_U24(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27e4))

#define GP_WB_WRITE_BLEFILT_RES_PR_LIST_CONFIG(val) \
      GP_WB_WRITE_U24(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27e4), (val))

/* resolvable private address table base address. Contains local entries of type ble_res_pr_local_entry. */
#define GP_WB_READ_BLEFILT_RES_PR_IDENTITY_LIST_BASE_ADDRESS() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27e4))

#define GP_WB_GET_BLEFILT_RES_PR_IDENTITY_LIST_BASE_ADDRESS_FROM_RES_PR_LIST_CONFIG(tmp) \
        ((tmp) & 0xFFFF)

#define GP_WB_WRITE_BLEFILT_RES_PR_IDENTITY_LIST_BASE_ADDRESS(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27e4), (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_RES_PR_IDENTITY_LIST_BASE_ADDRESS_TO_RES_PR_LIST_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0xFF0000; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* length of the whitelist in nr of entries */
#define GP_WB_READ_BLEFILT_RES_PR_LIST_LENGTH() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27e6))

#define GP_WB_GET_BLEFILT_RES_PR_LIST_LENGTH_FROM_RES_PR_LIST_CONFIG(tmp) \
        (((tmp) >> 16) & 0xFF)

#define GP_WB_WRITE_BLEFILT_RES_PR_LIST_LENGTH(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27e6), (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_RES_PR_LIST_LENGTH_TO_RES_PR_LIST_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x00FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)


/* resolvable private address table compressed address (16 byte alligned). Contains IRKs. */
#define GP_WB_READ_BLEFILT_RES_PR_PEER_IRK_LIST_BASE_ADDRESS() \
        GP_WB_READ_U24(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27e8))

#define GP_WB_WRITE_BLEFILT_RES_PR_PEER_IRK_LIST_BASE_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03FFFF); \
          GP_WB_WRITE_U24(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27e8), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BLEFILT_WHITELIST_RPA() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ec))

#define GP_WB_WRITE_BLEFILT_WHITELIST_RPA(val) \
      GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ec), (val))

/* Offset to start the search from */
#define GP_WB_READ_BLEFILT_WHITELIST_RPA_OFFSET() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ec))

#define GP_WB_GET_BLEFILT_WHITELIST_RPA_OFFSET_FROM_WHITELIST_RPA(tmp) \
        ((tmp) & 0xFF)

#define GP_WB_WRITE_BLEFILT_WHITELIST_RPA_OFFSET(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ec), (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_WHITELIST_RPA_OFFSET_TO_WHITELIST_RPA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          (tmp) &= 0xFF00; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Length to search. */
#define GP_WB_READ_BLEFILT_WHITELIST_RPA_LENGTH() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ed))

#define GP_WB_GET_BLEFILT_WHITELIST_RPA_LENGTH_FROM_WHITELIST_RPA(tmp) \
        (((tmp) >> 8) & 0xFF)

#define GP_WB_WRITE_BLEFILT_WHITELIST_RPA_LENGTH(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ed), (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_WHITELIST_RPA_LENGTH_TO_WHITELIST_RPA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          (tmp) &= 0x00FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BLEFILT_FRAME_TYPE_MASK() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ee))

#define GP_WB_WRITE_BLEFILT_FRAME_TYPE_MASK(val) \
      GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ee), (val))

#define GP_WB_READ_BLEFILT_FT_ADV_IND() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ee), 0)

#define GP_WB_GET_BLEFILT_FT_ADV_IND_FROM_FRAME_TYPE_MASK(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_BLEFILT_FT_ADV_IND(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ee), 0, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_FT_ADV_IND_TO_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFE; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

#define GP_WB_READ_BLEFILT_FT_ADV_DIRECT_IND() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ee), 1)

#define GP_WB_GET_BLEFILT_FT_ADV_DIRECT_IND_FROM_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_BLEFILT_FT_ADV_DIRECT_IND(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ee), 1, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_FT_ADV_DIRECT_IND_TO_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFD; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

#define GP_WB_READ_BLEFILT_FT_ADV_NONCONN_IND() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ee), 2)

#define GP_WB_GET_BLEFILT_FT_ADV_NONCONN_IND_FROM_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_BLEFILT_FT_ADV_NONCONN_IND(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ee), 2, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_FT_ADV_NONCONN_IND_TO_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFB; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

#define GP_WB_READ_BLEFILT_FT_SCAN_REQ() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ee), 3)

#define GP_WB_GET_BLEFILT_FT_SCAN_REQ_FROM_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_BLEFILT_FT_SCAN_REQ(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ee), 3, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_FT_SCAN_REQ_TO_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFF7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

#define GP_WB_READ_BLEFILT_FT_AUX_SCAN_REQ() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ee), 3)

#define GP_WB_GET_BLEFILT_FT_AUX_SCAN_REQ_FROM_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_BLEFILT_FT_AUX_SCAN_REQ(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ee), 3, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_FT_AUX_SCAN_REQ_TO_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFF7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

#define GP_WB_READ_BLEFILT_FT_SCAN_RSP() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ee), 4)

#define GP_WB_GET_BLEFILT_FT_SCAN_RSP_FROM_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_BLEFILT_FT_SCAN_RSP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ee), 4, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_FT_SCAN_RSP_TO_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFEF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

#define GP_WB_READ_BLEFILT_FT_CONNECT_REQ() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ee), 5)

#define GP_WB_GET_BLEFILT_FT_CONNECT_REQ_FROM_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_BLEFILT_FT_CONNECT_REQ(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ee), 5, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_FT_CONNECT_REQ_TO_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFDF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

#define GP_WB_READ_BLEFILT_FT_AUX_CONNECT_REQ() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ee), 5)

#define GP_WB_GET_BLEFILT_FT_AUX_CONNECT_REQ_FROM_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_BLEFILT_FT_AUX_CONNECT_REQ(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ee), 5, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_FT_AUX_CONNECT_REQ_TO_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFDF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

#define GP_WB_READ_BLEFILT_FT_ADV_SCAN_IND() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ee), 6)

#define GP_WB_GET_BLEFILT_FT_ADV_SCAN_IND_FROM_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_BLEFILT_FT_ADV_SCAN_IND(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ee), 6, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_FT_ADV_SCAN_IND_TO_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFBF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

#define GP_WB_READ_BLEFILT_FT_ADV_EXT_IND() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ee), 7)

#define GP_WB_GET_BLEFILT_FT_ADV_EXT_IND_FROM_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_BLEFILT_FT_ADV_EXT_IND(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ee), 7, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_FT_ADV_EXT_IND_TO_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_BLEFILT_FT_AUX_ADV_IND() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ee), 7)

#define GP_WB_GET_BLEFILT_FT_AUX_ADV_IND_FROM_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_BLEFILT_FT_AUX_ADV_IND(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ee), 7, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_FT_AUX_ADV_IND_TO_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_BLEFILT_FT_AUX_SCAN_RSP() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ee), 7)

#define GP_WB_GET_BLEFILT_FT_AUX_SCAN_RSP_FROM_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_BLEFILT_FT_AUX_SCAN_RSP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ee), 7, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_FT_AUX_SCAN_RSP_TO_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_BLEFILT_FT_AUX_SYNC_IND() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ee), 7)

#define GP_WB_GET_BLEFILT_FT_AUX_SYNC_IND_FROM_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_BLEFILT_FT_AUX_SYNC_IND(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ee), 7, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_FT_AUX_SYNC_IND_TO_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_BLEFILT_FT_AUX_CHAIN_IND() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ee), 7)

#define GP_WB_GET_BLEFILT_FT_AUX_CHAIN_IND_FROM_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_BLEFILT_FT_AUX_CHAIN_IND(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ee), 7, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_FT_AUX_CHAIN_IND_TO_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_BLEFILT_FT_AUX_CONNECT_RSP() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ef), 0)

#define GP_WB_GET_BLEFILT_FT_AUX_CONNECT_RSP_FROM_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_BLEFILT_FT_AUX_CONNECT_RSP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ef), 0, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_FT_AUX_CONNECT_RSP_TO_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFEFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

#define GP_WB_READ_BLEFILT_FT_RESERVED_9() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ef), 1)

#define GP_WB_GET_BLEFILT_FT_RESERVED_9_FROM_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_BLEFILT_FT_RESERVED_9(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ef), 1, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_FT_RESERVED_9_TO_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFDFF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)

#define GP_WB_READ_BLEFILT_FT_RESERVED_10() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ef), 2)

#define GP_WB_GET_BLEFILT_FT_RESERVED_10_FROM_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_BLEFILT_FT_RESERVED_10(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ef), 2, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_FT_RESERVED_10_TO_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFBFF; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)

#define GP_WB_READ_BLEFILT_FT_RESERVED_11() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ef), 3)

#define GP_WB_GET_BLEFILT_FT_RESERVED_11_FROM_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_BLEFILT_FT_RESERVED_11(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ef), 3, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_FT_RESERVED_11_TO_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7FF; \
          (tmp) |= (((UInt16)(val)) << 11); \
        } while (0)

#define GP_WB_READ_BLEFILT_FT_RESERVED_12() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ef), 4)

#define GP_WB_GET_BLEFILT_FT_RESERVED_12_FROM_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_BLEFILT_FT_RESERVED_12(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ef), 4, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_FT_RESERVED_12_TO_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEFFF; \
          (tmp) |= (((UInt16)(val)) << 12); \
        } while (0)

#define GP_WB_READ_BLEFILT_FT_RESERVED_13() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ef), 5)

#define GP_WB_GET_BLEFILT_FT_RESERVED_13_FROM_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_BLEFILT_FT_RESERVED_13(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ef), 5, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_FT_RESERVED_13_TO_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDFFF; \
          (tmp) |= (((UInt16)(val)) << 13); \
        } while (0)

#define GP_WB_READ_BLEFILT_FT_RESERVED_14() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ef), 6)

#define GP_WB_GET_BLEFILT_FT_RESERVED_14_FROM_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_BLEFILT_FT_RESERVED_14(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ef), 6, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_FT_RESERVED_14_TO_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBFFF; \
          (tmp) |= (((UInt16)(val)) << 14); \
        } while (0)

#define GP_WB_READ_BLEFILT_FT_RESERVED_15() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ef), 7)

#define GP_WB_GET_BLEFILT_FT_RESERVED_15_FROM_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_BLEFILT_FT_RESERVED_15(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ef), 7, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_FT_RESERVED_15_TO_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7FFF; \
          (tmp) |= (((UInt16)(val)) << 15); \
        } while (0)


#define GP_WB_READ_BLEFILT_IS_ADV_EXT_FRAME() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f0), 0)

#define GP_WB_WRITE_BLEFILT_IS_ADV_EXT_FRAME(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f0), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BLEFILT_ADV_EXT_PAYLOAD_HDR() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f1))

#define GP_WB_WRITE_BLEFILT_ADV_EXT_PAYLOAD_HDR(val) \
      GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f1), (val))

#define GP_WB_READ_BLEFILT_ADV_EXT_PAYLOAD_HDR_LEN() \
        (GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f1)) & 0x3F)

#define GP_WB_GET_BLEFILT_ADV_EXT_PAYLOAD_HDR_LEN_FROM_ADV_EXT_PAYLOAD_HDR(tmp) \
        ((tmp) & 0x3F)

#define GP_WB_WRITE_BLEFILT_ADV_EXT_PAYLOAD_HDR_LEN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f1), 0x3F, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_ADV_EXT_PAYLOAD_HDR_LEN_TO_ADV_EXT_PAYLOAD_HDR(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0xC0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_BLEFILT_ADV_EXT_PAYLOAD_HDR_MODE() \
        ((GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f1)) >> 6) & 0x03)

#define GP_WB_GET_BLEFILT_ADV_EXT_PAYLOAD_HDR_MODE_FROM_ADV_EXT_PAYLOAD_HDR(tmp) \
        (((tmp) >> 6) & 0x03)

#define GP_WB_WRITE_BLEFILT_ADV_EXT_PAYLOAD_HDR_MODE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_MWRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f1), 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_BLEFILT_ADV_EXT_PAYLOAD_HDR_MODE_TO_ADV_EXT_PAYLOAD_HDR(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BLEFILT_ADV_EXT_HDR_FLAGS() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f2))

#define GP_WB_WRITE_BLEFILT_ADV_EXT_HDR_FLAGS(val) \
      GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f2), (val))

#define GP_WB_READ_BLEFILT_ADV_EXT_HDR_FLAG_SRC_ADDR() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f2), 0)

#define GP_WB_GET_BLEFILT_ADV_EXT_HDR_FLAG_SRC_ADDR_FROM_ADV_EXT_HDR_FLAGS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_BLEFILT_ADV_EXT_HDR_FLAG_SRC_ADDR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f2), 0, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_ADV_EXT_HDR_FLAG_SRC_ADDR_TO_ADV_EXT_HDR_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_BLEFILT_ADV_EXT_HDR_FLAG_DST_ADDR() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f2), 1)

#define GP_WB_GET_BLEFILT_ADV_EXT_HDR_FLAG_DST_ADDR_FROM_ADV_EXT_HDR_FLAGS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_BLEFILT_ADV_EXT_HDR_FLAG_DST_ADDR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f2), 1, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_ADV_EXT_HDR_FLAG_DST_ADDR_TO_ADV_EXT_HDR_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_BLEFILT_ADV_EXT_HDR_FLAG_CTE_INFO() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f2), 2)

#define GP_WB_GET_BLEFILT_ADV_EXT_HDR_FLAG_CTE_INFO_FROM_ADV_EXT_HDR_FLAGS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_BLEFILT_ADV_EXT_HDR_FLAG_CTE_INFO(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f2), 2, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_ADV_EXT_HDR_FLAG_CTE_INFO_TO_ADV_EXT_HDR_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_BLEFILT_ADV_EXT_HDR_FLAG_DATA_INFO() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f2), 3)

#define GP_WB_GET_BLEFILT_ADV_EXT_HDR_FLAG_DATA_INFO_FROM_ADV_EXT_HDR_FLAGS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_BLEFILT_ADV_EXT_HDR_FLAG_DATA_INFO(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f2), 3, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_ADV_EXT_HDR_FLAG_DATA_INFO_TO_ADV_EXT_HDR_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x77; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_BLEFILT_ADV_EXT_HDR_FLAG_AUX_PTR() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f2), 4)

#define GP_WB_GET_BLEFILT_ADV_EXT_HDR_FLAG_AUX_PTR_FROM_ADV_EXT_HDR_FLAGS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_BLEFILT_ADV_EXT_HDR_FLAG_AUX_PTR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f2), 4, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_ADV_EXT_HDR_FLAG_AUX_PTR_TO_ADV_EXT_HDR_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x6F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_READ_BLEFILT_ADV_EXT_HDR_FLAG_SYNC_INFO() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f2), 5)

#define GP_WB_GET_BLEFILT_ADV_EXT_HDR_FLAG_SYNC_INFO_FROM_ADV_EXT_HDR_FLAGS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_BLEFILT_ADV_EXT_HDR_FLAG_SYNC_INFO(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f2), 5, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_ADV_EXT_HDR_FLAG_SYNC_INFO_TO_ADV_EXT_HDR_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x5F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

#define GP_WB_READ_BLEFILT_ADV_EXT_HDR_FLAG_TX_POWER() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f2), 6)

#define GP_WB_GET_BLEFILT_ADV_EXT_HDR_FLAG_TX_POWER_FROM_ADV_EXT_HDR_FLAGS(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_BLEFILT_ADV_EXT_HDR_FLAG_TX_POWER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f2), 6, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_ADV_EXT_HDR_FLAG_TX_POWER_TO_ADV_EXT_HDR_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BLEFILT_SUBFILT_0_FRAME_TYPE_ACCEPT() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f4))

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_FRAME_TYPE_ACCEPT(val) \
      GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f4), (val))

#define GP_WB_READ_BLEFILT_SUBFILT_0_ACCEPT_FT_ADV_IND() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f4), 0)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ACCEPT_FT_ADV_IND_FROM_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ACCEPT_FT_ADV_IND(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f4), 0, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ACCEPT_FT_ADV_IND_TO_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFE; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_ACCEPT_FT_ADV_DIRECT_IND() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f4), 1)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ACCEPT_FT_ADV_DIRECT_IND_FROM_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ACCEPT_FT_ADV_DIRECT_IND(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f4), 1, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ACCEPT_FT_ADV_DIRECT_IND_TO_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFD; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_ACCEPT_FT_ADV_NONCONN_IND() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f4), 2)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ACCEPT_FT_ADV_NONCONN_IND_FROM_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ACCEPT_FT_ADV_NONCONN_IND(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f4), 2, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ACCEPT_FT_ADV_NONCONN_IND_TO_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFB; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_ACCEPT_FT_SCAN_REQ() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f4), 3)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ACCEPT_FT_SCAN_REQ_FROM_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ACCEPT_FT_SCAN_REQ(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f4), 3, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ACCEPT_FT_SCAN_REQ_TO_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFF7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_ACCEPT_FT_AUX_SCAN_REQ() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f4), 3)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ACCEPT_FT_AUX_SCAN_REQ_FROM_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ACCEPT_FT_AUX_SCAN_REQ(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f4), 3, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ACCEPT_FT_AUX_SCAN_REQ_TO_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFF7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_ACCEPT_FT_SCAN_RSP() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f4), 4)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ACCEPT_FT_SCAN_RSP_FROM_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ACCEPT_FT_SCAN_RSP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f4), 4, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ACCEPT_FT_SCAN_RSP_TO_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFEF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_ACCEPT_FT_CONNECT_REQ() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f4), 5)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ACCEPT_FT_CONNECT_REQ_FROM_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ACCEPT_FT_CONNECT_REQ(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f4), 5, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ACCEPT_FT_CONNECT_REQ_TO_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFDF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_ACCEPT_FT_AUX_CONNECT_REQ() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f4), 5)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ACCEPT_FT_AUX_CONNECT_REQ_FROM_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ACCEPT_FT_AUX_CONNECT_REQ(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f4), 5, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ACCEPT_FT_AUX_CONNECT_REQ_TO_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFDF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_ACCEPT_FT_ADV_SCAN_IND() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f4), 6)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ACCEPT_FT_ADV_SCAN_IND_FROM_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ACCEPT_FT_ADV_SCAN_IND(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f4), 6, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ACCEPT_FT_ADV_SCAN_IND_TO_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFBF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_ACCEPT_FT_ADV_EXT_IND() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f4), 7)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ACCEPT_FT_ADV_EXT_IND_FROM_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ACCEPT_FT_ADV_EXT_IND(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f4), 7, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ACCEPT_FT_ADV_EXT_IND_TO_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_ACCEPT_FT_AUX_ADV_IND() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f4), 7)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ACCEPT_FT_AUX_ADV_IND_FROM_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ACCEPT_FT_AUX_ADV_IND(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f4), 7, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ACCEPT_FT_AUX_ADV_IND_TO_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_ACCEPT_FT_AUX_SCAN_RSP() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f4), 7)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ACCEPT_FT_AUX_SCAN_RSP_FROM_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ACCEPT_FT_AUX_SCAN_RSP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f4), 7, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ACCEPT_FT_AUX_SCAN_RSP_TO_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_ACCEPT_FT_AUX_SYNC_IND() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f4), 7)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ACCEPT_FT_AUX_SYNC_IND_FROM_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ACCEPT_FT_AUX_SYNC_IND(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f4), 7, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ACCEPT_FT_AUX_SYNC_IND_TO_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_ACCEPT_FT_AUX_CHAIN_IND() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f4), 7)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ACCEPT_FT_AUX_CHAIN_IND_FROM_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ACCEPT_FT_AUX_CHAIN_IND(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f4), 7, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ACCEPT_FT_AUX_CHAIN_IND_TO_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_ACCEPT_FT_AUX_CONNECT_RSP() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f5), 0)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ACCEPT_FT_AUX_CONNECT_RSP_FROM_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ACCEPT_FT_AUX_CONNECT_RSP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f5), 0, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ACCEPT_FT_AUX_CONNECT_RSP_TO_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFEFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_ACCEPT_FT_RESERVED_9() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f5), 1)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ACCEPT_FT_RESERVED_9_FROM_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ACCEPT_FT_RESERVED_9(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f5), 1, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ACCEPT_FT_RESERVED_9_TO_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFDFF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_ACCEPT_FT_RESERVED_10() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f5), 2)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ACCEPT_FT_RESERVED_10_FROM_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ACCEPT_FT_RESERVED_10(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f5), 2, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ACCEPT_FT_RESERVED_10_TO_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFBFF; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_ACCEPT_FT_RESERVED_11() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f5), 3)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ACCEPT_FT_RESERVED_11_FROM_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ACCEPT_FT_RESERVED_11(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f5), 3, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ACCEPT_FT_RESERVED_11_TO_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7FF; \
          (tmp) |= (((UInt16)(val)) << 11); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_ACCEPT_FT_RESERVED_12() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f5), 4)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ACCEPT_FT_RESERVED_12_FROM_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ACCEPT_FT_RESERVED_12(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f5), 4, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ACCEPT_FT_RESERVED_12_TO_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEFFF; \
          (tmp) |= (((UInt16)(val)) << 12); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_ACCEPT_FT_RESERVED_13() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f5), 5)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ACCEPT_FT_RESERVED_13_FROM_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ACCEPT_FT_RESERVED_13(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f5), 5, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ACCEPT_FT_RESERVED_13_TO_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDFFF; \
          (tmp) |= (((UInt16)(val)) << 13); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_ACCEPT_FT_RESERVED_14() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f5), 6)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ACCEPT_FT_RESERVED_14_FROM_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ACCEPT_FT_RESERVED_14(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f5), 6, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ACCEPT_FT_RESERVED_14_TO_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBFFF; \
          (tmp) |= (((UInt16)(val)) << 14); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_ACCEPT_FT_RESERVED_15() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f5), 7)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ACCEPT_FT_RESERVED_15_FROM_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ACCEPT_FT_RESERVED_15(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f5), 7, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ACCEPT_FT_RESERVED_15_TO_SUBFILT_0_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7FFF; \
          (tmp) |= (((UInt16)(val)) << 15); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BLEFILT_SUBFILT_0_FT_WHITELIST_ENABLE() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f6))

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_FT_WHITELIST_ENABLE(val) \
      GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f6), (val))

#define GP_WB_READ_BLEFILT_SUBFILT_0_FT_ADV_IND_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f6), 0)

#define GP_WB_GET_BLEFILT_SUBFILT_0_FT_ADV_IND_WL_EN_FROM_SUBFILT_0_FT_WHITELIST_ENABLE(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_FT_ADV_IND_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f6), 0, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_FT_ADV_IND_WL_EN_TO_SUBFILT_0_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFE; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_FT_ADV_DIRECT_IND_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f6), 1)

#define GP_WB_GET_BLEFILT_SUBFILT_0_FT_ADV_DIRECT_IND_WL_EN_FROM_SUBFILT_0_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_FT_ADV_DIRECT_IND_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f6), 1, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_FT_ADV_DIRECT_IND_WL_EN_TO_SUBFILT_0_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFD; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_FT_ADV_NONCONN_IND_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f6), 2)

#define GP_WB_GET_BLEFILT_SUBFILT_0_FT_ADV_NONCONN_IND_WL_EN_FROM_SUBFILT_0_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_FT_ADV_NONCONN_IND_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f6), 2, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_FT_ADV_NONCONN_IND_WL_EN_TO_SUBFILT_0_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFB; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_FT_SCAN_REQ_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f6), 3)

#define GP_WB_GET_BLEFILT_SUBFILT_0_FT_SCAN_REQ_WL_EN_FROM_SUBFILT_0_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_FT_SCAN_REQ_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f6), 3, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_FT_SCAN_REQ_WL_EN_TO_SUBFILT_0_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFF7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_FT_AUX_SCAN_REQ_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f6), 3)

#define GP_WB_GET_BLEFILT_SUBFILT_0_FT_AUX_SCAN_REQ_WL_EN_FROM_SUBFILT_0_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_FT_AUX_SCAN_REQ_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f6), 3, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_FT_AUX_SCAN_REQ_WL_EN_TO_SUBFILT_0_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFF7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_FT_SCAN_RSP_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f6), 4)

#define GP_WB_GET_BLEFILT_SUBFILT_0_FT_SCAN_RSP_WL_EN_FROM_SUBFILT_0_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_FT_SCAN_RSP_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f6), 4, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_FT_SCAN_RSP_WL_EN_TO_SUBFILT_0_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFEF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_FT_CONNECT_REQ_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f6), 5)

#define GP_WB_GET_BLEFILT_SUBFILT_0_FT_CONNECT_REQ_WL_EN_FROM_SUBFILT_0_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_FT_CONNECT_REQ_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f6), 5, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_FT_CONNECT_REQ_WL_EN_TO_SUBFILT_0_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFDF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_FT_AUX_CONNECT_REQ_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f6), 5)

#define GP_WB_GET_BLEFILT_SUBFILT_0_FT_AUX_CONNECT_REQ_WL_EN_FROM_SUBFILT_0_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_FT_AUX_CONNECT_REQ_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f6), 5, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_FT_AUX_CONNECT_REQ_WL_EN_TO_SUBFILT_0_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFDF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_FT_ADV_SCAN_IND_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f6), 6)

#define GP_WB_GET_BLEFILT_SUBFILT_0_FT_ADV_SCAN_IND_WL_EN_FROM_SUBFILT_0_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_FT_ADV_SCAN_IND_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f6), 6, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_FT_ADV_SCAN_IND_WL_EN_TO_SUBFILT_0_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFBF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_FT_ADV_EXT_IND_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f6), 7)

#define GP_WB_GET_BLEFILT_SUBFILT_0_FT_ADV_EXT_IND_WL_EN_FROM_SUBFILT_0_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_FT_ADV_EXT_IND_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f6), 7, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_FT_ADV_EXT_IND_WL_EN_TO_SUBFILT_0_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_FT_AUX_ADV_IND_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f6), 7)

#define GP_WB_GET_BLEFILT_SUBFILT_0_FT_AUX_ADV_IND_WL_EN_FROM_SUBFILT_0_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_FT_AUX_ADV_IND_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f6), 7, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_FT_AUX_ADV_IND_WL_EN_TO_SUBFILT_0_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_FT_AUX_SCAN_RSP_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f6), 7)

#define GP_WB_GET_BLEFILT_SUBFILT_0_FT_AUX_SCAN_RSP_WL_EN_FROM_SUBFILT_0_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_FT_AUX_SCAN_RSP_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f6), 7, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_FT_AUX_SCAN_RSP_WL_EN_TO_SUBFILT_0_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_FT_AUX_SYNC_IND_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f6), 7)

#define GP_WB_GET_BLEFILT_SUBFILT_0_FT_AUX_SYNC_IND_WL_EN_FROM_SUBFILT_0_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_FT_AUX_SYNC_IND_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f6), 7, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_FT_AUX_SYNC_IND_WL_EN_TO_SUBFILT_0_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_FT_AUX_CHAIN_IND_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f6), 7)

#define GP_WB_GET_BLEFILT_SUBFILT_0_FT_AUX_CHAIN_IND_WL_EN_FROM_SUBFILT_0_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_FT_AUX_CHAIN_IND_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f6), 7, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_FT_AUX_CHAIN_IND_WL_EN_TO_SUBFILT_0_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_FT_AUX_CONNECT_RSP_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f7), 0)

#define GP_WB_GET_BLEFILT_SUBFILT_0_FT_AUX_CONNECT_RSP_WL_EN_FROM_SUBFILT_0_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_FT_AUX_CONNECT_RSP_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f7), 0, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_FT_AUX_CONNECT_RSP_WL_EN_TO_SUBFILT_0_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFEFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_FT_RESERVED_9_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f7), 1)

#define GP_WB_GET_BLEFILT_SUBFILT_0_FT_RESERVED_9_WL_EN_FROM_SUBFILT_0_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_FT_RESERVED_9_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f7), 1, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_FT_RESERVED_9_WL_EN_TO_SUBFILT_0_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFDFF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_FT_RESERVED_10_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f7), 2)

#define GP_WB_GET_BLEFILT_SUBFILT_0_FT_RESERVED_10_WL_EN_FROM_SUBFILT_0_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_FT_RESERVED_10_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f7), 2, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_FT_RESERVED_10_WL_EN_TO_SUBFILT_0_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFBFF; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_FT_RESERVED_11_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f7), 3)

#define GP_WB_GET_BLEFILT_SUBFILT_0_FT_RESERVED_11_WL_EN_FROM_SUBFILT_0_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_FT_RESERVED_11_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f7), 3, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_FT_RESERVED_11_WL_EN_TO_SUBFILT_0_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7FF; \
          (tmp) |= (((UInt16)(val)) << 11); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_FT_RESERVED_12_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f7), 4)

#define GP_WB_GET_BLEFILT_SUBFILT_0_FT_RESERVED_12_WL_EN_FROM_SUBFILT_0_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_FT_RESERVED_12_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f7), 4, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_FT_RESERVED_12_WL_EN_TO_SUBFILT_0_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEFFF; \
          (tmp) |= (((UInt16)(val)) << 12); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_FT_RESERVED_13_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f7), 5)

#define GP_WB_GET_BLEFILT_SUBFILT_0_FT_RESERVED_13_WL_EN_FROM_SUBFILT_0_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_FT_RESERVED_13_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f7), 5, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_FT_RESERVED_13_WL_EN_TO_SUBFILT_0_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDFFF; \
          (tmp) |= (((UInt16)(val)) << 13); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_FT_RESERVED_14_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f7), 6)

#define GP_WB_GET_BLEFILT_SUBFILT_0_FT_RESERVED_14_WL_EN_FROM_SUBFILT_0_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_FT_RESERVED_14_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f7), 6, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_FT_RESERVED_14_WL_EN_TO_SUBFILT_0_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBFFF; \
          (tmp) |= (((UInt16)(val)) << 14); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_FT_RESERVED_15_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f7), 7)

#define GP_WB_GET_BLEFILT_SUBFILT_0_FT_RESERVED_15_WL_EN_FROM_SUBFILT_0_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_FT_RESERVED_15_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f7), 7, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_FT_RESERVED_15_WL_EN_TO_SUBFILT_0_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7FFF; \
          (tmp) |= (((UInt16)(val)) << 15); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BLEFILT_SUBFILT_0_ADV_EXT_HDR_FLAGS() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f8))

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ADV_EXT_HDR_FLAGS(val) \
      GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f8), (val))

#define GP_WB_READ_BLEFILT_SUBFILT_0_ADV_EXT_HDR_FLAG_SRC_ADDR() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f8), 0)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ADV_EXT_HDR_FLAG_SRC_ADDR_FROM_SUBFILT_0_ADV_EXT_HDR_FLAGS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ADV_EXT_HDR_FLAG_SRC_ADDR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f8), 0, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ADV_EXT_HDR_FLAG_SRC_ADDR_TO_SUBFILT_0_ADV_EXT_HDR_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_ADV_EXT_HDR_FLAG_DST_ADDR() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f8), 1)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ADV_EXT_HDR_FLAG_DST_ADDR_FROM_SUBFILT_0_ADV_EXT_HDR_FLAGS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ADV_EXT_HDR_FLAG_DST_ADDR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f8), 1, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ADV_EXT_HDR_FLAG_DST_ADDR_TO_SUBFILT_0_ADV_EXT_HDR_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_ADV_EXT_HDR_FLAG_CTE_INFO() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f8), 2)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ADV_EXT_HDR_FLAG_CTE_INFO_FROM_SUBFILT_0_ADV_EXT_HDR_FLAGS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ADV_EXT_HDR_FLAG_CTE_INFO(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f8), 2, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ADV_EXT_HDR_FLAG_CTE_INFO_TO_SUBFILT_0_ADV_EXT_HDR_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_ADV_EXT_HDR_FLAG_DATA_INFO() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f8), 3)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ADV_EXT_HDR_FLAG_DATA_INFO_FROM_SUBFILT_0_ADV_EXT_HDR_FLAGS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ADV_EXT_HDR_FLAG_DATA_INFO(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f8), 3, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ADV_EXT_HDR_FLAG_DATA_INFO_TO_SUBFILT_0_ADV_EXT_HDR_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x77; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_ADV_EXT_HDR_FLAG_AUX_PTR() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f8), 4)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ADV_EXT_HDR_FLAG_AUX_PTR_FROM_SUBFILT_0_ADV_EXT_HDR_FLAGS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ADV_EXT_HDR_FLAG_AUX_PTR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f8), 4, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ADV_EXT_HDR_FLAG_AUX_PTR_TO_SUBFILT_0_ADV_EXT_HDR_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x6F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_ADV_EXT_HDR_FLAG_SYNC_INFO() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f8), 5)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ADV_EXT_HDR_FLAG_SYNC_INFO_FROM_SUBFILT_0_ADV_EXT_HDR_FLAGS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ADV_EXT_HDR_FLAG_SYNC_INFO(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f8), 5, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ADV_EXT_HDR_FLAG_SYNC_INFO_TO_SUBFILT_0_ADV_EXT_HDR_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x5F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_0_ADV_EXT_HDR_FLAG_TX_POWER() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f8), 6)

#define GP_WB_GET_BLEFILT_SUBFILT_0_ADV_EXT_HDR_FLAG_TX_POWER_FROM_SUBFILT_0_ADV_EXT_HDR_FLAGS(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_ADV_EXT_HDR_FLAG_TX_POWER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f8), 6, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_0_ADV_EXT_HDR_FLAG_TX_POWER_TO_SUBFILT_0_ADV_EXT_HDR_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* phy mask */
#define GP_WB_READ_BLEFILT_SUBFILT_0_PHY_MASK() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f9))

#define GP_WB_WRITE_BLEFILT_SUBFILT_0_PHY_MASK(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27f9), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BLEFILT_SUBFILT_1_FRAME_TYPE_ACCEPT() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fa))

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_FRAME_TYPE_ACCEPT(val) \
      GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fa), (val))

#define GP_WB_READ_BLEFILT_SUBFILT_1_ACCEPT_FT_ADV_IND() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fa), 0)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ACCEPT_FT_ADV_IND_FROM_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ACCEPT_FT_ADV_IND(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fa), 0, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ACCEPT_FT_ADV_IND_TO_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFE; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_ACCEPT_FT_ADV_DIRECT_IND() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fa), 1)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ACCEPT_FT_ADV_DIRECT_IND_FROM_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ACCEPT_FT_ADV_DIRECT_IND(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fa), 1, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ACCEPT_FT_ADV_DIRECT_IND_TO_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFD; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_ACCEPT_FT_ADV_NONCONN_IND() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fa), 2)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ACCEPT_FT_ADV_NONCONN_IND_FROM_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ACCEPT_FT_ADV_NONCONN_IND(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fa), 2, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ACCEPT_FT_ADV_NONCONN_IND_TO_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFB; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_ACCEPT_FT_SCAN_REQ() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fa), 3)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ACCEPT_FT_SCAN_REQ_FROM_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ACCEPT_FT_SCAN_REQ(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fa), 3, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ACCEPT_FT_SCAN_REQ_TO_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFF7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_ACCEPT_FT_AUX_SCAN_REQ() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fa), 3)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ACCEPT_FT_AUX_SCAN_REQ_FROM_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ACCEPT_FT_AUX_SCAN_REQ(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fa), 3, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ACCEPT_FT_AUX_SCAN_REQ_TO_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFF7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_ACCEPT_FT_SCAN_RSP() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fa), 4)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ACCEPT_FT_SCAN_RSP_FROM_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ACCEPT_FT_SCAN_RSP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fa), 4, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ACCEPT_FT_SCAN_RSP_TO_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFEF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_ACCEPT_FT_CONNECT_REQ() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fa), 5)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ACCEPT_FT_CONNECT_REQ_FROM_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ACCEPT_FT_CONNECT_REQ(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fa), 5, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ACCEPT_FT_CONNECT_REQ_TO_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFDF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_ACCEPT_FT_AUX_CONNECT_REQ() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fa), 5)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ACCEPT_FT_AUX_CONNECT_REQ_FROM_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ACCEPT_FT_AUX_CONNECT_REQ(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fa), 5, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ACCEPT_FT_AUX_CONNECT_REQ_TO_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFDF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_ACCEPT_FT_ADV_SCAN_IND() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fa), 6)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ACCEPT_FT_ADV_SCAN_IND_FROM_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ACCEPT_FT_ADV_SCAN_IND(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fa), 6, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ACCEPT_FT_ADV_SCAN_IND_TO_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFBF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_ACCEPT_FT_ADV_EXT_IND() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fa), 7)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ACCEPT_FT_ADV_EXT_IND_FROM_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ACCEPT_FT_ADV_EXT_IND(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fa), 7, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ACCEPT_FT_ADV_EXT_IND_TO_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_ACCEPT_FT_AUX_ADV_IND() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fa), 7)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ACCEPT_FT_AUX_ADV_IND_FROM_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ACCEPT_FT_AUX_ADV_IND(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fa), 7, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ACCEPT_FT_AUX_ADV_IND_TO_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_ACCEPT_FT_AUX_SCAN_RSP() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fa), 7)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ACCEPT_FT_AUX_SCAN_RSP_FROM_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ACCEPT_FT_AUX_SCAN_RSP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fa), 7, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ACCEPT_FT_AUX_SCAN_RSP_TO_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_ACCEPT_FT_AUX_SYNC_IND() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fa), 7)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ACCEPT_FT_AUX_SYNC_IND_FROM_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ACCEPT_FT_AUX_SYNC_IND(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fa), 7, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ACCEPT_FT_AUX_SYNC_IND_TO_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_ACCEPT_FT_AUX_CHAIN_IND() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fa), 7)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ACCEPT_FT_AUX_CHAIN_IND_FROM_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ACCEPT_FT_AUX_CHAIN_IND(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fa), 7, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ACCEPT_FT_AUX_CHAIN_IND_TO_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_ACCEPT_FT_AUX_CONNECT_RSP() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fb), 0)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ACCEPT_FT_AUX_CONNECT_RSP_FROM_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ACCEPT_FT_AUX_CONNECT_RSP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fb), 0, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ACCEPT_FT_AUX_CONNECT_RSP_TO_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFEFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_ACCEPT_FT_RESERVED_9() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fb), 1)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ACCEPT_FT_RESERVED_9_FROM_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ACCEPT_FT_RESERVED_9(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fb), 1, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ACCEPT_FT_RESERVED_9_TO_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFDFF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_ACCEPT_FT_RESERVED_10() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fb), 2)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ACCEPT_FT_RESERVED_10_FROM_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ACCEPT_FT_RESERVED_10(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fb), 2, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ACCEPT_FT_RESERVED_10_TO_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFBFF; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_ACCEPT_FT_RESERVED_11() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fb), 3)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ACCEPT_FT_RESERVED_11_FROM_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ACCEPT_FT_RESERVED_11(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fb), 3, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ACCEPT_FT_RESERVED_11_TO_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7FF; \
          (tmp) |= (((UInt16)(val)) << 11); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_ACCEPT_FT_RESERVED_12() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fb), 4)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ACCEPT_FT_RESERVED_12_FROM_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ACCEPT_FT_RESERVED_12(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fb), 4, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ACCEPT_FT_RESERVED_12_TO_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEFFF; \
          (tmp) |= (((UInt16)(val)) << 12); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_ACCEPT_FT_RESERVED_13() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fb), 5)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ACCEPT_FT_RESERVED_13_FROM_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ACCEPT_FT_RESERVED_13(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fb), 5, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ACCEPT_FT_RESERVED_13_TO_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDFFF; \
          (tmp) |= (((UInt16)(val)) << 13); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_ACCEPT_FT_RESERVED_14() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fb), 6)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ACCEPT_FT_RESERVED_14_FROM_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ACCEPT_FT_RESERVED_14(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fb), 6, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ACCEPT_FT_RESERVED_14_TO_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBFFF; \
          (tmp) |= (((UInt16)(val)) << 14); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_ACCEPT_FT_RESERVED_15() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fb), 7)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ACCEPT_FT_RESERVED_15_FROM_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ACCEPT_FT_RESERVED_15(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fb), 7, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ACCEPT_FT_RESERVED_15_TO_SUBFILT_1_FRAME_TYPE_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7FFF; \
          (tmp) |= (((UInt16)(val)) << 15); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BLEFILT_SUBFILT_1_FT_WHITELIST_ENABLE() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fc))

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_FT_WHITELIST_ENABLE(val) \
      GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fc), (val))

#define GP_WB_READ_BLEFILT_SUBFILT_1_FT_ADV_IND_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fc), 0)

#define GP_WB_GET_BLEFILT_SUBFILT_1_FT_ADV_IND_WL_EN_FROM_SUBFILT_1_FT_WHITELIST_ENABLE(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_FT_ADV_IND_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fc), 0, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_FT_ADV_IND_WL_EN_TO_SUBFILT_1_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFE; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_FT_ADV_DIRECT_IND_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fc), 1)

#define GP_WB_GET_BLEFILT_SUBFILT_1_FT_ADV_DIRECT_IND_WL_EN_FROM_SUBFILT_1_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_FT_ADV_DIRECT_IND_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fc), 1, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_FT_ADV_DIRECT_IND_WL_EN_TO_SUBFILT_1_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFD; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_FT_ADV_NONCONN_IND_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fc), 2)

#define GP_WB_GET_BLEFILT_SUBFILT_1_FT_ADV_NONCONN_IND_WL_EN_FROM_SUBFILT_1_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_FT_ADV_NONCONN_IND_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fc), 2, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_FT_ADV_NONCONN_IND_WL_EN_TO_SUBFILT_1_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFB; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_FT_SCAN_REQ_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fc), 3)

#define GP_WB_GET_BLEFILT_SUBFILT_1_FT_SCAN_REQ_WL_EN_FROM_SUBFILT_1_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_FT_SCAN_REQ_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fc), 3, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_FT_SCAN_REQ_WL_EN_TO_SUBFILT_1_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFF7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_FT_AUX_SCAN_REQ_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fc), 3)

#define GP_WB_GET_BLEFILT_SUBFILT_1_FT_AUX_SCAN_REQ_WL_EN_FROM_SUBFILT_1_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_FT_AUX_SCAN_REQ_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fc), 3, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_FT_AUX_SCAN_REQ_WL_EN_TO_SUBFILT_1_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFF7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_FT_SCAN_RSP_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fc), 4)

#define GP_WB_GET_BLEFILT_SUBFILT_1_FT_SCAN_RSP_WL_EN_FROM_SUBFILT_1_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_FT_SCAN_RSP_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fc), 4, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_FT_SCAN_RSP_WL_EN_TO_SUBFILT_1_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFEF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_FT_CONNECT_REQ_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fc), 5)

#define GP_WB_GET_BLEFILT_SUBFILT_1_FT_CONNECT_REQ_WL_EN_FROM_SUBFILT_1_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_FT_CONNECT_REQ_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fc), 5, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_FT_CONNECT_REQ_WL_EN_TO_SUBFILT_1_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFDF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_FT_AUX_CONNECT_REQ_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fc), 5)

#define GP_WB_GET_BLEFILT_SUBFILT_1_FT_AUX_CONNECT_REQ_WL_EN_FROM_SUBFILT_1_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_FT_AUX_CONNECT_REQ_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fc), 5, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_FT_AUX_CONNECT_REQ_WL_EN_TO_SUBFILT_1_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFDF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_FT_ADV_SCAN_IND_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fc), 6)

#define GP_WB_GET_BLEFILT_SUBFILT_1_FT_ADV_SCAN_IND_WL_EN_FROM_SUBFILT_1_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_FT_ADV_SCAN_IND_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fc), 6, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_FT_ADV_SCAN_IND_WL_EN_TO_SUBFILT_1_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFBF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_FT_ADV_EXT_IND_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fc), 7)

#define GP_WB_GET_BLEFILT_SUBFILT_1_FT_ADV_EXT_IND_WL_EN_FROM_SUBFILT_1_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_FT_ADV_EXT_IND_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fc), 7, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_FT_ADV_EXT_IND_WL_EN_TO_SUBFILT_1_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_FT_AUX_ADV_IND_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fc), 7)

#define GP_WB_GET_BLEFILT_SUBFILT_1_FT_AUX_ADV_IND_WL_EN_FROM_SUBFILT_1_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_FT_AUX_ADV_IND_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fc), 7, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_FT_AUX_ADV_IND_WL_EN_TO_SUBFILT_1_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_FT_AUX_SCAN_RSP_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fc), 7)

#define GP_WB_GET_BLEFILT_SUBFILT_1_FT_AUX_SCAN_RSP_WL_EN_FROM_SUBFILT_1_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_FT_AUX_SCAN_RSP_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fc), 7, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_FT_AUX_SCAN_RSP_WL_EN_TO_SUBFILT_1_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_FT_AUX_SYNC_IND_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fc), 7)

#define GP_WB_GET_BLEFILT_SUBFILT_1_FT_AUX_SYNC_IND_WL_EN_FROM_SUBFILT_1_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_FT_AUX_SYNC_IND_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fc), 7, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_FT_AUX_SYNC_IND_WL_EN_TO_SUBFILT_1_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_FT_AUX_CHAIN_IND_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fc), 7)

#define GP_WB_GET_BLEFILT_SUBFILT_1_FT_AUX_CHAIN_IND_WL_EN_FROM_SUBFILT_1_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_FT_AUX_CHAIN_IND_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fc), 7, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_FT_AUX_CHAIN_IND_WL_EN_TO_SUBFILT_1_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_FT_AUX_CONNECT_RSP_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fd), 0)

#define GP_WB_GET_BLEFILT_SUBFILT_1_FT_AUX_CONNECT_RSP_WL_EN_FROM_SUBFILT_1_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_FT_AUX_CONNECT_RSP_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fd), 0, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_FT_AUX_CONNECT_RSP_WL_EN_TO_SUBFILT_1_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFEFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_FT_RESERVED_9_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fd), 1)

#define GP_WB_GET_BLEFILT_SUBFILT_1_FT_RESERVED_9_WL_EN_FROM_SUBFILT_1_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_FT_RESERVED_9_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fd), 1, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_FT_RESERVED_9_WL_EN_TO_SUBFILT_1_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFDFF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_FT_RESERVED_10_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fd), 2)

#define GP_WB_GET_BLEFILT_SUBFILT_1_FT_RESERVED_10_WL_EN_FROM_SUBFILT_1_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_FT_RESERVED_10_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fd), 2, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_FT_RESERVED_10_WL_EN_TO_SUBFILT_1_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFBFF; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_FT_RESERVED_11_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fd), 3)

#define GP_WB_GET_BLEFILT_SUBFILT_1_FT_RESERVED_11_WL_EN_FROM_SUBFILT_1_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_FT_RESERVED_11_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fd), 3, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_FT_RESERVED_11_WL_EN_TO_SUBFILT_1_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7FF; \
          (tmp) |= (((UInt16)(val)) << 11); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_FT_RESERVED_12_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fd), 4)

#define GP_WB_GET_BLEFILT_SUBFILT_1_FT_RESERVED_12_WL_EN_FROM_SUBFILT_1_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_FT_RESERVED_12_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fd), 4, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_FT_RESERVED_12_WL_EN_TO_SUBFILT_1_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEFFF; \
          (tmp) |= (((UInt16)(val)) << 12); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_FT_RESERVED_13_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fd), 5)

#define GP_WB_GET_BLEFILT_SUBFILT_1_FT_RESERVED_13_WL_EN_FROM_SUBFILT_1_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_FT_RESERVED_13_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fd), 5, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_FT_RESERVED_13_WL_EN_TO_SUBFILT_1_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDFFF; \
          (tmp) |= (((UInt16)(val)) << 13); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_FT_RESERVED_14_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fd), 6)

#define GP_WB_GET_BLEFILT_SUBFILT_1_FT_RESERVED_14_WL_EN_FROM_SUBFILT_1_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_FT_RESERVED_14_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fd), 6, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_FT_RESERVED_14_WL_EN_TO_SUBFILT_1_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBFFF; \
          (tmp) |= (((UInt16)(val)) << 14); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_FT_RESERVED_15_WL_EN() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fd), 7)

#define GP_WB_GET_BLEFILT_SUBFILT_1_FT_RESERVED_15_WL_EN_FROM_SUBFILT_1_FT_WHITELIST_ENABLE(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_FT_RESERVED_15_WL_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fd), 7, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_FT_RESERVED_15_WL_EN_TO_SUBFILT_1_FT_WHITELIST_ENABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7FFF; \
          (tmp) |= (((UInt16)(val)) << 15); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BLEFILT_SUBFILT_1_ADV_EXT_HDR_FLAGS() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fe))

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ADV_EXT_HDR_FLAGS(val) \
      GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fe), (val))

#define GP_WB_READ_BLEFILT_SUBFILT_1_ADV_EXT_HDR_FLAG_SRC_ADDR() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fe), 0)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ADV_EXT_HDR_FLAG_SRC_ADDR_FROM_SUBFILT_1_ADV_EXT_HDR_FLAGS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ADV_EXT_HDR_FLAG_SRC_ADDR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fe), 0, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ADV_EXT_HDR_FLAG_SRC_ADDR_TO_SUBFILT_1_ADV_EXT_HDR_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_ADV_EXT_HDR_FLAG_DST_ADDR() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fe), 1)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ADV_EXT_HDR_FLAG_DST_ADDR_FROM_SUBFILT_1_ADV_EXT_HDR_FLAGS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ADV_EXT_HDR_FLAG_DST_ADDR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fe), 1, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ADV_EXT_HDR_FLAG_DST_ADDR_TO_SUBFILT_1_ADV_EXT_HDR_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_ADV_EXT_HDR_FLAG_CTE_INFO() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fe), 2)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ADV_EXT_HDR_FLAG_CTE_INFO_FROM_SUBFILT_1_ADV_EXT_HDR_FLAGS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ADV_EXT_HDR_FLAG_CTE_INFO(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fe), 2, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ADV_EXT_HDR_FLAG_CTE_INFO_TO_SUBFILT_1_ADV_EXT_HDR_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_ADV_EXT_HDR_FLAG_DATA_INFO() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fe), 3)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ADV_EXT_HDR_FLAG_DATA_INFO_FROM_SUBFILT_1_ADV_EXT_HDR_FLAGS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ADV_EXT_HDR_FLAG_DATA_INFO(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fe), 3, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ADV_EXT_HDR_FLAG_DATA_INFO_TO_SUBFILT_1_ADV_EXT_HDR_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x77; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_ADV_EXT_HDR_FLAG_AUX_PTR() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fe), 4)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ADV_EXT_HDR_FLAG_AUX_PTR_FROM_SUBFILT_1_ADV_EXT_HDR_FLAGS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ADV_EXT_HDR_FLAG_AUX_PTR(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fe), 4, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ADV_EXT_HDR_FLAG_AUX_PTR_TO_SUBFILT_1_ADV_EXT_HDR_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x6F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_ADV_EXT_HDR_FLAG_SYNC_INFO() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fe), 5)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ADV_EXT_HDR_FLAG_SYNC_INFO_FROM_SUBFILT_1_ADV_EXT_HDR_FLAGS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ADV_EXT_HDR_FLAG_SYNC_INFO(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fe), 5, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ADV_EXT_HDR_FLAG_SYNC_INFO_TO_SUBFILT_1_ADV_EXT_HDR_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x5F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

#define GP_WB_READ_BLEFILT_SUBFILT_1_ADV_EXT_HDR_FLAG_TX_POWER() \
        GP_WB_READ_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fe), 6)

#define GP_WB_GET_BLEFILT_SUBFILT_1_ADV_EXT_HDR_FLAG_TX_POWER_FROM_SUBFILT_1_ADV_EXT_HDR_FLAGS(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_ADV_EXT_HDR_FLAG_TX_POWER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_MWRITE_U1(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27fe), 6, (val)); \
        } while (0)

#define GP_WB_SET_BLEFILT_SUBFILT_1_ADV_EXT_HDR_FLAG_TX_POWER_TO_SUBFILT_1_ADV_EXT_HDR_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* phy mask */
#define GP_WB_READ_BLEFILT_SUBFILT_1_PHY_MASK() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ff))

#define GP_WB_WRITE_BLEFILT_SUBFILT_1_PHY_MASK(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xc27ff), (val)); \
        } while (0)

/***************************
 * layout: rt_error
 ***************************/

/* The error or unexpected condition interface is an unidirectional interface from the GPMicro to NRT Software. It is used to signal error or unexpected conditions in the RT software. The GPMicro asserts the IPC_UNMASKED_GPM2X_UNEXPECTED_COND_INTERUPT when such a situation occurs. This is an one hit interface. As long as the IPC_UNMASKED_GPM2X_UNEXPECTED_COND_INTERUPT is asserted, the RT processor will not generate new messages. The NRT software is responsible for clearing the interrupt. */
#define GP_WB_READ_RT_ERROR_TYPE() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xf8008))

#define GP_WB_WRITE_RT_ERROR_TYPE(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xf8008), (val)); \
        } while (0)


/* Contains additional info. (which is dependent on the type of condition) */
#define GP_WB_READ_RT_ERROR_INFO() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xf8009))

#define GP_WB_WRITE_RT_ERROR_INFO(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xf8009), (val)); \
        } while (0)

/***************************
 * layout: rt_stat
 ***************************/

/* The STATUS interface is a general information output channel from RT processor. It is used to send out internal state/debug information. When there is a info message the IPC_UNMASKED_GPM2X_COMM_INTERRUPT is asserted. This is an one hit interface. As long as the IPC_UNMASKED_GPM2X_STAT_INTERRUPT is asserted, the RT processor will not generate new messages. The NRT software is responsible for clearing the interrupt. */
#define GP_WB_READ_RT_STAT_TYPE() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xf800c))

#define GP_WB_WRITE_RT_STAT_TYPE(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xf800c), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RT_STAT_INFO() \
        GP_WB_READ_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xf800e))

#define GP_WB_WRITE_RT_STAT_INFO(val) \
      GP_WB_WRITE_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xf800e), (val))

/* Which trigger type was executed too late. */
#define GP_WB_READ_RT_STAT_ES_TRIGGER_TOO_LATE_TRIGGER_TYPE() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xf800e))

#define GP_WB_GET_RT_STAT_ES_TRIGGER_TOO_LATE_TRIGGER_TYPE_FROM_INFO(tmp) \
        ((tmp) & 0xFF)

#define GP_WB_WRITE_RT_STAT_ES_TRIGGER_TOO_LATE_TRIGGER_TYPE(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xf800e), (val)); \
        } while (0)

#define GP_WB_SET_RT_STAT_ES_TRIGGER_TOO_LATE_TRIGGER_TYPE_TO_INFO(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0xFFFFFF00; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Which event type was executed too late. */
#define GP_WB_READ_RT_STAT_ES_TRIGGER_TOO_LATE_EVENT_TYPE() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xf800f))

#define GP_WB_GET_RT_STAT_ES_TRIGGER_TOO_LATE_EVENT_TYPE_FROM_INFO(tmp) \
        (((tmp) >> 8) & 0xFF)

#define GP_WB_WRITE_RT_STAT_ES_TRIGGER_TOO_LATE_EVENT_TYPE(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xf800f), (val)); \
        } while (0)

#define GP_WB_SET_RT_STAT_ES_TRIGGER_TOO_LATE_EVENT_TYPE_TO_INFO(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0xFFFF00FF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* Amount of time in microseconds the trigger was too late. Accuracy of this value is not that good.  Because this value is calculated by sampling the symbol counter at ES interrupt entry, and this might be blocked by a higher priority interrupt (which may take up to 200 us). */
#define GP_WB_READ_RT_STAT_ES_TRIGGER_TOO_LATE_T_TOO_LATE() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xf8010))

#define GP_WB_GET_RT_STAT_ES_TRIGGER_TOO_LATE_T_TOO_LATE_FROM_INFO(tmp) \
        (((tmp) >> 16) & 0xFFFF)

#define GP_WB_WRITE_RT_STAT_ES_TRIGGER_TOO_LATE_T_TOO_LATE(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xf8010), (val)); \
        } while (0)

#define GP_WB_SET_RT_STAT_ES_TRIGGER_TOO_LATE_T_TOO_LATE_TO_INFO(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x0000FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/***************************
 * layout: rt_cmd
 ***************************/

/* Command type for the BLE COMMAND interface. Only 1 command can be run at a time. The user must wait for completion before initiating a new command. */
#define GP_WB_READ_RT_CMD_TYPE() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xf80a0))

#define GP_WB_WRITE_RT_CMD_TYPE(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xf80a0), (val)); \
        } while (0)


/* The status of the ran command. If the contents of this register is equal to the rt_cmd_command type number, it indicates success. If otherwise, an error has occurred during the command execution. */
#define GP_WB_READ_RT_CMD_RESULT() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xf80a2))

#define GP_WB_WRITE_RT_CMD_RESULT(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xf80a2), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_RT_CMD_ARGS() \
        GP_WB_READ_U64(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xf80a4))

#define GP_WB_WRITE_RT_CMD_ARGS(val) \
      GP_WB_WRITE_U64(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xf80a4), (val))

/* Command arguments. The content of the arguments is dependent of the command type. */
#define GP_WB_READ_RT_CMD_ARG_0() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xf80a4))

#define GP_WB_GET_RT_CMD_ARG_0_FROM_ARGS(tmp) \
        ((tmp) & 0xFFFF)

#define GP_WB_WRITE_RT_CMD_ARG_0(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xf80a4), (val)); \
        } while (0)

#define GP_WB_SET_RT_CMD_ARG_0_TO_ARGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFFFFFFFF0000; \
          (tmp) |= ((UInt64)(val)); \
        } while (0)

/* Number of the ES HW event to be used for this BLE event */
#define GP_WB_READ_RT_CMD_START_EVENT_NR() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xf80a4))

#define GP_WB_GET_RT_CMD_START_EVENT_NR_FROM_ARGS(tmp) \
        ((tmp) & 0xFF)

#define GP_WB_WRITE_RT_CMD_START_EVENT_NR(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xf80a4), (val)); \
        } while (0)

#define GP_WB_SET_RT_CMD_START_EVENT_NR_TO_ARGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFFFFFFFFFF00; \
          (tmp) |= ((UInt64)(val)); \
        } while (0)

/* Type of the BLE event. Same format as EVENT_TYPE */
#define GP_WB_READ_RT_CMD_START_EVENT_TYPE() \
        GP_WB_READ_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xf80a5))

#define GP_WB_GET_RT_CMD_START_EVENT_TYPE_FROM_ARGS(tmp) \
        (((tmp) >> 8) & 0xFF)

#define GP_WB_WRITE_RT_CMD_START_EVENT_TYPE(val) do { \
          GP_WB_WRITE_U8(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xf80a5), (val)); \
        } while (0)

#define GP_WB_SET_RT_CMD_START_EVENT_TYPE_TO_ARGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFFFFFFFF00FF; \
          (tmp) |= (((UInt64)(val)) << 8); \
        } while (0)

/* Pointer to the info structure for that BLE event. Note Value of this pointer must be in the GPMicro address space. Use TO_GPM_ADDR macro to convert. */
#define GP_WB_READ_RT_CMD_START_EVENT_INFO_PTR() \
        GP_WB_READ_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xf80a6))

#define GP_WB_GET_RT_CMD_START_EVENT_INFO_PTR_FROM_ARGS(tmp) \
        (((tmp) >> 16) & 0xFFFF)

#define GP_WB_WRITE_RT_CMD_START_EVENT_INFO_PTR(val) do { \
          GP_WB_WRITE_U16(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xf80a6), (val)); \
        } while (0)

#define GP_WB_SET_RT_CMD_START_EVENT_INFO_PTR_TO_ARGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFFFF0000FFFF; \
          (tmp) |= (((UInt64)(val)) << 16); \
        } while (0)

/* First execution time to be scheduled for the BLE event. in microseconds */
#define GP_WB_READ_RT_CMD_START_EVENT_SCHEDULE_TIME() \
        GP_WB_READ_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xf80a8))

#define GP_WB_GET_RT_CMD_START_EVENT_SCHEDULE_TIME_FROM_ARGS(tmp) \
        (((tmp) >> 32) & 0xFFFFFFFF)

#define GP_WB_WRITE_RT_CMD_START_EVENT_SCHEDULE_TIME(val) do { \
          GP_WB_WRITE_U32(GP_MM_RAM_ADDR_FROM_COMPRESSED(0xf80a8), (val)); \
        } while (0)

#define GP_WB_SET_RT_CMD_START_EVENT_SCHEDULE_TIME_TO_ARGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0x00000000FFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 32); \
        } while (0)

/***************************
 * layout: event
 ***************************/

/* Execution time (1us units) */
#define GP_WB_READ_EVENT_EXECUTION_TIME(offset) \
        GP_WB_READ_U32((offset) + 0x000)

#define GP_WB_WRITE_EVENT_EXECUTION_TIME(offset, val) do { \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_WRITE_U32((offset) + 0x000, (val)); \
        } while (0)


/* Recurrence period (1us units) */
#define GP_WB_READ_EVENT_RECURRENCE_PERIOD(offset) \
        GP_WB_READ_U32((offset) + 0x004)

#define GP_WB_WRITE_EVENT_RECURRENCE_PERIOD(offset, val) do { \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_WRITE_U32((offset) + 0x004, (val)); \
        } while (0)


/* Recurrence Amount, event is executed (recurrence_amount+1) times */
#define GP_WB_READ_EVENT_RECURRENCE_AMOUNT(offset) \
        GP_WB_READ_U16((offset) + 0x008)

#define GP_WB_WRITE_EVENT_RECURRENCE_AMOUNT(offset, val) do { \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_WRITE_U16((offset) + 0x008, (val)); \
        } while (0)


/* Customer data, free to be used in sw */
#define GP_WB_READ_EVENT_CUSTOM_DATA(offset) \
        GP_WB_READ_U16((offset) + 0x00a)

#define GP_WB_WRITE_EVENT_CUSTOM_DATA(offset, val) do { \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_WRITE_U16((offset) + 0x00a, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_EVENT_OPTIONS_FIELD(offset) \
        GP_WB_READ_U16((offset) + 0x00c)

#define GP_WB_WRITE_EVENT_OPTIONS_FIELD(offset, val) \
      GP_WB_WRITE_U16((offset) + 0x00c, (val))

/* Event execution is delayed by the amount of time specified by the Guard Time Selector */
#define GP_WB_READ_EVENT_ADD_GUARD_TIME(offset) \
        GP_WB_READ_U1((offset) + 0x00c, 0)

#define GP_WB_GET_EVENT_ADD_GUARD_TIME_FROM_OPTIONS_FIELD(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_EVENT_ADD_GUARD_TIME(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00c, 0, (val)); \
        } while (0)

#define GP_WB_SET_EVENT_ADD_GUARD_TIME_TO_OPTIONS_FIELD(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F1E; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Event execution is advanced by the amount of time specified by the Guard Time Selector */
#define GP_WB_READ_EVENT_SUBTRACT_GUARD_TIME(offset) \
        GP_WB_READ_U1((offset) + 0x00c, 1)

#define GP_WB_GET_EVENT_SUBTRACT_GUARD_TIME_FROM_OPTIONS_FIELD(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_EVENT_SUBTRACT_GUARD_TIME(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00c, 1, (val)); \
        } while (0)

#define GP_WB_SET_EVENT_SUBTRACT_GUARD_TIME_TO_OPTIONS_FIELD(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F1D; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

/* Event will always be executed, even when too late */
#define GP_WB_READ_EVENT_EXECUTE_IF_TOO_LATE(offset) \
        GP_WB_READ_U1((offset) + 0x00c, 2)

#define GP_WB_GET_EVENT_EXECUTE_IF_TOO_LATE_FROM_OPTIONS_FIELD(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_EVENT_EXECUTE_IF_TOO_LATE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00c, 2, (val)); \
        } while (0)

#define GP_WB_SET_EVENT_EXECUTE_IF_TOO_LATE_TO_OPTIONS_FIELD(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F1B; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* Prevents going to sleep as long as at least one event is active with prohibit_standby enabled */
#define GP_WB_READ_EVENT_PROHIBIT_STANDBY(offset) \
        GP_WB_READ_U1((offset) + 0x00c, 3)

#define GP_WB_GET_EVENT_PROHIBIT_STANDBY_FROM_OPTIONS_FIELD(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_EVENT_PROHIBIT_STANDBY(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00c, 3, (val)); \
        } while (0)

#define GP_WB_SET_EVENT_PROHIBIT_STANDBY_TO_OPTIONS_FIELD(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F17; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

/* Event execution is delayed by the amount of time specified by Dither seed and Dither backoff exponent mask (in 320us units) */
#define GP_WB_READ_EVENT_ADD_DITHER_BACKOFF(offset) \
        GP_WB_READ_U1((offset) + 0x00c, 4)

#define GP_WB_GET_EVENT_ADD_DITHER_BACKOFF_FROM_OPTIONS_FIELD(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_EVENT_ADD_DITHER_BACKOFF(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00c, 4, (val)); \
        } while (0)

#define GP_WB_SET_EVENT_ADD_DITHER_BACKOFF_TO_OPTIONS_FIELD(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3F0F; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

#define GP_WB_READ_EVENT_INTERRUPT_ON_FIRST_ON_TIME(offset) \
        GP_WB_READ_U1((offset) + 0x00d, 0)

#define GP_WB_GET_EVENT_INTERRUPT_ON_FIRST_ON_TIME_FROM_OPTIONS_FIELD(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_EVENT_INTERRUPT_ON_FIRST_ON_TIME(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00d, 0, (val)); \
        } while (0)

#define GP_WB_SET_EVENT_INTERRUPT_ON_FIRST_ON_TIME_TO_OPTIONS_FIELD(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E1F; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

#define GP_WB_READ_EVENT_INTERRUPT_ON_OTHERS_ON_TIME(offset) \
        GP_WB_READ_U1((offset) + 0x00d, 1)

#define GP_WB_GET_EVENT_INTERRUPT_ON_OTHERS_ON_TIME_FROM_OPTIONS_FIELD(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_EVENT_INTERRUPT_ON_OTHERS_ON_TIME(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00d, 1, (val)); \
        } while (0)

#define GP_WB_SET_EVENT_INTERRUPT_ON_OTHERS_ON_TIME_TO_OPTIONS_FIELD(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3D1F; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)

#define GP_WB_READ_EVENT_INTERRUPT_ON_LAST_ON_TIME(offset) \
        GP_WB_READ_U1((offset) + 0x00d, 2)

#define GP_WB_GET_EVENT_INTERRUPT_ON_LAST_ON_TIME_FROM_OPTIONS_FIELD(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_EVENT_INTERRUPT_ON_LAST_ON_TIME(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00d, 2, (val)); \
        } while (0)

#define GP_WB_SET_EVENT_INTERRUPT_ON_LAST_ON_TIME_TO_OPTIONS_FIELD(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3B1F; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)

#define GP_WB_READ_EVENT_INTERRUPT_ON_FIRST_TOO_LATE(offset) \
        GP_WB_READ_U1((offset) + 0x00d, 3)

#define GP_WB_GET_EVENT_INTERRUPT_ON_FIRST_TOO_LATE_FROM_OPTIONS_FIELD(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_EVENT_INTERRUPT_ON_FIRST_TOO_LATE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00d, 3, (val)); \
        } while (0)

#define GP_WB_SET_EVENT_INTERRUPT_ON_FIRST_TOO_LATE_TO_OPTIONS_FIELD(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x371F; \
          (tmp) |= (((UInt16)(val)) << 11); \
        } while (0)

#define GP_WB_READ_EVENT_INTERRUPT_ON_OTHERS_TOO_LATE(offset) \
        GP_WB_READ_U1((offset) + 0x00d, 4)

#define GP_WB_GET_EVENT_INTERRUPT_ON_OTHERS_TOO_LATE_FROM_OPTIONS_FIELD(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_EVENT_INTERRUPT_ON_OTHERS_TOO_LATE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00d, 4, (val)); \
        } while (0)

#define GP_WB_SET_EVENT_INTERRUPT_ON_OTHERS_TOO_LATE_TO_OPTIONS_FIELD(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F1F; \
          (tmp) |= (((UInt16)(val)) << 12); \
        } while (0)

#define GP_WB_READ_EVENT_INTERRUPT_ON_LAST_TOO_LATE(offset) \
        GP_WB_READ_U1((offset) + 0x00d, 5)

#define GP_WB_GET_EVENT_INTERRUPT_ON_LAST_TOO_LATE_FROM_OPTIONS_FIELD(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_EVENT_INTERRUPT_ON_LAST_TOO_LATE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00d, 5, (val)); \
        } while (0)

#define GP_WB_SET_EVENT_INTERRUPT_ON_LAST_TOO_LATE_TO_OPTIONS_FIELD(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F1F; \
          (tmp) |= (((UInt16)(val)) << 13); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_EVENT_STATE_RESULT_FIELD(offset) \
        GP_WB_READ_U8((offset) + 0x00e)

#define GP_WB_WRITE_EVENT_STATE_RESULT_FIELD(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x00e, (val))

/* State field */
#define GP_WB_READ_EVENT_STATE_FIELD(offset) \
        (GP_WB_READ_U8((offset) + 0x00e) & 0x07)

#define GP_WB_GET_EVENT_STATE_FIELD_FROM_STATE_RESULT_FIELD(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_EVENT_STATE_FIELD(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_MWRITE_U8((offset) + 0x00e, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_EVENT_STATE_FIELD_TO_STATE_RESULT_FIELD(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x30; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Result Field */
#define GP_WB_READ_EVENT_RESULT_FIELD(offset) \
        ((GP_WB_READ_U8((offset) + 0x00e) >> 4) & 0x03)

#define GP_WB_GET_EVENT_RESULT_FIELD_FROM_STATE_RESULT_FIELD(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_EVENT_RESULT_FIELD(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_MWRITE_U8((offset) + 0x00e, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_EVENT_RESULT_FIELD_TO_STATE_RESULT_FIELD(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* Event Type field */
#define GP_WB_READ_EVENT_TYPE_FIELD(offset) \
        GP_WB_READ_U8((offset) + 0x00f)

#define GP_WB_WRITE_EVENT_TYPE_FIELD(offset, val) do { \
          GP_WB_CHECK_OFFSET_EVENT(offset); \
          GP_WB_WRITE_U8((offset) + 0x00f, (val)); \
        } while (0)

/***************************
 * layout: dma
 ***************************/

/* Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode) */
#define GP_WB_READ_DMA_SRC_ADDR(offset) \
        GP_WB_READ_U24((offset) + 0x000)

#define GP_WB_WRITE_DMA_SRC_ADDR(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFFFF); \
          GP_WB_CHECK_OFFSET_DMA(offset); \
          GP_WB_WRITE_U24((offset) + 0x000, (val)); \
        } while (0)


/* Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode) */
#define GP_WB_READ_DMA_DEST_ADDR(offset) \
        GP_WB_READ_U24((offset) + 0x004)

#define GP_WB_WRITE_DMA_DEST_ADDR(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFFFF); \
          GP_WB_CHECK_OFFSET_DMA(offset); \
          GP_WB_WRITE_U24((offset) + 0x004, (val)); \
        } while (0)


/* Size of either the source or destination buffer, depending on circular_buffer_select. Expressed as a multiple of the DMA memory access unit. buffer_size=n_units-1 */
#define GP_WB_READ_DMA_BUFFER_SIZE(offset) \
        GP_WB_READ_U16((offset) + 0x008)

#define GP_WB_WRITE_DMA_BUFFER_SIZE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_CHECK_OFFSET_DMA(offset); \
          GP_WB_WRITE_U16((offset) + 0x008, (val)); \
        } while (0)


/* Threshold to be used for generating either an almost empty or almost full interrupt, depending on circular_buffer_select. If SRC_BUFFER, interrupt is triggered when there are only (threshold-1) units left in the src buffer. If DEST_BUFFER, interrupt is triggered when there are (threshold+1) units written in the dest buffer. */
#define GP_WB_READ_DMA_BUFFER_ALMOST_COMPLETE_THRESHOLD(offset) \
        GP_WB_READ_U16((offset) + 0x00a)

#define GP_WB_WRITE_DMA_BUFFER_ALMOST_COMPLETE_THRESHOLD(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_CHECK_OFFSET_DMA(offset); \
          GP_WB_WRITE_U16((offset) + 0x00a, (val)); \
        } while (0)


/* Pointer value to be used when triggering the different pointer sets (allows for atomic pointer set) */
#define GP_WB_READ_DMA_BUFFER_PTR_VALUE(offset) \
        GP_WB_READ_U16((offset) + 0x00c)

#define GP_WB_WRITE_DMA_BUFFER_PTR_VALUE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_CHECK_OFFSET_DMA(offset); \
          GP_WB_WRITE_U16((offset) + 0x00c, (val)); \
        } while (0)


/* Pointer wrap value to be used when triggering the different pointer sets (allows for atomic pointer set) */
#define GP_WB_READ_DMA_BUFFER_PTR_WRAP_VALUE(offset) \
        GP_WB_READ_U1((offset) + 0x00e, 0)

#define GP_WB_WRITE_DMA_BUFFER_PTR_WRAP_VALUE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_DMA(offset); \
          GP_WB_WRITE_U8((offset) + 0x00e, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_DMA_CONFIG(offset) \
        GP_WB_READ_U16((offset) + 0x010)

#define GP_WB_WRITE_DMA_CONFIG(offset, val) \
      GP_WB_WRITE_U16((offset) + 0x010, (val))

/* Sets the size of the memory access unit. DMA supports 8/16/32-bit memory access. byte = 8 bits, half_word = 16 bits, word = 32 bits */
#define GP_WB_READ_DMA_WORD_MODE(offset) \
        (GP_WB_READ_U8((offset) + 0x010) & 0x03)

#define GP_WB_GET_DMA_WORD_MODE_FROM_CONFIG(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_DMA_WORD_MODE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_CHECK_OFFSET_DMA(offset); \
          GP_WB_MWRITE_U8((offset) + 0x010, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_DMA_WORD_MODE_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x1FFC; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Selects the slave interface that will be the source for triggering the dma copy action */
#define GP_WB_READ_DMA_CPY_TRIGGER_SRC_SELECT(offset) \
        ((GP_WB_READ_U8((offset) + 0x010) >> 2) & 0x1F)

#define GP_WB_GET_DMA_CPY_TRIGGER_SRC_SELECT_FROM_CONFIG(tmp) \
        (((tmp) >> 2) & 0x1F)

#define GP_WB_WRITE_DMA_CPY_TRIGGER_SRC_SELECT(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_CHECK_OFFSET_DMA(offset); \
          GP_WB_MWRITE_U8((offset) + 0x010, 0x7C, (val) << 2); \
        } while (0)

#define GP_WB_SET_DMA_CPY_TRIGGER_SRC_SELECT_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x1F83; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

/* regmap cpy trigger overrule. The dma copy will be triggered as long as this bit is set to 1 */
#define GP_WB_READ_DMA_CPY_TRIGGER_BY_REGMAP(offset) \
        GP_WB_READ_U1((offset) + 0x010, 7)

#define GP_WB_GET_DMA_CPY_TRIGGER_BY_REGMAP_FROM_CONFIG(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_DMA_CPY_TRIGGER_BY_REGMAP(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_DMA(offset); \
          GP_WB_MWRITE_U1((offset) + 0x010, 7, (val)); \
        } while (0)

#define GP_WB_SET_DMA_CPY_TRIGGER_BY_REGMAP_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* If set to error_mode then the buffer_complete interrupt indicates overflow/underrun conditions. Otherwise (status_mode) full/empty conditions are reported. */
#define GP_WB_READ_DMA_BUFFER_COMPLETE_INTERRUPT_MODE(offset) \
        GP_WB_READ_U1((offset) + 0x011, 0)

#define GP_WB_GET_DMA_BUFFER_COMPLETE_INTERRUPT_MODE_FROM_CONFIG(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_DMA_BUFFER_COMPLETE_INTERRUPT_MODE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_DMA(offset); \
          GP_WB_MWRITE_U1((offset) + 0x011, 0, (val)); \
        } while (0)

#define GP_WB_SET_DMA_BUFFER_COMPLETE_INTERRUPT_MODE_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1EFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* Minimum number of idle cycles between accesses to the same dma channel. Should be increased for slowly responding cpy_triggers. */
#define GP_WB_READ_DMA_ACCESS_LATENCY(offset) \
        ((GP_WB_READ_U8((offset) + 0x011) >> 1) & 0x0F)

#define GP_WB_GET_DMA_ACCESS_LATENCY_FROM_CONFIG(tmp) \
        (((tmp) >> 9) & 0x0F)

#define GP_WB_WRITE_DMA_ACCESS_LATENCY(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_CHECK_OFFSET_DMA(offset); \
          GP_WB_MWRITE_U8((offset) + 0x011, 0x1E, (val) << 1); \
        } while (0)

#define GP_WB_SET_DMA_ACCESS_LATENCY_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x01FF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)


/* When enabled, the buffer's completeness is ignored when triggering a dma copy action */
#define GP_WB_READ_DMA_CPY_TRIGGER_IGNORE_BUFFER_COMPLETE(offset) \
        GP_WB_READ_U1((offset) + 0x012, 0)

#define GP_WB_WRITE_DMA_CPY_TRIGGER_IGNORE_BUFFER_COMPLETE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_DMA(offset); \
          GP_WB_WRITE_U8((offset) + 0x012, (val)); \
        } while (0)


/* Selects between source and destination as circular buffer locatio. */
#define GP_WB_READ_DMA_CIRCULAR_BUFFER_SELECT(offset) \
        GP_WB_READ_U1((offset) + 0x013, 0)

#define GP_WB_WRITE_DMA_CIRCULAR_BUFFER_SELECT(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_DMA(offset); \
          GP_WB_WRITE_U8((offset) + 0x013, (val)); \
        } while (0)


#define GP_WB_WRITE_DMA_BUFFER_PTR_CONTROL(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x014, (val))

/* Sets the internal circular buffer write pointer by buffer_ptr_value / wrap value.  Provides atomic way for updating buffer write pointer */
#define GP_WB_DMA_SET_WRITE_PTR(offset) \
        GP_WB_WRITE_U8((offset) + 0x014, 0x01)

#define GP_WB_SET_DMA_SET_WRITE_PTR_TO_BUFFER_PTR_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Sets the internal circular buffer read pointer by buffer_ptr_value / wrap value.  Provides atomic way to initialize the buffer read pointer */
#define GP_WB_DMA_SET_READ_PTR(offset) \
        GP_WB_WRITE_U8((offset) + 0x014, 0x02)

#define GP_WB_SET_DMA_SET_READ_PTR_TO_BUFFER_PTR_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Resets all buffer pointers to 0 */
#define GP_WB_DMA_RESET_POINTERS(offset) \
        GP_WB_WRITE_U8((offset) + 0x014, 0x04)

#define GP_WB_SET_DMA_RESET_POINTERS_TO_BUFFER_PTR_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* clears the buffer_complete interrupt */
#define GP_WB_DMA_CLR_BUFFER_COMPLETE_INTERRUPT(offset) \
        GP_WB_WRITE_U8((offset) + 0x015, 0x01)


/* Actual read offset ptr that is being used internally to access the circular buffer. Allows atomic read out (data is latched when internal_ptr_l is read). */
#define GP_WB_READ_DMA_INTERNAL_PTR(offset) \
        (GP_WB_READ_SER_U16((offset) + 0x016) & 0x0FFF)

/* When circular_buffer_select = src_buffer, toggle signal that is toggled each time the dma internal read_ptr wraps around (for underrun detection). When circular_buffer_select = dest_buffer, it is toggled each time the dma internal write_ptr wraps around (for overflow detection). Allows atomic read out (data is latched when internal_ptr_l is read). */
#define GP_WB_READ_DMA_INTERNAL_PTR_WRAP(offset) \
        GP_WB_READ_SER_U1((offset) + 0x017, 4)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_DMA_STATUS(offset) \
        GP_WB_READ_U8((offset) + 0x018)

/* Refers to the selected circular buffer. In buffer_complete_interrupt_mode = error_mode overflow (for circular_buffer_select = dest_buffer) or underrun (for circular_buffer_select = src_buffer) errors are indicated. In buffer_complete_interrupt_mode = status_mode it indicates full (for circular_buffer_select = dest_buffer) or empty (for circular_buffer_select = src_buffer) status. */
#define GP_WB_READ_DMA_UNMASKED_BUFFER_COMPLETE_INTERRUPT(offset) \
        GP_WB_READ_U1((offset) + 0x018, 0)

#define GP_WB_GET_DMA_UNMASKED_BUFFER_COMPLETE_INTERRUPT_FROM_STATUS(tmp) \
        ((tmp) & 0x01)

/* Indicates that the almost complete threshold has been reached, actual level depends on the circular_buffer_select. See threshold setting for more info */
#define GP_WB_READ_DMA_UNMASKED_BUFFER_ALMOST_COMPLETE_INTERRUPT(offset) \
        GP_WB_READ_U1((offset) + 0x018, 1)

#define GP_WB_GET_DMA_UNMASKED_BUFFER_ALMOST_COMPLETE_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/***************************
 * layout: led
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_LED_CONTROL(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_LED_CONTROL(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x000, (val))

/* Set to 1 to enable the led */
#define GP_WB_READ_LED_ENABLE(offset) \
        GP_WB_READ_U1((offset) + 0x000, 0)

#define GP_WB_GET_LED_ENABLE_FROM_CONTROL(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_LED_ENABLE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_LED(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 0, (val)); \
        } while (0)

#define GP_WB_SET_LED_ENABLE_TO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When set to 1, fading will be used when enabling or disabling the led */
#define GP_WB_READ_LED_FADE(offset) \
        GP_WB_READ_U1((offset) + 0x000, 1)

#define GP_WB_GET_LED_FADE_FROM_CONTROL(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_LED_FADE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_LED(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 1, (val)); \
        } while (0)

#define GP_WB_SET_LED_FADE_TO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* Sets the target PWM threshold (255 =  max duty cycle) */
#define GP_WB_READ_LED_THRESHOLD(offset) \
        GP_WB_READ_U8((offset) + 0x001)

#define GP_WB_WRITE_LED_THRESHOLD(offset, val) do { \
          GP_WB_CHECK_OFFSET_LED(offset); \
          GP_WB_WRITE_U8((offset) + 0x001, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_LED_IO_CONTROL(offset) \
        GP_WB_READ_U8((offset) + 0x002)

#define GP_WB_WRITE_LED_IO_CONTROL(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x002, (val))

/* Sets the drive type for the output */
#define GP_WB_READ_LED_OUTPUT_DRIVE(offset) \
        GP_WB_READ_U1((offset) + 0x002, 0)

#define GP_WB_GET_LED_OUTPUT_DRIVE_FROM_IO_CONTROL(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_LED_OUTPUT_DRIVE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_LED(offset); \
          GP_WB_MWRITE_U1((offset) + 0x002, 0, (val)); \
        } while (0)

#define GP_WB_SET_LED_OUTPUT_DRIVE_TO_IO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Inverts the output */
#define GP_WB_READ_LED_OUTPUT_INVERT(offset) \
        GP_WB_READ_U1((offset) + 0x002, 1)

#define GP_WB_GET_LED_OUTPUT_INVERT_FROM_IO_CONTROL(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_LED_OUTPUT_INVERT(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_LED(offset); \
          GP_WB_MWRITE_U1((offset) + 0x002, 1, (val)); \
        } while (0)

#define GP_WB_SET_LED_OUTPUT_INVERT_TO_IO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* When set, the chip may go to sleep, even if the led is driven continuously (dutycycling prevents chip from going to sleep) */
#define GP_WB_READ_LED_ALLOW_GOTOSLEEP_WHEN_ON(offset) \
        GP_WB_READ_U1((offset) + 0x002, 2)

#define GP_WB_GET_LED_ALLOW_GOTOSLEEP_WHEN_ON_FROM_IO_CONTROL(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_LED_ALLOW_GOTOSLEEP_WHEN_ON(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_LED(offset); \
          GP_WB_MWRITE_U1((offset) + 0x002, 2, (val)); \
        } while (0)

#define GP_WB_SET_LED_ALLOW_GOTOSLEEP_WHEN_ON_TO_IO_CONTROL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/***************************
 * layout: pwm
 ***************************/

/* Enables the up/down mode of pwm */
#define GP_WB_READ_PWM_UP_DOWN_ENABLE(offset) \
        GP_WB_READ_U1((offset) + 0x000, 0)

#define GP_WB_WRITE_PWM_UP_DOWN_ENABLE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PWM(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 0, (val)); \
        } while (0)

/* Sets the drive type for the output of pwm */
#define GP_WB_READ_PWM_OUTPUT_DRIVE(offset) \
        GP_WB_READ_U1((offset) + 0x000, 1)

#define GP_WB_WRITE_PWM_OUTPUT_DRIVE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PWM(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 1, (val)); \
        } while (0)

/* Inverts the output of pwm */
#define GP_WB_READ_PWM_OUTPUT_INVERT(offset) \
        GP_WB_READ_U1((offset) + 0x000, 2)

#define GP_WB_WRITE_PWM_OUTPUT_INVERT(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PWM(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 2, (val)); \
        } while (0)


/* When set to 1, a wrap of the carrier counter will trigger an update of the threshold of pwm. */
#define GP_WB_READ_PWM_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP(offset) \
        GP_WB_READ_U1((offset) + 0x001, 0)

#define GP_WB_WRITE_PWM_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PWM(offset); \
          GP_WB_WRITE_U8((offset) + 0x001, (val)); \
        } while (0)


/* The current value of the threshold of pwm */
#define GP_WB_READ_PWM_THRESHOLD(offset) \
        GP_WB_READ_U16((offset) + 0x002)


/* The unmasked interrupt status of the threshold match interrupt of pwm */
#define GP_WB_READ_PWM_UNMASKED_THRESHOLD_MATCH_INTERRUPT(offset) \
        GP_WB_READ_U1((offset) + 0x004, 0)


/* Updates the threshold with the next threshold of pwm */
#define GP_WB_PWM_THRESHOLD_UPDATE(offset) \
        GP_WB_WRITE_U8((offset) + 0x005, 0x01)


/* Clears the threshold match interrupt of pwm, NOTE: also clears the timestamp overrun interrupt */
#define GP_WB_PWM_CLR_THRESHOLD_MATCH_INTERRUPT(offset) \
        GP_WB_WRITE_U8((offset) + 0x006, 0x01)

/***************************
 * layout: timestamp
 ***************************/

/* Enables the timestamp functinality. */
#define GP_WB_READ_TIMESTAMP_ENABLE(offset) \
        GP_WB_READ_U1((offset) + 0x000, 0)

#define GP_WB_WRITE_TIMESTAMP_ENABLE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_TIMESTAMP(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 0, (val)); \
        } while (0)

/* When set to 1, the timestamp fifos works in 16-bit word mode. In this mode, reading the timestamp_main property, pops an entry from the FIFO. When set to 0, the timestamp fifo works in byte mode. In this mode, writing the timestamp property pops an entry from the fifo. */
#define GP_WB_READ_TIMESTAMP_FIFO_SIZE(offset) \
        ((GP_WB_READ_U8((offset) + 0x000) >> 1) & 0x03)

#define GP_WB_WRITE_TIMESTAMP_FIFO_SIZE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_CHECK_OFFSET_TIMESTAMP(offset); \
          GP_WB_MWRITE_U8((offset) + 0x000, 0x06, (val) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TIMESTAMP_STABLE_POWERS(offset) \
        GP_WB_READ_U8((offset) + 0x001)

#define GP_WB_WRITE_TIMESTAMP_STABLE_POWERS(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x001, (val))

/* The amount of timestamp input signal processing clock cycles that the input signal has to be low before the processed signal becomes low is (2**timestamp_stable_low_power)-1 */
#define GP_WB_READ_TIMESTAMP_STABLE_LOW_POWER(offset) \
        (GP_WB_READ_U8((offset) + 0x001) & 0x07)

#define GP_WB_GET_TIMESTAMP_STABLE_LOW_POWER_FROM_STABLE_POWERS(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_TIMESTAMP_STABLE_LOW_POWER(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_CHECK_OFFSET_TIMESTAMP(offset); \
          GP_WB_MWRITE_U8((offset) + 0x001, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_TIMESTAMP_STABLE_LOW_POWER_TO_STABLE_POWERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x70; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* The amount of timestamp input signal processing clock cycles that the input signal has to be high before the processed signal becomes high is (2**timestamp_stable_high_power)-1 */
#define GP_WB_READ_TIMESTAMP_STABLE_HIGH_POWER(offset) \
        ((GP_WB_READ_U8((offset) + 0x001) >> 4) & 0x07)

#define GP_WB_GET_TIMESTAMP_STABLE_HIGH_POWER_FROM_STABLE_POWERS(tmp) \
        (((tmp) >> 4) & 0x07)

#define GP_WB_WRITE_TIMESTAMP_STABLE_HIGH_POWER(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_CHECK_OFFSET_TIMESTAMP(offset); \
          GP_WB_MWRITE_U8((offset) + 0x001, 0x70, (val) << 4); \
        } while (0)

#define GP_WB_SET_TIMESTAMP_STABLE_HIGH_POWER_TO_STABLE_POWERS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TIMESTAMP_STATUS(offset) \
        GP_WB_READ_U8((offset) + 0x002)

/* The current value of the timestamp input */
#define GP_WB_READ_TIMESTAMP_INPUT(offset) \
        GP_WB_READ_U1((offset) + 0x002, 0)

#define GP_WB_GET_TIMESTAMP_INPUT_FROM_STATUS(tmp) \
        ((tmp) & 0x01)

/* The unmasked interrupt status of the timestamp not empty interrupt */
#define GP_WB_READ_TIMESTAMP_UNMASKED_NOT_EMPTY_INTERRUPT(offset) \
        GP_WB_READ_U1((offset) + 0x002, 1)

#define GP_WB_GET_TIMESTAMP_UNMASKED_NOT_EMPTY_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* The unmasked interrupt status of the timestamp overrun interrupt */
#define GP_WB_READ_TIMESTAMP_UNMASKED_OVERRUN_INTERRUPT(offset) \
        GP_WB_READ_U1((offset) + 0x002, 2)

#define GP_WB_GET_TIMESTAMP_UNMASKED_OVERRUN_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)


/* Updates the timestamp with the current value main counter */
#define GP_WB_TIMESTAMP_UPDATE(offset) \
        GP_WB_WRITE_U8((offset) + 0x003, 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TIMESTAMP_VALUES(offset) \
        GP_WB_READ_SER_U24((offset) + 0x004)

/* The LSB of the timestamp of the main counter */
#define GP_WB_READ_TIMESTAMP_MAIN_0(offset) \
        GP_WB_READ_SER_U8((offset) + 0x004)

#define GP_WB_GET_TIMESTAMP_MAIN_0_FROM_VALUES(tmp) \
        ((tmp) & 0xFF)

/* The (16-bit) timestamp of the main counter */
#define GP_WB_READ_TIMESTAMP_MAIN(offset) \
        GP_WB_READ_SER_U16((offset) + 0x004)

#define GP_WB_GET_TIMESTAMP_MAIN_FROM_VALUES(tmp) \
        ((tmp) & 0xFFFF)

/* The full (23-bit) timestamp value (main+carrier) */
#define GP_WB_READ_TIMESTAMP_FULL_COUNTER(offset) \
        (GP_WB_READ_SER_U24((offset) + 0x004) & 0x7FFFFF)

#define GP_WB_GET_TIMESTAMP_FULL_COUNTER_FROM_VALUES(tmp) \
        ((tmp) & 0x7FFFFF)

/* The timestamp of the carrier counter */
#define GP_WB_READ_TIMESTAMP_CARRIER(offset) \
        (GP_WB_READ_SER_U8((offset) + 0x006) & 0x7F)

#define GP_WB_GET_TIMESTAMP_CARRIER_FROM_VALUES(tmp) \
        (((tmp) >> 16) & 0x7F)

/* The stable value of the input at the moment the timestamp is taken */
#define GP_WB_READ_TIMESTAMP_INPUT_ON_PREVIOUS_UPDATE(offset) \
        GP_WB_READ_SER_U1((offset) + 0x006, 7)

#define GP_WB_GET_TIMESTAMP_INPUT_ON_PREVIOUS_UPDATE_FROM_VALUES(tmp) \
        (((tmp) >> 23) & 0x01)


/* Clears the timestamp overrun interrupt, NOTE: also clears the threshold match interrupt of pwm */
#define GP_WB_TIMESTAMP_CLR_OVERRUN_INTERRUPT(offset) \
        GP_WB_WRITE_U8((offset) + 0x007, 0x01)

/***************************
 * layout: pbm_format_z
 ***************************/

#define GP_WB_READ_PBM_FORMAT_Z_RETURN_CODE(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_PBM_FORMAT_Z_RETURN_CODE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_Z(offset); \
          GP_WB_WRITE_U8((offset) + 0x000, (val)); \
        } while (0)

/***************************
 * layout: pbm_format_r
 ***************************/

/* Status of the PBM */
#define GP_WB_READ_PBM_FORMAT_R_RETURN_CODE(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_PBM_FORMAT_R_RETURN_CODE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x000, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_FORMAT_R_RX_STATUS(offset) \
        GP_WB_READ_U8((offset) + 0x001)

#define GP_WB_WRITE_PBM_FORMAT_R_RX_STATUS(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x001, (val))

/* Time slot on which the frame was received. Corresponds to the channel idx when all slots use different channel */
#define GP_WB_READ_PBM_FORMAT_R_SLOT_IDX(offset) \
        (GP_WB_READ_U8((offset) + 0x001) & 0x07)

#define GP_WB_GET_PBM_FORMAT_R_SLOT_IDX_FROM_RX_STATUS(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_PBM_FORMAT_R_SLOT_IDX(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_MWRITE_U8((offset) + 0x001, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_R_SLOT_IDX_TO_RX_STATUS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x38; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Indicates on which antenna the frame was received */
#define GP_WB_READ_PBM_FORMAT_R_ANTENNA(offset) \
        GP_WB_READ_U1((offset) + 0x001, 3)

#define GP_WB_GET_PBM_FORMAT_R_ANTENNA_FROM_RX_STATUS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_R_ANTENNA(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 3, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_R_ANTENNA_TO_RX_STATUS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Indicates whether attenuation was enabled during rx of the frame */
#define GP_WB_READ_PBM_FORMAT_R_ATTENUATED(offset) \
        GP_WB_READ_U1((offset) + 0x001, 4)

#define GP_WB_GET_PBM_FORMAT_R_ATTENUATED_FROM_RX_STATUS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_R_ATTENUATED(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 4, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_R_ATTENUATED_TO_RX_STATUS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Indicates if there is no Frame check sequence error as bad CRC */
#define GP_WB_READ_PBM_FORMAT_R_FCS_OK(offset) \
        GP_WB_READ_U1((offset) + 0x001, 5)

#define GP_WB_GET_PBM_FORMAT_R_FCS_OK_FROM_RX_STATUS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_R_FCS_OK(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 5, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_R_FCS_OK_TO_RX_STATUS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* Timestamp information on the received frame in us */
#define GP_WB_READ_PBM_FORMAT_R_TIMESTAMP(offset) \
        GP_WB_READ_U32((offset) + 0x004)

#define GP_WB_WRITE_PBM_FORMAT_R_TIMESTAMP(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_WRITE_U32((offset) + 0x004, (val)); \
        } while (0)


/* Memory address (pointer) to the first byte of the received frame stored in RAM */
#define GP_WB_READ_PBM_FORMAT_R_FRAME_PTR(offset) \
        GP_WB_READ_U8((offset) + 0x008)

#define GP_WB_WRITE_PBM_FORMAT_R_FRAME_PTR(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x008, (val)); \
        } while (0)


/* Length in bytes of the received frame */
#define GP_WB_READ_PBM_FORMAT_R_FRAME_LEN(offset) \
        GP_WB_READ_U8((offset) + 0x00a)

#define GP_WB_WRITE_PBM_FORMAT_R_FRAME_LEN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x00a, (val)); \
        } while (0)


/* Quality of the link during the frame reception */
#define GP_WB_READ_PBM_FORMAT_R_LQI(offset) \
        GP_WB_READ_U8((offset) + 0x00c)

#define GP_WB_WRITE_PBM_FORMAT_R_LQI(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x00c, (val)); \
        } while (0)


/* Signal strength of the received frame */
#define GP_WB_READ_PBM_FORMAT_R_RSSI(offset) \
        GP_WB_READ_U8((offset) + 0x00d)

#define GP_WB_WRITE_PBM_FORMAT_R_RSSI(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x00d, (val)); \
        } while (0)


#define GP_WB_READ_PBM_FORMAT_R_FOFFSET(offset) \
        (GP_WB_S16(GP_WB_READ_U16((offset) + 0x00e), 16))

#define GP_WB_WRITE_PBM_FORMAT_R_FOFFSET(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_WRITE_U16((offset) + 0x00e, (UInt16)((val))); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_FORMAT_R_CHANNEL_INFO(offset) \
        GP_WB_READ_U16((offset) + 0x010)

#define GP_WB_WRITE_PBM_FORMAT_R_CHANNEL_INFO(offset, val) \
      GP_WB_WRITE_U16((offset) + 0x010, (val))

/* Channel number of the received frame */
#define GP_WB_READ_PBM_FORMAT_R_CHANNEL(offset) \
        GP_WB_READ_U8((offset) + 0x010)

#define GP_WB_GET_PBM_FORMAT_R_CHANNEL_FROM_CHANNEL_INFO(tmp) \
        ((tmp) & 0x3F)

#define GP_WB_WRITE_PBM_FORMAT_R_CHANNEL(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x010, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_R_CHANNEL_TO_CHANNEL_INFO(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0x0700; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Channel bank the packet was received on */
#define GP_WB_READ_PBM_FORMAT_R_CHANNEL_IDX(offset) \
        GP_WB_READ_U8((offset) + 0x011)

#define GP_WB_GET_PBM_FORMAT_R_CHANNEL_IDX_FROM_CHANNEL_INFO(tmp) \
        (((tmp) >> 8) & 0x07)

#define GP_WB_WRITE_PBM_FORMAT_R_CHANNEL_IDX(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x011, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_R_CHANNEL_IDX_TO_CHANNEL_INFO(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x003F; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)


/* Indicates what indexes where configured to use the same channel as the channel this packet is received on */
#define GP_WB_READ_PBM_FORMAT_R_MATCHING_CH_IDX_MASK(offset) \
        GP_WB_READ_U8((offset) + 0x012)

#define GP_WB_WRITE_PBM_FORMAT_R_MATCHING_CH_IDX_MASK(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x012, (val)); \
        } while (0)


/* Reason why frame was dropped. Should always be E_NO_DROP, except in sniffing mode where this will indicate if the frame is ok or not */
#define GP_WB_READ_PBM_FORMAT_R_DROP_REASON(offset) \
        GP_WB_READ_U8((offset) + 0x013)

#define GP_WB_WRITE_PBM_FORMAT_R_DROP_REASON(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x013, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_FORMAT_R_ACK_FRAME_CTRL(offset) \
        GP_WB_READ_U16((offset) + 0x014)

#define GP_WB_WRITE_PBM_FORMAT_R_ACK_FRAME_CTRL(offset, val) \
      GP_WB_WRITE_U16((offset) + 0x014, (val))

/* Frame Type of the transmitted ACK frame */
#define GP_WB_READ_PBM_FORMAT_R_ACK_FRAME_TYPE(offset) \
        (GP_WB_READ_U8((offset) + 0x014) & 0x07)

#define GP_WB_GET_PBM_FORMAT_R_ACK_FRAME_TYPE_FROM_ACK_FRAME_CTRL(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_PBM_FORMAT_R_ACK_FRAME_TYPE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_MWRITE_U8((offset) + 0x014, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_R_ACK_FRAME_TYPE_TO_ACK_FRAME_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0xFF78; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Security enabled or not on the transmitted ACK frame */
#define GP_WB_READ_PBM_FORMAT_R_ACK_SEC_ENABLED(offset) \
        GP_WB_READ_U1((offset) + 0x014, 3)

#define GP_WB_GET_PBM_FORMAT_R_ACK_SEC_ENABLED_FROM_ACK_FRAME_CTRL(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_R_ACK_SEC_ENABLED(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_MWRITE_U1((offset) + 0x014, 3, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_R_ACK_SEC_ENABLED_TO_ACK_FRAME_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF77; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

/* Frame Pending but for the transmitted ACK frame */
#define GP_WB_READ_PBM_FORMAT_R_ACK_FP(offset) \
        GP_WB_READ_U1((offset) + 0x014, 4)

#define GP_WB_GET_PBM_FORMAT_R_ACK_FP_FROM_ACK_FRAME_CTRL(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_R_ACK_FP(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_MWRITE_U1((offset) + 0x014, 4, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_R_ACK_FP_TO_ACK_FRAME_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF6F; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* AR for the transmitted ACK frame */
#define GP_WB_READ_PBM_FORMAT_R_ACK_AR(offset) \
        GP_WB_READ_U1((offset) + 0x014, 5)

#define GP_WB_GET_PBM_FORMAT_R_ACK_AR_FROM_ACK_FRAME_CTRL(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_R_ACK_AR(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_MWRITE_U1((offset) + 0x014, 5, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_R_ACK_AR_TO_ACK_FRAME_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF5F; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

/* panid compression for the transmitted ACK frame */
#define GP_WB_READ_PBM_FORMAT_R_ACK_PANID_COMPRESSION(offset) \
        GP_WB_READ_U1((offset) + 0x014, 6)

#define GP_WB_GET_PBM_FORMAT_R_ACK_PANID_COMPRESSION_FROM_ACK_FRAME_CTRL(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_R_ACK_PANID_COMPRESSION(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_MWRITE_U1((offset) + 0x014, 6, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_R_ACK_PANID_COMPRESSION_TO_ACK_FRAME_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF3F; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

/* seq nr suppression for the transmitted ACK frame */
#define GP_WB_READ_PBM_FORMAT_R_ACK_SEQ_NR_SUPPRESSION(offset) \
        GP_WB_READ_U1((offset) + 0x015, 0)

#define GP_WB_GET_PBM_FORMAT_R_ACK_SEQ_NR_SUPPRESSION_FROM_ACK_FRAME_CTRL(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_R_ACK_SEQ_NR_SUPPRESSION(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_MWRITE_U1((offset) + 0x015, 0, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_R_ACK_SEQ_NR_SUPPRESSION_TO_ACK_FRAME_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFE7F; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* Set if ie elements are present in the transmitted ACK frame */
#define GP_WB_READ_PBM_FORMAT_R_ACK_IE_PRESENT(offset) \
        GP_WB_READ_U1((offset) + 0x015, 1)

#define GP_WB_GET_PBM_FORMAT_R_ACK_IE_PRESENT_FROM_ACK_FRAME_CTRL(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_R_ACK_IE_PRESENT(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_MWRITE_U1((offset) + 0x015, 1, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_R_ACK_IE_PRESENT_TO_ACK_FRAME_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFD7F; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)

/* Destination address mode for the transmitted ACK frame */
#define GP_WB_READ_PBM_FORMAT_R_ACK_DEST_ADDR_MODE(offset) \
        ((GP_WB_READ_U8((offset) + 0x015) >> 2) & 0x03)

#define GP_WB_GET_PBM_FORMAT_R_ACK_DEST_ADDR_MODE_FROM_ACK_FRAME_CTRL(tmp) \
        (((tmp) >> 10) & 0x03)

#define GP_WB_WRITE_PBM_FORMAT_R_ACK_DEST_ADDR_MODE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_MWRITE_U8((offset) + 0x015, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_R_ACK_DEST_ADDR_MODE_TO_ACK_FRAME_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0xF37F; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)

/* Frame version for the transmitted ACK frame */
#define GP_WB_READ_PBM_FORMAT_R_ACK_FRAME_VERSION(offset) \
        ((GP_WB_READ_U8((offset) + 0x015) >> 4) & 0x03)

#define GP_WB_GET_PBM_FORMAT_R_ACK_FRAME_VERSION_FROM_ACK_FRAME_CTRL(tmp) \
        (((tmp) >> 12) & 0x03)

#define GP_WB_WRITE_PBM_FORMAT_R_ACK_FRAME_VERSION(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_MWRITE_U8((offset) + 0x015, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_R_ACK_FRAME_VERSION_TO_ACK_FRAME_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0xCF7F; \
          (tmp) |= (((UInt16)(val)) << 12); \
        } while (0)

/* Source address mode for the transmitted ACK frame */
#define GP_WB_READ_PBM_FORMAT_R_ACK_SOURCE_ADDR_MODE(offset) \
        ((GP_WB_READ_U8((offset) + 0x015) >> 6) & 0x03)

#define GP_WB_GET_PBM_FORMAT_R_ACK_SOURCE_ADDR_MODE_FROM_ACK_FRAME_CTRL(tmp) \
        (((tmp) >> 14) & 0x03)

#define GP_WB_WRITE_PBM_FORMAT_R_ACK_SOURCE_ADDR_MODE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_MWRITE_U8((offset) + 0x015, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_R_ACK_SOURCE_ADDR_MODE_TO_ACK_FRAME_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3F7F; \
          (tmp) |= (((UInt16)(val)) << 14); \
        } while (0)


/* keyid from the ack frame that was transmitted */
#define GP_WB_READ_PBM_FORMAT_R_ACK_KEYID(offset) \
        GP_WB_READ_U8((offset) + 0x016)

#define GP_WB_WRITE_PBM_FORMAT_R_ACK_KEYID(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x016, (val)); \
        } while (0)


/* some spare bytes that can be used to put in some meta data. Could be useful for very lowlevel applications (like macfilter) */
#define GP_WB_READ_PBM_FORMAT_R_MISC_DATA(offset) \
        GP_WB_READ_U8((offset) + 0x01b)

#define GP_WB_WRITE_PBM_FORMAT_R_MISC_DATA(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x01b, (val)); \
        } while (0)


/* framecounter of the ack frame that was transmitted */
#define GP_WB_READ_PBM_FORMAT_R_ACK_FRAMECOUNTER(offset) \
        GP_WB_READ_U32((offset) + 0x01c)

#define GP_WB_WRITE_PBM_FORMAT_R_ACK_FRAMECOUNTER(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_R(offset); \
          GP_WB_WRITE_U32((offset) + 0x01c, (val)); \
        } while (0)

/***************************
 * layout: pbm_format_t
 ***************************/

/* Return code with the status of the request */
#define GP_WB_READ_PBM_FORMAT_T_RETURN_CODE(offset) \
        (GP_WB_READ_U8((offset) + 0x000) & 0x07)

#define GP_WB_WRITE_PBM_FORMAT_T_RETURN_CODE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x000, 0x07, (val)); \
        } while (0)

/* Indicates if during the ED scan the carrier senses circuit triggered (meaning that modulated carrier is present) */
#define GP_WB_READ_PBM_FORMAT_T_ED_CS_DETECT(offset) \
        GP_WB_READ_U1((offset) + 0x000, 3)

#define GP_WB_WRITE_PBM_FORMAT_T_ED_CS_DETECT(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 3, (val)); \
        } while (0)

/* Antenna the ack was received on */
#define GP_WB_READ_PBM_FORMAT_T_ACK_ANTENNA(offset) \
        GP_WB_READ_U1((offset) + 0x000, 4)

#define GP_WB_WRITE_PBM_FORMAT_T_ACK_ANTENNA(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 4, (val)); \
        } while (0)

/* Indicates if the ack was received with an attenuated receiver */
#define GP_WB_READ_PBM_FORMAT_T_ACK_ATTENUATED(offset) \
        GP_WB_READ_U1((offset) + 0x000, 5)

#define GP_WB_WRITE_PBM_FORMAT_T_ACK_ATTENUATED(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 5, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_FORMAT_T_TX_STATUS(offset) \
        GP_WB_READ_U8((offset) + 0x001)

#define GP_WB_WRITE_PBM_FORMAT_T_TX_STATUS(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x001, (val))

/* Number of MAC retries performed */
#define GP_WB_READ_PBM_FORMAT_T_TX_RETRY(offset) \
        (GP_WB_READ_U8((offset) + 0x001) & 0x07)

#define GP_WB_GET_PBM_FORMAT_T_TX_RETRY_FROM_TX_STATUS(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_PBM_FORMAT_T_TX_RETRY(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x001, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_TX_RETRY_TO_TX_STATUS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x78; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Informed if the received ACK had the frame pending bit set, only valid when ack_request and an ack is received */
#define GP_WB_READ_PBM_FORMAT_T_TX_FRM_PENDING(offset) \
        GP_WB_READ_U1((offset) + 0x001, 3)

#define GP_WB_GET_PBM_FORMAT_T_TX_FRM_PENDING_FROM_TX_STATUS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_TX_FRM_PENDING(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 3, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_TX_FRM_PENDING_TO_TX_STATUS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x77; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* The number of CCA-s that were done for transmitting the packet - Only valid when csma-cca is enabled on the packet. If csma-cca is disabled, this field needs to be ignored as it will hold the value of the previous csma-cca run */
#define GP_WB_READ_PBM_FORMAT_T_TX_CCA_CNT(offset) \
        ((GP_WB_READ_U8((offset) + 0x001) >> 4) & 0x07)

#define GP_WB_GET_PBM_FORMAT_T_TX_CCA_CNT_FROM_TX_STATUS(tmp) \
        (((tmp) >> 4) & 0x07)

#define GP_WB_WRITE_PBM_FORMAT_T_TX_CCA_CNT(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x001, 0x70, (val) << 4); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_TX_CCA_CNT_TO_TX_STATUS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* Holds the result of an ED scan */
#define GP_WB_READ_PBM_FORMAT_T_ED_RESULT(offset) \
        GP_WB_READ_U8((offset) + 0x002)

#define GP_WB_WRITE_PBM_FORMAT_T_ED_RESULT(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_WRITE_U8((offset) + 0x002, (val)); \
        } while (0)


/* The rssi of the ACK received on this transmit, only valid when ack_request and an ack is received */
#define GP_WB_READ_PBM_FORMAT_T_ACK_RSSI(offset) \
        GP_WB_READ_U8((offset) + 0x003)

#define GP_WB_WRITE_PBM_FORMAT_T_ACK_RSSI(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_WRITE_U8((offset) + 0x003, (val)); \
        } while (0)


#define GP_WB_READ_PBM_FORMAT_T_TIMESTAMP(offset) \
        GP_WB_READ_U32((offset) + 0x004)

#define GP_WB_WRITE_PBM_FORMAT_T_TIMESTAMP(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_WRITE_U32((offset) + 0x004, (val)); \
        } while (0)


/* Memory address (pointer) to the first byte of the frame buffer to be sent stored in RAM */
#define GP_WB_READ_PBM_FORMAT_T_FRAME_PTR(offset) \
        GP_WB_READ_U8((offset) + 0x008)

#define GP_WB_WRITE_PBM_FORMAT_T_FRAME_PTR(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_WRITE_U8((offset) + 0x008, (val)); \
        } while (0)


/* Length in bytes of the frame to be sent */
#define GP_WB_READ_PBM_FORMAT_T_FRAME_LEN(offset) \
        GP_WB_READ_U8((offset) + 0x00a)

#define GP_WB_WRITE_PBM_FORMAT_T_FRAME_LEN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_WRITE_U8((offset) + 0x00a, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_FORMAT_T_GP_FLOW_CTRL_0(offset) \
        GP_WB_READ_U8((offset) + 0x00c)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_FLOW_CTRL_0(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x00c, (val))

/* The length of first backoff slot will be forced to zero. */
#define GP_WB_READ_PBM_FORMAT_T_GP_FIRST_BOFF_IS_0(offset) \
        GP_WB_READ_U1((offset) + 0x00c, 0)

#define GP_WB_GET_PBM_FORMAT_T_GP_FIRST_BOFF_IS_0_FROM_GP_FLOW_CTRL_0(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_FIRST_BOFF_IS_0(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00c, 0, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_FIRST_BOFF_IS_0_TO_GP_FLOW_CTRL_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When set, enable CSMA-CA algorithm for the TX, if disabled, CCA is skipped */
#define GP_WB_READ_PBM_FORMAT_T_GP_CSMA_CA_ENABLE(offset) \
        GP_WB_READ_U1((offset) + 0x00c, 1)

#define GP_WB_GET_PBM_FORMAT_T_GP_CSMA_CA_ENABLE_FROM_GP_FLOW_CTRL_0(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_CSMA_CA_ENABLE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00c, 1, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_CSMA_CA_ENABLE_TO_GP_FLOW_CTRL_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* When set, a CCA failure will be treated as a no-ACK failure and use the same retry mechanism as if no ACK has been received */
#define GP_WB_READ_PBM_FORMAT_T_GP_TREAT_CSMA_FAIL_AS_NO_ACK(offset) \
        GP_WB_READ_U1((offset) + 0x00c, 2)

#define GP_WB_GET_PBM_FORMAT_T_GP_TREAT_CSMA_FAIL_AS_NO_ACK_FROM_GP_FLOW_CTRL_0(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_TREAT_CSMA_FAIL_AS_NO_ACK(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00c, 2, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_TREAT_CSMA_FAIL_AS_NO_ACK_TO_GP_FLOW_CTRL_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Selection of the transmission queue type (timed vs untimed tx) */
#define GP_WB_READ_PBM_FORMAT_T_GP_VQ_SEL(offset) \
        ((GP_WB_READ_U8((offset) + 0x00c) >> 3) & 0x07)

#define GP_WB_GET_PBM_FORMAT_T_GP_VQ_SEL_FROM_GP_FLOW_CTRL_0(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_VQ_SEL(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x00c, 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_VQ_SEL_TO_GP_FLOW_CTRL_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0xC7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* When set, the FLL frequency and dac calibration will be skipped. Not advised to do this though ... */
#define GP_WB_READ_PBM_FORMAT_T_GP_SKIP_CAL_TX(offset) \
        GP_WB_READ_U1((offset) + 0x00c, 6)

#define GP_WB_GET_PBM_FORMAT_T_GP_SKIP_CAL_TX_FROM_GP_FLOW_CTRL_0(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_SKIP_CAL_TX(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00c, 6, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_SKIP_CAL_TX_TO_GP_FLOW_CTRL_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* When set, ED scans and cca measurements will be doen on the antenna specified by gp_antenna. Otherwise the global antenna diversity setting is used to either toggle the antenna or use the rx antenna. */
#define GP_WB_READ_PBM_FORMAT_T_GP_USE_TX_ANTENNA_FOR_ED_AND_CCA(offset) \
        GP_WB_READ_U1((offset) + 0x00c, 7)

#define GP_WB_GET_PBM_FORMAT_T_GP_USE_TX_ANTENNA_FOR_ED_AND_CCA_FROM_GP_FLOW_CTRL_0(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_USE_TX_ANTENNA_FOR_ED_AND_CCA(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00c, 7, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_USE_TX_ANTENNA_FOR_ED_AND_CCA_TO_GP_FLOW_CTRL_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_FORMAT_T_GP_FLOW_CTRL_1(offset) \
        GP_WB_READ_U8((offset) + 0x00d)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_FLOW_CTRL_1(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x00d, (val))

/* Selection of which data confirm queue will be used for confirm the request (0, 1, 2 or 3) */
#define GP_WB_READ_PBM_FORMAT_T_GP_CONFIRM_QUEUE(offset) \
        (GP_WB_READ_U8((offset) + 0x00d) & 0x03)

#define GP_WB_GET_PBM_FORMAT_T_GP_CONFIRM_QUEUE_FROM_GP_FLOW_CTRL_1(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_CONFIRM_QUEUE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x00d, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_CONFIRM_QUEUE_TO_GP_FLOW_CTRL_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0xFC; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When set, transmission will be request an ACK */
#define GP_WB_READ_PBM_FORMAT_T_GP_ACKED_MODE(offset) \
        GP_WB_READ_U1((offset) + 0x00d, 2)

#define GP_WB_GET_PBM_FORMAT_T_GP_ACKED_MODE_FROM_GP_FLOW_CTRL_1(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_ACKED_MODE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00d, 2, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_ACKED_MODE_TO_GP_FLOW_CTRL_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Select which antenna will be used for the TX, or the ED scan if gp_use_tx_antenna_for_ed_and_cca is set */
#define GP_WB_READ_PBM_FORMAT_T_GP_ANTENNA(offset) \
        GP_WB_READ_U1((offset) + 0x00d, 3)

#define GP_WB_GET_PBM_FORMAT_T_GP_ANTENNA_FROM_GP_FLOW_CTRL_1(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_ANTENNA(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00d, 3, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_ANTENNA_TO_GP_FLOW_CTRL_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* If set, no CRC is added in the end of the packet, it allows the SW to send without CRC or to create a custom CRC */
#define GP_WB_READ_PBM_FORMAT_T_GP_FCS_INSERT_DIS(offset) \
        GP_WB_READ_U1((offset) + 0x00d, 4)

#define GP_WB_GET_PBM_FORMAT_T_GP_FCS_INSERT_DIS_FROM_GP_FLOW_CTRL_1(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_FCS_INSERT_DIS(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00d, 4, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_FCS_INSERT_DIS_TO_GP_FLOW_CTRL_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* The RX window is stopped when the PBM is full (from the TRC point of view this means it is not granted any PBM entry after reception of the last packet) */
#define GP_WB_READ_PBM_FORMAT_T_GP_STOP_RX_WINDOW_ON_PBM_FULL(offset) \
        GP_WB_READ_U1((offset) + 0x00d, 5)

#define GP_WB_GET_PBM_FORMAT_T_GP_STOP_RX_WINDOW_ON_PBM_FULL_FROM_GP_FLOW_CTRL_1(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_STOP_RX_WINDOW_ON_PBM_FULL(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00d, 5, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_STOP_RX_WINDOW_ON_PBM_FULL_TO_GP_FLOW_CTRL_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* If set, request is an ED scan, if false, it is a transmission */
#define GP_WB_READ_PBM_FORMAT_T_GP_ED_SCAN(offset) \
        GP_WB_READ_U1((offset) + 0x00d, 6)

#define GP_WB_GET_PBM_FORMAT_T_GP_ED_SCAN_FROM_GP_FLOW_CTRL_1(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_ED_SCAN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00d, 6, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_ED_SCAN_TO_GP_FLOW_CTRL_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* When set, the value in gp_rx_duration will be taken into acount. */
#define GP_WB_READ_PBM_FORMAT_T_GP_RX_DURATION_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x00d, 7)

#define GP_WB_GET_PBM_FORMAT_T_GP_RX_DURATION_VALID_FROM_GP_FLOW_CTRL_1(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_RX_DURATION_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00d, 7, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_RX_DURATION_VALID_TO_GP_FLOW_CTRL_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_FORMAT_T_GP_FLOW_CTRL_2(offset) \
        GP_WB_READ_U8((offset) + 0x00e)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_FLOW_CTRL_2(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x00e, (val))

/* Indicates to which stack, the pbm belongs. In a multichannel environment this will determine what channel in hte channel list will be changed during pre and post channel change */
#define GP_WB_READ_PBM_FORMAT_T_GP_CHANNEL_IDX(offset) \
        (GP_WB_READ_U8((offset) + 0x00e) & 0x07)

#define GP_WB_GET_PBM_FORMAT_T_GP_CHANNEL_IDX_FROM_GP_FLOW_CTRL_2(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_CHANNEL_IDX(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x00e, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_CHANNEL_IDX_TO_GP_FLOW_CTRL_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0xF8; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* The optional RX listening window will be started only if the expected ACK has the pending bit set */
#define GP_WB_READ_PBM_FORMAT_T_GP_START_RX_ONLY_IF_PENDING_BIT_SET(offset) \
        GP_WB_READ_U1((offset) + 0x00e, 3)

#define GP_WB_GET_PBM_FORMAT_T_GP_START_RX_ONLY_IF_PENDING_BIT_SET_FROM_GP_FLOW_CTRL_2(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_START_RX_ONLY_IF_PENDING_BIT_SET(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00e, 3, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_START_RX_ONLY_IF_PENDING_BIT_SET_TO_GP_FLOW_CTRL_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Before each packet transmission (including retransmission), the MAC will check the status of this bits in the sequence CH0A_EN (first transmission), CH0B_EN (first retransmission), CH0C_EN (second retransmission), CH0A_EN (third retransmission) etc. If the bit being analyzed is set, the PHY channel will be set to the corresponding value (MM_GP_CHANNEL_CH0[A/B/C]) */
#define GP_WB_READ_PBM_FORMAT_T_GP_CHANNEL_CH0A_EN(offset) \
        GP_WB_READ_U1((offset) + 0x00e, 4)

#define GP_WB_GET_PBM_FORMAT_T_GP_CHANNEL_CH0A_EN_FROM_GP_FLOW_CTRL_2(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_CHANNEL_CH0A_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00e, 4, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_CHANNEL_CH0A_EN_TO_GP_FLOW_CTRL_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* see gp_channel_ch0a_en */
#define GP_WB_READ_PBM_FORMAT_T_GP_CHANNEL_CH0B_EN(offset) \
        GP_WB_READ_U1((offset) + 0x00e, 5)

#define GP_WB_GET_PBM_FORMAT_T_GP_CHANNEL_CH0B_EN_FROM_GP_FLOW_CTRL_2(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_CHANNEL_CH0B_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00e, 5, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_CHANNEL_CH0B_EN_TO_GP_FLOW_CTRL_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* see gp_channel_ch0a_en */
#define GP_WB_READ_PBM_FORMAT_T_GP_CHANNEL_CH0C_EN(offset) \
        GP_WB_READ_U1((offset) + 0x00e, 6)

#define GP_WB_GET_PBM_FORMAT_T_GP_CHANNEL_CH0C_EN_FROM_GP_FLOW_CTRL_2(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_CHANNEL_CH0C_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00e, 6, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_CHANNEL_CH0C_EN_TO_GP_FLOW_CTRL_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* If this bit is set, at the end of the transmission process the PHY channel will be set to the corresponding value */
#define GP_WB_READ_PBM_FORMAT_T_GP_CHANNEL_CH1_EN(offset) \
        GP_WB_READ_U1((offset) + 0x00e, 7)

#define GP_WB_GET_PBM_FORMAT_T_GP_CHANNEL_CH1_EN_FROM_GP_FLOW_CTRL_2(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_CHANNEL_CH1_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00e, 7, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_CHANNEL_CH1_EN_TO_GP_FLOW_CTRL_2(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_FORMAT_T_CSMA_CA_BO_RETRY_SETTINGS(offset) \
        GP_WB_READ_U8((offset) + 0x00f)

#define GP_WB_WRITE_PBM_FORMAT_T_CSMA_CA_BO_RETRY_SETTINGS(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x00f, (val))

/* Max backoffs to be performed - only valid when csma_ca mode enabled */
#define GP_WB_READ_PBM_FORMAT_T_MAX_CSMA_BACKOFFS(offset) \
        (GP_WB_READ_U8((offset) + 0x00f) & 0x07)

#define GP_WB_GET_PBM_FORMAT_T_MAX_CSMA_BACKOFFS_FROM_CSMA_CA_BO_RETRY_SETTINGS(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_PBM_FORMAT_T_MAX_CSMA_BACKOFFS(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x00f, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_MAX_CSMA_BACKOFFS_TO_CSMA_CA_BO_RETRY_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0xF8; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Max number of retries - always valid */
#define GP_WB_READ_PBM_FORMAT_T_MAX_FRAME_RETRIES(offset) \
        ((GP_WB_READ_U8((offset) + 0x00f) >> 3) & 0x07)

#define GP_WB_GET_PBM_FORMAT_T_MAX_FRAME_RETRIES_FROM_CSMA_CA_BO_RETRY_SETTINGS(tmp) \
        (((tmp) >> 3) & 0x07)

#define GP_WB_WRITE_PBM_FORMAT_T_MAX_FRAME_RETRIES(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x00f, 0x38, (val) << 3); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_MAX_FRAME_RETRIES_TO_CSMA_CA_BO_RETRY_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0xC7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* The number of active channel slots, should be a number between 1 and 3, used for the retransmissions to determine which channel_change setting to use */
#define GP_WB_READ_PBM_FORMAT_T_NUM_CHANNEL_SLOTS(offset) \
        ((GP_WB_READ_U8((offset) + 0x00f) >> 6) & 0x03)

#define GP_WB_GET_PBM_FORMAT_T_NUM_CHANNEL_SLOTS_FROM_CSMA_CA_BO_RETRY_SETTINGS(tmp) \
        (((tmp) >> 6) & 0x03)

#define GP_WB_WRITE_PBM_FORMAT_T_NUM_CHANNEL_SLOTS(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x00f, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_NUM_CHANNEL_SLOTS_TO_CSMA_CA_BO_RETRY_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_FORMAT_T_PA_POWER_SETTINGS(offset) \
        GP_WB_READ_U8((offset) + 0x011)

#define GP_WB_WRITE_PBM_FORMAT_T_PA_POWER_SETTINGS(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x011, (val))

/* Desired Power for transmitted packet */
#define GP_WB_READ_PBM_FORMAT_T_TX_POWER(offset) \
        (GP_WB_READ_U8((offset) + 0x011) & 0x3F)

#define GP_WB_GET_PBM_FORMAT_T_TX_POWER_FROM_PA_POWER_SETTINGS(tmp) \
        ((tmp) & 0x3F)

#define GP_WB_WRITE_PBM_FORMAT_T_TX_POWER(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x011, 0x3F, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_TX_POWER_TO_PA_POWER_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0xC0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Chooses the low PA power curve when set */
#define GP_WB_READ_PBM_FORMAT_T_PA_LOW(offset) \
        GP_WB_READ_U1((offset) + 0x011, 6)

#define GP_WB_GET_PBM_FORMAT_T_PA_LOW_FROM_PA_POWER_SETTINGS(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_PA_LOW(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x011, 6, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_PA_LOW_TO_PA_POWER_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* Chooses the low ultra low PA power curve when set */
#define GP_WB_READ_PBM_FORMAT_T_PA_ULTRA_LOW(offset) \
        GP_WB_READ_U1((offset) + 0x011, 7)

#define GP_WB_GET_PBM_FORMAT_T_PA_ULTRA_LOW_FROM_PA_POWER_SETTINGS(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_PA_ULTRA_LOW(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x011, 7, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_PA_ULTRA_LOW_TO_PA_POWER_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* Selects the attenuator mode to use (only relevant for ED scan) */
#define GP_WB_READ_PBM_FORMAT_T_ATTENUATOR_SEL(offset) \
        GP_WB_READ_U8((offset) + 0x012)

#define GP_WB_WRITE_PBM_FORMAT_T_ATTENUATOR_SEL(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_WRITE_U8((offset) + 0x012, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_FORMAT_T_CSMA_CA_BE_SETTINGS(offset) \
        GP_WB_READ_U8((offset) + 0x013)

#define GP_WB_WRITE_PBM_FORMAT_T_CSMA_CA_BE_SETTINGS(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x013, (val))

/* Min BE setting for the CSMA CA cycle - only valid when csma_ca mode enabled */
#define GP_WB_READ_PBM_FORMAT_T_MIN_BE(offset) \
        (GP_WB_READ_U8((offset) + 0x013) & 0x0F)

#define GP_WB_GET_PBM_FORMAT_T_MIN_BE_FROM_CSMA_CA_BE_SETTINGS(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_PBM_FORMAT_T_MIN_BE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x013, 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_MIN_BE_TO_CSMA_CA_BE_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0xF0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Min BE setting for the CSMA CA cycle - only valid when csma_ca mode enabled */
#define GP_WB_READ_PBM_FORMAT_T_MAX_BE(offset) \
        ((GP_WB_READ_U8((offset) + 0x013) >> 4) & 0x0F)

#define GP_WB_GET_PBM_FORMAT_T_MAX_BE_FROM_CSMA_CA_BE_SETTINGS(tmp) \
        (((tmp) >> 4) & 0x0F)

#define GP_WB_WRITE_PBM_FORMAT_T_MAX_BE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x013, 0xF0, (val) << 4); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_MAX_BE_TO_CSMA_CA_BE_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_FORMAT_T_EXTERNAL_PA_FEM_SETTINGS(offset) \
        GP_WB_READ_U8((offset) + 0x014)

#define GP_WB_WRITE_PBM_FORMAT_T_EXTERNAL_PA_FEM_SETTINGS(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x014, (val))

/* 4 general purpose mode bits that are output to the iob and can be put on pins during the TX phase. This allows for controlling external PA/FEM */
#define GP_WB_READ_PBM_FORMAT_T_GP_MODE_CTRL(offset) \
        (GP_WB_READ_U8((offset) + 0x014) & 0x0F)

#define GP_WB_GET_PBM_FORMAT_T_GP_MODE_CTRL_FROM_EXTERNAL_PA_FEM_SETTINGS(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_MODE_CTRL(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x014, 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_MODE_CTRL_TO_EXTERNAL_PA_FEM_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0xF0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* External antenna to be used */
#define GP_WB_READ_PBM_FORMAT_T_GP_EXT_ANTENNA(offset) \
        ((GP_WB_READ_U8((offset) + 0x014) >> 4) & 0x0F)

#define GP_WB_GET_PBM_FORMAT_T_GP_EXT_ANTENNA_FROM_EXTERNAL_PA_FEM_SETTINGS(tmp) \
        (((tmp) >> 4) & 0x0F)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_EXT_ANTENNA(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x014, 0xF0, (val) << 4); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_EXT_ANTENNA_TO_EXTERNAL_PA_FEM_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_FORMAT_T_GP_CHANNEL_CHANGE_0(offset) \
        GP_WB_READ_U8((offset) + 0x015)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_CHANNEL_CHANGE_0(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x015, (val))

/* see gp_channel_ch0a_en */
#define GP_WB_READ_PBM_FORMAT_T_GP_CHANNEL_CH0A(offset) \
        (GP_WB_READ_U8((offset) + 0x015) & 0x0F)

#define GP_WB_GET_PBM_FORMAT_T_GP_CHANNEL_CH0A_FROM_GP_CHANNEL_CHANGE_0(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_CHANNEL_CH0A(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x015, 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_CHANNEL_CH0A_TO_GP_CHANNEL_CHANGE_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0xF0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* see gp_channel_ch0a_en */
#define GP_WB_READ_PBM_FORMAT_T_GP_CHANNEL_CH0B(offset) \
        ((GP_WB_READ_U8((offset) + 0x015) >> 4) & 0x0F)

#define GP_WB_GET_PBM_FORMAT_T_GP_CHANNEL_CH0B_FROM_GP_CHANNEL_CHANGE_0(tmp) \
        (((tmp) >> 4) & 0x0F)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_CHANNEL_CH0B(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x015, 0xF0, (val) << 4); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_CHANNEL_CH0B_TO_GP_CHANNEL_CHANGE_0(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_FORMAT_T_GP_CHANNEL_CHANGE_1(offset) \
        GP_WB_READ_U8((offset) + 0x016)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_CHANNEL_CHANGE_1(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x016, (val))

/* see gp_channel_ch0a_en */
#define GP_WB_READ_PBM_FORMAT_T_GP_CHANNEL_CH0C(offset) \
        (GP_WB_READ_U8((offset) + 0x016) & 0x0F)

#define GP_WB_GET_PBM_FORMAT_T_GP_CHANNEL_CH0C_FROM_GP_CHANNEL_CHANGE_1(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_CHANNEL_CH0C(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x016, 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_CHANNEL_CH0C_TO_GP_CHANNEL_CHANGE_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0xF0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* see gp_channel_ch1_en */
#define GP_WB_READ_PBM_FORMAT_T_GP_CHANNEL_CH1(offset) \
        ((GP_WB_READ_U8((offset) + 0x016) >> 4) & 0x0F)

#define GP_WB_GET_PBM_FORMAT_T_GP_CHANNEL_CH1_FROM_GP_CHANNEL_CHANGE_1(tmp) \
        (((tmp) >> 4) & 0x0F)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_CHANNEL_CH1(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x016, 0xF0, (val) << 4); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_GP_CHANNEL_CH1_TO_GP_CHANNEL_CHANGE_1(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* Offset of the csl ie which needs to be filled at transmit time. */
#define GP_WB_READ_PBM_FORMAT_T_CSL_IE_OFFSET(offset) \
        GP_WB_READ_U8((offset) + 0x017)

#define GP_WB_WRITE_PBM_FORMAT_T_CSL_IE_OFFSET(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_WRITE_U8((offset) + 0x017, (val)); \
        } while (0)


/* If gp_rx_duration_valid=True, number of symbols the receiver will be enabled after the successfull transmission packet has been transmitted (if a packet needed to be transmitted). If transmission was not succesfull gp_force_rx_on_after_tx_fail has to be set to use this feature. In case of an ED scan this is has to be interpreted as the scan length. If it is equal to zero a single ED will be performed. */
#define GP_WB_READ_PBM_FORMAT_T_GP_RX_DURATION(offset) \
        GP_WB_READ_U24((offset) + 0x018)

#define GP_WB_WRITE_PBM_FORMAT_T_GP_RX_DURATION(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_WRITE_U24((offset) + 0x018, (val)); \
        } while (0)


/* some spare bytes that can be used to put in some meta data. Could be useful for very lowlevel applications (like macfilter) */
#define GP_WB_READ_PBM_FORMAT_T_MISC_DATA(offset) \
        GP_WB_READ_U8((offset) + 0x01b)

#define GP_WB_WRITE_PBM_FORMAT_T_MISC_DATA(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_WRITE_U8((offset) + 0x01b, (val)); \
        } while (0)


/* Index to entry in global PA table (used to identify the original tx power setting that was requested) */
#define GP_WB_READ_PBM_FORMAT_T_PA_POWER_TABLE_INDEX(offset) \
        GP_WB_READ_U8((offset) + 0x01c)

#define GP_WB_WRITE_PBM_FORMAT_T_PA_POWER_TABLE_INDEX(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_WRITE_U8((offset) + 0x01c, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_FORMAT_T_RAW_MODE_CFG(offset) \
        GP_WB_READ_U8((offset) + 0x01d)

#define GP_WB_WRITE_PBM_FORMAT_T_RAW_MODE_CFG(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x01d, (val))

/* When set, the frame will be encrypted by the RT using the raw mode settings. */
#define GP_WB_READ_PBM_FORMAT_T_ENC_ENABLE(offset) \
        GP_WB_READ_U1((offset) + 0x01d, 0)

#define GP_WB_GET_PBM_FORMAT_T_ENC_ENABLE_FROM_RAW_MODE_CFG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_ENC_ENABLE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x01d, 0, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_ENC_ENABLE_TO_RAW_MODE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* When set, the framecounter will not be updated. */
#define GP_WB_READ_PBM_FORMAT_T_ENC_KEEP_FRAMECOUNTER(offset) \
        GP_WB_READ_U1((offset) + 0x01d, 1)

#define GP_WB_GET_PBM_FORMAT_T_ENC_KEEP_FRAMECOUNTER_FROM_RAW_MODE_CFG(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_ENC_KEEP_FRAMECOUNTER(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x01d, 1, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_ENC_KEEP_FRAMECOUNTER_TO_RAW_MODE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* To be set to 0. Will be set to 1 by the RT when encryption is completed. */
#define GP_WB_READ_PBM_FORMAT_T_ENC_DONE(offset) \
        GP_WB_READ_U1((offset) + 0x01d, 2)

#define GP_WB_GET_PBM_FORMAT_T_ENC_DONE_FROM_RAW_MODE_CFG(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_ENC_DONE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x01d, 2, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_ENC_DONE_TO_RAW_MODE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* To be set to 0. Will be set to 1 by the RT if a secured ACK frame is received. */
#define GP_WB_READ_PBM_FORMAT_T_ACK_SEC(offset) \
        GP_WB_READ_U1((offset) + 0x01d, 3)

#define GP_WB_GET_PBM_FORMAT_T_ACK_SEC_FROM_RAW_MODE_CFG(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_PBM_FORMAT_T_ACK_SEC(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x01d, 3, (val)); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_ACK_SEC_TO_RAW_MODE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* To be set to 0. Will be set to the frame version of the ACK by the RT. */
#define GP_WB_READ_PBM_FORMAT_T_ACK_FRAME_VERS(offset) \
        ((GP_WB_READ_U8((offset) + 0x01d) >> 4) & 0x03)

#define GP_WB_GET_PBM_FORMAT_T_ACK_FRAME_VERS_FROM_RAW_MODE_CFG(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_PBM_FORMAT_T_ACK_FRAME_VERS(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x01d, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_PBM_FORMAT_T_ACK_FRAME_VERS_TO_RAW_MODE_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* Offset of the Aux header in the frame to be used by the RT to fill in the framecounter. */
#define GP_WB_READ_PBM_FORMAT_T_AUX_OFFSET(offset) \
        GP_WB_READ_U8((offset) + 0x01e)

#define GP_WB_WRITE_PBM_FORMAT_T_AUX_OFFSET(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_WRITE_U8((offset) + 0x01e, (val)); \
        } while (0)


/* Offset of the data which is to be encrypted inside the packet. */
#define GP_WB_READ_PBM_FORMAT_T_ENCR_OFFSET(offset) \
        GP_WB_READ_U8((offset) + 0x01f)

#define GP_WB_WRITE_PBM_FORMAT_T_ENCR_OFFSET(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_FORMAT_T(offset); \
          GP_WB_WRITE_U8((offset) + 0x01f, (val)); \
        } while (0)

/***************************
 * layout: pbm_ble_format_r
 ***************************/

/* Status of the PBM */
#define GP_WB_READ_PBM_BLE_FORMAT_R_RETURN_CODE(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_RETURN_CODE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x000, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_BLE_FORMAT_R_RX_STATUS(offset) \
        GP_WB_READ_U8((offset) + 0x001)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_RX_STATUS(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x001, (val))

/* Time Slot on which the frame was received. Corresponds to the channel idx when all slots use different channel */
#define GP_WB_READ_PBM_BLE_FORMAT_R_SLOT_IDX(offset) \
        (GP_WB_READ_U8((offset) + 0x001) & 0x07)

#define GP_WB_GET_PBM_BLE_FORMAT_R_SLOT_IDX_FROM_RX_STATUS(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_SLOT_IDX(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_R(offset); \
          GP_WB_MWRITE_U8((offset) + 0x001, 0x07, (val)); \
        } while (0)

#define GP_WB_SET_PBM_BLE_FORMAT_R_SLOT_IDX_TO_RX_STATUS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0xF8; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Antenna on which packet was received */
#define GP_WB_READ_PBM_BLE_FORMAT_R_ANTENNA(offset) \
        GP_WB_READ_U1((offset) + 0x001, 3)

#define GP_WB_GET_PBM_BLE_FORMAT_R_ANTENNA_FROM_RX_STATUS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_ANTENNA(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_R(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 3, (val)); \
        } while (0)

#define GP_WB_SET_PBM_BLE_FORMAT_R_ANTENNA_TO_RX_STATUS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Indicates whether attenuation was enabled during rx of the frame */
#define GP_WB_READ_PBM_BLE_FORMAT_R_ATTENUATED(offset) \
        GP_WB_READ_U1((offset) + 0x001, 4)

#define GP_WB_GET_PBM_BLE_FORMAT_R_ATTENUATED_FROM_RX_STATUS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_ATTENUATED(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_R(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 4, (val)); \
        } while (0)

#define GP_WB_SET_PBM_BLE_FORMAT_R_ATTENUATED_TO_RX_STATUS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Indicates whether the received packet has a valid crc or not */
#define GP_WB_READ_PBM_BLE_FORMAT_R_FCS_OK(offset) \
        GP_WB_READ_U1((offset) + 0x001, 5)

#define GP_WB_GET_PBM_BLE_FORMAT_R_FCS_OK_FROM_RX_STATUS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_FCS_OK(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_R(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 5, (val)); \
        } while (0)

#define GP_WB_SET_PBM_BLE_FORMAT_R_FCS_OK_TO_RX_STATUS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* Indicates whether the access code was correct */
#define GP_WB_READ_PBM_BLE_FORMAT_R_ACCESS_ADDR_OK(offset) \
        GP_WB_READ_U1((offset) + 0x001, 6)

#define GP_WB_GET_PBM_BLE_FORMAT_R_ACCESS_ADDR_OK_FROM_RX_STATUS(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_ACCESS_ADDR_OK(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_R(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 6, (val)); \
        } while (0)

#define GP_WB_SET_PBM_BLE_FORMAT_R_ACCESS_ADDR_OK_TO_RX_STATUS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* Indicates whether the packet contains a CTE info field */
#define GP_WB_READ_PBM_BLE_FORMAT_R_CTE_PRESENT(offset) \
        GP_WB_READ_U1((offset) + 0x001, 7)

#define GP_WB_GET_PBM_BLE_FORMAT_R_CTE_PRESENT_FROM_RX_STATUS(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_CTE_PRESENT(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_R(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 7, (val)); \
        } while (0)

#define GP_WB_SET_PBM_BLE_FORMAT_R_CTE_PRESENT_TO_RX_STATUS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* The nr of the event that is related to this PBM */
#define GP_WB_READ_PBM_BLE_FORMAT_R_RELATED_EVENT(offset) \
        GP_WB_READ_U8((offset) + 0x003)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_RELATED_EVENT(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x003, (val)); \
        } while (0)


/* Timestamp information on the received frame in us */
#define GP_WB_READ_PBM_BLE_FORMAT_R_TIMESTAMP(offset) \
        GP_WB_READ_U32((offset) + 0x004)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_TIMESTAMP(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_R(offset); \
          GP_WB_WRITE_U32((offset) + 0x004, (val)); \
        } while (0)


/* Memory address (pointer) to the first byte of the received frame stored in RAM */
#define GP_WB_READ_PBM_BLE_FORMAT_R_FRAME_PTR(offset) \
        GP_WB_READ_U16((offset) + 0x008)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_FRAME_PTR(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_R(offset); \
          GP_WB_WRITE_U16((offset) + 0x008, (val)); \
        } while (0)


/* Length in bytes of the received frame */
#define GP_WB_READ_PBM_BLE_FORMAT_R_FRAME_LEN(offset) \
        GP_WB_READ_U16((offset) + 0x00a)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_FRAME_LEN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_R(offset); \
          GP_WB_WRITE_U16((offset) + 0x00a, (val)); \
        } while (0)


/* Quality of the link during the frame reception */
#define GP_WB_READ_PBM_BLE_FORMAT_R_LQI(offset) \
        GP_WB_READ_U8((offset) + 0x00c)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_LQI(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x00c, (val)); \
        } while (0)


/* Signal strength of the received frame */
#define GP_WB_READ_PBM_BLE_FORMAT_R_RSSI(offset) \
        GP_WB_READ_U8((offset) + 0x00d)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_RSSI(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x00d, (val)); \
        } while (0)


#define GP_WB_READ_PBM_BLE_FORMAT_R_FOFFSET(offset) \
        (GP_WB_S16(GP_WB_READ_U16((offset) + 0x00e), 16))

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_FOFFSET(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_R(offset); \
          GP_WB_WRITE_U16((offset) + 0x00e, (UInt16)((val))); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_BLE_FORMAT_R_CHANNEL_INFO(offset) \
        GP_WB_READ_U16((offset) + 0x010)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_CHANNEL_INFO(offset, val) \
      GP_WB_WRITE_U16((offset) + 0x010, (val))

/* Channel number of the received frame */
#define GP_WB_READ_PBM_BLE_FORMAT_R_CHANNEL(offset) \
        GP_WB_READ_U8((offset) + 0x010)

#define GP_WB_GET_PBM_BLE_FORMAT_R_CHANNEL_FROM_CHANNEL_INFO(tmp) \
        ((tmp) & 0x3F)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_CHANNEL(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x010, (val)); \
        } while (0)

#define GP_WB_SET_PBM_BLE_FORMAT_R_CHANNEL_TO_CHANNEL_INFO(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0x0700; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Channel bank the packet was received on */
#define GP_WB_READ_PBM_BLE_FORMAT_R_CHANNEL_IDX(offset) \
        GP_WB_READ_U8((offset) + 0x011)

#define GP_WB_GET_PBM_BLE_FORMAT_R_CHANNEL_IDX_FROM_CHANNEL_INFO(tmp) \
        (((tmp) >> 8) & 0x07)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_CHANNEL_IDX(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x011, (val)); \
        } while (0)

#define GP_WB_SET_PBM_BLE_FORMAT_R_CHANNEL_IDX_TO_CHANNEL_INFO(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x003F; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)


/* Indicates what indexes where configured to use the same channel as the channel this packet is received on */
#define GP_WB_READ_PBM_BLE_FORMAT_R_MATCHING_CH_IDX_MASK(offset) \
        GP_WB_READ_U8((offset) + 0x012)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_MATCHING_CH_IDX_MASK(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x012, (val)); \
        } while (0)


/* Indicates the BLE RX mode the frame was received in */
#define GP_WB_READ_PBM_BLE_FORMAT_R_PHY_MODE(offset) \
        GP_WB_READ_U8((offset) + 0x013)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_PHY_MODE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x013, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_BLE_FORMAT_R_BLE_RES_PR(offset) \
        GP_WB_READ_U16((offset) + 0x014)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_BLE_RES_PR(offset, val) \
      GP_WB_WRITE_U16((offset) + 0x014, (val))

/* Index in both local and peer IRK resolving lists, 0xFF is invalid */
#define GP_WB_READ_PBM_BLE_FORMAT_R_IRK_IDX(offset) \
        GP_WB_READ_U8((offset) + 0x014)

#define GP_WB_GET_PBM_BLE_FORMAT_R_IRK_IDX_FROM_BLE_RES_PR(tmp) \
        ((tmp) & 0xFF)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_IRK_IDX(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x014, (val)); \
        } while (0)

#define GP_WB_SET_PBM_BLE_FORMAT_R_IRK_IDX_TO_BLE_RES_PR(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          (tmp) &= 0x0700; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Irk_idx is valid, i.e. peer is in resolving list */
#define GP_WB_READ_PBM_BLE_FORMAT_R_IRK_IDX_IS_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x015, 0)

#define GP_WB_GET_PBM_BLE_FORMAT_R_IRK_IDX_IS_VALID_FROM_BLE_RES_PR(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_IRK_IDX_IS_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_R(offset); \
          GP_WB_MWRITE_U1((offset) + 0x015, 0, (val)); \
        } while (0)

#define GP_WB_SET_PBM_BLE_FORMAT_R_IRK_IDX_IS_VALID_TO_BLE_RES_PR(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* src is RPA and was resolved */
#define GP_WB_READ_PBM_BLE_FORMAT_R_SRC_IS_RESOLVED(offset) \
        GP_WB_READ_U1((offset) + 0x015, 1)

#define GP_WB_GET_PBM_BLE_FORMAT_R_SRC_IS_RESOLVED_FROM_BLE_RES_PR(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_SRC_IS_RESOLVED(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_R(offset); \
          GP_WB_MWRITE_U1((offset) + 0x015, 1, (val)); \
        } while (0)

#define GP_WB_SET_PBM_BLE_FORMAT_R_SRC_IS_RESOLVED_TO_BLE_RES_PR(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05FF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)

/* Target RPA was resolved flag */
#define GP_WB_READ_PBM_BLE_FORMAT_R_TARGET_RESOLVED(offset) \
        GP_WB_READ_U1((offset) + 0x015, 2)

#define GP_WB_GET_PBM_BLE_FORMAT_R_TARGET_RESOLVED_FROM_BLE_RES_PR(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_TARGET_RESOLVED(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_R(offset); \
          GP_WB_MWRITE_U1((offset) + 0x015, 2, (val)); \
        } while (0)

#define GP_WB_SET_PBM_BLE_FORMAT_R_TARGET_RESOLVED_TO_BLE_RES_PR(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FF; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)


/* Contains the AdvASC, ScanASC index associated with the sED during which this packet was received */
#define GP_WB_READ_PBM_BLE_FORMAT_R_EVENT_CONTEXT(offset) \
        GP_WB_READ_U8((offset) + 0x016)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_EVENT_CONTEXT(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x016, (val)); \
        } while (0)


/* Contains the sED EventType during which this packet was received */
#define GP_WB_READ_PBM_BLE_FORMAT_R_EVENT_SUBTYPE(offset) \
        GP_WB_READ_U8((offset) + 0x017)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_EVENT_SUBTYPE(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x017, (val)); \
        } while (0)


/* Pointer to buffer with raw phase samples (= offset added to SM_linear start address) */
#define GP_WB_READ_PBM_BLE_FORMAT_R_RAW_PHASE_SAMPLE_PTR(offset) \
        GP_WB_READ_U24((offset) + 0x018)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_RAW_PHASE_SAMPLE_PTR(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x07FFFF); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_R(offset); \
          GP_WB_WRITE_U24((offset) + 0x018, (val)); \
        } while (0)


/* Some spare bytes that can be used to put in some meta data. Could be useful for very lowlevel applications (like macfilter) */
#define GP_WB_READ_PBM_BLE_FORMAT_R_MISC_DATA(offset) \
        GP_WB_READ_U8((offset) + 0x01b)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_MISC_DATA(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x01b, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_BLE_FORMAT_R_SUBFILT_ACCEPT(offset) \
        GP_WB_READ_U8((offset) + 0x01c)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_SUBFILT_ACCEPT(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x01c, (val))

/* Subfilter 0 accepted the pdu */
#define GP_WB_READ_PBM_BLE_FORMAT_R_SUBFILT_0_ACCEPT(offset) \
        GP_WB_READ_U1((offset) + 0x01c, 0)

#define GP_WB_GET_PBM_BLE_FORMAT_R_SUBFILT_0_ACCEPT_FROM_SUBFILT_ACCEPT(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_SUBFILT_0_ACCEPT(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_R(offset); \
          GP_WB_MWRITE_U1((offset) + 0x01c, 0, (val)); \
        } while (0)

#define GP_WB_SET_PBM_BLE_FORMAT_R_SUBFILT_0_ACCEPT_TO_SUBFILT_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Subfilter 1 accepted the pdu */
#define GP_WB_READ_PBM_BLE_FORMAT_R_SUBFILT_1_ACCEPT(offset) \
        GP_WB_READ_U1((offset) + 0x01c, 1)

#define GP_WB_GET_PBM_BLE_FORMAT_R_SUBFILT_1_ACCEPT_FROM_SUBFILT_ACCEPT(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_SUBFILT_1_ACCEPT(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_R(offset); \
          GP_WB_MWRITE_U1((offset) + 0x01c, 1, (val)); \
        } while (0)

#define GP_WB_SET_PBM_BLE_FORMAT_R_SUBFILT_1_ACCEPT_TO_SUBFILT_ACCEPT(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* whitelist entry index that was used for packet filtering */
#define GP_WB_READ_PBM_BLE_FORMAT_R_WL_IDX(offset) \
        GP_WB_READ_U8((offset) + 0x01d)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_WL_IDX(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_R(offset); \
          GP_WB_WRITE_U8((offset) + 0x01d, (val)); \
        } while (0)


/* Event counter when this pbm is received */
#define GP_WB_READ_PBM_BLE_FORMAT_R_EVENT_COUNTER(offset) \
        GP_WB_READ_U16((offset) + 0x01e)

#define GP_WB_WRITE_PBM_BLE_FORMAT_R_EVENT_COUNTER(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_R(offset); \
          GP_WB_WRITE_U16((offset) + 0x01e, (val)); \
        } while (0)

/***************************
 * layout: pbm_ble_format_t
 ***************************/

/* Return code with the status of the request */
#define GP_WB_READ_PBM_BLE_FORMAT_T_RETURN_CODE(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_PBM_BLE_FORMAT_T_RETURN_CODE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_T(offset); \
          GP_WB_WRITE_U8((offset) + 0x000, (val)); \
        } while (0)


/* The nr of the event that is related to this PBM */
#define GP_WB_READ_PBM_BLE_FORMAT_T_RELATED_EVENT(offset) \
        GP_WB_READ_U8((offset) + 0x003)

#define GP_WB_WRITE_PBM_BLE_FORMAT_T_RELATED_EVENT(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_T(offset); \
          GP_WB_WRITE_U8((offset) + 0x003, (val)); \
        } while (0)


/* Timestamp of the transmission in us */
#define GP_WB_READ_PBM_BLE_FORMAT_T_TIMESTAMP(offset) \
        GP_WB_READ_U32((offset) + 0x004)

#define GP_WB_WRITE_PBM_BLE_FORMAT_T_TIMESTAMP(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_T(offset); \
          GP_WB_WRITE_U32((offset) + 0x004, (val)); \
        } while (0)


/* Memory address (pointer) to the first byte of the frame buffer to be sent stored in RAM */
#define GP_WB_READ_PBM_BLE_FORMAT_T_FRAME_PTR(offset) \
        GP_WB_READ_U16((offset) + 0x008)

#define GP_WB_WRITE_PBM_BLE_FORMAT_T_FRAME_PTR(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_T(offset); \
          GP_WB_WRITE_U16((offset) + 0x008, (val)); \
        } while (0)


/* Length in bytes of the frame to be sent */
#define GP_WB_READ_PBM_BLE_FORMAT_T_FRAME_LEN(offset) \
        GP_WB_READ_U16((offset) + 0x00a)

#define GP_WB_WRITE_PBM_BLE_FORMAT_T_FRAME_LEN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FF); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_T(offset); \
          GP_WB_WRITE_U16((offset) + 0x00a, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_BLE_FORMAT_T_CHANNEL_SETTINGS(offset) \
        GP_WB_READ_U24((offset) + 0x00c)

#define GP_WB_WRITE_PBM_BLE_FORMAT_T_CHANNEL_SETTINGS(offset, val) \
      GP_WB_WRITE_U24((offset) + 0x00c, (val))

/* Indicates to which stack, the pbm belongs. In a multichannel environment this will determine what channel in hte channel list will be changed during pre and post channel change */
#define GP_WB_READ_PBM_BLE_FORMAT_T_CHANNEL_IDX(offset) \
        GP_WB_READ_U8((offset) + 0x00c)

#define GP_WB_GET_PBM_BLE_FORMAT_T_CHANNEL_IDX_FROM_CHANNEL_SETTINGS(tmp) \
        ((tmp) & 0x07)

#define GP_WB_WRITE_PBM_BLE_FORMAT_T_CHANNEL_IDX(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_T(offset); \
          GP_WB_WRITE_U8((offset) + 0x00c, (val)); \
        } while (0)

#define GP_WB_SET_PBM_BLE_FORMAT_T_CHANNEL_IDX_TO_CHANNEL_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x3F3F00; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* BLE FLL channel to change to when channel_ch0 is enabled */
#define GP_WB_READ_PBM_BLE_FORMAT_T_CHANNEL_CH0(offset) \
        GP_WB_READ_U8((offset) + 0x00d)

#define GP_WB_GET_PBM_BLE_FORMAT_T_CHANNEL_CH0_FROM_CHANNEL_SETTINGS(tmp) \
        (((tmp) >> 8) & 0x3F)

#define GP_WB_WRITE_PBM_BLE_FORMAT_T_CHANNEL_CH0(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_T(offset); \
          GP_WB_WRITE_U8((offset) + 0x00d, (val)); \
        } while (0)

#define GP_WB_SET_PBM_BLE_FORMAT_T_CHANNEL_CH0_TO_CHANNEL_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0x3F0007; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* BLE FLL channel to change to when channel_ch1 is enabled */
#define GP_WB_READ_PBM_BLE_FORMAT_T_CHANNEL_CH1(offset) \
        GP_WB_READ_U8((offset) + 0x00e)

#define GP_WB_GET_PBM_BLE_FORMAT_T_CHANNEL_CH1_FROM_CHANNEL_SETTINGS(tmp) \
        (((tmp) >> 16) & 0x3F)

#define GP_WB_WRITE_PBM_BLE_FORMAT_T_CHANNEL_CH1(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_T(offset); \
          GP_WB_WRITE_U8((offset) + 0x00e, (val)); \
        } while (0)

#define GP_WB_SET_PBM_BLE_FORMAT_T_CHANNEL_CH1_TO_CHANNEL_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0x003F07; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_BLE_FORMAT_T_FLOW_CTRL(offset) \
        GP_WB_READ_U8((offset) + 0x00f)

#define GP_WB_WRITE_PBM_BLE_FORMAT_T_FLOW_CTRL(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x00f, (val))

/* When set to the FLL frequency and dac calibration will be skipped. Not advised to do this though ... */
#define GP_WB_READ_PBM_BLE_FORMAT_T_SKIP_CAL(offset) \
        GP_WB_READ_U1((offset) + 0x00f, 0)

#define GP_WB_GET_PBM_BLE_FORMAT_T_SKIP_CAL_FROM_FLOW_CTRL(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_PBM_BLE_FORMAT_T_SKIP_CAL(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00f, 0, (val)); \
        } while (0)

#define GP_WB_SET_PBM_BLE_FORMAT_T_SKIP_CAL_TO_FLOW_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Before each packet transmission, the MAC will check the status of this bits in the sequence and the PHY channel will be set to the corresponding value */
#define GP_WB_READ_PBM_BLE_FORMAT_T_CHANNEL_CH0_EN(offset) \
        GP_WB_READ_U1((offset) + 0x00f, 1)

#define GP_WB_GET_PBM_BLE_FORMAT_T_CHANNEL_CH0_EN_FROM_FLOW_CTRL(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_PBM_BLE_FORMAT_T_CHANNEL_CH0_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00f, 1, (val)); \
        } while (0)

#define GP_WB_SET_PBM_BLE_FORMAT_T_CHANNEL_CH0_EN_TO_FLOW_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* If this bit is set, at the end of the transmission process the PHY channel will be set to the corresponding value */
#define GP_WB_READ_PBM_BLE_FORMAT_T_CHANNEL_CH1_EN(offset) \
        GP_WB_READ_U1((offset) + 0x00f, 2)

#define GP_WB_GET_PBM_BLE_FORMAT_T_CHANNEL_CH1_EN_FROM_FLOW_CTRL(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_PBM_BLE_FORMAT_T_CHANNEL_CH1_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00f, 2, (val)); \
        } while (0)

#define GP_WB_SET_PBM_BLE_FORMAT_T_CHANNEL_CH1_EN_TO_FLOW_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Start tx even when a frame is being received */
#define GP_WB_READ_PBM_BLE_FORMAT_T_TX_INTERRUPT_RX(offset) \
        GP_WB_READ_U1((offset) + 0x00f, 3)

#define GP_WB_GET_PBM_BLE_FORMAT_T_TX_INTERRUPT_RX_FROM_FLOW_CTRL(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_PBM_BLE_FORMAT_T_TX_INTERRUPT_RX(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00f, 3, (val)); \
        } while (0)

#define GP_WB_SET_PBM_BLE_FORMAT_T_TX_INTERRUPT_RX_TO_FLOW_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Perform tx even if timestamp has already passed (eg due to calibration taking too long) */
#define GP_WB_READ_PBM_BLE_FORMAT_T_TX_IF_TOO_LATE(offset) \
        GP_WB_READ_U1((offset) + 0x00f, 4)

#define GP_WB_GET_PBM_BLE_FORMAT_T_TX_IF_TOO_LATE_FROM_FLOW_CTRL(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_PBM_BLE_FORMAT_T_TX_IF_TOO_LATE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00f, 4, (val)); \
        } while (0)

#define GP_WB_SET_PBM_BLE_FORMAT_T_TX_IF_TOO_LATE_TO_FLOW_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Do tx on given timestamp */
#define GP_WB_READ_PBM_BLE_FORMAT_T_TX_ON_TIMESTAMP(offset) \
        GP_WB_READ_U1((offset) + 0x00f, 5)

#define GP_WB_GET_PBM_BLE_FORMAT_T_TX_ON_TIMESTAMP_FROM_FLOW_CTRL(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_PBM_BLE_FORMAT_T_TX_ON_TIMESTAMP(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00f, 5, (val)); \
        } while (0)

#define GP_WB_SET_PBM_BLE_FORMAT_T_TX_ON_TIMESTAMP_TO_FLOW_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* If set, no CRC is added in the end of the packet, it allows the SW to send without CRC or to create a custom CRC */
#define GP_WB_READ_PBM_BLE_FORMAT_T_FCS_INSERT_DIS(offset) \
        GP_WB_READ_U1((offset) + 0x00f, 6)

#define GP_WB_GET_PBM_BLE_FORMAT_T_FCS_INSERT_DIS_FROM_FLOW_CTRL(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_PBM_BLE_FORMAT_T_FCS_INSERT_DIS(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00f, 6, (val)); \
        } while (0)

#define GP_WB_SET_PBM_BLE_FORMAT_T_FCS_INSERT_DIS_TO_FLOW_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* Enabled BLE whitening */
#define GP_WB_READ_PBM_BLE_FORMAT_T_WHITENING_ENABLE(offset) \
        GP_WB_READ_U1((offset) + 0x00f, 7)

#define GP_WB_GET_PBM_BLE_FORMAT_T_WHITENING_ENABLE_FROM_FLOW_CTRL(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_PBM_BLE_FORMAT_T_WHITENING_ENABLE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00f, 7, (val)); \
        } while (0)

#define GP_WB_SET_PBM_BLE_FORMAT_T_WHITENING_ENABLE_TO_FLOW_CTRL(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* 4 general purpose mode bits that are output to the iob and can be put on pins during the TX phase. This allows for controlling external PA/FEM */
#define GP_WB_READ_PBM_BLE_FORMAT_T_MODE_CTRL(offset) \
        GP_WB_READ_U8((offset) + 0x010)

#define GP_WB_WRITE_PBM_BLE_FORMAT_T_MODE_CTRL(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_T(offset); \
          GP_WB_WRITE_U8((offset) + 0x010, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_PBM_BLE_FORMAT_T_PA_POWER_SETTINGS(offset) \
        GP_WB_READ_U8((offset) + 0x011)

#define GP_WB_WRITE_PBM_BLE_FORMAT_T_PA_POWER_SETTINGS(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x011, (val))

/* Desired Power for transmitted packet */
#define GP_WB_READ_PBM_BLE_FORMAT_T_TX_POWER(offset) \
        (GP_WB_READ_U8((offset) + 0x011) & 0x3F)

#define GP_WB_GET_PBM_BLE_FORMAT_T_TX_POWER_FROM_PA_POWER_SETTINGS(tmp) \
        ((tmp) & 0x3F)

#define GP_WB_WRITE_PBM_BLE_FORMAT_T_TX_POWER(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_T(offset); \
          GP_WB_MWRITE_U8((offset) + 0x011, 0x3F, (val)); \
        } while (0)

#define GP_WB_SET_PBM_BLE_FORMAT_T_TX_POWER_TO_PA_POWER_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          (tmp) &= 0xC0; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Chooses the low PA power curve when set */
#define GP_WB_READ_PBM_BLE_FORMAT_T_PA_LOW(offset) \
        GP_WB_READ_U1((offset) + 0x011, 6)

#define GP_WB_GET_PBM_BLE_FORMAT_T_PA_LOW_FROM_PA_POWER_SETTINGS(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_PBM_BLE_FORMAT_T_PA_LOW(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x011, 6, (val)); \
        } while (0)

#define GP_WB_SET_PBM_BLE_FORMAT_T_PA_LOW_TO_PA_POWER_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

/* Chooses the low ultra low PA power curve when set */
#define GP_WB_READ_PBM_BLE_FORMAT_T_PA_ULTRA_LOW(offset) \
        GP_WB_READ_U1((offset) + 0x011, 7)

#define GP_WB_GET_PBM_BLE_FORMAT_T_PA_ULTRA_LOW_FROM_PA_POWER_SETTINGS(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_PBM_BLE_FORMAT_T_PA_ULTRA_LOW(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_T(offset); \
          GP_WB_MWRITE_U1((offset) + 0x011, 7, (val)); \
        } while (0)

#define GP_WB_SET_PBM_BLE_FORMAT_T_PA_ULTRA_LOW_TO_PA_POWER_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* Supplemental length in us. Includes Guard and Reference periods */
#define GP_WB_READ_PBM_BLE_FORMAT_T_SUPPLEMENTAL_LEN(offset) \
        GP_WB_READ_U8((offset) + 0x012)

#define GP_WB_WRITE_PBM_BLE_FORMAT_T_SUPPLEMENTAL_LEN(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_T(offset); \
          GP_WB_WRITE_U8((offset) + 0x012, (val)); \
        } while (0)


/* Default is -250kHz */
#define GP_WB_READ_PBM_BLE_FORMAT_T_SUPPLEMENTAL_INVERT(offset) \
        GP_WB_READ_U1((offset) + 0x013, 0)

#define GP_WB_WRITE_PBM_BLE_FORMAT_T_SUPPLEMENTAL_INVERT(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_T(offset); \
          GP_WB_WRITE_U8((offset) + 0x013, (val)); \
        } while (0)


/* some spare bytes that can be used to put in some meta data. Could be useful for very lowlevel applications (like macfilter) */
#define GP_WB_READ_PBM_BLE_FORMAT_T_MISC_DATA(offset) \
        GP_WB_READ_U8((offset) + 0x014)

#define GP_WB_WRITE_PBM_BLE_FORMAT_T_MISC_DATA(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_T(offset); \
          GP_WB_WRITE_U8((offset) + 0x014, (val)); \
        } while (0)


/* Index to entry in global PA table (used to identify the original tx power setting that was requested) */
#define GP_WB_READ_PBM_BLE_FORMAT_T_PA_POWER_TABLE_INDEX(offset) \
        GP_WB_READ_U8((offset) + 0x01c)

#define GP_WB_WRITE_PBM_BLE_FORMAT_T_PA_POWER_TABLE_INDEX(offset, val) do { \
          GP_WB_CHECK_OFFSET_PBM_BLE_FORMAT_T(offset); \
          GP_WB_WRITE_U8((offset) + 0x01c, (val)); \
        } while (0)

/***************************
 * layout: short_src_entry
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SHORT_SRC_ENTRY_CHANNEL_IDX_VALID_MASK(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_SHORT_SRC_ENTRY_CHANNEL_IDX_VALID_MASK(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x000, (val))

/* Indicates wheter this short src address entry is valid for channel index 0 */
#define GP_WB_READ_SHORT_SRC_ENTRY_CHANNEL_IDX_0_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x000, 0)

#define GP_WB_GET_SHORT_SRC_ENTRY_CHANNEL_IDX_0_VALID_FROM_CHANNEL_IDX_VALID_MASK(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_SHORT_SRC_ENTRY_CHANNEL_IDX_0_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SHORT_SRC_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 0, (val)); \
        } while (0)

#define GP_WB_SET_SHORT_SRC_ENTRY_CHANNEL_IDX_0_VALID_TO_CHANNEL_IDX_VALID_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Indicates wheter this short src address entry is valid for channel index 1 */
#define GP_WB_READ_SHORT_SRC_ENTRY_CHANNEL_IDX_1_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x000, 1)

#define GP_WB_GET_SHORT_SRC_ENTRY_CHANNEL_IDX_1_VALID_FROM_CHANNEL_IDX_VALID_MASK(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_SHORT_SRC_ENTRY_CHANNEL_IDX_1_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SHORT_SRC_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 1, (val)); \
        } while (0)

#define GP_WB_SET_SHORT_SRC_ENTRY_CHANNEL_IDX_1_VALID_TO_CHANNEL_IDX_VALID_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Indicates wheter this short src address entry is valid for channel index 2 */
#define GP_WB_READ_SHORT_SRC_ENTRY_CHANNEL_IDX_2_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x000, 2)

#define GP_WB_GET_SHORT_SRC_ENTRY_CHANNEL_IDX_2_VALID_FROM_CHANNEL_IDX_VALID_MASK(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_SHORT_SRC_ENTRY_CHANNEL_IDX_2_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SHORT_SRC_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 2, (val)); \
        } while (0)

#define GP_WB_SET_SHORT_SRC_ENTRY_CHANNEL_IDX_2_VALID_TO_CHANNEL_IDX_VALID_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Indicates wheter this short src address entry is valid for channel index 3 */
#define GP_WB_READ_SHORT_SRC_ENTRY_CHANNEL_IDX_3_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x000, 3)

#define GP_WB_GET_SHORT_SRC_ENTRY_CHANNEL_IDX_3_VALID_FROM_CHANNEL_IDX_VALID_MASK(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_SHORT_SRC_ENTRY_CHANNEL_IDX_3_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SHORT_SRC_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 3, (val)); \
        } while (0)

#define GP_WB_SET_SHORT_SRC_ENTRY_CHANNEL_IDX_3_VALID_TO_CHANNEL_IDX_VALID_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Indicates wheter this short src address entry is valid for channel index 4 */
#define GP_WB_READ_SHORT_SRC_ENTRY_CHANNEL_IDX_4_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x000, 4)

#define GP_WB_GET_SHORT_SRC_ENTRY_CHANNEL_IDX_4_VALID_FROM_CHANNEL_IDX_VALID_MASK(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_SHORT_SRC_ENTRY_CHANNEL_IDX_4_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SHORT_SRC_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 4, (val)); \
        } while (0)

#define GP_WB_SET_SHORT_SRC_ENTRY_CHANNEL_IDX_4_VALID_TO_CHANNEL_IDX_VALID_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Indicates wheter this short src address entry is valid for channel index 5 */
#define GP_WB_READ_SHORT_SRC_ENTRY_CHANNEL_IDX_5_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x000, 5)

#define GP_WB_GET_SHORT_SRC_ENTRY_CHANNEL_IDX_5_VALID_FROM_CHANNEL_IDX_VALID_MASK(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_SHORT_SRC_ENTRY_CHANNEL_IDX_5_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SHORT_SRC_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 5, (val)); \
        } while (0)

#define GP_WB_SET_SHORT_SRC_ENTRY_CHANNEL_IDX_5_VALID_TO_CHANNEL_IDX_VALID_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* Indicates wheter this short src address is valid */
#define GP_WB_READ_SHORT_SRC_ENTRY_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x001, 0)

#define GP_WB_WRITE_SHORT_SRC_ENTRY_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SHORT_SRC_ENTRY(offset); \
          GP_WB_WRITE_U8((offset) + 0x001, (val)); \
        } while (0)


/* The pan id for this short src address entry */
#define GP_WB_READ_SHORT_SRC_ENTRY_PAN_ID(offset) \
        GP_WB_READ_U16((offset) + 0x002)

#define GP_WB_WRITE_SHORT_SRC_ENTRY_PAN_ID(offset, val) do { \
          GP_WB_CHECK_OFFSET_SHORT_SRC_ENTRY(offset); \
          GP_WB_WRITE_U16((offset) + 0x002, (val)); \
        } while (0)


/* the short address for this short src address entry */
#define GP_WB_READ_SHORT_SRC_ENTRY_ADDRESS(offset) \
        GP_WB_READ_U16((offset) + 0x004)

#define GP_WB_WRITE_SHORT_SRC_ENTRY_ADDRESS(offset, val) do { \
          GP_WB_CHECK_OFFSET_SHORT_SRC_ENTRY(offset); \
          GP_WB_WRITE_U16((offset) + 0x004, (val)); \
        } while (0)

/***************************
 * layout: long_src_entry
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_LONG_SRC_ENTRY_CHANNEL_IDX_VALID_MASK(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_LONG_SRC_ENTRY_CHANNEL_IDX_VALID_MASK(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x000, (val))

/* Indicates whether this long src address entry is valid for channel index 0 */
#define GP_WB_READ_LONG_SRC_ENTRY_CHANNEL_IDX_0_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x000, 0)

#define GP_WB_GET_LONG_SRC_ENTRY_CHANNEL_IDX_0_VALID_FROM_CHANNEL_IDX_VALID_MASK(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_LONG_SRC_ENTRY_CHANNEL_IDX_0_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_LONG_SRC_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 0, (val)); \
        } while (0)

#define GP_WB_SET_LONG_SRC_ENTRY_CHANNEL_IDX_0_VALID_TO_CHANNEL_IDX_VALID_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Indicates whether this long src address entry is valid for channel index 1 */
#define GP_WB_READ_LONG_SRC_ENTRY_CHANNEL_IDX_1_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x000, 1)

#define GP_WB_GET_LONG_SRC_ENTRY_CHANNEL_IDX_1_VALID_FROM_CHANNEL_IDX_VALID_MASK(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_LONG_SRC_ENTRY_CHANNEL_IDX_1_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_LONG_SRC_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 1, (val)); \
        } while (0)

#define GP_WB_SET_LONG_SRC_ENTRY_CHANNEL_IDX_1_VALID_TO_CHANNEL_IDX_VALID_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Indicates whether this long src address entry is valid for channel index 2 */
#define GP_WB_READ_LONG_SRC_ENTRY_CHANNEL_IDX_2_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x000, 2)

#define GP_WB_GET_LONG_SRC_ENTRY_CHANNEL_IDX_2_VALID_FROM_CHANNEL_IDX_VALID_MASK(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_LONG_SRC_ENTRY_CHANNEL_IDX_2_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_LONG_SRC_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 2, (val)); \
        } while (0)

#define GP_WB_SET_LONG_SRC_ENTRY_CHANNEL_IDX_2_VALID_TO_CHANNEL_IDX_VALID_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Indicates whether this long src address entry is valid for channel index 3 */
#define GP_WB_READ_LONG_SRC_ENTRY_CHANNEL_IDX_3_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x000, 3)

#define GP_WB_GET_LONG_SRC_ENTRY_CHANNEL_IDX_3_VALID_FROM_CHANNEL_IDX_VALID_MASK(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_LONG_SRC_ENTRY_CHANNEL_IDX_3_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_LONG_SRC_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 3, (val)); \
        } while (0)

#define GP_WB_SET_LONG_SRC_ENTRY_CHANNEL_IDX_3_VALID_TO_CHANNEL_IDX_VALID_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Indicates whether this long src address entry is valid for channel index 4 */
#define GP_WB_READ_LONG_SRC_ENTRY_CHANNEL_IDX_4_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x000, 4)

#define GP_WB_GET_LONG_SRC_ENTRY_CHANNEL_IDX_4_VALID_FROM_CHANNEL_IDX_VALID_MASK(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_LONG_SRC_ENTRY_CHANNEL_IDX_4_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_LONG_SRC_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 4, (val)); \
        } while (0)

#define GP_WB_SET_LONG_SRC_ENTRY_CHANNEL_IDX_4_VALID_TO_CHANNEL_IDX_VALID_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Indicates whether this long src address entry is valid for channel index 5 */
#define GP_WB_READ_LONG_SRC_ENTRY_CHANNEL_IDX_5_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x000, 5)

#define GP_WB_GET_LONG_SRC_ENTRY_CHANNEL_IDX_5_VALID_FROM_CHANNEL_IDX_VALID_MASK(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_LONG_SRC_ENTRY_CHANNEL_IDX_5_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_LONG_SRC_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 5, (val)); \
        } while (0)

#define GP_WB_SET_LONG_SRC_ENTRY_CHANNEL_IDX_5_VALID_TO_CHANNEL_IDX_VALID_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* Indicates whether this long src address is valid */
#define GP_WB_READ_LONG_SRC_ENTRY_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x001, 0)

#define GP_WB_WRITE_LONG_SRC_ENTRY_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_LONG_SRC_ENTRY(offset); \
          GP_WB_WRITE_U8((offset) + 0x001, (val)); \
        } while (0)


/* The pan id for this long src address entry */
#define GP_WB_READ_LONG_SRC_ENTRY_PAN_ID(offset) \
        GP_WB_READ_U16((offset) + 0x002)

#define GP_WB_WRITE_LONG_SRC_ENTRY_PAN_ID(offset, val) do { \
          GP_WB_CHECK_OFFSET_LONG_SRC_ENTRY(offset); \
          GP_WB_WRITE_U16((offset) + 0x002, (val)); \
        } while (0)


/* the long address for this long src address entry */
#define GP_WB_READ_LONG_SRC_ENTRY_ADDRESS(offset) \
        GP_WB_READ_U64((offset) + 0x004)

#define GP_WB_WRITE_LONG_SRC_ENTRY_ADDRESS(offset, val) do { \
          GP_WB_CHECK_OFFSET_LONG_SRC_ENTRY(offset); \
          GP_WB_WRITE_U64((offset) + 0x004, (val)); \
        } while (0)

/***************************
 * layout: zb_rawmode_nonce
 ***************************/

/* macaddress to be used in the nonce for the tx encryption */
#define GP_WB_READ_ZB_RAWMODE_NONCE_MACADDRESS(offset) \
        GP_WB_READ_U64((offset) + 0x000)

#define GP_WB_WRITE_ZB_RAWMODE_NONCE_MACADDRESS(offset, val) do { \
          GP_WB_CHECK_OFFSET_ZB_RAWMODE_NONCE(offset); \
          GP_WB_WRITE_U64((offset) + 0x000, (val)); \
        } while (0)


/* framecounter to be used in raw mode for tx frames */
#define GP_WB_READ_ZB_RAWMODE_NONCE_FRAMECOUNTER(offset) \
        GP_WB_READ_U32((offset) + 0x008)

#define GP_WB_WRITE_ZB_RAWMODE_NONCE_FRAMECOUNTER(offset, val) do { \
          GP_WB_CHECK_OFFSET_ZB_RAWMODE_NONCE(offset); \
          GP_WB_WRITE_U32((offset) + 0x008, (val)); \
        } while (0)


/* seclevel to be used in the nonce for the tx encryption */
#define GP_WB_READ_ZB_RAWMODE_NONCE_SECLEVEL(offset) \
        GP_WB_READ_U8((offset) + 0x00c)

#define GP_WB_WRITE_ZB_RAWMODE_NONCE_SECLEVEL(offset, val) do { \
          GP_WB_CHECK_OFFSET_ZB_RAWMODE_NONCE(offset); \
          GP_WB_WRITE_U8((offset) + 0x00c, (val)); \
        } while (0)

/***************************
 * layout: zb_rawmode_key_info
 ***************************/

/* current key to be used in raw mode for tx frames */
#define GP_WB_READ_ZB_RAWMODE_KEY_INFO_CURRKEY(offset) \
        GP_WB_READ_U128((offset) + 0x000)

#define GP_WB_WRITE_ZB_RAWMODE_KEY_INFO_CURRKEY(offset, val) do { \
          GP_WB_CHECK_OFFSET_ZB_RAWMODE_KEY_INFO(offset); \
          GP_WB_WRITE_U128((offset) + 0x000, (val)); \
        } while (0)


/* key index corresponding to the current key to be used in raw mode for tx frames */
#define GP_WB_READ_ZB_RAWMODE_KEY_INFO_KEYID(offset) \
        GP_WB_READ_U8((offset) + 0x010)

#define GP_WB_WRITE_ZB_RAWMODE_KEY_INFO_KEYID(offset, val) do { \
          GP_WB_CHECK_OFFSET_ZB_RAWMODE_KEY_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x010, (val)); \
        } while (0)

/***************************
 * layout: zb_rawmode_vsie
 ***************************/

/* content of the VS IE which needs to be added to EnhAck frames. */
#define GP_WB_READ_ZB_RAWMODE_VSIE_VSIEDATA(offset) \
        GP_WB_READ_U64((offset) + 0x000)

#define GP_WB_WRITE_ZB_RAWMODE_VSIE_VSIEDATA(offset, val) do { \
          GP_WB_CHECK_OFFSET_ZB_RAWMODE_VSIE(offset); \
          GP_WB_WRITE_U64((offset) + 0x000, (val)); \
        } while (0)


/* length of the VS IE which needs to be added to EnhAck frames. Use 0 to disable. */
#define GP_WB_READ_ZB_RAWMODE_VSIE_VSIELEN(offset) \
        GP_WB_READ_U8((offset) + 0x008)

#define GP_WB_WRITE_ZB_RAWMODE_VSIE_VSIELEN(offset, val) do { \
          GP_WB_CHECK_OFFSET_ZB_RAWMODE_VSIE(offset); \
          GP_WB_WRITE_U8((offset) + 0x008, (val)); \
        } while (0)

/***************************
 * layout: ble_whitelist_entry
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BLE_WHITELIST_ENTRY_VALID_FRAME_TYPE_MASK(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_BLE_WHITELIST_ENTRY_VALID_FRAME_TYPE_MASK(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x000, (val))

/* Indicates whether this device address is valid for adv_ind frames */
#define GP_WB_READ_BLE_WHITELIST_ENTRY_FT_ADV_IND_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x000, 0)

#define GP_WB_GET_BLE_WHITELIST_ENTRY_FT_ADV_IND_VALID_FROM_VALID_FRAME_TYPE_MASK(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_BLE_WHITELIST_ENTRY_FT_ADV_IND_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_WHITELIST_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 0, (val)); \
        } while (0)

#define GP_WB_SET_BLE_WHITELIST_ENTRY_FT_ADV_IND_VALID_TO_VALID_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Indicates whether this device address is valid for adv_direct_ind frames */
#define GP_WB_READ_BLE_WHITELIST_ENTRY_FT_ADV_DIRECT_IND_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x000, 1)

#define GP_WB_GET_BLE_WHITELIST_ENTRY_FT_ADV_DIRECT_IND_VALID_FROM_VALID_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_BLE_WHITELIST_ENTRY_FT_ADV_DIRECT_IND_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_WHITELIST_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 1, (val)); \
        } while (0)

#define GP_WB_SET_BLE_WHITELIST_ENTRY_FT_ADV_DIRECT_IND_VALID_TO_VALID_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Indicates whether this device address is valid for adv_nonconn_ind frames */
#define GP_WB_READ_BLE_WHITELIST_ENTRY_FT_ADV_NONCONN_IND_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x000, 2)

#define GP_WB_GET_BLE_WHITELIST_ENTRY_FT_ADV_NONCONN_IND_VALID_FROM_VALID_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_BLE_WHITELIST_ENTRY_FT_ADV_NONCONN_IND_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_WHITELIST_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 2, (val)); \
        } while (0)

#define GP_WB_SET_BLE_WHITELIST_ENTRY_FT_ADV_NONCONN_IND_VALID_TO_VALID_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Indicates whether this device address is valid for scan_req frames */
#define GP_WB_READ_BLE_WHITELIST_ENTRY_FT_SCAN_REQ_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x000, 3)

#define GP_WB_GET_BLE_WHITELIST_ENTRY_FT_SCAN_REQ_VALID_FROM_VALID_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_BLE_WHITELIST_ENTRY_FT_SCAN_REQ_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_WHITELIST_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 3, (val)); \
        } while (0)

#define GP_WB_SET_BLE_WHITELIST_ENTRY_FT_SCAN_REQ_VALID_TO_VALID_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Indicates whether this device address is valid for scan_req frames */
#define GP_WB_READ_BLE_WHITELIST_ENTRY_FT_AUX_SCAN_REQ_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x000, 3)

#define GP_WB_GET_BLE_WHITELIST_ENTRY_FT_AUX_SCAN_REQ_VALID_FROM_VALID_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_BLE_WHITELIST_ENTRY_FT_AUX_SCAN_REQ_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_WHITELIST_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 3, (val)); \
        } while (0)

#define GP_WB_SET_BLE_WHITELIST_ENTRY_FT_AUX_SCAN_REQ_VALID_TO_VALID_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Indicates whether this device address is valid for scan_rsp frames */
#define GP_WB_READ_BLE_WHITELIST_ENTRY_FT_SCAN_RSP_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x000, 4)

#define GP_WB_GET_BLE_WHITELIST_ENTRY_FT_SCAN_RSP_VALID_FROM_VALID_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_BLE_WHITELIST_ENTRY_FT_SCAN_RSP_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_WHITELIST_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 4, (val)); \
        } while (0)

#define GP_WB_SET_BLE_WHITELIST_ENTRY_FT_SCAN_RSP_VALID_TO_VALID_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* Indicates whether this device address is valid for connect_req frames */
#define GP_WB_READ_BLE_WHITELIST_ENTRY_FT_CONNECT_REQ_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x000, 5)

#define GP_WB_GET_BLE_WHITELIST_ENTRY_FT_CONNECT_REQ_VALID_FROM_VALID_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_BLE_WHITELIST_ENTRY_FT_CONNECT_REQ_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_WHITELIST_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 5, (val)); \
        } while (0)

#define GP_WB_SET_BLE_WHITELIST_ENTRY_FT_CONNECT_REQ_VALID_TO_VALID_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* Indicates whether this device address is valid for connect_req frames */
#define GP_WB_READ_BLE_WHITELIST_ENTRY_FT_AUX_CONNECT_REQ_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x000, 5)

#define GP_WB_GET_BLE_WHITELIST_ENTRY_FT_AUX_CONNECT_REQ_VALID_FROM_VALID_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_BLE_WHITELIST_ENTRY_FT_AUX_CONNECT_REQ_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_WHITELIST_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 5, (val)); \
        } while (0)

#define GP_WB_SET_BLE_WHITELIST_ENTRY_FT_AUX_CONNECT_REQ_VALID_TO_VALID_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

/* Indicates whether this device address is valid for adv_scan_ind frames */
#define GP_WB_READ_BLE_WHITELIST_ENTRY_FT_ADV_SCAN_IND_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x000, 6)

#define GP_WB_GET_BLE_WHITELIST_ENTRY_FT_ADV_SCAN_IND_VALID_FROM_VALID_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_BLE_WHITELIST_ENTRY_FT_ADV_SCAN_IND_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_WHITELIST_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 6, (val)); \
        } while (0)

#define GP_WB_SET_BLE_WHITELIST_ENTRY_FT_ADV_SCAN_IND_VALID_TO_VALID_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

#define GP_WB_READ_BLE_WHITELIST_ENTRY_FT_ADV_EXT_IND_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x000, 7)

#define GP_WB_GET_BLE_WHITELIST_ENTRY_FT_ADV_EXT_IND_VALID_FROM_VALID_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_BLE_WHITELIST_ENTRY_FT_ADV_EXT_IND_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_WHITELIST_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 7, (val)); \
        } while (0)

#define GP_WB_SET_BLE_WHITELIST_ENTRY_FT_ADV_EXT_IND_VALID_TO_VALID_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)

#define GP_WB_READ_BLE_WHITELIST_ENTRY_FT_AUX_ADV_IND_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x000, 7)

#define GP_WB_GET_BLE_WHITELIST_ENTRY_FT_AUX_ADV_IND_VALID_FROM_VALID_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_BLE_WHITELIST_ENTRY_FT_AUX_ADV_IND_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_WHITELIST_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 7, (val)); \
        } while (0)

#define GP_WB_SET_BLE_WHITELIST_ENTRY_FT_AUX_ADV_IND_VALID_TO_VALID_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)

#define GP_WB_READ_BLE_WHITELIST_ENTRY_FT_AUX_SCAN_RSP_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x000, 7)

#define GP_WB_GET_BLE_WHITELIST_ENTRY_FT_AUX_SCAN_RSP_VALID_FROM_VALID_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_BLE_WHITELIST_ENTRY_FT_AUX_SCAN_RSP_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_WHITELIST_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 7, (val)); \
        } while (0)

#define GP_WB_SET_BLE_WHITELIST_ENTRY_FT_AUX_SCAN_RSP_VALID_TO_VALID_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)

#define GP_WB_READ_BLE_WHITELIST_ENTRY_FT_AUX_SYNC_IND_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x000, 7)

#define GP_WB_GET_BLE_WHITELIST_ENTRY_FT_AUX_SYNC_IND_VALID_FROM_VALID_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_BLE_WHITELIST_ENTRY_FT_AUX_SYNC_IND_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_WHITELIST_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 7, (val)); \
        } while (0)

#define GP_WB_SET_BLE_WHITELIST_ENTRY_FT_AUX_SYNC_IND_VALID_TO_VALID_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)

#define GP_WB_READ_BLE_WHITELIST_ENTRY_FT_AUX_CHAIN_IND_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x000, 7)

#define GP_WB_GET_BLE_WHITELIST_ENTRY_FT_AUX_CHAIN_IND_VALID_FROM_VALID_FRAME_TYPE_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_BLE_WHITELIST_ENTRY_FT_AUX_CHAIN_IND_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_WHITELIST_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 7, (val)); \
        } while (0)

#define GP_WB_SET_BLE_WHITELIST_ENTRY_FT_AUX_CHAIN_IND_VALID_TO_VALID_FRAME_TYPE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BLE_WHITELIST_ENTRY_VALID_STATE_MASK_ADDRESS_TYPE(offset) \
        GP_WB_READ_U8((offset) + 0x001)

#define GP_WB_WRITE_BLE_WHITELIST_ENTRY_VALID_STATE_MASK_ADDRESS_TYPE(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x001, (val))

/* Indicates whether this entry is regular whitelist entry or controller specific: 0b0 = controller specific, 0b1 = regular entry */
#define GP_WB_READ_BLE_WHITELIST_ENTRY_S_ENTRY_TYPE(offset) \
        GP_WB_READ_U1((offset) + 0x001, 0)

#define GP_WB_GET_BLE_WHITELIST_ENTRY_S_ENTRY_TYPE_FROM_VALID_STATE_MASK_ADDRESS_TYPE(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_BLE_WHITELIST_ENTRY_S_ENTRY_TYPE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_WHITELIST_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 0, (val)); \
        } while (0)

#define GP_WB_SET_BLE_WHITELIST_ENTRY_S_ENTRY_TYPE_TO_VALID_STATE_MASK_ADDRESS_TYPE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Indicates whether this device address valid when the BLE manager is in the advertising state */
#define GP_WB_READ_BLE_WHITELIST_ENTRY_S_ADVERTISING_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x001, 1)

#define GP_WB_GET_BLE_WHITELIST_ENTRY_S_ADVERTISING_VALID_FROM_VALID_STATE_MASK_ADDRESS_TYPE(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_BLE_WHITELIST_ENTRY_S_ADVERTISING_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_WHITELIST_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 1, (val)); \
        } while (0)

#define GP_WB_SET_BLE_WHITELIST_ENTRY_S_ADVERTISING_VALID_TO_VALID_STATE_MASK_ADDRESS_TYPE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Indicates whether this device address valid when the BLE manager is in the scanning state */
#define GP_WB_READ_BLE_WHITELIST_ENTRY_S_SCANNING_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x001, 2)

#define GP_WB_GET_BLE_WHITELIST_ENTRY_S_SCANNING_VALID_FROM_VALID_STATE_MASK_ADDRESS_TYPE(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_BLE_WHITELIST_ENTRY_S_SCANNING_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_WHITELIST_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 2, (val)); \
        } while (0)

#define GP_WB_SET_BLE_WHITELIST_ENTRY_S_SCANNING_VALID_TO_VALID_STATE_MASK_ADDRESS_TYPE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Indicates whether this device address valid when the BLE manager is in the initiating state */
#define GP_WB_READ_BLE_WHITELIST_ENTRY_S_INTIATING_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x001, 3)

#define GP_WB_GET_BLE_WHITELIST_ENTRY_S_INTIATING_VALID_FROM_VALID_STATE_MASK_ADDRESS_TYPE(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_BLE_WHITELIST_ENTRY_S_INTIATING_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_WHITELIST_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 3, (val)); \
        } while (0)

#define GP_WB_SET_BLE_WHITELIST_ENTRY_S_INTIATING_VALID_TO_VALID_STATE_MASK_ADDRESS_TYPE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xD7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Indicates whether this device address valid when the BLE manager is in the periodic sync state */
#define GP_WB_READ_BLE_WHITELIST_ENTRY_S_PERSYNC_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x001, 4)

#define GP_WB_GET_BLE_WHITELIST_ENTRY_S_PERSYNC_VALID_FROM_VALID_STATE_MASK_ADDRESS_TYPE(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_BLE_WHITELIST_ENTRY_S_PERSYNC_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_WHITELIST_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 4, (val)); \
        } while (0)

#define GP_WB_SET_BLE_WHITELIST_ENTRY_S_PERSYNC_VALID_TO_VALID_STATE_MASK_ADDRESS_TYPE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xCF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* 0b01 = (0)public, 0b10 = (1)random, or just trx_add+1 */
#define GP_WB_READ_BLE_WHITELIST_ENTRY_ADDRESS_TYPE(offset) \
        ((GP_WB_READ_U8((offset) + 0x001) >> 6) & 0x03)

#define GP_WB_GET_BLE_WHITELIST_ENTRY_ADDRESS_TYPE_FROM_VALID_STATE_MASK_ADDRESS_TYPE(tmp) \
        (((tmp) >> 6) & 0x03)

#define GP_WB_WRITE_BLE_WHITELIST_ENTRY_ADDRESS_TYPE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_CHECK_OFFSET_BLE_WHITELIST_ENTRY(offset); \
          GP_WB_MWRITE_U8((offset) + 0x001, 0xC0, (val) << 6); \
        } while (0)

#define GP_WB_SET_BLE_WHITELIST_ENTRY_ADDRESS_TYPE_TO_VALID_STATE_MASK_ADDRESS_TYPE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)


/* 6 byte device address */
#define GP_WB_READ_BLE_WHITELIST_ENTRY_DEVICE_ADDRESS(offset) \
        GP_WB_READ_U48((offset) + 0x002)

#define GP_WB_WRITE_BLE_WHITELIST_ENTRY_DEVICE_ADDRESS(offset, val) do { \
          GP_WB_CHECK_OFFSET_BLE_WHITELIST_ENTRY(offset); \
          GP_WB_WRITE_U48((offset) + 0x002, (val)); \
        } while (0)

/***************************
 * layout: ble_res_pr_identity_entry
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BLE_RES_PR_IDENTITY_ENTRY_FLAGS(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_BLE_RES_PR_IDENTITY_ENTRY_FLAGS(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x000, (val))

/* Is public device address (cannot be both public and random!). To enable entry matching with mem_part_match. */
#define GP_WB_READ_BLE_RES_PR_IDENTITY_ENTRY_IS_PUBLIC_PEER_ADDRESS(offset) \
        GP_WB_READ_U1((offset) + 0x000, 0)

#define GP_WB_GET_BLE_RES_PR_IDENTITY_ENTRY_IS_PUBLIC_PEER_ADDRESS_FROM_FLAGS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_BLE_RES_PR_IDENTITY_ENTRY_IS_PUBLIC_PEER_ADDRESS(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_RES_PR_IDENTITY_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 0, (val)); \
        } while (0)

#define GP_WB_SET_BLE_RES_PR_IDENTITY_ENTRY_IS_PUBLIC_PEER_ADDRESS_TO_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Is random device address (cannot be both public and random!). To enable entry matching with mem_part_match. */
#define GP_WB_READ_BLE_RES_PR_IDENTITY_ENTRY_IS_RANDOM_PEER_ADDRESS(offset) \
        GP_WB_READ_U1((offset) + 0x000, 1)

#define GP_WB_GET_BLE_RES_PR_IDENTITY_ENTRY_IS_RANDOM_PEER_ADDRESS_FROM_FLAGS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_BLE_RES_PR_IDENTITY_ENTRY_IS_RANDOM_PEER_ADDRESS(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_RES_PR_IDENTITY_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 1, (val)); \
        } while (0)

#define GP_WB_SET_BLE_RES_PR_IDENTITY_ENTRY_IS_RANDOM_PEER_ADDRESS_TO_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* 0==network privacy, 1==device privacy */
#define GP_WB_READ_BLE_RES_PR_IDENTITY_ENTRY_PRIVACY_MODE(offset) \
        GP_WB_READ_U1((offset) + 0x000, 2)

#define GP_WB_GET_BLE_RES_PR_IDENTITY_ENTRY_PRIVACY_MODE_FROM_FLAGS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_BLE_RES_PR_IDENTITY_ENTRY_PRIVACY_MODE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_RES_PR_IDENTITY_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 2, (val)); \
        } while (0)

#define GP_WB_SET_BLE_RES_PR_IDENTITY_ENTRY_PRIVACY_MODE_TO_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Indicates whether this device address is valid for scan_rsp frames */
#define GP_WB_READ_BLE_RES_PR_IDENTITY_ENTRY_ALL_ZEROS_LOCAL_IRK(offset) \
        GP_WB_READ_U1((offset) + 0x000, 3)

#define GP_WB_GET_BLE_RES_PR_IDENTITY_ENTRY_ALL_ZEROS_LOCAL_IRK_FROM_FLAGS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_BLE_RES_PR_IDENTITY_ENTRY_ALL_ZEROS_LOCAL_IRK(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_RES_PR_IDENTITY_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 3, (val)); \
        } while (0)

#define GP_WB_SET_BLE_RES_PR_IDENTITY_ENTRY_ALL_ZEROS_LOCAL_IRK_TO_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* Indicates whether this device address is valid for scan_rsp frames */
#define GP_WB_READ_BLE_RES_PR_IDENTITY_ENTRY_ALL_ZEROS_PEER_IRK(offset) \
        GP_WB_READ_U1((offset) + 0x000, 4)

#define GP_WB_GET_BLE_RES_PR_IDENTITY_ENTRY_ALL_ZEROS_PEER_IRK_FROM_FLAGS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_BLE_RES_PR_IDENTITY_ENTRY_ALL_ZEROS_PEER_IRK(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_RES_PR_IDENTITY_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 4, (val)); \
        } while (0)

#define GP_WB_SET_BLE_RES_PR_IDENTITY_ENTRY_ALL_ZEROS_PEER_IRK_TO_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* if 1, wl_idx is valid */
#define GP_WB_READ_BLE_RES_PR_IDENTITY_ENTRY_WL_IDX_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x000, 5)

#define GP_WB_GET_BLE_RES_PR_IDENTITY_ENTRY_WL_IDX_VALID_FROM_FLAGS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_BLE_RES_PR_IDENTITY_ENTRY_WL_IDX_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_RES_PR_IDENTITY_ENTRY(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 5, (val)); \
        } while (0)

#define GP_WB_SET_BLE_RES_PR_IDENTITY_ENTRY_WL_IDX_VALID_TO_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* index of the corresponding entry in the whitelist table */
#define GP_WB_READ_BLE_RES_PR_IDENTITY_ENTRY_WL_IDX(offset) \
        GP_WB_READ_U8((offset) + 0x001)

#define GP_WB_WRITE_BLE_RES_PR_IDENTITY_ENTRY_WL_IDX(offset, val) do { \
          GP_WB_CHECK_OFFSET_BLE_RES_PR_IDENTITY_ENTRY(offset); \
          GP_WB_WRITE_U8((offset) + 0x001, (val)); \
        } while (0)


/* Indicates whether this device address is valid for adv_direct_ind frames */
#define GP_WB_READ_BLE_RES_PR_IDENTITY_ENTRY_PEER_IDENTITY_ADDRESS(offset) \
        GP_WB_READ_U48((offset) + 0x002)

#define GP_WB_WRITE_BLE_RES_PR_IDENTITY_ENTRY_PEER_IDENTITY_ADDRESS(offset, val) do { \
          GP_WB_CHECK_OFFSET_BLE_RES_PR_IDENTITY_ENTRY(offset); \
          GP_WB_WRITE_U48((offset) + 0x002, (val)); \
        } while (0)

/***************************
 * layout: dsfix_ch
 ***************************/

#define GP_WB_READ_DSFIX_CH_CHANNEL(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_DSFIX_CH_CHANNEL(offset, val) do { \
          GP_WB_CHECK_OFFSET_DSFIX_CH(offset); \
          GP_WB_WRITE_U8((offset) + 0x000, (val)); \
        } while (0)

#define GP_WB_READ_DSFIX_CH_LOWEST_RSSI(offset) \
        GP_WB_READ_U8((offset) + 0x001)

#define GP_WB_WRITE_DSFIX_CH_LOWEST_RSSI(offset, val) do { \
          GP_WB_CHECK_OFFSET_DSFIX_CH(offset); \
          GP_WB_WRITE_U8((offset) + 0x001, (val)); \
        } while (0)

/* counter that keeps the number of param0 wraps, is reset when rssi ageing is applied (rssi_ageing_cnt >= rssi_ageing_threshold) */
#define GP_WB_READ_DSFIX_CH_RSSI_AGEING_CNT(offset) \
        GP_WB_READ_U8((offset) + 0x002)

#define GP_WB_WRITE_DSFIX_CH_RSSI_AGEING_CNT(offset, val) do { \
          GP_WB_CHECK_OFFSET_DSFIX_CH(offset); \
          GP_WB_WRITE_U8((offset) + 0x002, (val)); \
        } while (0)

/* counter that keeps the number of measurements since the last best param combination was checked. is reset when a new best param combination was found or when the best param combination is forced to be checked (lock_poll_cnt >= lock_poll_threshold) */
#define GP_WB_READ_DSFIX_CH_BEST_POLL_CNT(offset) \
        GP_WB_READ_U8((offset) + 0x003)

#define GP_WB_WRITE_DSFIX_CH_BEST_POLL_CNT(offset, val) do { \
          GP_WB_CHECK_OFFSET_DSFIX_CH(offset); \
          GP_WB_WRITE_U8((offset) + 0x003, (val)); \
        } while (0)

/* number of times the full set of params was sweeped, stops counting at 255 */
#define GP_WB_READ_DSFIX_CH_PARAM_SWEEP_CNT(offset) \
        GP_WB_READ_U8((offset) + 0x004)

#define GP_WB_WRITE_DSFIX_CH_PARAM_SWEEP_CNT(offset, val) do { \
          GP_WB_CHECK_OFFSET_DSFIX_CH(offset); \
          GP_WB_WRITE_U8((offset) + 0x004, (val)); \
        } while (0)


#define GP_WB_READ_DSFIX_CH_CUR_PARAM0(offset) \
        (GP_WB_S8(GP_WB_READ_U8((offset) + 0x006), 8))

#define GP_WB_WRITE_DSFIX_CH_CUR_PARAM0(offset, val) do { \
          GP_WB_CHECK_OFFSET_DSFIX_CH(offset); \
          GP_WB_WRITE_U8((offset) + 0x006, (UInt8)((val))); \
        } while (0)

#define GP_WB_READ_DSFIX_CH_CUR_PARAM1(offset) \
        (GP_WB_S8(GP_WB_READ_U8((offset) + 0x007), 8))

#define GP_WB_WRITE_DSFIX_CH_CUR_PARAM1(offset, val) do { \
          GP_WB_CHECK_OFFSET_DSFIX_CH(offset); \
          GP_WB_WRITE_U8((offset) + 0x007, (UInt8)((val))); \
        } while (0)

#define GP_WB_READ_DSFIX_CH_CUR_PARAM2(offset) \
        (GP_WB_S8(GP_WB_READ_U8((offset) + 0x008), 8))

#define GP_WB_WRITE_DSFIX_CH_CUR_PARAM2(offset, val) do { \
          GP_WB_CHECK_OFFSET_DSFIX_CH(offset); \
          GP_WB_WRITE_U8((offset) + 0x008, (UInt8)((val))); \
        } while (0)

#define GP_WB_READ_DSFIX_CH_CUR_PARAM3(offset) \
        (GP_WB_S8(GP_WB_READ_U8((offset) + 0x009), 8))

#define GP_WB_WRITE_DSFIX_CH_CUR_PARAM3(offset, val) do { \
          GP_WB_CHECK_OFFSET_DSFIX_CH(offset); \
          GP_WB_WRITE_U8((offset) + 0x009, (UInt8)((val))); \
        } while (0)


#define GP_WB_READ_DSFIX_CH_BEST_PARAM0(offset) \
        (GP_WB_S8(GP_WB_READ_U8((offset) + 0x00a), 8))

#define GP_WB_WRITE_DSFIX_CH_BEST_PARAM0(offset, val) do { \
          GP_WB_CHECK_OFFSET_DSFIX_CH(offset); \
          GP_WB_WRITE_U8((offset) + 0x00a, (UInt8)((val))); \
        } while (0)

#define GP_WB_READ_DSFIX_CH_BEST_PARAM1(offset) \
        (GP_WB_S8(GP_WB_READ_U8((offset) + 0x00b), 8))

#define GP_WB_WRITE_DSFIX_CH_BEST_PARAM1(offset, val) do { \
          GP_WB_CHECK_OFFSET_DSFIX_CH(offset); \
          GP_WB_WRITE_U8((offset) + 0x00b, (UInt8)((val))); \
        } while (0)

#define GP_WB_READ_DSFIX_CH_BEST_PARAM2(offset) \
        (GP_WB_S8(GP_WB_READ_U8((offset) + 0x00c), 8))

#define GP_WB_WRITE_DSFIX_CH_BEST_PARAM2(offset, val) do { \
          GP_WB_CHECK_OFFSET_DSFIX_CH(offset); \
          GP_WB_WRITE_U8((offset) + 0x00c, (UInt8)((val))); \
        } while (0)

#define GP_WB_READ_DSFIX_CH_BEST_PARAM3(offset) \
        (GP_WB_S8(GP_WB_READ_U8((offset) + 0x00d), 8))

#define GP_WB_WRITE_DSFIX_CH_BEST_PARAM3(offset, val) do { \
          GP_WB_CHECK_OFFSET_DSFIX_CH(offset); \
          GP_WB_WRITE_U8((offset) + 0x00d, (UInt8)((val))); \
        } while (0)

/***************************
 * layout: dsfix_param
 ***************************/

#define GP_WB_READ_DSFIX_PARAM_LSB(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_DSFIX_PARAM_LSB(offset, val) do { \
          GP_WB_CHECK_OFFSET_DSFIX_PARAM(offset); \
          GP_WB_WRITE_U8((offset) + 0x000, (val)); \
        } while (0)

#define GP_WB_READ_DSFIX_PARAM_MASK(offset) \
        GP_WB_READ_U8((offset) + 0x001)

#define GP_WB_WRITE_DSFIX_PARAM_MASK(offset, val) do { \
          GP_WB_CHECK_OFFSET_DSFIX_PARAM(offset); \
          GP_WB_WRITE_U8((offset) + 0x001, (val)); \
        } while (0)

#define GP_WB_READ_DSFIX_PARAM_ADDRESS(offset) \
        GP_WB_READ_U16((offset) + 0x002)

#define GP_WB_WRITE_DSFIX_PARAM_ADDRESS(offset, val) do { \
          GP_WB_CHECK_OFFSET_DSFIX_PARAM(offset); \
          GP_WB_WRITE_U16((offset) + 0x002, (val)); \
        } while (0)

#define GP_WB_READ_DSFIX_PARAM_MIN(offset) \
        (GP_WB_S8(GP_WB_READ_U8((offset) + 0x004), 8))

#define GP_WB_WRITE_DSFIX_PARAM_MIN(offset, val) do { \
          GP_WB_CHECK_OFFSET_DSFIX_PARAM(offset); \
          GP_WB_WRITE_U8((offset) + 0x004, (UInt8)((val))); \
        } while (0)

#define GP_WB_READ_DSFIX_PARAM_MAX(offset) \
        (GP_WB_S8(GP_WB_READ_U8((offset) + 0x005), 8))

#define GP_WB_WRITE_DSFIX_PARAM_MAX(offset, val) do { \
          GP_WB_CHECK_OFFSET_DSFIX_PARAM(offset); \
          GP_WB_WRITE_U8((offset) + 0x005, (UInt8)((val))); \
        } while (0)

/***************************
 * layout: adv_ev_info
 ***************************/

/* priority of the event, (0= lowest priority; 255 is highest priority) */
#define GP_WB_READ_ADV_EV_INFO_PRIORITY(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_ADV_EV_INFO_PRIORITY(offset, val) do { \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x000, (val)); \
        } while (0)


/* when enabled, the event will not do any radio activity and the event will be skipped. The event state will still be updated though. */
#define GP_WB_READ_ADV_EV_INFO_SUSPEND_EVENT(offset) \
        GP_WB_READ_U1((offset) + 0x001, 0)

#define GP_WB_WRITE_ADV_EV_INFO_SUSPEND_EVENT(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 0, (val)); \
        } while (0)

/* when 1, the round robin mechanism will also take into account the nr_consec_skipped_events for this event */
#define GP_WB_READ_ADV_EV_INFO_EXTENDED_PRIO_EN(offset) \
        GP_WB_READ_U1((offset) + 0x001, 1)

#define GP_WB_WRITE_ADV_EV_INFO_EXTENDED_PRIO_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 1, (val)); \
        } while (0)


/* Indicates the number of events that are skipped in a row */
#define GP_WB_READ_ADV_EV_INFO_NR_CONSEC_SKIPPED_EVENTS(offset) \
        GP_WB_READ_U16((offset) + 0x002)

#define GP_WB_WRITE_ADV_EV_INFO_NR_CONSEC_SKIPPED_EVENTS(offset, val) do { \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x002, (val)); \
        } while (0)


/* Time an event needs to be soft aborted before next event trigger of the same event (in us), should be minumum the event_processing delay */
#define GP_WB_READ_ADV_EV_INFO_GUARD_TIME(offset) \
        GP_WB_READ_U24((offset) + 0x004)

#define GP_WB_WRITE_ADV_EV_INFO_GUARD_TIME(offset, val) do { \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_WRITE_U24((offset) + 0x004, (val)); \
        } while (0)


/* The time between two events (in us) */
#define GP_WB_READ_ADV_EV_INFO_INTERVAL(offset) \
        GP_WB_READ_U24((offset) + 0x008)

#define GP_WB_WRITE_ADV_EV_INFO_INTERVAL(offset, val) do { \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_WRITE_U24((offset) + 0x008, (val)); \
        } while (0)


/* the time between advertising transmissions (on different channels), has to be a value between 0 and 10 ms. Resolution 1 us */
#define GP_WB_READ_ADV_EV_INFO_INTRA_EV_TX_SPACING(offset) \
        GP_WB_READ_U16((offset) + 0x00c)

#define GP_WB_WRITE_ADV_EV_INFO_INTRA_EV_TX_SPACING(offset, val) do { \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x00c, (val)); \
        } while (0)


/* the mask used for generating the random adv delay, the resulting random number has a resolution of 625 us. Set to 15 according to BLE spec */
#define GP_WB_READ_ADV_EV_INFO_ADV_DELAY_MASK(offset) \
        GP_WB_READ_U8((offset) + 0x00e)

#define GP_WB_WRITE_ADV_EV_INFO_ADV_DELAY_MASK(offset, val) do { \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x00e, (val)); \
        } while (0)


/* pbm to transmit as advertising frame */
#define GP_WB_READ_ADV_EV_INFO_ADV_PBM(offset) \
        GP_WB_READ_U8((offset) + 0x00f)

#define GP_WB_WRITE_ADV_EV_INFO_ADV_PBM(offset, val) do { \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x00f, (val)); \
        } while (0)


/* pbm to transmit as scan response */
#define GP_WB_READ_ADV_EV_INFO_SCAN_RSP_PBM(offset) \
        GP_WB_READ_U8((offset) + 0x010)

#define GP_WB_WRITE_ADV_EV_INFO_SCAN_RSP_PBM(offset, val) do { \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x010, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADV_EV_INFO_ADV_CH_MAP(offset) \
        GP_WB_READ_U24((offset) + 0x014)

#define GP_WB_WRITE_ADV_EV_INFO_ADV_CH_MAP(offset, val) \
      GP_WB_WRITE_U24((offset) + 0x014, (val))

/* channel for first  adv transmission. if 255, advertising event will stop. */
#define GP_WB_READ_ADV_EV_INFO_ADV_CH0(offset) \
        GP_WB_READ_U8((offset) + 0x014)

#define GP_WB_GET_ADV_EV_INFO_ADV_CH0_FROM_ADV_CH_MAP(tmp) \
        ((tmp) & 0xFF)

#define GP_WB_WRITE_ADV_EV_INFO_ADV_CH0(offset, val) do { \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x014, (val)); \
        } while (0)

#define GP_WB_SET_ADV_EV_INFO_ADV_CH0_TO_ADV_CH_MAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0xFFFF00; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* channel for second adv transmission. if 255, advertising event will stop. */
#define GP_WB_READ_ADV_EV_INFO_ADV_CH1(offset) \
        GP_WB_READ_U8((offset) + 0x015)

#define GP_WB_GET_ADV_EV_INFO_ADV_CH1_FROM_ADV_CH_MAP(tmp) \
        (((tmp) >> 8) & 0xFF)

#define GP_WB_WRITE_ADV_EV_INFO_ADV_CH1(offset, val) do { \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x015, (val)); \
        } while (0)

#define GP_WB_SET_ADV_EV_INFO_ADV_CH1_TO_ADV_CH_MAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0xFF00FF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* channel for third  adv transmission. if 255, advertising event will stop. */
#define GP_WB_READ_ADV_EV_INFO_ADV_CH2(offset) \
        GP_WB_READ_U8((offset) + 0x016)

#define GP_WB_GET_ADV_EV_INFO_ADV_CH2_FROM_ADV_CH_MAP(tmp) \
        (((tmp) >> 16) & 0xFF)

#define GP_WB_WRITE_ADV_EV_INFO_ADV_CH2(offset, val) do { \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x016, (val)); \
        } while (0)

#define GP_WB_SET_ADV_EV_INFO_ADV_CH2_TO_ADV_CH_MAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x00FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADV_EV_INFO_FRAME_TYPE_ACCEPT_MASK(offset) \
        GP_WB_READ_U8((offset) + 0x017)

#define GP_WB_WRITE_ADV_EV_INFO_FRAME_TYPE_ACCEPT_MASK(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x017, (val))

#define GP_WB_READ_ADV_EV_INFO_ACCEPT_FT_ADV_IND(offset) \
        GP_WB_READ_U1((offset) + 0x017, 0)

#define GP_WB_GET_ADV_EV_INFO_ACCEPT_FT_ADV_IND_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_ADV_EV_INFO_ACCEPT_FT_ADV_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 0, (val)); \
        } while (0)

#define GP_WB_SET_ADV_EV_INFO_ACCEPT_FT_ADV_IND_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_ADV_EV_INFO_ACCEPT_FT_ADV_DIRECT_IND(offset) \
        GP_WB_READ_U1((offset) + 0x017, 1)

#define GP_WB_GET_ADV_EV_INFO_ACCEPT_FT_ADV_DIRECT_IND_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_ADV_EV_INFO_ACCEPT_FT_ADV_DIRECT_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 1, (val)); \
        } while (0)

#define GP_WB_SET_ADV_EV_INFO_ACCEPT_FT_ADV_DIRECT_IND_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_ADV_EV_INFO_ACCEPT_FT_ADV_NONCONN_IND(offset) \
        GP_WB_READ_U1((offset) + 0x017, 2)

#define GP_WB_GET_ADV_EV_INFO_ACCEPT_FT_ADV_NONCONN_IND_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_ADV_EV_INFO_ACCEPT_FT_ADV_NONCONN_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 2, (val)); \
        } while (0)

#define GP_WB_SET_ADV_EV_INFO_ACCEPT_FT_ADV_NONCONN_IND_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_ADV_EV_INFO_ACCEPT_FT_SCAN_REQ(offset) \
        GP_WB_READ_U1((offset) + 0x017, 3)

#define GP_WB_GET_ADV_EV_INFO_ACCEPT_FT_SCAN_REQ_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_ADV_EV_INFO_ACCEPT_FT_SCAN_REQ(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 3, (val)); \
        } while (0)

#define GP_WB_SET_ADV_EV_INFO_ACCEPT_FT_SCAN_REQ_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_ADV_EV_INFO_ACCEPT_FT_AUX_SCAN_REQ(offset) \
        GP_WB_READ_U1((offset) + 0x017, 3)

#define GP_WB_GET_ADV_EV_INFO_ACCEPT_FT_AUX_SCAN_REQ_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_ADV_EV_INFO_ACCEPT_FT_AUX_SCAN_REQ(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 3, (val)); \
        } while (0)

#define GP_WB_SET_ADV_EV_INFO_ACCEPT_FT_AUX_SCAN_REQ_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_ADV_EV_INFO_ACCEPT_FT_SCAN_RSP(offset) \
        GP_WB_READ_U1((offset) + 0x017, 4)

#define GP_WB_GET_ADV_EV_INFO_ACCEPT_FT_SCAN_RSP_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_ADV_EV_INFO_ACCEPT_FT_SCAN_RSP(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 4, (val)); \
        } while (0)

#define GP_WB_SET_ADV_EV_INFO_ACCEPT_FT_SCAN_RSP_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_READ_ADV_EV_INFO_ACCEPT_FT_CONNECT_REQ(offset) \
        GP_WB_READ_U1((offset) + 0x017, 5)

#define GP_WB_GET_ADV_EV_INFO_ACCEPT_FT_CONNECT_REQ_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_ADV_EV_INFO_ACCEPT_FT_CONNECT_REQ(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 5, (val)); \
        } while (0)

#define GP_WB_SET_ADV_EV_INFO_ACCEPT_FT_CONNECT_REQ_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

#define GP_WB_READ_ADV_EV_INFO_ACCEPT_FT_AUX_CONNECT_REQ(offset) \
        GP_WB_READ_U1((offset) + 0x017, 5)

#define GP_WB_GET_ADV_EV_INFO_ACCEPT_FT_AUX_CONNECT_REQ_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_ADV_EV_INFO_ACCEPT_FT_AUX_CONNECT_REQ(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 5, (val)); \
        } while (0)

#define GP_WB_SET_ADV_EV_INFO_ACCEPT_FT_AUX_CONNECT_REQ_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

#define GP_WB_READ_ADV_EV_INFO_ACCEPT_FT_ADV_SCAN_IND(offset) \
        GP_WB_READ_U1((offset) + 0x017, 6)

#define GP_WB_GET_ADV_EV_INFO_ACCEPT_FT_ADV_SCAN_IND_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_ADV_EV_INFO_ACCEPT_FT_ADV_SCAN_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 6, (val)); \
        } while (0)

#define GP_WB_SET_ADV_EV_INFO_ACCEPT_FT_ADV_SCAN_IND_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

#define GP_WB_READ_ADV_EV_INFO_ACCEPT_FT_ADV_EXT_IND(offset) \
        GP_WB_READ_U1((offset) + 0x017, 7)

#define GP_WB_GET_ADV_EV_INFO_ACCEPT_FT_ADV_EXT_IND_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADV_EV_INFO_ACCEPT_FT_ADV_EXT_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 7, (val)); \
        } while (0)

#define GP_WB_SET_ADV_EV_INFO_ACCEPT_FT_ADV_EXT_IND_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)

#define GP_WB_READ_ADV_EV_INFO_ACCEPT_FT_AUX_ADV_IND(offset) \
        GP_WB_READ_U1((offset) + 0x017, 7)

#define GP_WB_GET_ADV_EV_INFO_ACCEPT_FT_AUX_ADV_IND_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADV_EV_INFO_ACCEPT_FT_AUX_ADV_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 7, (val)); \
        } while (0)

#define GP_WB_SET_ADV_EV_INFO_ACCEPT_FT_AUX_ADV_IND_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)

#define GP_WB_READ_ADV_EV_INFO_ACCEPT_FT_AUX_SCAN_RSP(offset) \
        GP_WB_READ_U1((offset) + 0x017, 7)

#define GP_WB_GET_ADV_EV_INFO_ACCEPT_FT_AUX_SCAN_RSP_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADV_EV_INFO_ACCEPT_FT_AUX_SCAN_RSP(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 7, (val)); \
        } while (0)

#define GP_WB_SET_ADV_EV_INFO_ACCEPT_FT_AUX_SCAN_RSP_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)

#define GP_WB_READ_ADV_EV_INFO_ACCEPT_FT_AUX_SYNC_IND(offset) \
        GP_WB_READ_U1((offset) + 0x017, 7)

#define GP_WB_GET_ADV_EV_INFO_ACCEPT_FT_AUX_SYNC_IND_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADV_EV_INFO_ACCEPT_FT_AUX_SYNC_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 7, (val)); \
        } while (0)

#define GP_WB_SET_ADV_EV_INFO_ACCEPT_FT_AUX_SYNC_IND_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)

#define GP_WB_READ_ADV_EV_INFO_ACCEPT_FT_AUX_CHAIN_IND(offset) \
        GP_WB_READ_U1((offset) + 0x017, 7)

#define GP_WB_GET_ADV_EV_INFO_ACCEPT_FT_AUX_CHAIN_IND_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADV_EV_INFO_ACCEPT_FT_AUX_CHAIN_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 7, (val)); \
        } while (0)

#define GP_WB_SET_ADV_EV_INFO_ACCEPT_FT_AUX_CHAIN_IND_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADV_EV_INFO_FT_WHITELIST_ENABLE_MASK(offset) \
        GP_WB_READ_U8((offset) + 0x018)

#define GP_WB_WRITE_ADV_EV_INFO_FT_WHITELIST_ENABLE_MASK(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x018, (val))

#define GP_WB_READ_ADV_EV_INFO_FT_ADV_IND_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 0)

#define GP_WB_GET_ADV_EV_INFO_FT_ADV_IND_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_ADV_EV_INFO_FT_ADV_IND_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 0, (val)); \
        } while (0)

#define GP_WB_SET_ADV_EV_INFO_FT_ADV_IND_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_ADV_EV_INFO_FT_ADV_DIRECT_IND_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 1)

#define GP_WB_GET_ADV_EV_INFO_FT_ADV_DIRECT_IND_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_ADV_EV_INFO_FT_ADV_DIRECT_IND_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 1, (val)); \
        } while (0)

#define GP_WB_SET_ADV_EV_INFO_FT_ADV_DIRECT_IND_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_ADV_EV_INFO_FT_ADV_NONCONN_IND_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 2)

#define GP_WB_GET_ADV_EV_INFO_FT_ADV_NONCONN_IND_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_ADV_EV_INFO_FT_ADV_NONCONN_IND_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 2, (val)); \
        } while (0)

#define GP_WB_SET_ADV_EV_INFO_FT_ADV_NONCONN_IND_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_ADV_EV_INFO_FT_SCAN_REQ_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 3)

#define GP_WB_GET_ADV_EV_INFO_FT_SCAN_REQ_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_ADV_EV_INFO_FT_SCAN_REQ_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 3, (val)); \
        } while (0)

#define GP_WB_SET_ADV_EV_INFO_FT_SCAN_REQ_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_ADV_EV_INFO_FT_AUX_SCAN_REQ_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 3)

#define GP_WB_GET_ADV_EV_INFO_FT_AUX_SCAN_REQ_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_ADV_EV_INFO_FT_AUX_SCAN_REQ_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 3, (val)); \
        } while (0)

#define GP_WB_SET_ADV_EV_INFO_FT_AUX_SCAN_REQ_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_ADV_EV_INFO_FT_SCAN_RSP_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 4)

#define GP_WB_GET_ADV_EV_INFO_FT_SCAN_RSP_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_ADV_EV_INFO_FT_SCAN_RSP_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 4, (val)); \
        } while (0)

#define GP_WB_SET_ADV_EV_INFO_FT_SCAN_RSP_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_READ_ADV_EV_INFO_FT_CONNECT_REQ_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 5)

#define GP_WB_GET_ADV_EV_INFO_FT_CONNECT_REQ_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_ADV_EV_INFO_FT_CONNECT_REQ_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 5, (val)); \
        } while (0)

#define GP_WB_SET_ADV_EV_INFO_FT_CONNECT_REQ_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

#define GP_WB_READ_ADV_EV_INFO_FT_AUX_CONNECT_REQ_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 5)

#define GP_WB_GET_ADV_EV_INFO_FT_AUX_CONNECT_REQ_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_ADV_EV_INFO_FT_AUX_CONNECT_REQ_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 5, (val)); \
        } while (0)

#define GP_WB_SET_ADV_EV_INFO_FT_AUX_CONNECT_REQ_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

#define GP_WB_READ_ADV_EV_INFO_FT_ADV_SCAN_IND_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 6)

#define GP_WB_GET_ADV_EV_INFO_FT_ADV_SCAN_IND_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_ADV_EV_INFO_FT_ADV_SCAN_IND_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 6, (val)); \
        } while (0)

#define GP_WB_SET_ADV_EV_INFO_FT_ADV_SCAN_IND_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

#define GP_WB_READ_ADV_EV_INFO_FT_ADV_EXT_IND_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 7)

#define GP_WB_GET_ADV_EV_INFO_FT_ADV_EXT_IND_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADV_EV_INFO_FT_ADV_EXT_IND_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 7, (val)); \
        } while (0)

#define GP_WB_SET_ADV_EV_INFO_FT_ADV_EXT_IND_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)

#define GP_WB_READ_ADV_EV_INFO_FT_AUX_ADV_IND_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 7)

#define GP_WB_GET_ADV_EV_INFO_FT_AUX_ADV_IND_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADV_EV_INFO_FT_AUX_ADV_IND_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 7, (val)); \
        } while (0)

#define GP_WB_SET_ADV_EV_INFO_FT_AUX_ADV_IND_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)

#define GP_WB_READ_ADV_EV_INFO_FT_AUX_SCAN_RSP_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 7)

#define GP_WB_GET_ADV_EV_INFO_FT_AUX_SCAN_RSP_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADV_EV_INFO_FT_AUX_SCAN_RSP_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 7, (val)); \
        } while (0)

#define GP_WB_SET_ADV_EV_INFO_FT_AUX_SCAN_RSP_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)

#define GP_WB_READ_ADV_EV_INFO_FT_AUX_SYNC_IND_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 7)

#define GP_WB_GET_ADV_EV_INFO_FT_AUX_SYNC_IND_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADV_EV_INFO_FT_AUX_SYNC_IND_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 7, (val)); \
        } while (0)

#define GP_WB_SET_ADV_EV_INFO_FT_AUX_SYNC_IND_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)

#define GP_WB_READ_ADV_EV_INFO_FT_AUX_CHAIN_IND_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 7)

#define GP_WB_GET_ADV_EV_INFO_FT_AUX_CHAIN_IND_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADV_EV_INFO_FT_AUX_CHAIN_IND_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 7, (val)); \
        } while (0)

#define GP_WB_SET_ADV_EV_INFO_FT_AUX_CHAIN_IND_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* when 1, unresolved RPA src addresses will not be dropped */
#define GP_WB_READ_ADV_EV_INFO_RT0_FORWARD_RES_PR_SRC(offset) \
        GP_WB_READ_U1((offset) + 0x019, 0)

#define GP_WB_WRITE_ADV_EV_INFO_RT0_FORWARD_RES_PR_SRC(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x019, 0, (val)); \
        } while (0)

/* when 1, unresolved RPA dst addresses will not be dropped */
#define GP_WB_READ_ADV_EV_INFO_RT0_FORWARD_RES_PR_DST(offset) \
        GP_WB_READ_U1((offset) + 0x019, 1)

#define GP_WB_WRITE_ADV_EV_INFO_RT0_FORWARD_RES_PR_DST(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x019, 1, (val)); \
        } while (0)

/* when 1, unresolved RPA src addresses will not be dropped */
#define GP_WB_READ_ADV_EV_INFO_ACCEPT_UNRESOLVED_RPA_SRC(offset) \
        GP_WB_READ_U1((offset) + 0x019, 2)

#define GP_WB_WRITE_ADV_EV_INFO_ACCEPT_UNRESOLVED_RPA_SRC(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x019, 2, (val)); \
        } while (0)

/* when 1, unresolved RPA dst addresses will not be dropped */
#define GP_WB_READ_ADV_EV_INFO_ACCEPT_UNRESOLVED_RPA_DST(offset) \
        GP_WB_READ_U1((offset) + 0x019, 3)

#define GP_WB_WRITE_ADV_EV_INFO_ACCEPT_UNRESOLVED_RPA_DST(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x019, 3, (val)); \
        } while (0)

/* when 1, unresolved identity (non-RPA) src addresses will not be dropped */
#define GP_WB_READ_ADV_EV_INFO_ACCEPT_UNRESOLVED_ID_SRC(offset) \
        GP_WB_READ_U1((offset) + 0x019, 4)

#define GP_WB_WRITE_ADV_EV_INFO_ACCEPT_UNRESOLVED_ID_SRC(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x019, 4, (val)); \
        } while (0)


/* Indicates whether the antenna swithcing feature should be enabled */
#define GP_WB_READ_ADV_EV_INFO_EN_ANT_SWITCHING(offset) \
        GP_WB_READ_U8((offset) + 0x01a)

#define GP_WB_WRITE_ADV_EV_INFO_EN_ANT_SWITCHING(offset, val) do { \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x01a, (val)); \
        } while (0)


/* Indicates the antenna currently being used (or next to be used when not during the event) */
#define GP_WB_READ_ADV_EV_INFO_CURR_ANTENNA(offset) \
        GP_WB_READ_U8((offset) + 0x01b)

#define GP_WB_WRITE_ADV_EV_INFO_CURR_ANTENNA(offset, val) do { \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x01b, (val)); \
        } while (0)


/* pointer to a CM style list of rx_list_entry elements that get written after the RX mode is set and before the receiver is started */
#define GP_WB_READ_ADV_EV_INFO_RX_LIST_PTR(offset) \
        GP_WB_READ_U16((offset) + 0x01c)

#define GP_WB_WRITE_ADV_EV_INFO_RX_LIST_PTR(offset, val) do { \
          GP_WB_CHECK_OFFSET_ADV_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x01c, (val)); \
        } while (0)

/***************************
 * layout: scan_ev_info
 ***************************/

/* priority of the event, (0= lowest priority; 255 is highest priority) */
#define GP_WB_READ_SCAN_EV_INFO_PRIORITY(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_SCAN_EV_INFO_PRIORITY(offset, val) do { \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x000, (val)); \
        } while (0)


/* when enabled, the event will not do any radio activity and the event will be skipped. The event state will still be updated though. */
#define GP_WB_READ_SCAN_EV_INFO_SUSPEND_EVENT(offset) \
        GP_WB_READ_U1((offset) + 0x001, 0)

#define GP_WB_WRITE_SCAN_EV_INFO_SUSPEND_EVENT(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 0, (val)); \
        } while (0)

/* when 1, the round robin mechanism will also take into account the nr_consec_skipped_events for this event */
#define GP_WB_READ_SCAN_EV_INFO_EXTENDED_PRIO_EN(offset) \
        GP_WB_READ_U1((offset) + 0x001, 1)

#define GP_WB_WRITE_SCAN_EV_INFO_EXTENDED_PRIO_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 1, (val)); \
        } while (0)


/* Indicates the number of events that are skipped in a row */
#define GP_WB_READ_SCAN_EV_INFO_NR_CONSEC_SKIPPED_EVENTS(offset) \
        GP_WB_READ_U16((offset) + 0x002)

#define GP_WB_WRITE_SCAN_EV_INFO_NR_CONSEC_SKIPPED_EVENTS(offset, val) do { \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x002, (val)); \
        } while (0)


/* Time an event needs to be soft aborted before next event trigger of the same event (in us), should be minumum the event_processing delay */
#define GP_WB_READ_SCAN_EV_INFO_GUARD_TIME(offset) \
        GP_WB_READ_U24((offset) + 0x004)

#define GP_WB_WRITE_SCAN_EV_INFO_GUARD_TIME(offset, val) do { \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_WRITE_U24((offset) + 0x004, (val)); \
        } while (0)


/* The time between two events (in us) */
#define GP_WB_READ_SCAN_EV_INFO_INTERVAL(offset) \
        GP_WB_READ_U24((offset) + 0x008)

#define GP_WB_WRITE_SCAN_EV_INFO_INTERVAL(offset, val) do { \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_WRITE_U24((offset) + 0x008, (val)); \
        } while (0)


/* the duration of the RX window. Resolution 16 us */
#define GP_WB_READ_SCAN_EV_INFO_SCAN_WINDOW_DURATION(offset) \
        GP_WB_READ_U24((offset) + 0x00c)

#define GP_WB_WRITE_SCAN_EV_INFO_SCAN_WINDOW_DURATION(offset, val) do { \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_WRITE_U24((offset) + 0x00c, (val)); \
        } while (0)


/* pbm to transmit in response to a scan-able advertisement */
#define GP_WB_READ_SCAN_EV_INFO_SCAN_REQ_PBM(offset) \
        GP_WB_READ_U8((offset) + 0x00f)

#define GP_WB_WRITE_SCAN_EV_INFO_SCAN_REQ_PBM(offset, val) do { \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x00f, (val)); \
        } while (0)


/* current index within the channel map */
#define GP_WB_READ_SCAN_EV_INFO_CURRENT_CH_MAP_IDX(offset) \
        GP_WB_READ_U8((offset) + 0x010)

#define GP_WB_WRITE_SCAN_EV_INFO_CURRENT_CH_MAP_IDX(offset, val) do { \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x010, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SCAN_EV_INFO_SCAN_CH_MAP(offset) \
        GP_WB_READ_U24((offset) + 0x014)

#define GP_WB_WRITE_SCAN_EV_INFO_SCAN_CH_MAP(offset, val) \
      GP_WB_WRITE_U24((offset) + 0x014, (val))

/* channel for first  scan RX window. Always used */
#define GP_WB_READ_SCAN_EV_INFO_SCAN_CH0(offset) \
        GP_WB_READ_U8((offset) + 0x014)

#define GP_WB_GET_SCAN_EV_INFO_SCAN_CH0_FROM_SCAN_CH_MAP(tmp) \
        ((tmp) & 0xFF)

#define GP_WB_WRITE_SCAN_EV_INFO_SCAN_CH0(offset, val) do { \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x014, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_SCAN_CH0_TO_SCAN_CH_MAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0xFFFF00; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* channel for second scan RX window. if 255, channel is skipped */
#define GP_WB_READ_SCAN_EV_INFO_SCAN_CH1(offset) \
        GP_WB_READ_U8((offset) + 0x015)

#define GP_WB_GET_SCAN_EV_INFO_SCAN_CH1_FROM_SCAN_CH_MAP(tmp) \
        (((tmp) >> 8) & 0xFF)

#define GP_WB_WRITE_SCAN_EV_INFO_SCAN_CH1(offset, val) do { \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x015, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_SCAN_CH1_TO_SCAN_CH_MAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0xFF00FF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* channel for third  scan RX window. if 255, channel is skipped */
#define GP_WB_READ_SCAN_EV_INFO_SCAN_CH2(offset) \
        GP_WB_READ_U8((offset) + 0x016)

#define GP_WB_GET_SCAN_EV_INFO_SCAN_CH2_FROM_SCAN_CH_MAP(tmp) \
        (((tmp) >> 16) & 0xFF)

#define GP_WB_WRITE_SCAN_EV_INFO_SCAN_CH2(offset, val) do { \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x016, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_SCAN_CH2_TO_SCAN_CH_MAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x00FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SCAN_EV_INFO_FRAME_TYPE_ACCEPT_MASK(offset) \
        GP_WB_READ_U8((offset) + 0x017)

#define GP_WB_WRITE_SCAN_EV_INFO_FRAME_TYPE_ACCEPT_MASK(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x017, (val))

#define GP_WB_READ_SCAN_EV_INFO_ACCEPT_FT_ADV_IND(offset) \
        GP_WB_READ_U1((offset) + 0x017, 0)

#define GP_WB_GET_SCAN_EV_INFO_ACCEPT_FT_ADV_IND_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_ACCEPT_FT_ADV_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 0, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_ACCEPT_FT_ADV_IND_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_SCAN_EV_INFO_ACCEPT_FT_ADV_DIRECT_IND(offset) \
        GP_WB_READ_U1((offset) + 0x017, 1)

#define GP_WB_GET_SCAN_EV_INFO_ACCEPT_FT_ADV_DIRECT_IND_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_ACCEPT_FT_ADV_DIRECT_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 1, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_ACCEPT_FT_ADV_DIRECT_IND_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_SCAN_EV_INFO_ACCEPT_FT_ADV_NONCONN_IND(offset) \
        GP_WB_READ_U1((offset) + 0x017, 2)

#define GP_WB_GET_SCAN_EV_INFO_ACCEPT_FT_ADV_NONCONN_IND_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_ACCEPT_FT_ADV_NONCONN_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 2, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_ACCEPT_FT_ADV_NONCONN_IND_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_SCAN_EV_INFO_ACCEPT_FT_SCAN_REQ(offset) \
        GP_WB_READ_U1((offset) + 0x017, 3)

#define GP_WB_GET_SCAN_EV_INFO_ACCEPT_FT_SCAN_REQ_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_ACCEPT_FT_SCAN_REQ(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 3, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_ACCEPT_FT_SCAN_REQ_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_SCAN_EV_INFO_ACCEPT_FT_AUX_SCAN_REQ(offset) \
        GP_WB_READ_U1((offset) + 0x017, 3)

#define GP_WB_GET_SCAN_EV_INFO_ACCEPT_FT_AUX_SCAN_REQ_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_ACCEPT_FT_AUX_SCAN_REQ(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 3, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_ACCEPT_FT_AUX_SCAN_REQ_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_SCAN_EV_INFO_ACCEPT_FT_SCAN_RSP(offset) \
        GP_WB_READ_U1((offset) + 0x017, 4)

#define GP_WB_GET_SCAN_EV_INFO_ACCEPT_FT_SCAN_RSP_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_ACCEPT_FT_SCAN_RSP(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 4, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_ACCEPT_FT_SCAN_RSP_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_READ_SCAN_EV_INFO_ACCEPT_FT_CONNECT_REQ(offset) \
        GP_WB_READ_U1((offset) + 0x017, 5)

#define GP_WB_GET_SCAN_EV_INFO_ACCEPT_FT_CONNECT_REQ_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_ACCEPT_FT_CONNECT_REQ(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 5, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_ACCEPT_FT_CONNECT_REQ_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

#define GP_WB_READ_SCAN_EV_INFO_ACCEPT_FT_AUX_CONNECT_REQ(offset) \
        GP_WB_READ_U1((offset) + 0x017, 5)

#define GP_WB_GET_SCAN_EV_INFO_ACCEPT_FT_AUX_CONNECT_REQ_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_ACCEPT_FT_AUX_CONNECT_REQ(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 5, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_ACCEPT_FT_AUX_CONNECT_REQ_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

#define GP_WB_READ_SCAN_EV_INFO_ACCEPT_FT_ADV_SCAN_IND(offset) \
        GP_WB_READ_U1((offset) + 0x017, 6)

#define GP_WB_GET_SCAN_EV_INFO_ACCEPT_FT_ADV_SCAN_IND_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_ACCEPT_FT_ADV_SCAN_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 6, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_ACCEPT_FT_ADV_SCAN_IND_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

#define GP_WB_READ_SCAN_EV_INFO_ACCEPT_FT_ADV_EXT_IND(offset) \
        GP_WB_READ_U1((offset) + 0x017, 7)

#define GP_WB_GET_SCAN_EV_INFO_ACCEPT_FT_ADV_EXT_IND_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_ACCEPT_FT_ADV_EXT_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 7, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_ACCEPT_FT_ADV_EXT_IND_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)

#define GP_WB_READ_SCAN_EV_INFO_ACCEPT_FT_AUX_ADV_IND(offset) \
        GP_WB_READ_U1((offset) + 0x017, 7)

#define GP_WB_GET_SCAN_EV_INFO_ACCEPT_FT_AUX_ADV_IND_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_ACCEPT_FT_AUX_ADV_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 7, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_ACCEPT_FT_AUX_ADV_IND_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)

#define GP_WB_READ_SCAN_EV_INFO_ACCEPT_FT_AUX_SCAN_RSP(offset) \
        GP_WB_READ_U1((offset) + 0x017, 7)

#define GP_WB_GET_SCAN_EV_INFO_ACCEPT_FT_AUX_SCAN_RSP_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_ACCEPT_FT_AUX_SCAN_RSP(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 7, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_ACCEPT_FT_AUX_SCAN_RSP_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)

#define GP_WB_READ_SCAN_EV_INFO_ACCEPT_FT_AUX_SYNC_IND(offset) \
        GP_WB_READ_U1((offset) + 0x017, 7)

#define GP_WB_GET_SCAN_EV_INFO_ACCEPT_FT_AUX_SYNC_IND_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_ACCEPT_FT_AUX_SYNC_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 7, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_ACCEPT_FT_AUX_SYNC_IND_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)

#define GP_WB_READ_SCAN_EV_INFO_ACCEPT_FT_AUX_CHAIN_IND(offset) \
        GP_WB_READ_U1((offset) + 0x017, 7)

#define GP_WB_GET_SCAN_EV_INFO_ACCEPT_FT_AUX_CHAIN_IND_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_ACCEPT_FT_AUX_CHAIN_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 7, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_ACCEPT_FT_AUX_CHAIN_IND_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SCAN_EV_INFO_FT_WHITELIST_ENABLE_MASK(offset) \
        GP_WB_READ_U8((offset) + 0x018)

#define GP_WB_WRITE_SCAN_EV_INFO_FT_WHITELIST_ENABLE_MASK(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x018, (val))

#define GP_WB_READ_SCAN_EV_INFO_FT_ADV_IND_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 0)

#define GP_WB_GET_SCAN_EV_INFO_FT_ADV_IND_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_FT_ADV_IND_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 0, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_FT_ADV_IND_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_SCAN_EV_INFO_FT_ADV_DIRECT_IND_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 1)

#define GP_WB_GET_SCAN_EV_INFO_FT_ADV_DIRECT_IND_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_FT_ADV_DIRECT_IND_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 1, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_FT_ADV_DIRECT_IND_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_SCAN_EV_INFO_FT_ADV_NONCONN_IND_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 2)

#define GP_WB_GET_SCAN_EV_INFO_FT_ADV_NONCONN_IND_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_FT_ADV_NONCONN_IND_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 2, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_FT_ADV_NONCONN_IND_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_SCAN_EV_INFO_FT_SCAN_REQ_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 3)

#define GP_WB_GET_SCAN_EV_INFO_FT_SCAN_REQ_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_FT_SCAN_REQ_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 3, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_FT_SCAN_REQ_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_SCAN_EV_INFO_FT_AUX_SCAN_REQ_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 3)

#define GP_WB_GET_SCAN_EV_INFO_FT_AUX_SCAN_REQ_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_FT_AUX_SCAN_REQ_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 3, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_FT_AUX_SCAN_REQ_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_SCAN_EV_INFO_FT_SCAN_RSP_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 4)

#define GP_WB_GET_SCAN_EV_INFO_FT_SCAN_RSP_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_FT_SCAN_RSP_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 4, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_FT_SCAN_RSP_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_READ_SCAN_EV_INFO_FT_CONNECT_REQ_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 5)

#define GP_WB_GET_SCAN_EV_INFO_FT_CONNECT_REQ_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_FT_CONNECT_REQ_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 5, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_FT_CONNECT_REQ_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

#define GP_WB_READ_SCAN_EV_INFO_FT_AUX_CONNECT_REQ_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 5)

#define GP_WB_GET_SCAN_EV_INFO_FT_AUX_CONNECT_REQ_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_FT_AUX_CONNECT_REQ_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 5, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_FT_AUX_CONNECT_REQ_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

#define GP_WB_READ_SCAN_EV_INFO_FT_ADV_SCAN_IND_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 6)

#define GP_WB_GET_SCAN_EV_INFO_FT_ADV_SCAN_IND_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_FT_ADV_SCAN_IND_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 6, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_FT_ADV_SCAN_IND_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

#define GP_WB_READ_SCAN_EV_INFO_FT_ADV_EXT_IND_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 7)

#define GP_WB_GET_SCAN_EV_INFO_FT_ADV_EXT_IND_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_FT_ADV_EXT_IND_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 7, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_FT_ADV_EXT_IND_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)

#define GP_WB_READ_SCAN_EV_INFO_FT_AUX_ADV_IND_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 7)

#define GP_WB_GET_SCAN_EV_INFO_FT_AUX_ADV_IND_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_FT_AUX_ADV_IND_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 7, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_FT_AUX_ADV_IND_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)

#define GP_WB_READ_SCAN_EV_INFO_FT_AUX_SCAN_RSP_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 7)

#define GP_WB_GET_SCAN_EV_INFO_FT_AUX_SCAN_RSP_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_FT_AUX_SCAN_RSP_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 7, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_FT_AUX_SCAN_RSP_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)

#define GP_WB_READ_SCAN_EV_INFO_FT_AUX_SYNC_IND_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 7)

#define GP_WB_GET_SCAN_EV_INFO_FT_AUX_SYNC_IND_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_FT_AUX_SYNC_IND_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 7, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_FT_AUX_SYNC_IND_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)

#define GP_WB_READ_SCAN_EV_INFO_FT_AUX_CHAIN_IND_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 7)

#define GP_WB_GET_SCAN_EV_INFO_FT_AUX_CHAIN_IND_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_FT_AUX_CHAIN_IND_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 7, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_FT_AUX_CHAIN_IND_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* The address to check against for directed advertising packets */
#define GP_WB_READ_SCAN_EV_INFO_OWN_DEVICE_ADDRESS(offset) \
        GP_WB_READ_U48((offset) + 0x01c)

#define GP_WB_WRITE_SCAN_EV_INFO_OWN_DEVICE_ADDRESS(offset, val) do { \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_WRITE_U48((offset) + 0x01c, (val)); \
        } while (0)


/* The address_type to check against for directed advertising packets */
#define GP_WB_READ_SCAN_EV_INFO_OWN_DEVICE_ADDRESS_TYPE(offset) \
        GP_WB_READ_U1((offset) + 0x022, 0)

#define GP_WB_WRITE_SCAN_EV_INFO_OWN_DEVICE_ADDRESS_TYPE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x022, 0, (val)); \
        } while (0)

/* generate resolvable private source address for outgoing packets */
#define GP_WB_READ_SCAN_EV_INFO_GENERATE_RES_PR(offset) \
        GP_WB_READ_U1((offset) + 0x022, 1)

#define GP_WB_WRITE_SCAN_EV_INFO_GENERATE_RES_PR(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x022, 1, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SCAN_EV_INFO_EXTRA_OPTIONS(offset) \
        GP_WB_READ_U8((offset) + 0x023)

#define GP_WB_WRITE_SCAN_EV_INFO_EXTRA_OPTIONS(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x023, (val))

/* when 1, unresolved RPA src addresses will not be dropped */
#define GP_WB_READ_SCAN_EV_INFO_RT0_FORWARD_RES_PR_SRC(offset) \
        GP_WB_READ_U1((offset) + 0x023, 0)

#define GP_WB_GET_SCAN_EV_INFO_RT0_FORWARD_RES_PR_SRC_FROM_EXTRA_OPTIONS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_RT0_FORWARD_RES_PR_SRC(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x023, 0, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_RT0_FORWARD_RES_PR_SRC_TO_EXTRA_OPTIONS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* when 1, unresolved RPA dst addresses will not be dropped */
#define GP_WB_READ_SCAN_EV_INFO_RT0_FORWARD_RES_PR_DST(offset) \
        GP_WB_READ_U1((offset) + 0x023, 1)

#define GP_WB_GET_SCAN_EV_INFO_RT0_FORWARD_RES_PR_DST_FROM_EXTRA_OPTIONS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_RT0_FORWARD_RES_PR_DST(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x023, 1, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_RT0_FORWARD_RES_PR_DST_TO_EXTRA_OPTIONS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* when 1, an active scan will be executed and the scan_req_pbm may be sent out */
#define GP_WB_READ_SCAN_EV_INFO_ACTIVE_SCANNING(offset) \
        GP_WB_READ_U1((offset) + 0x023, 2)

#define GP_WB_GET_SCAN_EV_INFO_ACTIVE_SCANNING_FROM_EXTRA_OPTIONS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_ACTIVE_SCANNING(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x023, 2, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_ACTIVE_SCANNING_TO_EXTRA_OPTIONS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* when 1, unresolved RPA src addresses will not be dropped */
#define GP_WB_READ_SCAN_EV_INFO_ACCEPT_UNRESOLVED_RPA_SRC(offset) \
        GP_WB_READ_U1((offset) + 0x023, 3)

#define GP_WB_GET_SCAN_EV_INFO_ACCEPT_UNRESOLVED_RPA_SRC_FROM_EXTRA_OPTIONS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_ACCEPT_UNRESOLVED_RPA_SRC(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x023, 3, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_ACCEPT_UNRESOLVED_RPA_SRC_TO_EXTRA_OPTIONS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* when 1, unresolved RPA dst addresses will not be dropped (filter policy 0x02|0x03) */
#define GP_WB_READ_SCAN_EV_INFO_ACCEPT_UNRESOLVED_RPA_DST(offset) \
        GP_WB_READ_U1((offset) + 0x023, 4)

#define GP_WB_GET_SCAN_EV_INFO_ACCEPT_UNRESOLVED_RPA_DST_FROM_EXTRA_OPTIONS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_ACCEPT_UNRESOLVED_RPA_DST(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x023, 4, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_ACCEPT_UNRESOLVED_RPA_DST_TO_EXTRA_OPTIONS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* when 1, unresolved identity (non-RPA) src addresses will not be dropped */
#define GP_WB_READ_SCAN_EV_INFO_ACCEPT_UNRESOLVED_ID_SRC(offset) \
        GP_WB_READ_U1((offset) + 0x023, 5)

#define GP_WB_GET_SCAN_EV_INFO_ACCEPT_UNRESOLVED_ID_SRC_FROM_EXTRA_OPTIONS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_SCAN_EV_INFO_ACCEPT_UNRESOLVED_ID_SRC(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x023, 5, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EV_INFO_ACCEPT_UNRESOLVED_ID_SRC_TO_EXTRA_OPTIONS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* backoff count used by ble_ev_mgr to know when to send a SCAN_REQ. Only used for active scanning. Initialize to 0 */
#define GP_WB_READ_SCAN_EV_INFO_BACKOFF_CNT(offset) \
        GP_WB_READ_U8((offset) + 0x024)

#define GP_WB_WRITE_SCAN_EV_INFO_BACKOFF_CNT(offset, val) do { \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x024, (val)); \
        } while (0)


/* upper limit, used by ble_ev_mgr to generate a new backoff count. Only used for active scanning. Initialize to 0 */
#define GP_WB_READ_SCAN_EV_INFO_UPPER_LIMIT_MASK(offset) \
        GP_WB_READ_U8((offset) + 0x025)

#define GP_WB_WRITE_SCAN_EV_INFO_UPPER_LIMIT_MASK(offset, val) do { \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x025, (val)); \
        } while (0)


/* number off consecutive successes upon receiving a SCAN_RSP. Only used for active scanning. Initialize to 0 */
#define GP_WB_READ_SCAN_EV_INFO_SUCCESS_CNT(offset) \
        GP_WB_READ_U8((offset) + 0x026)

#define GP_WB_WRITE_SCAN_EV_INFO_SUCCESS_CNT(offset, val) do { \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x026, (val)); \
        } while (0)


/* number off consecutive failures upon receiving a SCAN_RSP. Only used for active scanning. Initialize to 0 */
#define GP_WB_READ_SCAN_EV_INFO_FAILURE_CNT(offset) \
        GP_WB_READ_U8((offset) + 0x027)

#define GP_WB_WRITE_SCAN_EV_INFO_FAILURE_CNT(offset, val) do { \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x027, (val)); \
        } while (0)


/* Indicates whether the antenna switching feature should be enabled */
#define GP_WB_READ_SCAN_EV_INFO_EN_ANT_SWITCHING(offset) \
        GP_WB_READ_U8((offset) + 0x028)

#define GP_WB_WRITE_SCAN_EV_INFO_EN_ANT_SWITCHING(offset, val) do { \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x028, (val)); \
        } while (0)


/* Indicates the antenna currently being used (or next to be used when not during the event) */
#define GP_WB_READ_SCAN_EV_INFO_CURR_ANTENNA(offset) \
        GP_WB_READ_U8((offset) + 0x029)

#define GP_WB_WRITE_SCAN_EV_INFO_CURR_ANTENNA(offset, val) do { \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x029, (val)); \
        } while (0)


/* pointer to a CM style list of rx_list_entry elements that get written after the RX mode is set and before the receiver is started */
#define GP_WB_READ_SCAN_EV_INFO_RX_LIST_PTR(offset) \
        GP_WB_READ_U16((offset) + 0x02a)

#define GP_WB_WRITE_SCAN_EV_INFO_RX_LIST_PTR(offset, val) do { \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x02a, (val)); \
        } while (0)


/* indicates if multistandard listening is allowed for this subevent. */
#define GP_WB_READ_SCAN_EV_INFO_MS_ALLOWED(offset) \
        GP_WB_READ_U1((offset) + 0x02c, 0)

#define GP_WB_WRITE_SCAN_EV_INFO_MS_ALLOWED(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x02c, (val)); \
        } while (0)

/***************************
 * layout: init_ev_info
 ***************************/

/* priority of the event, (0= lowest priority; 255 is highest priority) */
#define GP_WB_READ_INIT_EV_INFO_PRIORITY(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_INIT_EV_INFO_PRIORITY(offset, val) do { \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x000, (val)); \
        } while (0)


/* when enabled, the event will not do any radio activity and the event will be skipped. The event state will still be updated though. */
#define GP_WB_READ_INIT_EV_INFO_SUSPEND_EVENT(offset) \
        GP_WB_READ_U1((offset) + 0x001, 0)

#define GP_WB_WRITE_INIT_EV_INFO_SUSPEND_EVENT(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 0, (val)); \
        } while (0)

/* when 1, the round robin mechanism will also take into account the nr_consec_skipped_events for this event */
#define GP_WB_READ_INIT_EV_INFO_EXTENDED_PRIO_EN(offset) \
        GP_WB_READ_U1((offset) + 0x001, 1)

#define GP_WB_WRITE_INIT_EV_INFO_EXTENDED_PRIO_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 1, (val)); \
        } while (0)


/* Indicates the number of events that are skipped in a row */
#define GP_WB_READ_INIT_EV_INFO_NR_CONSEC_SKIPPED_EVENTS(offset) \
        GP_WB_READ_U16((offset) + 0x002)

#define GP_WB_WRITE_INIT_EV_INFO_NR_CONSEC_SKIPPED_EVENTS(offset, val) do { \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x002, (val)); \
        } while (0)


/* Time an event needs to be soft aborted before next event trigger of the same event (in us), should be minumum the event_processing delay */
#define GP_WB_READ_INIT_EV_INFO_GUARD_TIME(offset) \
        GP_WB_READ_U24((offset) + 0x004)

#define GP_WB_WRITE_INIT_EV_INFO_GUARD_TIME(offset, val) do { \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_WRITE_U24((offset) + 0x004, (val)); \
        } while (0)


/* The time between two events (in us) */
#define GP_WB_READ_INIT_EV_INFO_INTERVAL(offset) \
        GP_WB_READ_U24((offset) + 0x008)

#define GP_WB_WRITE_INIT_EV_INFO_INTERVAL(offset, val) do { \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_WRITE_U24((offset) + 0x008, (val)); \
        } while (0)


/* the duration of the RX window. Resolution 1 us */
#define GP_WB_READ_INIT_EV_INFO_INIT_WINDOW_DURATION(offset) \
        GP_WB_READ_U24((offset) + 0x00c)

#define GP_WB_WRITE_INIT_EV_INFO_INIT_WINDOW_DURATION(offset, val) do { \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_WRITE_U24((offset) + 0x00c, (val)); \
        } while (0)


/* pbm to transmit as connection request frame */
#define GP_WB_READ_INIT_EV_INFO_CONN_REQ_PBM(offset) \
        GP_WB_READ_U8((offset) + 0x00f)

#define GP_WB_WRITE_INIT_EV_INFO_CONN_REQ_PBM(offset, val) do { \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x00f, (val)); \
        } while (0)


/* current index within the channel map */
#define GP_WB_READ_INIT_EV_INFO_CURRENT_CH_MAP_IDX(offset) \
        GP_WB_READ_U8((offset) + 0x010)

#define GP_WB_WRITE_INIT_EV_INFO_CURRENT_CH_MAP_IDX(offset, val) do { \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x010, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INIT_EV_INFO_INIT_CH_MAP(offset) \
        GP_WB_READ_U24((offset) + 0x014)

#define GP_WB_WRITE_INIT_EV_INFO_INIT_CH_MAP(offset, val) \
      GP_WB_WRITE_U24((offset) + 0x014, (val))

/* channel for first  initiating RX window. Always used */
#define GP_WB_READ_INIT_EV_INFO_INIT_CH0(offset) \
        GP_WB_READ_U8((offset) + 0x014)

#define GP_WB_GET_INIT_EV_INFO_INIT_CH0_FROM_INIT_CH_MAP(tmp) \
        ((tmp) & 0xFF)

#define GP_WB_WRITE_INIT_EV_INFO_INIT_CH0(offset, val) do { \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x014, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_INIT_CH0_TO_INIT_CH_MAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0xFFFF00; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* channel for second initiating RX window. Always used */
#define GP_WB_READ_INIT_EV_INFO_INIT_CH1(offset) \
        GP_WB_READ_U8((offset) + 0x015)

#define GP_WB_GET_INIT_EV_INFO_INIT_CH1_FROM_INIT_CH_MAP(tmp) \
        (((tmp) >> 8) & 0xFF)

#define GP_WB_WRITE_INIT_EV_INFO_INIT_CH1(offset, val) do { \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x015, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_INIT_CH1_TO_INIT_CH_MAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0xFF00FF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* channel for third  initiating RX window. Always used */
#define GP_WB_READ_INIT_EV_INFO_INIT_CH2(offset) \
        GP_WB_READ_U8((offset) + 0x016)

#define GP_WB_GET_INIT_EV_INFO_INIT_CH2_FROM_INIT_CH_MAP(tmp) \
        (((tmp) >> 16) & 0xFF)

#define GP_WB_WRITE_INIT_EV_INFO_INIT_CH2(offset, val) do { \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x016, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_INIT_CH2_TO_INIT_CH_MAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x00FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INIT_EV_INFO_FRAME_TYPE_ACCEPT_MASK(offset) \
        GP_WB_READ_U8((offset) + 0x017)

#define GP_WB_WRITE_INIT_EV_INFO_FRAME_TYPE_ACCEPT_MASK(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x017, (val))

#define GP_WB_READ_INIT_EV_INFO_ACCEPT_FT_ADV_IND(offset) \
        GP_WB_READ_U1((offset) + 0x017, 0)

#define GP_WB_GET_INIT_EV_INFO_ACCEPT_FT_ADV_IND_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_ACCEPT_FT_ADV_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 0, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_ACCEPT_FT_ADV_IND_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_INIT_EV_INFO_ACCEPT_FT_ADV_DIRECT_IND(offset) \
        GP_WB_READ_U1((offset) + 0x017, 1)

#define GP_WB_GET_INIT_EV_INFO_ACCEPT_FT_ADV_DIRECT_IND_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_ACCEPT_FT_ADV_DIRECT_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 1, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_ACCEPT_FT_ADV_DIRECT_IND_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_INIT_EV_INFO_ACCEPT_FT_ADV_NONCONN_IND(offset) \
        GP_WB_READ_U1((offset) + 0x017, 2)

#define GP_WB_GET_INIT_EV_INFO_ACCEPT_FT_ADV_NONCONN_IND_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_ACCEPT_FT_ADV_NONCONN_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 2, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_ACCEPT_FT_ADV_NONCONN_IND_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_INIT_EV_INFO_ACCEPT_FT_SCAN_REQ(offset) \
        GP_WB_READ_U1((offset) + 0x017, 3)

#define GP_WB_GET_INIT_EV_INFO_ACCEPT_FT_SCAN_REQ_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_ACCEPT_FT_SCAN_REQ(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 3, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_ACCEPT_FT_SCAN_REQ_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_INIT_EV_INFO_ACCEPT_FT_AUX_SCAN_REQ(offset) \
        GP_WB_READ_U1((offset) + 0x017, 3)

#define GP_WB_GET_INIT_EV_INFO_ACCEPT_FT_AUX_SCAN_REQ_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_ACCEPT_FT_AUX_SCAN_REQ(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 3, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_ACCEPT_FT_AUX_SCAN_REQ_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_INIT_EV_INFO_ACCEPT_FT_SCAN_RSP(offset) \
        GP_WB_READ_U1((offset) + 0x017, 4)

#define GP_WB_GET_INIT_EV_INFO_ACCEPT_FT_SCAN_RSP_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_ACCEPT_FT_SCAN_RSP(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 4, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_ACCEPT_FT_SCAN_RSP_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_READ_INIT_EV_INFO_ACCEPT_FT_CONNECT_REQ(offset) \
        GP_WB_READ_U1((offset) + 0x017, 5)

#define GP_WB_GET_INIT_EV_INFO_ACCEPT_FT_CONNECT_REQ_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_ACCEPT_FT_CONNECT_REQ(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 5, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_ACCEPT_FT_CONNECT_REQ_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

#define GP_WB_READ_INIT_EV_INFO_ACCEPT_FT_AUX_CONNECT_REQ(offset) \
        GP_WB_READ_U1((offset) + 0x017, 5)

#define GP_WB_GET_INIT_EV_INFO_ACCEPT_FT_AUX_CONNECT_REQ_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_ACCEPT_FT_AUX_CONNECT_REQ(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 5, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_ACCEPT_FT_AUX_CONNECT_REQ_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

#define GP_WB_READ_INIT_EV_INFO_ACCEPT_FT_ADV_SCAN_IND(offset) \
        GP_WB_READ_U1((offset) + 0x017, 6)

#define GP_WB_GET_INIT_EV_INFO_ACCEPT_FT_ADV_SCAN_IND_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_ACCEPT_FT_ADV_SCAN_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 6, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_ACCEPT_FT_ADV_SCAN_IND_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

#define GP_WB_READ_INIT_EV_INFO_ACCEPT_FT_ADV_EXT_IND(offset) \
        GP_WB_READ_U1((offset) + 0x017, 7)

#define GP_WB_GET_INIT_EV_INFO_ACCEPT_FT_ADV_EXT_IND_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_ACCEPT_FT_ADV_EXT_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 7, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_ACCEPT_FT_ADV_EXT_IND_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)

#define GP_WB_READ_INIT_EV_INFO_ACCEPT_FT_AUX_ADV_IND(offset) \
        GP_WB_READ_U1((offset) + 0x017, 7)

#define GP_WB_GET_INIT_EV_INFO_ACCEPT_FT_AUX_ADV_IND_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_ACCEPT_FT_AUX_ADV_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 7, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_ACCEPT_FT_AUX_ADV_IND_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)

#define GP_WB_READ_INIT_EV_INFO_ACCEPT_FT_AUX_SCAN_RSP(offset) \
        GP_WB_READ_U1((offset) + 0x017, 7)

#define GP_WB_GET_INIT_EV_INFO_ACCEPT_FT_AUX_SCAN_RSP_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_ACCEPT_FT_AUX_SCAN_RSP(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 7, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_ACCEPT_FT_AUX_SCAN_RSP_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)

#define GP_WB_READ_INIT_EV_INFO_ACCEPT_FT_AUX_SYNC_IND(offset) \
        GP_WB_READ_U1((offset) + 0x017, 7)

#define GP_WB_GET_INIT_EV_INFO_ACCEPT_FT_AUX_SYNC_IND_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_ACCEPT_FT_AUX_SYNC_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 7, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_ACCEPT_FT_AUX_SYNC_IND_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)

#define GP_WB_READ_INIT_EV_INFO_ACCEPT_FT_AUX_CHAIN_IND(offset) \
        GP_WB_READ_U1((offset) + 0x017, 7)

#define GP_WB_GET_INIT_EV_INFO_ACCEPT_FT_AUX_CHAIN_IND_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_ACCEPT_FT_AUX_CHAIN_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x017, 7, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_ACCEPT_FT_AUX_CHAIN_IND_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INIT_EV_INFO_FT_WHITELIST_ENABLE_MASK(offset) \
        GP_WB_READ_U8((offset) + 0x018)

#define GP_WB_WRITE_INIT_EV_INFO_FT_WHITELIST_ENABLE_MASK(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x018, (val))

#define GP_WB_READ_INIT_EV_INFO_FT_ADV_IND_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 0)

#define GP_WB_GET_INIT_EV_INFO_FT_ADV_IND_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_FT_ADV_IND_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 0, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_FT_ADV_IND_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFE; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_INIT_EV_INFO_FT_ADV_DIRECT_IND_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 1)

#define GP_WB_GET_INIT_EV_INFO_FT_ADV_DIRECT_IND_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_FT_ADV_DIRECT_IND_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 1, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_FT_ADV_DIRECT_IND_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFD; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_INIT_EV_INFO_FT_ADV_NONCONN_IND_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 2)

#define GP_WB_GET_INIT_EV_INFO_FT_ADV_NONCONN_IND_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_FT_ADV_NONCONN_IND_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 2, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_FT_ADV_NONCONN_IND_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFB; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_INIT_EV_INFO_FT_SCAN_REQ_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 3)

#define GP_WB_GET_INIT_EV_INFO_FT_SCAN_REQ_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_FT_SCAN_REQ_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 3, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_FT_SCAN_REQ_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_INIT_EV_INFO_FT_AUX_SCAN_REQ_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 3)

#define GP_WB_GET_INIT_EV_INFO_FT_AUX_SCAN_REQ_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_FT_AUX_SCAN_REQ_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 3, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_FT_AUX_SCAN_REQ_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_INIT_EV_INFO_FT_SCAN_RSP_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 4)

#define GP_WB_GET_INIT_EV_INFO_FT_SCAN_RSP_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_FT_SCAN_RSP_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 4, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_FT_SCAN_RSP_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEF; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_READ_INIT_EV_INFO_FT_CONNECT_REQ_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 5)

#define GP_WB_GET_INIT_EV_INFO_FT_CONNECT_REQ_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_FT_CONNECT_REQ_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 5, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_FT_CONNECT_REQ_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

#define GP_WB_READ_INIT_EV_INFO_FT_AUX_CONNECT_REQ_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 5)

#define GP_WB_GET_INIT_EV_INFO_FT_AUX_CONNECT_REQ_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_FT_AUX_CONNECT_REQ_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 5, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_FT_AUX_CONNECT_REQ_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDF; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)

#define GP_WB_READ_INIT_EV_INFO_FT_ADV_SCAN_IND_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 6)

#define GP_WB_GET_INIT_EV_INFO_FT_ADV_SCAN_IND_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_FT_ADV_SCAN_IND_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 6, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_FT_ADV_SCAN_IND_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBF; \
          (tmp) |= (((UInt8)(val)) << 6); \
        } while (0)

#define GP_WB_READ_INIT_EV_INFO_FT_ADV_EXT_IND_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 7)

#define GP_WB_GET_INIT_EV_INFO_FT_ADV_EXT_IND_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_FT_ADV_EXT_IND_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 7, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_FT_ADV_EXT_IND_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)

#define GP_WB_READ_INIT_EV_INFO_FT_AUX_ADV_IND_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 7)

#define GP_WB_GET_INIT_EV_INFO_FT_AUX_ADV_IND_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_FT_AUX_ADV_IND_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 7, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_FT_AUX_ADV_IND_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)

#define GP_WB_READ_INIT_EV_INFO_FT_AUX_SCAN_RSP_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 7)

#define GP_WB_GET_INIT_EV_INFO_FT_AUX_SCAN_RSP_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_FT_AUX_SCAN_RSP_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 7, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_FT_AUX_SCAN_RSP_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)

#define GP_WB_READ_INIT_EV_INFO_FT_AUX_SYNC_IND_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 7)

#define GP_WB_GET_INIT_EV_INFO_FT_AUX_SYNC_IND_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_FT_AUX_SYNC_IND_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 7, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_FT_AUX_SYNC_IND_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)

#define GP_WB_READ_INIT_EV_INFO_FT_AUX_CHAIN_IND_WL_EN(offset) \
        GP_WB_READ_U1((offset) + 0x018, 7)

#define GP_WB_GET_INIT_EV_INFO_FT_AUX_CHAIN_IND_WL_EN_FROM_FT_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_FT_AUX_CHAIN_IND_WL_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x018, 7, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_FT_AUX_CHAIN_IND_WL_EN_TO_FT_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7F; \
          (tmp) |= (((UInt8)(val)) << 7); \
        } while (0)


/* The address to check against for directed advertising packets */
#define GP_WB_READ_INIT_EV_INFO_OWN_DEVICE_ADDRESS(offset) \
        GP_WB_READ_U48((offset) + 0x01c)

#define GP_WB_WRITE_INIT_EV_INFO_OWN_DEVICE_ADDRESS(offset, val) do { \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_WRITE_U48((offset) + 0x01c, (val)); \
        } while (0)


/* The address_type to check against for directed advertising packets */
#define GP_WB_READ_INIT_EV_INFO_OWN_DEVICE_ADDRESS_TYPE(offset) \
        GP_WB_READ_U1((offset) + 0x022, 0)

#define GP_WB_WRITE_INIT_EV_INFO_OWN_DEVICE_ADDRESS_TYPE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x022, 0, (val)); \
        } while (0)

/* generate resolvable private source address for outgoing packets */
#define GP_WB_READ_INIT_EV_INFO_GENERATE_RES_PR(offset) \
        GP_WB_READ_U1((offset) + 0x022, 1)

#define GP_WB_WRITE_INIT_EV_INFO_GENERATE_RES_PR(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x022, 1, (val)); \
        } while (0)

/* Indicates if the received ADV PDU has the ChSel bit set or not */
#define GP_WB_READ_INIT_EV_INFO_CHAN_SEL_BIT_SET_BY_ADVERTISER(offset) \
        GP_WB_READ_U1((offset) + 0x022, 2)

#define GP_WB_WRITE_INIT_EV_INFO_CHAN_SEL_BIT_SET_BY_ADVERTISER(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x022, 2, (val)); \
        } while (0)

/* when 1, unresolved RPA src addresses will not be dropped */
#define GP_WB_READ_INIT_EV_INFO_ACCEPT_UNRESOLVED_RPA_SRC(offset) \
        GP_WB_READ_U1((offset) + 0x022, 3)

#define GP_WB_WRITE_INIT_EV_INFO_ACCEPT_UNRESOLVED_RPA_SRC(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x022, 3, (val)); \
        } while (0)

/* when 1, unresolved identity (non-RPA) src addresses will not be dropped */
#define GP_WB_READ_INIT_EV_INFO_ACCEPT_UNRESOLVED_ID_SRC(offset) \
        GP_WB_READ_U1((offset) + 0x022, 4)

#define GP_WB_WRITE_INIT_EV_INFO_ACCEPT_UNRESOLVED_ID_SRC(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x022, 4, (val)); \
        } while (0)


/* Pointer to the virtual event to be used for connection parameters. When this is value is invalid (greater than 15), the window offset is not calculated and not written to the frame */
#define GP_WB_READ_INIT_EV_INFO_VIRT_EV_NR(offset) \
        GP_WB_READ_U8((offset) + 0x023)

#define GP_WB_WRITE_INIT_EV_INFO_VIRT_EV_NR(offset, val) do { \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x023, (val)); \
        } while (0)


/* Holds the address of the device a connection was just initiated with */
#define GP_WB_READ_INIT_EV_INFO_CONN_DST_ADDRESS(offset) \
        GP_WB_READ_U48((offset) + 0x024)

#define GP_WB_WRITE_INIT_EV_INFO_CONN_DST_ADDRESS(offset, val) do { \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_WRITE_U48((offset) + 0x024, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INIT_EV_INFO_COEX_TX_SETTINGS(offset) \
        GP_WB_READ_U8((offset) + 0x02a)

#define GP_WB_WRITE_INIT_EV_INFO_COEX_TX_SETTINGS(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x02a, (val))

/* priority of the coex request (if enabled by req_en) */
#define GP_WB_READ_INIT_EV_INFO_COEX_TX_PRIO(offset) \
        (GP_WB_READ_U8((offset) + 0x02a) & 0x03)

#define GP_WB_GET_INIT_EV_INFO_COEX_TX_PRIO_FROM_COEX_TX_SETTINGS(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_INIT_EV_INFO_COEX_TX_PRIO(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U8((offset) + 0x02a, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_COEX_TX_PRIO_TO_COEX_TX_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x0C; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* if 1, a coex request will be launched upon radio action */
#define GP_WB_READ_INIT_EV_INFO_COEX_TX_REQ_EN(offset) \
        GP_WB_READ_U1((offset) + 0x02a, 2)

#define GP_WB_GET_INIT_EV_INFO_COEX_TX_REQ_EN_FROM_COEX_TX_SETTINGS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_COEX_TX_REQ_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x02a, 2, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_COEX_TX_REQ_EN_TO_COEX_TX_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* If 1, the PA will be disabled if no coex grant is received */
#define GP_WB_READ_INIT_EV_INFO_COEX_TX_GRANT_AWARE(offset) \
        GP_WB_READ_U1((offset) + 0x02a, 3)

#define GP_WB_GET_INIT_EV_INFO_COEX_TX_GRANT_AWARE_FROM_COEX_TX_SETTINGS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_COEX_TX_GRANT_AWARE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x02a, 3, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_COEX_TX_GRANT_AWARE_TO_COEX_TX_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INIT_EV_INFO_COEX_RX_SETTINGS(offset) \
        GP_WB_READ_U8((offset) + 0x02b)

#define GP_WB_WRITE_INIT_EV_INFO_COEX_RX_SETTINGS(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x02b, (val))

/* priority of the coex request (if enabled by req_en) */
#define GP_WB_READ_INIT_EV_INFO_COEX_RX_PRIO(offset) \
        (GP_WB_READ_U8((offset) + 0x02b) & 0x03)

#define GP_WB_GET_INIT_EV_INFO_COEX_RX_PRIO_FROM_COEX_RX_SETTINGS(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_INIT_EV_INFO_COEX_RX_PRIO(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U8((offset) + 0x02b, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_COEX_RX_PRIO_TO_COEX_RX_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x0C; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* if 1, a coex request will be launched upon radio action */
#define GP_WB_READ_INIT_EV_INFO_COEX_RX_REQ_EN(offset) \
        GP_WB_READ_U1((offset) + 0x02b, 2)

#define GP_WB_GET_INIT_EV_INFO_COEX_RX_REQ_EN_FROM_COEX_RX_SETTINGS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_COEX_RX_REQ_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x02b, 2, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_COEX_RX_REQ_EN_TO_COEX_RX_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* If 1, the PA will be disabled if no coex grant is received */
#define GP_WB_READ_INIT_EV_INFO_COEX_RX_GRANT_AWARE(offset) \
        GP_WB_READ_U1((offset) + 0x02b, 3)

#define GP_WB_GET_INIT_EV_INFO_COEX_RX_GRANT_AWARE_FROM_COEX_RX_SETTINGS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_COEX_RX_GRANT_AWARE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x02b, 3, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_COEX_RX_GRANT_AWARE_TO_COEX_RX_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INIT_EV_INFO_COEX_RX_WD_SETTINGS(offset) \
        GP_WB_READ_U8((offset) + 0x02c)

#define GP_WB_WRITE_INIT_EV_INFO_COEX_RX_WD_SETTINGS(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x02c, (val))

/* priority of the coex request (if enabled by req_en) */
#define GP_WB_READ_INIT_EV_INFO_COEX_RX_WD_PRIO(offset) \
        (GP_WB_READ_U8((offset) + 0x02c) & 0x03)

#define GP_WB_GET_INIT_EV_INFO_COEX_RX_WD_PRIO_FROM_COEX_RX_WD_SETTINGS(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_INIT_EV_INFO_COEX_RX_WD_PRIO(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U8((offset) + 0x02c, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_COEX_RX_WD_PRIO_TO_COEX_RX_WD_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x0C; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* if 1, a coex request will be launched upon radio action */
#define GP_WB_READ_INIT_EV_INFO_COEX_RX_WD_REQ_EN(offset) \
        GP_WB_READ_U1((offset) + 0x02c, 2)

#define GP_WB_GET_INIT_EV_INFO_COEX_RX_WD_REQ_EN_FROM_COEX_RX_WD_SETTINGS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_COEX_RX_WD_REQ_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x02c, 2, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_COEX_RX_WD_REQ_EN_TO_COEX_RX_WD_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* If 1, the PA will be disabled if no coex grant is received */
#define GP_WB_READ_INIT_EV_INFO_COEX_RX_WD_GRANT_AWARE(offset) \
        GP_WB_READ_U1((offset) + 0x02c, 3)

#define GP_WB_GET_INIT_EV_INFO_COEX_RX_WD_GRANT_AWARE_FROM_COEX_RX_WD_SETTINGS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_INIT_EV_INFO_COEX_RX_WD_GRANT_AWARE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x02c, 3, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EV_INFO_COEX_RX_WD_GRANT_AWARE_TO_COEX_RX_WD_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* Indicates whether the antenna swithcing feature should be enabled */
#define GP_WB_READ_INIT_EV_INFO_EN_ANT_SWITCHING(offset) \
        GP_WB_READ_U8((offset) + 0x02d)

#define GP_WB_WRITE_INIT_EV_INFO_EN_ANT_SWITCHING(offset, val) do { \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x02d, (val)); \
        } while (0)


/* Indicates the antenna currently being used (or next to be used when not during the event) */
#define GP_WB_READ_INIT_EV_INFO_CURR_ANTENNA(offset) \
        GP_WB_READ_U8((offset) + 0x02e)

#define GP_WB_WRITE_INIT_EV_INFO_CURR_ANTENNA(offset, val) do { \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x02e, (val)); \
        } while (0)


/* pointer to a CM style list of rx_list_entry elements that get written after the RX mode is set and before the receiver is started */
#define GP_WB_READ_INIT_EV_INFO_RX_LIST_PTR(offset) \
        GP_WB_READ_U16((offset) + 0x030)

#define GP_WB_WRITE_INIT_EV_INFO_RX_LIST_PTR(offset, val) do { \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x030, (val)); \
        } while (0)


/* indicates if multistandard listening is allowed for this subevent. */
#define GP_WB_READ_INIT_EV_INFO_MS_ALLOWED(offset) \
        GP_WB_READ_U1((offset) + 0x032, 0)

#define GP_WB_WRITE_INIT_EV_INFO_MS_ALLOWED(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x032, (val)); \
        } while (0)

/***************************
 * layout: init_ext_info
 ***************************/

/* Pointer to the virtual event to be used for connection parameters. When this is value is invalid (greater than 15), the window offset is not calculated and not written to the frame */
#define GP_WB_READ_INIT_EXT_INFO_BLE_HDR_VIRT_EV_NR(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_INIT_EXT_INFO_BLE_HDR_VIRT_EV_NR(offset, val) do { \
          GP_WB_CHECK_OFFSET_INIT_EXT_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x000, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INIT_EXT_INFO_BLE_HDR_LLDATA(offset) \
        GP_WB_READ_U32((offset) + 0x002)

#define GP_WB_WRITE_INIT_EXT_INFO_BLE_HDR_LLDATA(offset, val) \
      GP_WB_WRITE_U32((offset) + 0x002, (val))

/* Latency to be copied to the LLData field of the connect_req_pdu */
#define GP_WB_READ_INIT_EXT_INFO_BLE_HDR_LLDATA_LATENCY(offset) \
        GP_WB_READ_U16((offset) + 0x002)

#define GP_WB_GET_INIT_EXT_INFO_BLE_HDR_LLDATA_LATENCY_FROM_BLE_HDR_LLDATA(tmp) \
        ((tmp) & 0xFFFF)

#define GP_WB_WRITE_INIT_EXT_INFO_BLE_HDR_LLDATA_LATENCY(offset, val) do { \
          GP_WB_CHECK_OFFSET_INIT_EXT_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x002, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EXT_INFO_BLE_HDR_LLDATA_LATENCY_TO_BLE_HDR_LLDATA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0xFFFF0000; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Timeout to be copied to the LLData field of the connect_req_pdu */
#define GP_WB_READ_INIT_EXT_INFO_BLE_HDR_LLDATA_TIMEOUT(offset) \
        GP_WB_READ_U16((offset) + 0x004)

#define GP_WB_GET_INIT_EXT_INFO_BLE_HDR_LLDATA_TIMEOUT_FROM_BLE_HDR_LLDATA(tmp) \
        (((tmp) >> 16) & 0xFFFF)

#define GP_WB_WRITE_INIT_EXT_INFO_BLE_HDR_LLDATA_TIMEOUT(offset, val) do { \
          GP_WB_CHECK_OFFSET_INIT_EXT_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x004, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EXT_INFO_BLE_HDR_LLDATA_TIMEOUT_TO_BLE_HDR_LLDATA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x0000FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)


/* Pointer to the virtual event to be used for connection parameters. When this is value is invalid (greater than 15), the window offset is not calculated and not written to the frame */
#define GP_WB_READ_INIT_EXT_INFO_BLE_LR_VIRT_EV_NR(offset) \
        GP_WB_READ_U8((offset) + 0x006)

#define GP_WB_WRITE_INIT_EXT_INFO_BLE_LR_VIRT_EV_NR(offset, val) do { \
          GP_WB_CHECK_OFFSET_INIT_EXT_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x006, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INIT_EXT_INFO_BLE_LR_LLDATA(offset) \
        GP_WB_READ_U32((offset) + 0x008)

#define GP_WB_WRITE_INIT_EXT_INFO_BLE_LR_LLDATA(offset, val) \
      GP_WB_WRITE_U32((offset) + 0x008, (val))

/* Latency to be copied to the LLData field of the connect_req_pdu */
#define GP_WB_READ_INIT_EXT_INFO_BLE_LR_LLDATA_LATENCY(offset) \
        GP_WB_READ_U16((offset) + 0x008)

#define GP_WB_GET_INIT_EXT_INFO_BLE_LR_LLDATA_LATENCY_FROM_BLE_LR_LLDATA(tmp) \
        ((tmp) & 0xFFFF)

#define GP_WB_WRITE_INIT_EXT_INFO_BLE_LR_LLDATA_LATENCY(offset, val) do { \
          GP_WB_CHECK_OFFSET_INIT_EXT_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x008, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EXT_INFO_BLE_LR_LLDATA_LATENCY_TO_BLE_LR_LLDATA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0xFFFF0000; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Timeout to be copied to the LLData field of the connect_req_pdu */
#define GP_WB_READ_INIT_EXT_INFO_BLE_LR_LLDATA_TIMEOUT(offset) \
        GP_WB_READ_U16((offset) + 0x00a)

#define GP_WB_GET_INIT_EXT_INFO_BLE_LR_LLDATA_TIMEOUT_FROM_BLE_LR_LLDATA(tmp) \
        (((tmp) >> 16) & 0xFFFF)

#define GP_WB_WRITE_INIT_EXT_INFO_BLE_LR_LLDATA_TIMEOUT(offset, val) do { \
          GP_WB_CHECK_OFFSET_INIT_EXT_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x00a, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EXT_INFO_BLE_LR_LLDATA_TIMEOUT_TO_BLE_LR_LLDATA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x0000FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INIT_EXT_INFO_PRI_PHY_MASK(offset) \
        GP_WB_READ_U8((offset) + 0x00c)

#define GP_WB_WRITE_INIT_EXT_INFO_PRI_PHY_MASK(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x00c, (val))

/* 1Mbit */
#define GP_WB_READ_INIT_EXT_INFO_PRI_ONE(offset) \
        GP_WB_READ_U1((offset) + 0x00c, 0)

#define GP_WB_GET_INIT_EXT_INFO_PRI_ONE_FROM_PRI_PHY_MASK(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INIT_EXT_INFO_PRI_ONE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EXT_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00c, 0, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EXT_INFO_PRI_ONE_TO_PRI_PHY_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* reserved for future use */
#define GP_WB_READ_INIT_EXT_INFO_PRI_RFU(offset) \
        GP_WB_READ_U1((offset) + 0x00c, 1)

#define GP_WB_GET_INIT_EXT_INFO_PRI_RFU_FROM_PRI_PHY_MASK(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INIT_EXT_INFO_PRI_RFU(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EXT_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00c, 1, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EXT_INFO_PRI_RFU_TO_PRI_PHY_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* long range */
#define GP_WB_READ_INIT_EXT_INFO_PRI_LR(offset) \
        GP_WB_READ_U1((offset) + 0x00c, 2)

#define GP_WB_GET_INIT_EXT_INFO_PRI_LR_FROM_PRI_PHY_MASK(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INIT_EXT_INFO_PRI_LR(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EXT_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00c, 2, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EXT_INFO_PRI_LR_TO_PRI_PHY_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INIT_EXT_INFO_SEC_PHY_MASK(offset) \
        GP_WB_READ_U8((offset) + 0x00d)

#define GP_WB_WRITE_INIT_EXT_INFO_SEC_PHY_MASK(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x00d, (val))

/* 1Mbit */
#define GP_WB_READ_INIT_EXT_INFO_SEC_ONE(offset) \
        GP_WB_READ_U1((offset) + 0x00d, 0)

#define GP_WB_GET_INIT_EXT_INFO_SEC_ONE_FROM_SEC_PHY_MASK(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INIT_EXT_INFO_SEC_ONE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EXT_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00d, 0, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EXT_INFO_SEC_ONE_TO_SEC_PHY_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* 2Mbit */
#define GP_WB_READ_INIT_EXT_INFO_SEC_TWO(offset) \
        GP_WB_READ_U1((offset) + 0x00d, 1)

#define GP_WB_GET_INIT_EXT_INFO_SEC_TWO_FROM_SEC_PHY_MASK(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INIT_EXT_INFO_SEC_TWO(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EXT_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00d, 1, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EXT_INFO_SEC_TWO_TO_SEC_PHY_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* long range */
#define GP_WB_READ_INIT_EXT_INFO_SEC_LR(offset) \
        GP_WB_READ_U1((offset) + 0x00d, 2)

#define GP_WB_GET_INIT_EXT_INFO_SEC_LR_FROM_SEC_PHY_MASK(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INIT_EXT_INFO_SEC_LR(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_EXT_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00d, 2, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EXT_INFO_SEC_LR_TO_SEC_PHY_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/***************************
 * layout: init_ext_virt_conn_info
 ***************************/

/* Pointer to the virtual event to be used for connection parameters. When this is value is invalid (greater than 15), the window offset is not calculated and not written to the frame */
#define GP_WB_READ_INIT_EXT_VIRT_CONN_INFO_VIRT_EV_NR(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_INIT_EXT_VIRT_CONN_INFO_VIRT_EV_NR(offset, val) do { \
          GP_WB_CHECK_OFFSET_INIT_EXT_VIRT_CONN_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x000, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INIT_EXT_VIRT_CONN_INFO_LLDATA(offset) \
        GP_WB_READ_U32((offset) + 0x002)

#define GP_WB_WRITE_INIT_EXT_VIRT_CONN_INFO_LLDATA(offset, val) \
      GP_WB_WRITE_U32((offset) + 0x002, (val))

/* Latency to be copied to the LLData field of the connect_req_pdu */
#define GP_WB_READ_INIT_EXT_VIRT_CONN_INFO_LLDATA_LATENCY(offset) \
        GP_WB_READ_U16((offset) + 0x002)

#define GP_WB_GET_INIT_EXT_VIRT_CONN_INFO_LLDATA_LATENCY_FROM_LLDATA(tmp) \
        ((tmp) & 0xFFFF)

#define GP_WB_WRITE_INIT_EXT_VIRT_CONN_INFO_LLDATA_LATENCY(offset, val) do { \
          GP_WB_CHECK_OFFSET_INIT_EXT_VIRT_CONN_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x002, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EXT_VIRT_CONN_INFO_LLDATA_LATENCY_TO_LLDATA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0xFFFF0000; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Timeout to be copied to the LLData field of the connect_req_pdu */
#define GP_WB_READ_INIT_EXT_VIRT_CONN_INFO_LLDATA_TIMEOUT(offset) \
        GP_WB_READ_U16((offset) + 0x004)

#define GP_WB_GET_INIT_EXT_VIRT_CONN_INFO_LLDATA_TIMEOUT_FROM_LLDATA(tmp) \
        (((tmp) >> 16) & 0xFFFF)

#define GP_WB_WRITE_INIT_EXT_VIRT_CONN_INFO_LLDATA_TIMEOUT(offset, val) do { \
          GP_WB_CHECK_OFFSET_INIT_EXT_VIRT_CONN_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x004, (val)); \
        } while (0)

#define GP_WB_SET_INIT_EXT_VIRT_CONN_INFO_LLDATA_TIMEOUT_TO_LLDATA(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x0000FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/***************************
 * layout: init_common_ext_info_depr
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INIT_COMMON_EXT_INFO_DEPR_PRI_PHY_MASK(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_INIT_COMMON_EXT_INFO_DEPR_PRI_PHY_MASK(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x000, (val))

/* 1Mbit */
#define GP_WB_READ_INIT_COMMON_EXT_INFO_DEPR_PRI_ONE(offset) \
        GP_WB_READ_U1((offset) + 0x000, 0)

#define GP_WB_GET_INIT_COMMON_EXT_INFO_DEPR_PRI_ONE_FROM_PRI_PHY_MASK(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INIT_COMMON_EXT_INFO_DEPR_PRI_ONE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_COMMON_EXT_INFO_DEPR(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 0, (val)); \
        } while (0)

#define GP_WB_SET_INIT_COMMON_EXT_INFO_DEPR_PRI_ONE_TO_PRI_PHY_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* reserved for future use */
#define GP_WB_READ_INIT_COMMON_EXT_INFO_DEPR_PRI_RFU(offset) \
        GP_WB_READ_U1((offset) + 0x000, 1)

#define GP_WB_GET_INIT_COMMON_EXT_INFO_DEPR_PRI_RFU_FROM_PRI_PHY_MASK(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INIT_COMMON_EXT_INFO_DEPR_PRI_RFU(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_COMMON_EXT_INFO_DEPR(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 1, (val)); \
        } while (0)

#define GP_WB_SET_INIT_COMMON_EXT_INFO_DEPR_PRI_RFU_TO_PRI_PHY_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* long range */
#define GP_WB_READ_INIT_COMMON_EXT_INFO_DEPR_PRI_LR(offset) \
        GP_WB_READ_U1((offset) + 0x000, 2)

#define GP_WB_GET_INIT_COMMON_EXT_INFO_DEPR_PRI_LR_FROM_PRI_PHY_MASK(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INIT_COMMON_EXT_INFO_DEPR_PRI_LR(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_COMMON_EXT_INFO_DEPR(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 2, (val)); \
        } while (0)

#define GP_WB_SET_INIT_COMMON_EXT_INFO_DEPR_PRI_LR_TO_PRI_PHY_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_INIT_COMMON_EXT_INFO_DEPR_SEC_PHY_MASK(offset) \
        GP_WB_READ_U8((offset) + 0x001)

#define GP_WB_WRITE_INIT_COMMON_EXT_INFO_DEPR_SEC_PHY_MASK(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x001, (val))

/* 1Mbit */
#define GP_WB_READ_INIT_COMMON_EXT_INFO_DEPR_SEC_ONE(offset) \
        GP_WB_READ_U1((offset) + 0x001, 0)

#define GP_WB_GET_INIT_COMMON_EXT_INFO_DEPR_SEC_ONE_FROM_SEC_PHY_MASK(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_INIT_COMMON_EXT_INFO_DEPR_SEC_ONE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_COMMON_EXT_INFO_DEPR(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 0, (val)); \
        } while (0)

#define GP_WB_SET_INIT_COMMON_EXT_INFO_DEPR_SEC_ONE_TO_SEC_PHY_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* 2Mbit */
#define GP_WB_READ_INIT_COMMON_EXT_INFO_DEPR_SEC_TWO(offset) \
        GP_WB_READ_U1((offset) + 0x001, 1)

#define GP_WB_GET_INIT_COMMON_EXT_INFO_DEPR_SEC_TWO_FROM_SEC_PHY_MASK(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_INIT_COMMON_EXT_INFO_DEPR_SEC_TWO(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_COMMON_EXT_INFO_DEPR(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 1, (val)); \
        } while (0)

#define GP_WB_SET_INIT_COMMON_EXT_INFO_DEPR_SEC_TWO_TO_SEC_PHY_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* long range */
#define GP_WB_READ_INIT_COMMON_EXT_INFO_DEPR_SEC_LR(offset) \
        GP_WB_READ_U1((offset) + 0x001, 2)

#define GP_WB_GET_INIT_COMMON_EXT_INFO_DEPR_SEC_LR_FROM_SEC_PHY_MASK(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_INIT_COMMON_EXT_INFO_DEPR_SEC_LR(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_INIT_COMMON_EXT_INFO_DEPR(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 2, (val)); \
        } while (0)

#define GP_WB_SET_INIT_COMMON_EXT_INFO_DEPR_SEC_LR_TO_SEC_PHY_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/***************************
 * layout: scan_ext_info
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SCAN_EXT_INFO_PRI_PHY_MASK(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_SCAN_EXT_INFO_PRI_PHY_MASK(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x000, (val))

/* 1Mbit */
#define GP_WB_READ_SCAN_EXT_INFO_PRI_ONE(offset) \
        GP_WB_READ_U1((offset) + 0x000, 0)

#define GP_WB_GET_SCAN_EXT_INFO_PRI_ONE_FROM_PRI_PHY_MASK(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_SCAN_EXT_INFO_PRI_ONE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EXT_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 0, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EXT_INFO_PRI_ONE_TO_PRI_PHY_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* reserved for future use */
#define GP_WB_READ_SCAN_EXT_INFO_PRI_RFU(offset) \
        GP_WB_READ_U1((offset) + 0x000, 1)

#define GP_WB_GET_SCAN_EXT_INFO_PRI_RFU_FROM_PRI_PHY_MASK(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_SCAN_EXT_INFO_PRI_RFU(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EXT_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 1, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EXT_INFO_PRI_RFU_TO_PRI_PHY_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* long range */
#define GP_WB_READ_SCAN_EXT_INFO_PRI_LR(offset) \
        GP_WB_READ_U1((offset) + 0x000, 2)

#define GP_WB_GET_SCAN_EXT_INFO_PRI_LR_FROM_PRI_PHY_MASK(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_SCAN_EXT_INFO_PRI_LR(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EXT_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 2, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EXT_INFO_PRI_LR_TO_PRI_PHY_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SCAN_EXT_INFO_SEC_PHY_MASK(offset) \
        GP_WB_READ_U8((offset) + 0x001)

#define GP_WB_WRITE_SCAN_EXT_INFO_SEC_PHY_MASK(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x001, (val))

/* 1Mbit */
#define GP_WB_READ_SCAN_EXT_INFO_SEC_ONE(offset) \
        GP_WB_READ_U1((offset) + 0x001, 0)

#define GP_WB_GET_SCAN_EXT_INFO_SEC_ONE_FROM_SEC_PHY_MASK(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_SCAN_EXT_INFO_SEC_ONE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EXT_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 0, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EXT_INFO_SEC_ONE_TO_SEC_PHY_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* 2Mbit */
#define GP_WB_READ_SCAN_EXT_INFO_SEC_TWO(offset) \
        GP_WB_READ_U1((offset) + 0x001, 1)

#define GP_WB_GET_SCAN_EXT_INFO_SEC_TWO_FROM_SEC_PHY_MASK(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_SCAN_EXT_INFO_SEC_TWO(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EXT_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 1, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EXT_INFO_SEC_TWO_TO_SEC_PHY_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* long range */
#define GP_WB_READ_SCAN_EXT_INFO_SEC_LR(offset) \
        GP_WB_READ_U1((offset) + 0x001, 2)

#define GP_WB_GET_SCAN_EXT_INFO_SEC_LR_FROM_SEC_PHY_MASK(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_SCAN_EXT_INFO_SEC_LR(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_EXT_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 2, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_EXT_INFO_SEC_LR_TO_SEC_PHY_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/***************************
 * layout: conn_ev_info
 ***************************/

/* priority of the event, (0= lowest priority; 255 is highest priority) */
#define GP_WB_READ_CONN_EV_INFO_PRIORITY(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_CONN_EV_INFO_PRIORITY(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x000, (val)); \
        } while (0)


/* when enabled, the event will not do any radio activity and the event will be skipped. The event state will still be updated though. */
#define GP_WB_READ_CONN_EV_INFO_SUSPEND_EVENT(offset) \
        GP_WB_READ_U1((offset) + 0x001, 0)

#define GP_WB_WRITE_CONN_EV_INFO_SUSPEND_EVENT(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 0, (val)); \
        } while (0)

/* when 1, the round robin mechanism will also take into account the nr_consec_skipped_events for this event */
#define GP_WB_READ_CONN_EV_INFO_EXTENDED_PRIO_EN(offset) \
        GP_WB_READ_U1((offset) + 0x001, 1)

#define GP_WB_WRITE_CONN_EV_INFO_EXTENDED_PRIO_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 1, (val)); \
        } while (0)


/* Indicates the number of events that are skipped in a row */
#define GP_WB_READ_CONN_EV_INFO_NR_CONSEC_SKIPPED_EVENTS(offset) \
        GP_WB_READ_U16((offset) + 0x002)

#define GP_WB_WRITE_CONN_EV_INFO_NR_CONSEC_SKIPPED_EVENTS(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x002, (val)); \
        } while (0)


/* Time an event needs to be soft aborted before next event trigger of the same event (in us), should be minumum the event_processing delay */
#define GP_WB_READ_CONN_EV_INFO_GUARD_TIME(offset) \
        GP_WB_READ_U24((offset) + 0x004)

#define GP_WB_WRITE_CONN_EV_INFO_GUARD_TIME(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U24((offset) + 0x004, (val)); \
        } while (0)


/* The time between two events (in us) */
#define GP_WB_READ_CONN_EV_INFO_INTERVAL(offset) \
        GP_WB_READ_U24((offset) + 0x008)

#define GP_WB_WRITE_CONN_EV_INFO_INTERVAL(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U24((offset) + 0x008, (val)); \
        } while (0)


/* increase to use when jumping to the next channel */
#define GP_WB_READ_CONN_EV_INFO_HOP_INCREMENT(offset) \
        GP_WB_READ_U8((offset) + 0x00b)

#define GP_WB_WRITE_CONN_EV_INFO_HOP_INCREMENT(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x00b, (val)); \
        } while (0)


/* pointer to the 38 byte hopping remap table */
#define GP_WB_READ_CONN_EV_INFO_CH_MAP_PTR(offset) \
        GP_WB_READ_U16((offset) + 0x00c)

#define GP_WB_WRITE_CONN_EV_INFO_CH_MAP_PTR(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x00c, (val)); \
        } while (0)


/* preamble symbol to fill in into the empty pbm */
#define GP_WB_READ_CONN_EV_INFO_PREAMBLE(offset) \
        GP_WB_READ_U8((offset) + 0x00e)

#define GP_WB_WRITE_CONN_EV_INFO_PREAMBLE(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x00e, (val)); \
        } while (0)


/* phy mode when transmitting connection packets */
#define GP_WB_READ_CONN_EV_INFO_TX_PHY_MODE(offset) \
        (GP_WB_READ_U8((offset) + 0x00f) & 0x03)

#define GP_WB_WRITE_CONN_EV_INFO_TX_PHY_MODE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_MWRITE_U8((offset) + 0x00f, 0x03, (val)); \
        } while (0)

/* phy mode when receiving connection packets */
#define GP_WB_READ_CONN_EV_INFO_RX_PHY_MODE(offset) \
        ((GP_WB_READ_U8((offset) + 0x00f) >> 2) & 0x03)

#define GP_WB_WRITE_CONN_EV_INFO_RX_PHY_MODE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_MWRITE_U8((offset) + 0x00f, 0x0C, (val) << 2); \
        } while (0)


/* access address for this connection */
#define GP_WB_READ_CONN_EV_INFO_ACCESS_ADDRESS(offset) \
        GP_WB_READ_U32((offset) + 0x010)

#define GP_WB_WRITE_CONN_EV_INFO_ACCESS_ADDRESS(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U32((offset) + 0x010, (val)); \
        } while (0)


/* Threshold for BLE preamble detect */
#define GP_WB_READ_CONN_EV_INFO_PREAMBLE_THRESH(offset) \
        GP_WB_READ_U16((offset) + 0x014)

#define GP_WB_WRITE_CONN_EV_INFO_PREAMBLE_THRESH(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x014, (val)); \
        } while (0)


/* Absolute worst-case combined sleep clock accuracy of master and slave. Note that this field is only used on slave links. NRT should add an extra 5% compensation (this will allow RT to make simpler calculations). */
#define GP_WB_READ_CONN_EV_INFO_COMBINED_SCA_WORST(offset) \
        GP_WB_READ_U16((offset) + 0x016)

#define GP_WB_WRITE_CONN_EV_INFO_COMBINED_SCA_WORST(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x016, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_CONN_EV_INFO_VALIDATION_SETTINGS(offset) \
        GP_WB_READ_U32((offset) + 0x018)

#define GP_WB_WRITE_CONN_EV_INFO_VALIDATION_SETTINGS(offset, val) \
      GP_WB_WRITE_U32((offset) + 0x018, (val))

/* Threshold for BLE preamble validation */
#define GP_WB_READ_CONN_EV_INFO_VALIDATION_THRESH(offset) \
        GP_WB_READ_U16((offset) + 0x018)

#define GP_WB_GET_CONN_EV_INFO_VALIDATION_THRESH_FROM_VALIDATION_SETTINGS(tmp) \
        ((tmp) & 0xFFFF)

#define GP_WB_WRITE_CONN_EV_INFO_VALIDATION_THRESH(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x018, (val)); \
        } while (0)

#define GP_WB_SET_CONN_EV_INFO_VALIDATION_THRESH_TO_VALIDATION_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x9F1F0000; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Amount of symbols inside the access code the validation is going to start */
#define GP_WB_READ_CONN_EV_INFO_VALIDATION_START_IDX(offset) \
        GP_WB_READ_U8((offset) + 0x01a)

#define GP_WB_GET_CONN_EV_INFO_VALIDATION_START_IDX_FROM_VALIDATION_SETTINGS(tmp) \
        (((tmp) >> 16) & 0x1F)

#define GP_WB_WRITE_CONN_EV_INFO_VALIDATION_START_IDX(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x01a, (val)); \
        } while (0)

#define GP_WB_SET_CONN_EV_INFO_VALIDATION_START_IDX_TO_VALIDATION_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x9F00FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* The index inside the access code where a fake preamble starts */
#define GP_WB_READ_CONN_EV_INFO_FAKE_PREAMBLE_START_IDX(offset) \
        (GP_WB_READ_U8((offset) + 0x01b) & 0x1F)

#define GP_WB_GET_CONN_EV_INFO_FAKE_PREAMBLE_START_IDX_FROM_VALIDATION_SETTINGS(tmp) \
        (((tmp) >> 24) & 0x1F)

#define GP_WB_WRITE_CONN_EV_INFO_FAKE_PREAMBLE_START_IDX(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_MWRITE_U8((offset) + 0x01b, 0x1F, (val)); \
        } while (0)

#define GP_WB_SET_CONN_EV_INFO_FAKE_PREAMBLE_START_IDX_TO_VALIDATION_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x801FFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)

/* Indicates wheter a fake preamble is present in the access code or not (valid flag for fake_preamble_start_idx) */
#define GP_WB_READ_CONN_EV_INFO_FAKE_PREAMBLE_PRESENT(offset) \
        GP_WB_READ_U1((offset) + 0x01b, 7)

#define GP_WB_GET_CONN_EV_INFO_FAKE_PREAMBLE_PRESENT_FROM_VALIDATION_SETTINGS(tmp) \
        (((tmp) >> 31) & 0x01)

#define GP_WB_WRITE_CONN_EV_INFO_FAKE_PREAMBLE_PRESENT(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x01b, 7, (val)); \
        } while (0)

#define GP_WB_SET_CONN_EV_INFO_FAKE_PREAMBLE_PRESENT_TO_VALIDATION_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F1FFFFF; \
          (tmp) |= (((UInt32)(val)) << 31); \
        } while (0)


/* crc init for this connection */
#define GP_WB_READ_CONN_EV_INFO_CRC_INIT(offset) \
        GP_WB_READ_U24((offset) + 0x01c)

#define GP_WB_WRITE_CONN_EV_INFO_CRC_INIT(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U24((offset) + 0x01c, (val)); \
        } while (0)


/* duration the slave should listen for first synchronisation with the master */
#define GP_WB_READ_CONN_EV_INFO_WINDOW_DURATION(offset) \
        GP_WB_READ_U32((offset) + 0x020)

#define GP_WB_WRITE_CONN_EV_INFO_WINDOW_DURATION(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U32((offset) + 0x020, (val)); \
        } while (0)


/* sleep clock accury of master and slave combined in ppm */
#define GP_WB_READ_CONN_EV_INFO_COMBINED_SCA(offset) \
        GP_WB_READ_U16((offset) + 0x024)

#define GP_WB_WRITE_CONN_EV_INFO_COMBINED_SCA(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x024, (val)); \
        } while (0)


/* Number of events that can be skipped due to slave latency */
#define GP_WB_READ_CONN_EV_INFO_SLAVE_LATENCY(offset) \
        GP_WB_READ_U16((offset) + 0x026)

#define GP_WB_WRITE_CONN_EV_INFO_SLAVE_LATENCY(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x026, (val)); \
        } while (0)


/* (Obsolete since Halo RT v2) window duration to use when the fixed_wd_threshold has been reached */
#define GP_WB_READ_CONN_EV_INFO_FIXED_WD_DUR(offset) \
        GP_WB_READ_U32((offset) + 0x028)

#define GP_WB_WRITE_CONN_EV_INFO_FIXED_WD_DUR(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U32((offset) + 0x028, (val)); \
        } while (0)


/* the number of connection events passed since the start. Initialize to 0. Wraps around at 0xFFFF */
#define GP_WB_READ_CONN_EV_INFO_EVENT_CNT(offset) \
        GP_WB_READ_U16((offset) + 0x02c)

#define GP_WB_WRITE_CONN_EV_INFO_EVENT_CNT(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x02c, (val)); \
        } while (0)


/* The current unmapped channel pointer, initialize to 0 */
#define GP_WB_READ_CONN_EV_INFO_UNMAPPED_CH_PTR(offset) \
        GP_WB_READ_U8((offset) + 0x02e)

#define GP_WB_WRITE_CONN_EV_INFO_UNMAPPED_CH_PTR(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x02e, (val)); \
        } while (0)


/* The sequence number used to identify transmitted packets. Initialize to 0 */
#define GP_WB_READ_CONN_EV_INFO_TX_SN(offset) \
        GP_WB_READ_U8((offset) + 0x02f)

#define GP_WB_WRITE_CONN_EV_INFO_TX_SN(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x02f, (val)); \
        } while (0)


/* The Next Expected Sequence Number to indicate an ack or not. Initialize to 0 */
#define GP_WB_READ_CONN_EV_INFO_TX_NESN(offset) \
        GP_WB_READ_U8((offset) + 0x030)

#define GP_WB_WRITE_CONN_EV_INFO_TX_NESN(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x030, (val)); \
        } while (0)


/* The Sequence Number of the the incomming packet. Indicates if this is a retransmit or not. Initialize to 1 */
#define GP_WB_READ_CONN_EV_INFO_RX_SN(offset) \
        GP_WB_READ_U8((offset) + 0x031)

#define GP_WB_WRITE_CONN_EV_INFO_RX_SN(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x031, (val)); \
        } while (0)


/* The Next Expected Sequence Number of the the incomming packet. indicates if we need to resend Tx_pbm or not. Initialize to 0 */
#define GP_WB_READ_CONN_EV_INFO_RX_NESN(offset) \
        GP_WB_READ_U8((offset) + 0x032)

#define GP_WB_WRITE_CONN_EV_INFO_RX_NESN(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x032, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_CONN_EV_INFO_SLAVE_LATENCY_STATE(offset) \
        GP_WB_READ_U8((offset) + 0x033)

#define GP_WB_WRITE_CONN_EV_INFO_SLAVE_LATENCY_STATE(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x033, (val))

/* Indicates whether the slave latency should be enabled for the next (few) events. This accounts for the MD bits and acks of the previous packets. Initialize to 0 */
#define GP_WB_READ_CONN_EV_INFO_SLAVE_LATENCY_EN(offset) \
        GP_WB_READ_U1((offset) + 0x033, 0)

#define GP_WB_GET_CONN_EV_INFO_SLAVE_LATENCY_EN_FROM_SLAVE_LATENCY_STATE(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_CONN_EV_INFO_SLAVE_LATENCY_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x033, 0, (val)); \
        } while (0)

#define GP_WB_SET_CONN_EV_INFO_SLAVE_LATENCY_EN_TO_SLAVE_LATENCY_STATE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* represents if the next event will be skipped because the current window duration is too large >(interval-guard_time-processing_delay) */
#define GP_WB_READ_CONN_EV_INFO_SLAVE_LATENCY_WD_TOO_LARGE(offset) \
        GP_WB_READ_U1((offset) + 0x033, 1)

#define GP_WB_GET_CONN_EV_INFO_SLAVE_LATENCY_WD_TOO_LARGE_FROM_SLAVE_LATENCY_STATE(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_CONN_EV_INFO_SLAVE_LATENCY_WD_TOO_LARGE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x033, 1, (val)); \
        } while (0)

#define GP_WB_SET_CONN_EV_INFO_SLAVE_LATENCY_WD_TOO_LARGE_TO_SLAVE_LATENCY_STATE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Indicates wheter the slave will wakeup each event interval to check for new data in the queue. If this bit is 1, slave_latency events will not be executed at all (chip will not wakeup) and event will be time warped to the next non slave latency event. */
#define GP_WB_READ_CONN_EV_INFO_SLAVE_LATENCY_SLEEP_ENABLE(offset) \
        GP_WB_READ_U1((offset) + 0x033, 2)

#define GP_WB_GET_CONN_EV_INFO_SLAVE_LATENCY_SLEEP_ENABLE_FROM_SLAVE_LATENCY_STATE(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_CONN_EV_INFO_SLAVE_LATENCY_SLEEP_ENABLE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x033, 2, (val)); \
        } while (0)

#define GP_WB_SET_CONN_EV_INFO_SLAVE_LATENCY_SLEEP_ENABLE_TO_SLAVE_LATENCY_STATE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Internal state of the event. indicates that an event is being skipped due to slave latency */
#define GP_WB_READ_CONN_EV_INFO_SLAVE_LATENCY_ACTIVE(offset) \
        GP_WB_READ_U1((offset) + 0x033, 3)

#define GP_WB_GET_CONN_EV_INFO_SLAVE_LATENCY_ACTIVE_FROM_SLAVE_LATENCY_STATE(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_CONN_EV_INFO_SLAVE_LATENCY_ACTIVE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x033, 3, (val)); \
        } while (0)

#define GP_WB_SET_CONN_EV_INFO_SLAVE_LATENCY_ACTIVE_TO_SLAVE_LATENCY_STATE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* State that indicates if an event is asleep. if this is 1 and a frame needs to be sent asap, the event needs to be woken up with a WAKEUP_EVENT ipc command. */
#define GP_WB_READ_CONN_EV_INFO_SLAVE_LATENCY_ASLEEP(offset) \
        GP_WB_READ_U1((offset) + 0x033, 4)

#define GP_WB_GET_CONN_EV_INFO_SLAVE_LATENCY_ASLEEP_FROM_SLAVE_LATENCY_STATE(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_CONN_EV_INFO_SLAVE_LATENCY_ASLEEP(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x033, 4, (val)); \
        } while (0)

#define GP_WB_SET_CONN_EV_INFO_SLAVE_LATENCY_ASLEEP_TO_SLAVE_LATENCY_STATE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* Indicates what the current tx pbm is. This is needed to ensure correct data_cnf signals. Initialize to 255 */
#define GP_WB_READ_CONN_EV_INFO_CURRENT_TX_PBM(offset) \
        GP_WB_READ_U8((offset) + 0x034)

#define GP_WB_WRITE_CONN_EV_INFO_CURRENT_TX_PBM(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x034, (val)); \
        } while (0)


/* Indicates the number of events there was no rx activity, used for slave latency */
#define GP_WB_READ_CONN_EV_INFO_NR_NO_RX_EVENTS(offset) \
        GP_WB_READ_U16((offset) + 0x036)

#define GP_WB_WRITE_CONN_EV_INFO_NR_NO_RX_EVENTS(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x036, (val)); \
        } while (0)


/* Indicates the number of events there was no rx activity, used for slave latency */
#define GP_WB_READ_CONN_EV_INFO_NR_MISSED_RX_EVENTS(offset) \
        GP_WB_READ_U16((offset) + 0x038)

#define GP_WB_WRITE_CONN_EV_INFO_NR_MISSED_RX_EVENTS(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x038, (val)); \
        } while (0)


/* Internal state that indicates if the fixed window duration or the normal window duration is used */
#define GP_WB_READ_CONN_EV_INFO_USE_FIXED_WD(offset) \
        GP_WB_READ_U1((offset) + 0x03a, 0)

#define GP_WB_WRITE_CONN_EV_INFO_USE_FIXED_WD(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x03a, (val)); \
        } while (0)


/* threshold (in nr_missed_rx_events) from where the fixed window duration should be used */
#define GP_WB_READ_CONN_EV_INFO_FIXED_WD_THRESHOLD(offset) \
        GP_WB_READ_U16((offset) + 0x03c)

#define GP_WB_WRITE_CONN_EV_INFO_FIXED_WD_THRESHOLD(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x03c, (val)); \
        } while (0)


/* The last connection event count to be executed from this connection event, after execution is done the event is disabled by the ble_mgr. This count is only valid when last_sch_event_cnt_valid is set */
#define GP_WB_READ_CONN_EV_INFO_LAST_SCH_EVENT_CNT(offset) \
        GP_WB_READ_U16((offset) + 0x03e)

#define GP_WB_WRITE_CONN_EV_INFO_LAST_SCH_EVENT_CNT(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x03e, (val)); \
        } while (0)


/* Enables the last connection event count mechanism */
#define GP_WB_READ_CONN_EV_INFO_LAST_SCH_EVENT_CNT_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x040, 0)

#define GP_WB_WRITE_CONN_EV_INFO_LAST_SCH_EVENT_CNT_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x040, (val)); \
        } while (0)


/* If set, the BLE Event Manager will generate a NACK-condition upon every received PDU. If not set, a normal ack is generated */
#define GP_WB_READ_CONN_EV_INFO_RX_FLOW_CTRL_FLAG(offset) \
        GP_WB_READ_U1((offset) + 0x041, 0)

#define GP_WB_WRITE_CONN_EV_INFO_RX_FLOW_CTRL_FLAG(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x041, (val)); \
        } while (0)


/* pointer for NRT that indicates where the queue entry in the tx_queue can be written. increase this AFTER write */
#define GP_WB_READ_CONN_EV_INFO_TX_QUEUE_WR_PTR(offset) \
        GP_WB_READ_U8((offset) + 0x042)

#define GP_WB_WRITE_CONN_EV_INFO_TX_QUEUE_WR_PTR(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x042, (val)); \
        } while (0)


/* pointer for RT that indicates where the next queue entry can be read. */
#define GP_WB_READ_CONN_EV_INFO_TX_QUEUE_RD_PTR(offset) \
        GP_WB_READ_U8((offset) + 0x043)

#define GP_WB_WRITE_CONN_EV_INFO_TX_QUEUE_RD_PTR(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x043, (val)); \
        } while (0)


/* the TX queue. holds the PBM's to transmit. when rd_ptr = wr_ptr, the queue is empty. The queue can never get full! (> max nr pbm's) */
#define GP_WB_READ_CONN_EV_INFO_TX_QUEUE(offset) \
        GP_WB_READ_U64((offset) + 0x044)

#define GP_WB_WRITE_CONN_EV_INFO_TX_QUEUE(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U64((offset) + 0x044, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_CONN_EV_INFO_COEX_SETTINGS(offset) \
        GP_WB_READ_U8((offset) + 0x04c)

#define GP_WB_WRITE_CONN_EV_INFO_COEX_SETTINGS(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x04c, (val))

/* priority of the coex request (if enabled by req_en) */
#define GP_WB_READ_CONN_EV_INFO_COEX_PRIO(offset) \
        (GP_WB_READ_U8((offset) + 0x04c) & 0x03)

#define GP_WB_GET_CONN_EV_INFO_COEX_PRIO_FROM_COEX_SETTINGS(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_CONN_EV_INFO_COEX_PRIO(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_MWRITE_U8((offset) + 0x04c, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_CONN_EV_INFO_COEX_PRIO_TO_COEX_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x0C; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* if 1, a coex request will be launched upon radio action */
#define GP_WB_READ_CONN_EV_INFO_COEX_REQ_EN(offset) \
        GP_WB_READ_U1((offset) + 0x04c, 2)

#define GP_WB_GET_CONN_EV_INFO_COEX_REQ_EN_FROM_COEX_SETTINGS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_CONN_EV_INFO_COEX_REQ_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x04c, 2, (val)); \
        } while (0)

#define GP_WB_SET_CONN_EV_INFO_COEX_REQ_EN_TO_COEX_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* If 1, the PA will be disabled if no coex grant is received */
#define GP_WB_READ_CONN_EV_INFO_COEX_GRANT_AWARE(offset) \
        GP_WB_READ_U1((offset) + 0x04c, 3)

#define GP_WB_GET_CONN_EV_INFO_COEX_GRANT_AWARE_FROM_COEX_SETTINGS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_CONN_EV_INFO_COEX_GRANT_AWARE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x04c, 3, (val)); \
        } while (0)

#define GP_WB_SET_CONN_EV_INFO_COEX_GRANT_AWARE_TO_COEX_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_CONN_EV_INFO_METRICS_UPDATE_STATUS(offset) \
        GP_WB_READ_U8((offset) + 0x04d)

#define GP_WB_WRITE_CONN_EV_INFO_METRICS_UPDATE_STATUS(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x04d, (val))

/* Read only flag that indicates that the ble_mgr is busy updating the metrics */
#define GP_WB_READ_CONN_EV_INFO_METRICS_UPDATE_BUSY(offset) \
        GP_WB_READ_U1((offset) + 0x04d, 0)

#define GP_WB_GET_CONN_EV_INFO_METRICS_UPDATE_BUSY_FROM_METRICS_UPDATE_STATUS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_CONN_EV_INFO_METRICS_UPDATE_BUSY(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x04d, 0, (val)); \
        } while (0)

#define GP_WB_SET_CONN_EV_INFO_METRICS_UPDATE_BUSY_TO_METRICS_UPDATE_STATUS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* one shot flag is set by the ble_mgr at the start and end of a metrics update, so is set at a change in the metrics_update_busy flag. NRT may clear this (using atomic bit write!) */
#define GP_WB_READ_CONN_EV_INFO_METRICS_UPDATE_CHANGE(offset) \
        GP_WB_READ_U1((offset) + 0x04d, 1)

#define GP_WB_GET_CONN_EV_INFO_METRICS_UPDATE_CHANGE_FROM_METRICS_UPDATE_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_CONN_EV_INFO_METRICS_UPDATE_CHANGE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x04d, 1, (val)); \
        } while (0)

#define GP_WB_SET_CONN_EV_INFO_METRICS_UPDATE_CHANGE_TO_METRICS_UPDATE_STATUS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* When the next anchor point is expected */
#define GP_WB_READ_CONN_EV_INFO_T_NEXT_EXP_ANCHOR_POINT(offset) \
        GP_WB_READ_U32((offset) + 0x050)

#define GP_WB_WRITE_CONN_EV_INFO_T_NEXT_EXP_ANCHOR_POINT(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U32((offset) + 0x050, (val)); \
        } while (0)


/* Indicates the last timestamp on which a packet was received (with correct crc) */
#define GP_WB_READ_CONN_EV_INFO_T_LAST_CORRELATION(offset) \
        GP_WB_READ_U32((offset) + 0x054)

#define GP_WB_WRITE_CONN_EV_INFO_T_LAST_CORRELATION(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U32((offset) + 0x054, (val)); \
        } while (0)


/* Indicates the last timestamp on which a packet was received (irrelevant of it being a correct packet) */
#define GP_WB_READ_CONN_EV_INFO_T_LAST_PEER_PACKET(offset) \
        GP_WB_READ_U32((offset) + 0x058)

#define GP_WB_WRITE_CONN_EV_INFO_T_LAST_PEER_PACKET(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U32((offset) + 0x058, (val)); \
        } while (0)


/* Indicates whether the antenna swithcing feature should be enabled */
#define GP_WB_READ_CONN_EV_INFO_EN_ANT_SWITCHING(offset) \
        GP_WB_READ_U8((offset) + 0x05c)

#define GP_WB_WRITE_CONN_EV_INFO_EN_ANT_SWITCHING(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x05c, (val)); \
        } while (0)


/* If antenna switching is enabled, crc errors are accounted for in PER */
#define GP_WB_READ_CONN_EV_INFO_ANT_SW_USE_CRC(offset) \
        GP_WB_READ_U8((offset) + 0x05d)

#define GP_WB_WRITE_CONN_EV_INFO_ANT_SW_USE_CRC(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x05d, (val)); \
        } while (0)


/* If antenna switching is enabled, nack frames are accounted for in PER */
#define GP_WB_READ_CONN_EV_INFO_ANT_SW_USE_NACK(offset) \
        GP_WB_READ_U8((offset) + 0x05e)

#define GP_WB_WRITE_CONN_EV_INFO_ANT_SW_USE_NACK(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x05e, (val)); \
        } while (0)


/* If antenna switching is enabled, missed frames are accounted for in PER */
#define GP_WB_READ_CONN_EV_INFO_ANT_SW_USE_MISSED(offset) \
        GP_WB_READ_U8((offset) + 0x05f)

#define GP_WB_WRITE_CONN_EV_INFO_ANT_SW_USE_MISSED(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x05f, (val)); \
        } while (0)


/* Threshold on per, on which the antenna has to be switched (fixed point Q1.15) */
#define GP_WB_READ_CONN_EV_INFO_ANT_SW_THRESHOLD(offset) \
        GP_WB_READ_U16((offset) + 0x060)

#define GP_WB_WRITE_CONN_EV_INFO_ANT_SW_THRESHOLD(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x060, (val)); \
        } while (0)


/* Factor (=2**value) of the iir filter (that filters the per) */
#define GP_WB_READ_CONN_EV_INFO_ANT_SW_IIR_FACTOR(offset) \
        GP_WB_READ_U8((offset) + 0x062)

#define GP_WB_WRITE_CONN_EV_INFO_ANT_SW_IIR_FACTOR(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x062, (val)); \
        } while (0)


/* Nr of connection events before per_other_ant is reset */
#define GP_WB_READ_CONN_EV_INFO_ANT_SW_NR_BACKOFF(offset) \
        GP_WB_READ_U8((offset) + 0x063)

#define GP_WB_WRITE_CONN_EV_INFO_ANT_SW_NR_BACKOFF(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x063, (val)); \
        } while (0)


/* Indicates the antenna currently being used (or next to be used when not during the event) */
#define GP_WB_READ_CONN_EV_INFO_CURR_ANTENNA(offset) \
        GP_WB_READ_U1((offset) + 0x064, 0)

#define GP_WB_WRITE_CONN_EV_INFO_CURR_ANTENNA(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x064, (val)); \
        } while (0)


/* PER of the antenna currently being used (fixed point Q1.15) */
#define GP_WB_READ_CONN_EV_INFO_PER_CURR_ANT(offset) \
        GP_WB_READ_U16((offset) + 0x066)

#define GP_WB_WRITE_CONN_EV_INFO_PER_CURR_ANT(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x066, (val)); \
        } while (0)


/* PER of the antenna currently not in use (fixed point Q1.15) */
#define GP_WB_READ_CONN_EV_INFO_PER_OTHER_ANT(offset) \
        GP_WB_READ_U16((offset) + 0x068)

#define GP_WB_WRITE_CONN_EV_INFO_PER_OTHER_ANT(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x068, (val)); \
        } while (0)


/* Reflects the remaining nr of connection events before per_other_ant is reset */
#define GP_WB_READ_CONN_EV_INFO_CURR_BACKOFF_CNT(offset) \
        GP_WB_READ_U8((offset) + 0x06a)

#define GP_WB_WRITE_CONN_EV_INFO_CURR_BACKOFF_CNT(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x06a, (val)); \
        } while (0)


/* if set, a connection event will be limited to 1 (req and response) cycle, DEBUG feature, only implemented for connection master */
#define GP_WB_READ_CONN_EV_INFO_LIMIT_TO_1_CYCLE(offset) \
        GP_WB_READ_U1((offset) + 0x06b, 0)

#define GP_WB_WRITE_CONN_EV_INFO_LIMIT_TO_1_CYCLE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x06b, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_CONN_EV_INFO_ANT_SWITCH_CONFIG_RX(offset) \
        GP_WB_READ_U32((offset) + 0x06c)

#define GP_WB_WRITE_CONN_EV_INFO_ANT_SWITCH_CONFIG_RX(offset, val) \
      GP_WB_WRITE_U32((offset) + 0x06c, (val))

/* A pointer to the antenna switching sequence (compressed address) */
#define GP_WB_READ_CONN_EV_INFO_ANT_SWITCH_SEQ_PTR_RX(offset) \
        GP_WB_READ_U24((offset) + 0x06c)

#define GP_WB_GET_CONN_EV_INFO_ANT_SWITCH_SEQ_PTR_RX_FROM_ANT_SWITCH_CONFIG_RX(tmp) \
        ((tmp) & 0x07FFFF)

#define GP_WB_WRITE_CONN_EV_INFO_ANT_SWITCH_SEQ_PTR_RX(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x07FFFF); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U24((offset) + 0x06c, (val)); \
        } while (0)

#define GP_WB_SET_CONN_EV_INFO_ANT_SWITCH_SEQ_PTR_RX_TO_ANT_SWITCH_CONFIG_RX(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07FFFF); \
          (tmp) &= 0xFF000000; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Length of the antenna switching sequence */
#define GP_WB_READ_CONN_EV_INFO_ANT_SWITCH_LENGTH_RX(offset) \
        GP_WB_READ_U8((offset) + 0x06f)

#define GP_WB_GET_CONN_EV_INFO_ANT_SWITCH_LENGTH_RX_FROM_ANT_SWITCH_CONFIG_RX(tmp) \
        (((tmp) >> 24) & 0xFF)

#define GP_WB_WRITE_CONN_EV_INFO_ANT_SWITCH_LENGTH_RX(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x06f, (val)); \
        } while (0)

#define GP_WB_SET_CONN_EV_INFO_ANT_SWITCH_LENGTH_RX_TO_ANT_SWITCH_CONFIG_RX(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x0007FFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_CONN_EV_INFO_ANT_SWITCH_CONFIG_TX(offset) \
        GP_WB_READ_U32((offset) + 0x070)

#define GP_WB_WRITE_CONN_EV_INFO_ANT_SWITCH_CONFIG_TX(offset, val) \
      GP_WB_WRITE_U32((offset) + 0x070, (val))

/* A pointer to the antenna switching sequence (compressed address) */
#define GP_WB_READ_CONN_EV_INFO_ANT_SWITCH_SEQ_PTR_TX(offset) \
        GP_WB_READ_U24((offset) + 0x070)

#define GP_WB_GET_CONN_EV_INFO_ANT_SWITCH_SEQ_PTR_TX_FROM_ANT_SWITCH_CONFIG_TX(tmp) \
        ((tmp) & 0x07FFFF)

#define GP_WB_WRITE_CONN_EV_INFO_ANT_SWITCH_SEQ_PTR_TX(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x07FFFF); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U24((offset) + 0x070, (val)); \
        } while (0)

#define GP_WB_SET_CONN_EV_INFO_ANT_SWITCH_SEQ_PTR_TX_TO_ANT_SWITCH_CONFIG_TX(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07FFFF); \
          (tmp) &= 0xFF000000; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Length of the antenna switching sequence */
#define GP_WB_READ_CONN_EV_INFO_ANT_SWITCH_LENGTH_TX(offset) \
        GP_WB_READ_U8((offset) + 0x073)

#define GP_WB_GET_CONN_EV_INFO_ANT_SWITCH_LENGTH_TX_FROM_ANT_SWITCH_CONFIG_TX(tmp) \
        (((tmp) >> 24) & 0xFF)

#define GP_WB_WRITE_CONN_EV_INFO_ANT_SWITCH_LENGTH_TX(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x073, (val)); \
        } while (0)

#define GP_WB_SET_CONN_EV_INFO_ANT_SWITCH_LENGTH_TX_TO_ANT_SWITCH_CONFIG_TX(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x0007FFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_CONN_EV_INFO_DIRECTION_FINDING_CONFIG_RX(offset) \
        GP_WB_READ_U8((offset) + 0x074)

#define GP_WB_WRITE_CONN_EV_INFO_DIRECTION_FINDING_CONFIG_RX(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x074, (val))

/* 0 = no antenna switching (for AoD receiver); 1 = enable antenna switching (for AoA receiver) */
#define GP_WB_READ_CONN_EV_INFO_ANT_SWITCH_ENA_RX(offset) \
        GP_WB_READ_U1((offset) + 0x074, 0)

#define GP_WB_GET_CONN_EV_INFO_ANT_SWITCH_ENA_RX_FROM_DIRECTION_FINDING_CONFIG_RX(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_CONN_EV_INFO_ANT_SWITCH_ENA_RX(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x074, 0, (val)); \
        } while (0)

#define GP_WB_SET_CONN_EV_INFO_ANT_SWITCH_ENA_RX_TO_DIRECTION_FINDING_CONFIG_RX(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* 0 to enable debug mode (no dma), 1 to enable ant fifo mode (use DMA) */
#define GP_WB_READ_CONN_EV_INFO_AFIFO_ENABLED_RX(offset) \
        GP_WB_READ_U1((offset) + 0x074, 1)

#define GP_WB_GET_CONN_EV_INFO_AFIFO_ENABLED_RX_FROM_DIRECTION_FINDING_CONFIG_RX(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_CONN_EV_INFO_AFIFO_ENABLED_RX(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x074, 1, (val)); \
        } while (0)

#define GP_WB_SET_CONN_EV_INFO_AFIFO_ENABLED_RX_TO_DIRECTION_FINDING_CONFIG_RX(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Slot time for AoA/AoD. Can be 1,2,3,4 us */
#define GP_WB_READ_CONN_EV_INFO_SLOT_TIME_RX(offset) \
        ((GP_WB_READ_U8((offset) + 0x074) >> 2) & 0x03)

#define GP_WB_GET_CONN_EV_INFO_SLOT_TIME_RX_FROM_DIRECTION_FINDING_CONFIG_RX(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_CONN_EV_INFO_SLOT_TIME_RX(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_MWRITE_U8((offset) + 0x074, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_CONN_EV_INFO_SLOT_TIME_RX_TO_DIRECTION_FINDING_CONFIG_RX(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_CONN_EV_INFO_DIRECTION_FINDING_CONFIG_TX(offset) \
        GP_WB_READ_U8((offset) + 0x075)

#define GP_WB_WRITE_CONN_EV_INFO_DIRECTION_FINDING_CONFIG_TX(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x075, (val))

/* 0 = no antenna switching (for AoD receiver); 1 = enable antenna switching (for AoA receiver) */
#define GP_WB_READ_CONN_EV_INFO_ANT_SWITCH_ENA_TX(offset) \
        GP_WB_READ_U1((offset) + 0x075, 0)

#define GP_WB_GET_CONN_EV_INFO_ANT_SWITCH_ENA_TX_FROM_DIRECTION_FINDING_CONFIG_TX(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_CONN_EV_INFO_ANT_SWITCH_ENA_TX(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x075, 0, (val)); \
        } while (0)

#define GP_WB_SET_CONN_EV_INFO_ANT_SWITCH_ENA_TX_TO_DIRECTION_FINDING_CONFIG_TX(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* 0 to enable debug mode (no dma), 1 to enable ant fifo mode (use DMA) */
#define GP_WB_READ_CONN_EV_INFO_AFIFO_ENABLED_TX(offset) \
        GP_WB_READ_U1((offset) + 0x075, 1)

#define GP_WB_GET_CONN_EV_INFO_AFIFO_ENABLED_TX_FROM_DIRECTION_FINDING_CONFIG_TX(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_CONN_EV_INFO_AFIFO_ENABLED_TX(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x075, 1, (val)); \
        } while (0)

#define GP_WB_SET_CONN_EV_INFO_AFIFO_ENABLED_TX_TO_DIRECTION_FINDING_CONFIG_TX(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Slot time for AoA/AoD. Can be 1,2,3,4 us */
#define GP_WB_READ_CONN_EV_INFO_SLOT_TIME_TX(offset) \
        ((GP_WB_READ_U8((offset) + 0x075) >> 2) & 0x03)

#define GP_WB_GET_CONN_EV_INFO_SLOT_TIME_TX_FROM_DIRECTION_FINDING_CONFIG_TX(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_CONN_EV_INFO_SLOT_TIME_TX(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_MWRITE_U8((offset) + 0x075, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_CONN_EV_INFO_SLOT_TIME_TX_TO_DIRECTION_FINDING_CONFIG_TX(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* Max number of (16bit) words that fit inside the raw phase samples buffer */
#define GP_WB_READ_CONN_EV_INFO_RAW_PHASE_SAMPLE_MAX_WORDS(offset) \
        GP_WB_READ_U16((offset) + 0x076)

#define GP_WB_WRITE_CONN_EV_INFO_RAW_PHASE_SAMPLE_MAX_WORDS(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x076, (val)); \
        } while (0)


/* Pointer to buffer for storing raw phase samples (compressed address) */
#define GP_WB_READ_CONN_EV_INFO_RAW_PHASE_SAMPLE_PTR(offset) \
        GP_WB_READ_U24((offset) + 0x078)

#define GP_WB_WRITE_CONN_EV_INFO_RAW_PHASE_SAMPLE_PTR(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x07FFFF); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U24((offset) + 0x078, (val)); \
        } while (0)


/* if set, a single measurement will be taken on the first received packet that includes a CTE. */
#define GP_WB_READ_CONN_EV_INFO_RAW_PHASE_MEASUREMENT_ARMED(offset) \
        GP_WB_READ_U1((offset) + 0x07b, 0)

#define GP_WB_WRITE_CONN_EV_INFO_RAW_PHASE_MEASUREMENT_ARMED(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x07b, (val)); \
        } while (0)


/* Enable channel selection algorithm #2 */
#define GP_WB_READ_CONN_EV_INFO_USE_CHAN_SEL_ALGO2(offset) \
        GP_WB_READ_U1((offset) + 0x07f, 0)

#define GP_WB_WRITE_CONN_EV_INFO_USE_CHAN_SEL_ALGO2(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x07f, (val)); \
        } while (0)


/* The connection event counter where the last packet was received from the remote */
#define GP_WB_READ_CONN_EV_INFO_EVENT_CNT_LAST_RX(offset) \
        GP_WB_READ_U16((offset) + 0x080)

#define GP_WB_WRITE_CONN_EV_INFO_EVENT_CNT_LAST_RX(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x080, (val)); \
        } while (0)

/* The number of connection events that have been elapsed since the previous correlation point. */
#define GP_WB_READ_CONN_EV_INFO_EVENT_CNT_PREV_RX_DIFF(offset) \
        GP_WB_READ_U16((offset) + 0x082)

#define GP_WB_WRITE_CONN_EV_INFO_EVENT_CNT_PREV_RX_DIFF(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x082, (val)); \
        } while (0)


/* The offset between the actual anchor point and the expected anchor point */
#define GP_WB_READ_CONN_EV_INFO_T_ANCHOR_OFFSET(offset) \
        (GP_WB_S16(GP_WB_READ_U16((offset) + 0x084), 16))

#define GP_WB_WRITE_CONN_EV_INFO_T_ANCHOR_OFFSET(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x084, (UInt16)((val))); \
        } while (0)


/* pointer to a CM style list of rx_list_entry elements that get written after the RX mode is set and before the receiver is started */
#define GP_WB_READ_CONN_EV_INFO_RX_LIST_PTR(offset) \
        GP_WB_READ_U16((offset) + 0x086)

#define GP_WB_WRITE_CONN_EV_INFO_RX_LIST_PTR(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x086, (val)); \
        } while (0)


/* If nonzero, indicates a shift of the rx window around the anchor point (expressed in ppm). NRT should add 5% margin to this (makes it easier for RT to work with). */
#define GP_WB_READ_CONN_EV_INFO_RX_WINDOW_SHIFT_PPM(offset) \
        (GP_WB_S16(GP_WB_READ_U16((offset) + 0x088), 16))

#define GP_WB_WRITE_CONN_EV_INFO_RX_WINDOW_SHIFT_PPM(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x088, (UInt16)((val))); \
        } while (0)


/* The anchor point of the connection event where the last packet was received */
#define GP_WB_READ_CONN_EV_INFO_T_ANCHOR_POINT_LAST_RX_EVENT(offset) \
        GP_WB_READ_U32((offset) + 0x08c)

#define GP_WB_WRITE_CONN_EV_INFO_T_ANCHOR_POINT_LAST_RX_EVENT(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_EV_INFO(offset); \
          GP_WB_WRITE_U32((offset) + 0x08c, (val)); \
        } while (0)

/***************************
 * layout: conn_ch_map
 ***************************/

/* The channel indexes to be used for the connection event */
#define GP_WB_READ_CONN_CH_MAP_USED_CH_IDXS(offset) \
        GP_WB_READ_U40((offset) + 0x000)

#define GP_WB_WRITE_CONN_CH_MAP_USED_CH_IDXS(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x1FFFFFFFFF); \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U40((offset) + 0x000, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_TABLE(offset) \
        GP_WB_READ_U64((offset) + 0x008)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_TABLE(offset, val) \
      GP_WB_WRITE_U64((offset) + 0x008, (val))

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_0(offset) \
        GP_WB_READ_U8((offset) + 0x008)

#define GP_WB_GET_CONN_CH_MAP_HOP_REMAP_0_FROM_HOP_REMAP_TABLE(tmp) \
        ((tmp) & 0xFF)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_0(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x008, (val)); \
        } while (0)

#define GP_WB_SET_CONN_CH_MAP_HOP_REMAP_0_TO_HOP_REMAP_TABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFFFFFFFFFF00; \
          (tmp) |= ((UInt64)(val)); \
        } while (0)

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_1(offset) \
        GP_WB_READ_U8((offset) + 0x009)

#define GP_WB_GET_CONN_CH_MAP_HOP_REMAP_1_FROM_HOP_REMAP_TABLE(tmp) \
        (((tmp) >> 8) & 0xFF)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_1(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x009, (val)); \
        } while (0)

#define GP_WB_SET_CONN_CH_MAP_HOP_REMAP_1_TO_HOP_REMAP_TABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFFFFFFFF00FF; \
          (tmp) |= (((UInt64)(val)) << 8); \
        } while (0)

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_2(offset) \
        GP_WB_READ_U8((offset) + 0x00a)

#define GP_WB_GET_CONN_CH_MAP_HOP_REMAP_2_FROM_HOP_REMAP_TABLE(tmp) \
        (((tmp) >> 16) & 0xFF)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_2(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x00a, (val)); \
        } while (0)

#define GP_WB_SET_CONN_CH_MAP_HOP_REMAP_2_TO_HOP_REMAP_TABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFFFFFF00FFFF; \
          (tmp) |= (((UInt64)(val)) << 16); \
        } while (0)

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_3(offset) \
        GP_WB_READ_U8((offset) + 0x00b)

#define GP_WB_GET_CONN_CH_MAP_HOP_REMAP_3_FROM_HOP_REMAP_TABLE(tmp) \
        (((tmp) >> 24) & 0xFF)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_3(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x00b, (val)); \
        } while (0)

#define GP_WB_SET_CONN_CH_MAP_HOP_REMAP_3_TO_HOP_REMAP_TABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFFFF00FFFFFF; \
          (tmp) |= (((UInt64)(val)) << 24); \
        } while (0)

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_4(offset) \
        GP_WB_READ_U8((offset) + 0x00c)

#define GP_WB_GET_CONN_CH_MAP_HOP_REMAP_4_FROM_HOP_REMAP_TABLE(tmp) \
        (((tmp) >> 32) & 0xFF)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_4(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x00c, (val)); \
        } while (0)

#define GP_WB_SET_CONN_CH_MAP_HOP_REMAP_4_TO_HOP_REMAP_TABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFF00FFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 32); \
        } while (0)

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_5(offset) \
        GP_WB_READ_U8((offset) + 0x00d)

#define GP_WB_GET_CONN_CH_MAP_HOP_REMAP_5_FROM_HOP_REMAP_TABLE(tmp) \
        (((tmp) >> 40) & 0xFF)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_5(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x00d, (val)); \
        } while (0)

#define GP_WB_SET_CONN_CH_MAP_HOP_REMAP_5_TO_HOP_REMAP_TABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFF00FFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 40); \
        } while (0)

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_6(offset) \
        GP_WB_READ_U8((offset) + 0x00e)

#define GP_WB_GET_CONN_CH_MAP_HOP_REMAP_6_FROM_HOP_REMAP_TABLE(tmp) \
        (((tmp) >> 48) & 0xFF)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_6(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x00e, (val)); \
        } while (0)

#define GP_WB_SET_CONN_CH_MAP_HOP_REMAP_6_TO_HOP_REMAP_TABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFF00FFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 48); \
        } while (0)

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_7(offset) \
        GP_WB_READ_U8((offset) + 0x00f)

#define GP_WB_GET_CONN_CH_MAP_HOP_REMAP_7_FROM_HOP_REMAP_TABLE(tmp) \
        (((tmp) >> 56) & 0xFF)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_7(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x00f, (val)); \
        } while (0)

#define GP_WB_SET_CONN_CH_MAP_HOP_REMAP_7_TO_HOP_REMAP_TABLE(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0x00FFFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 56); \
        } while (0)


#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_8(offset) \
        GP_WB_READ_U8((offset) + 0x010)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_8(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x010, (val)); \
        } while (0)

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_9(offset) \
        GP_WB_READ_U8((offset) + 0x011)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_9(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x011, (val)); \
        } while (0)

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_10(offset) \
        GP_WB_READ_U8((offset) + 0x012)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_10(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x012, (val)); \
        } while (0)

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_11(offset) \
        GP_WB_READ_U8((offset) + 0x013)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_11(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x013, (val)); \
        } while (0)

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_12(offset) \
        GP_WB_READ_U8((offset) + 0x014)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_12(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x014, (val)); \
        } while (0)

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_13(offset) \
        GP_WB_READ_U8((offset) + 0x015)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_13(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x015, (val)); \
        } while (0)

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_14(offset) \
        GP_WB_READ_U8((offset) + 0x016)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_14(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x016, (val)); \
        } while (0)

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_15(offset) \
        GP_WB_READ_U8((offset) + 0x017)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_15(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x017, (val)); \
        } while (0)


#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_16(offset) \
        GP_WB_READ_U8((offset) + 0x018)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_16(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x018, (val)); \
        } while (0)

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_17(offset) \
        GP_WB_READ_U8((offset) + 0x019)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_17(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x019, (val)); \
        } while (0)

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_18(offset) \
        GP_WB_READ_U8((offset) + 0x01a)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_18(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x01a, (val)); \
        } while (0)

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_19(offset) \
        GP_WB_READ_U8((offset) + 0x01b)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_19(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x01b, (val)); \
        } while (0)

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_20(offset) \
        GP_WB_READ_U8((offset) + 0x01c)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_20(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x01c, (val)); \
        } while (0)

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_21(offset) \
        GP_WB_READ_U8((offset) + 0x01d)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_21(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x01d, (val)); \
        } while (0)

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_22(offset) \
        GP_WB_READ_U8((offset) + 0x01e)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_22(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x01e, (val)); \
        } while (0)

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_23(offset) \
        GP_WB_READ_U8((offset) + 0x01f)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_23(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x01f, (val)); \
        } while (0)


#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_24(offset) \
        GP_WB_READ_U8((offset) + 0x020)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_24(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x020, (val)); \
        } while (0)

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_25(offset) \
        GP_WB_READ_U8((offset) + 0x021)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_25(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x021, (val)); \
        } while (0)

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_26(offset) \
        GP_WB_READ_U8((offset) + 0x022)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_26(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x022, (val)); \
        } while (0)

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_27(offset) \
        GP_WB_READ_U8((offset) + 0x023)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_27(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x023, (val)); \
        } while (0)

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_28(offset) \
        GP_WB_READ_U8((offset) + 0x024)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_28(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x024, (val)); \
        } while (0)

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_29(offset) \
        GP_WB_READ_U8((offset) + 0x025)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_29(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x025, (val)); \
        } while (0)

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_30(offset) \
        GP_WB_READ_U8((offset) + 0x026)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_30(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x026, (val)); \
        } while (0)

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_31(offset) \
        GP_WB_READ_U8((offset) + 0x027)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_31(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x027, (val)); \
        } while (0)


#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_32(offset) \
        GP_WB_READ_U8((offset) + 0x028)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_32(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x028, (val)); \
        } while (0)

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_33(offset) \
        GP_WB_READ_U8((offset) + 0x029)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_33(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x029, (val)); \
        } while (0)

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_34(offset) \
        GP_WB_READ_U8((offset) + 0x02a)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_34(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x02a, (val)); \
        } while (0)

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_35(offset) \
        GP_WB_READ_U8((offset) + 0x02b)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_35(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x02b, (val)); \
        } while (0)

#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_36(offset) \
        GP_WB_READ_U8((offset) + 0x02c)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_36(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x02c, (val)); \
        } while (0)


/* length of the hopping remaping table, used for relaying unmapped channels */
#define GP_WB_READ_CONN_CH_MAP_HOP_REMAP_TABLE_LEN(offset) \
        GP_WB_READ_U8((offset) + 0x02d)

#define GP_WB_WRITE_CONN_CH_MAP_HOP_REMAP_TABLE_LEN(offset, val) do { \
          GP_WB_CHECK_OFFSET_CONN_CH_MAP(offset); \
          GP_WB_WRITE_U8((offset) + 0x02d, (val)); \
        } while (0)

/***************************
 * layout: ble_test_info
 ***************************/

/* the type of long range mode, 125 or 500 */
#define GP_WB_READ_BLE_TEST_INFO_TX_PHY_MODE(offset) \
        (GP_WB_READ_U8((offset) + 0x000) & 0x03)

#define GP_WB_WRITE_BLE_TEST_INFO_TX_PHY_MODE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_CHECK_OFFSET_BLE_TEST_INFO(offset); \
          GP_WB_MWRITE_U8((offset) + 0x000, 0x03, (val)); \
        } while (0)

/* the type of long range mode, 125 or 500 */
#define GP_WB_READ_BLE_TEST_INFO_RX_PHY_MODE(offset) \
        (GP_WB_READ_U8((offset) + 0x000) & 0x03)

#define GP_WB_WRITE_BLE_TEST_INFO_RX_PHY_MODE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_CHECK_OFFSET_BLE_TEST_INFO(offset); \
          GP_WB_MWRITE_U8((offset) + 0x000, 0x03, (val)); \
        } while (0)

/* The test scenario, 0 for transmitter test, 1 for receiver test */
#define GP_WB_READ_BLE_TEST_INFO_RX_NOT_TX(offset) \
        GP_WB_READ_U1((offset) + 0x000, 2)

#define GP_WB_WRITE_BLE_TEST_INFO_RX_NOT_TX(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_TEST_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 2, (val)); \
        } while (0)

/* antenna on which to listen/transmit during the test */
#define GP_WB_READ_BLE_TEST_INFO_ANTENNA(offset) \
        GP_WB_READ_U1((offset) + 0x000, 3)

#define GP_WB_WRITE_BLE_TEST_INFO_ANTENNA(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_TEST_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 3, (val)); \
        } while (0)

/* turns on/off the channel based whitening */
#define GP_WB_READ_BLE_TEST_INFO_WHITENING_ENABLE(offset) \
        GP_WB_READ_U1((offset) + 0x000, 4)

#define GP_WB_WRITE_BLE_TEST_INFO_WHITENING_ENABLE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_TEST_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 4, (val)); \
        } while (0)

/* Enable/Disable forwarding of received packets to NRT. Use for debug only!! */
#define GP_WB_READ_BLE_TEST_INFO_FORWARD_RX_PDUS(offset) \
        GP_WB_READ_U1((offset) + 0x000, 5)

#define GP_WB_WRITE_BLE_TEST_INFO_FORWARD_RX_PDUS(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_TEST_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x000, 5, (val)); \
        } while (0)


/* Access address to transmit/receive */
#define GP_WB_READ_BLE_TEST_INFO_ACCESS_ADDRESS(offset) \
        GP_WB_READ_U32((offset) + 0x004)

#define GP_WB_WRITE_BLE_TEST_INFO_ACCESS_ADDRESS(offset, val) do { \
          GP_WB_CHECK_OFFSET_BLE_TEST_INFO(offset); \
          GP_WB_WRITE_U32((offset) + 0x004, (val)); \
        } while (0)


/* Threshold for BLE preamble detect */
#define GP_WB_READ_BLE_TEST_INFO_PREAMBLE_THRESH(offset) \
        GP_WB_READ_U16((offset) + 0x008)

#define GP_WB_WRITE_BLE_TEST_INFO_PREAMBLE_THRESH(offset, val) do { \
          GP_WB_CHECK_OFFSET_BLE_TEST_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x008, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BLE_TEST_INFO_VALIDATION_SETTINGS(offset) \
        GP_WB_READ_U32((offset) + 0x00c)

#define GP_WB_WRITE_BLE_TEST_INFO_VALIDATION_SETTINGS(offset, val) \
      GP_WB_WRITE_U32((offset) + 0x00c, (val))

/* Threshold for BLE preamble validation */
#define GP_WB_READ_BLE_TEST_INFO_VALIDATION_THRESH(offset) \
        GP_WB_READ_U16((offset) + 0x00c)

#define GP_WB_GET_BLE_TEST_INFO_VALIDATION_THRESH_FROM_VALIDATION_SETTINGS(tmp) \
        ((tmp) & 0xFFFF)

#define GP_WB_WRITE_BLE_TEST_INFO_VALIDATION_THRESH(offset, val) do { \
          GP_WB_CHECK_OFFSET_BLE_TEST_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x00c, (val)); \
        } while (0)

#define GP_WB_SET_BLE_TEST_INFO_VALIDATION_THRESH_TO_VALIDATION_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x9F1F0000; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Amount of symbols inside the access code the validation is going to start */
#define GP_WB_READ_BLE_TEST_INFO_VALIDATION_START_IDX(offset) \
        GP_WB_READ_U8((offset) + 0x00e)

#define GP_WB_GET_BLE_TEST_INFO_VALIDATION_START_IDX_FROM_VALIDATION_SETTINGS(tmp) \
        (((tmp) >> 16) & 0x1F)

#define GP_WB_WRITE_BLE_TEST_INFO_VALIDATION_START_IDX(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_CHECK_OFFSET_BLE_TEST_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x00e, (val)); \
        } while (0)

#define GP_WB_SET_BLE_TEST_INFO_VALIDATION_START_IDX_TO_VALIDATION_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x9F00FFFF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* The index inside the access code where a fake preamble starts */
#define GP_WB_READ_BLE_TEST_INFO_FAKE_PREAMBLE_START_IDX(offset) \
        (GP_WB_READ_U8((offset) + 0x00f) & 0x1F)

#define GP_WB_GET_BLE_TEST_INFO_FAKE_PREAMBLE_START_IDX_FROM_VALIDATION_SETTINGS(tmp) \
        (((tmp) >> 24) & 0x1F)

#define GP_WB_WRITE_BLE_TEST_INFO_FAKE_PREAMBLE_START_IDX(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          GP_WB_CHECK_OFFSET_BLE_TEST_INFO(offset); \
          GP_WB_MWRITE_U8((offset) + 0x00f, 0x1F, (val)); \
        } while (0)

#define GP_WB_SET_BLE_TEST_INFO_FAKE_PREAMBLE_START_IDX_TO_VALIDATION_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x1F); \
          (tmp) &= 0x801FFFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)

/* Indicates wheter a fake preamble is present in the access code or not (valid flag for fake_preamble_start_idx) */
#define GP_WB_READ_BLE_TEST_INFO_FAKE_PREAMBLE_PRESENT(offset) \
        GP_WB_READ_U1((offset) + 0x00f, 7)

#define GP_WB_GET_BLE_TEST_INFO_FAKE_PREAMBLE_PRESENT_FROM_VALIDATION_SETTINGS(tmp) \
        (((tmp) >> 31) & 0x01)

#define GP_WB_WRITE_BLE_TEST_INFO_FAKE_PREAMBLE_PRESENT(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_TEST_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00f, 7, (val)); \
        } while (0)

#define GP_WB_SET_BLE_TEST_INFO_FAKE_PREAMBLE_PRESENT_TO_VALIDATION_SETTINGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F1FFFFF; \
          (tmp) |= (((UInt32)(val)) << 31); \
        } while (0)


/* preamble symbol for RX/TX */
#define GP_WB_READ_BLE_TEST_INFO_PREAMBLE(offset) \
        GP_WB_READ_U8((offset) + 0x010)

#define GP_WB_WRITE_BLE_TEST_INFO_PREAMBLE(offset, val) do { \
          GP_WB_CHECK_OFFSET_BLE_TEST_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x010, (val)); \
        } while (0)


/* CRC init value for RX/TX */
#define GP_WB_READ_BLE_TEST_INFO_CRC_INIT(offset) \
        GP_WB_READ_U24((offset) + 0x014)

#define GP_WB_WRITE_BLE_TEST_INFO_CRC_INIT(offset, val) do { \
          GP_WB_CHECK_OFFSET_BLE_TEST_INFO(offset); \
          GP_WB_WRITE_U24((offset) + 0x014, (val)); \
        } while (0)


/* if whitening is enabled, this init value will be used. (bit reversed) */
#define GP_WB_READ_BLE_TEST_INFO_WHITENING_INIT_REV(offset) \
        GP_WB_READ_U8((offset) + 0x017)

#define GP_WB_WRITE_BLE_TEST_INFO_WHITENING_INIT_REV(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_WB_CHECK_OFFSET_BLE_TEST_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x017, (val)); \
        } while (0)


/* BLE channel on which to listen/transmit, CAUTION! this is a PHY channel f=(2*phy_channel+2402) MHz */
#define GP_WB_READ_BLE_TEST_INFO_CHANNEL(offset) \
        GP_WB_READ_U8((offset) + 0x018)

#define GP_WB_WRITE_BLE_TEST_INFO_CHANNEL(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_WB_CHECK_OFFSET_BLE_TEST_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x018, (val)); \
        } while (0)


/* time between 2 transmission starts in us */
#define GP_WB_READ_BLE_TEST_INFO_TX_PACKET_INTERVAL(offset) \
        GP_WB_READ_U16((offset) + 0x01a)

#define GP_WB_WRITE_BLE_TEST_INFO_TX_PACKET_INTERVAL(offset, val) do { \
          GP_WB_CHECK_OFFSET_BLE_TEST_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x01a, (val)); \
        } while (0)


/* number of packets to be transmitted, 0xFFFF means never ending */
#define GP_WB_READ_BLE_TEST_INFO_TX_PACKET_COUNT(offset) \
        GP_WB_READ_U16((offset) + 0x01c)

#define GP_WB_WRITE_BLE_TEST_INFO_TX_PACKET_COUNT(offset, val) do { \
          GP_WB_CHECK_OFFSET_BLE_TEST_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x01c, (val)); \
        } while (0)


/* The pbm to be transmitted during TX test mode */
#define GP_WB_READ_BLE_TEST_INFO_TX_PBM(offset) \
        GP_WB_READ_U8((offset) + 0x01e)

#define GP_WB_WRITE_BLE_TEST_INFO_TX_PBM(offset, val) do { \
          GP_WB_CHECK_OFFSET_BLE_TEST_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x01e, (val)); \
        } while (0)


/* number of packets correctly received, wrap around, initialize to 0 */
#define GP_WB_READ_BLE_TEST_INFO_RX_PACKET_COUNT(offset) \
        GP_WB_READ_U16((offset) + 0x020)

#define GP_WB_WRITE_BLE_TEST_INFO_RX_PACKET_COUNT(offset, val) do { \
          GP_WB_CHECK_OFFSET_BLE_TEST_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x020, (val)); \
        } while (0)


/* if set, a single measurement will be taken on the first received packet that includes a CTE. */
#define GP_WB_READ_BLE_TEST_INFO_RAW_PHASE_MEASUREMENT_ARMED(offset) \
        GP_WB_READ_U1((offset) + 0x022, 0)

#define GP_WB_WRITE_BLE_TEST_INFO_RAW_PHASE_MEASUREMENT_ARMED(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_TEST_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x022, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BLE_TEST_INFO_DIRECTION_FINDING_CONFIG(offset) \
        GP_WB_READ_U8((offset) + 0x023)

#define GP_WB_WRITE_BLE_TEST_INFO_DIRECTION_FINDING_CONFIG(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x023, (val))

/* 0 = no antenna switching (for AoA transmitter); 1 = enable antenna switching (for AoD transmitter) */
#define GP_WB_READ_BLE_TEST_INFO_ANT_SWITCH_ENA(offset) \
        GP_WB_READ_U1((offset) + 0x023, 0)

#define GP_WB_GET_BLE_TEST_INFO_ANT_SWITCH_ENA_FROM_DIRECTION_FINDING_CONFIG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_BLE_TEST_INFO_ANT_SWITCH_ENA(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_TEST_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x023, 0, (val)); \
        } while (0)

#define GP_WB_SET_BLE_TEST_INFO_ANT_SWITCH_ENA_TO_DIRECTION_FINDING_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* 0 to enable debug mode (no dma), 1 to enable ant fifo mode (use DMA) */
#define GP_WB_READ_BLE_TEST_INFO_AFIFO_ENABLED(offset) \
        GP_WB_READ_U1((offset) + 0x023, 1)

#define GP_WB_GET_BLE_TEST_INFO_AFIFO_ENABLED_FROM_DIRECTION_FINDING_CONFIG(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_BLE_TEST_INFO_AFIFO_ENABLED(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_TEST_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x023, 1, (val)); \
        } while (0)

#define GP_WB_SET_BLE_TEST_INFO_AFIFO_ENABLED_TO_DIRECTION_FINDING_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Slot time for AoA/AoD. Can be 1,2,3,4 us */
#define GP_WB_READ_BLE_TEST_INFO_SLOT_TIME(offset) \
        ((GP_WB_READ_U8((offset) + 0x023) >> 2) & 0x03)

#define GP_WB_GET_BLE_TEST_INFO_SLOT_TIME_FROM_DIRECTION_FINDING_CONFIG(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_BLE_TEST_INFO_SLOT_TIME(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_CHECK_OFFSET_BLE_TEST_INFO(offset); \
          GP_WB_MWRITE_U8((offset) + 0x023, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_BLE_TEST_INFO_SLOT_TIME_TO_DIRECTION_FINDING_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BLE_TEST_INFO_ANT_SWITCH_CONFIG(offset) \
        GP_WB_READ_U32((offset) + 0x024)

#define GP_WB_WRITE_BLE_TEST_INFO_ANT_SWITCH_CONFIG(offset, val) \
      GP_WB_WRITE_U32((offset) + 0x024, (val))

/* A pointer to the antenna switching sequence (compressed address) */
#define GP_WB_READ_BLE_TEST_INFO_ANT_SWITCH_SEQ_PTR(offset) \
        GP_WB_READ_U24((offset) + 0x024)

#define GP_WB_GET_BLE_TEST_INFO_ANT_SWITCH_SEQ_PTR_FROM_ANT_SWITCH_CONFIG(tmp) \
        ((tmp) & 0x07FFFF)

#define GP_WB_WRITE_BLE_TEST_INFO_ANT_SWITCH_SEQ_PTR(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x07FFFF); \
          GP_WB_CHECK_OFFSET_BLE_TEST_INFO(offset); \
          GP_WB_WRITE_U24((offset) + 0x024, (val)); \
        } while (0)

#define GP_WB_SET_BLE_TEST_INFO_ANT_SWITCH_SEQ_PTR_TO_ANT_SWITCH_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07FFFF); \
          (tmp) &= 0xFF000000; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Length of the antenna switching sequence */
#define GP_WB_READ_BLE_TEST_INFO_ANT_SWITCH_LENGTH(offset) \
        GP_WB_READ_U8((offset) + 0x027)

#define GP_WB_GET_BLE_TEST_INFO_ANT_SWITCH_LENGTH_FROM_ANT_SWITCH_CONFIG(tmp) \
        (((tmp) >> 24) & 0xFF)

#define GP_WB_WRITE_BLE_TEST_INFO_ANT_SWITCH_LENGTH(offset, val) do { \
          GP_WB_CHECK_OFFSET_BLE_TEST_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x027, (val)); \
        } while (0)

#define GP_WB_SET_BLE_TEST_INFO_ANT_SWITCH_LENGTH_TO_ANT_SWITCH_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          (tmp) &= 0x0007FFFF; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)


/* Pointer to buffer for storing raw phase samples (compressed address) */
#define GP_WB_READ_BLE_TEST_INFO_RAW_PHASE_SAMPLE_PTR(offset) \
        GP_WB_READ_U24((offset) + 0x028)

#define GP_WB_WRITE_BLE_TEST_INFO_RAW_PHASE_SAMPLE_PTR(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x07FFFF); \
          GP_WB_CHECK_OFFSET_BLE_TEST_INFO(offset); \
          GP_WB_WRITE_U24((offset) + 0x028, (val)); \
        } while (0)


/* Max number of (16bit) words that fit inside the raw phase samples buffer */
#define GP_WB_READ_BLE_TEST_INFO_RAW_PHASE_SAMPLE_MAX_WORDS(offset) \
        GP_WB_READ_U16((offset) + 0x02c)

#define GP_WB_WRITE_BLE_TEST_INFO_RAW_PHASE_SAMPLE_MAX_WORDS(offset, val) do { \
          GP_WB_CHECK_OFFSET_BLE_TEST_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x02c, (val)); \
        } while (0)


/* pointer to a CM style list of rx_list_entry elements that get written after the RX mode is set and before the receiver is started */
#define GP_WB_READ_BLE_TEST_INFO_RX_LIST_PTR(offset) \
        GP_WB_READ_U16((offset) + 0x02e)

#define GP_WB_WRITE_BLE_TEST_INFO_RX_LIST_PTR(offset, val) do { \
          GP_WB_CHECK_OFFSET_BLE_TEST_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x02e, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BLE_TEST_INFO_RX_ALLPHY_MASK(offset) \
        GP_WB_READ_U8((offset) + 0x030)

#define GP_WB_WRITE_BLE_TEST_INFO_RX_ALLPHY_MASK(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x030, (val))

/* rx ( concurrent ) listening modes 1 Mb */
#define GP_WB_READ_BLE_TEST_INFO_RX_MODE_1MB(offset) \
        GP_WB_READ_U1((offset) + 0x030, 0)

#define GP_WB_GET_BLE_TEST_INFO_RX_MODE_1MB_FROM_RX_ALLPHY_MASK(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_BLE_TEST_INFO_RX_MODE_1MB(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_TEST_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x030, 0, (val)); \
        } while (0)

#define GP_WB_SET_BLE_TEST_INFO_RX_MODE_1MB_TO_RX_ALLPHY_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* rx ( concurrent ) listening modes 2 Mb */
#define GP_WB_READ_BLE_TEST_INFO_RX_MODE_2MB(offset) \
        GP_WB_READ_U1((offset) + 0x030, 1)

#define GP_WB_GET_BLE_TEST_INFO_RX_MODE_2MB_FROM_RX_ALLPHY_MASK(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_BLE_TEST_INFO_RX_MODE_2MB(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BLE_TEST_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x030, 1, (val)); \
        } while (0)

#define GP_WB_SET_BLE_TEST_INFO_RX_MODE_2MB_TO_RX_ALLPHY_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/***************************
 * layout: subev_ev_info
 ***************************/

/* priority of the event, (0= lowest priority; 255 is highest priority) */
#define GP_WB_READ_SUBEV_EV_INFO_PRIORITY(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_SUBEV_EV_INFO_PRIORITY(offset, val) do { \
          GP_WB_CHECK_OFFSET_SUBEV_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x000, (val)); \
        } while (0)


/* when enabled, the event will not do any radio activity and the event will be skipped. The event state will still be updated though. */
#define GP_WB_READ_SUBEV_EV_INFO_SUSPEND_EVENT(offset) \
        GP_WB_READ_U1((offset) + 0x001, 0)

#define GP_WB_WRITE_SUBEV_EV_INFO_SUSPEND_EVENT(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SUBEV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 0, (val)); \
        } while (0)

/* when 1, the round robin mechanism will also take into account the nr_consec_skipped_events for this event */
#define GP_WB_READ_SUBEV_EV_INFO_EXTENDED_PRIO_EN(offset) \
        GP_WB_READ_U1((offset) + 0x001, 1)

#define GP_WB_WRITE_SUBEV_EV_INFO_EXTENDED_PRIO_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SUBEV_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 1, (val)); \
        } while (0)


/* Indicates the number of events that are skipped in a row */
#define GP_WB_READ_SUBEV_EV_INFO_NR_CONSEC_SKIPPED_EVENTS(offset) \
        GP_WB_READ_U16((offset) + 0x002)

#define GP_WB_WRITE_SUBEV_EV_INFO_NR_CONSEC_SKIPPED_EVENTS(offset, val) do { \
          GP_WB_CHECK_OFFSET_SUBEV_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x002, (val)); \
        } while (0)

/***************************
 * layout: subev_dsc
 ***************************/

#define GP_WB_READ_SUBEV_DSC_EVENT_TYPE(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_SUBEV_DSC_EVENT_TYPE(offset, val) do { \
          GP_WB_CHECK_OFFSET_SUBEV_DSC(offset); \
          GP_WB_WRITE_U8((offset) + 0x000, (val)); \
        } while (0)


/* ble_channel to use for the subevent */
#define GP_WB_READ_SUBEV_DSC_CHANNEL(offset) \
        GP_WB_READ_U8((offset) + 0x001)

#define GP_WB_WRITE_SUBEV_DSC_CHANNEL(offset, val) do { \
          GP_WB_CHECK_OFFSET_SUBEV_DSC(offset); \
          GP_WB_WRITE_U8((offset) + 0x001, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SUBEV_DSC_PHY_OPTIONS(offset) \
        GP_WB_READ_U8((offset) + 0x002)

#define GP_WB_WRITE_SUBEV_DSC_PHY_OPTIONS(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x002, (val))

/* Tx phy mode to use for the subevent */
#define GP_WB_READ_SUBEV_DSC_TX_PHY(offset) \
        (GP_WB_READ_U8((offset) + 0x002) & 0x03)

#define GP_WB_GET_SUBEV_DSC_TX_PHY_FROM_PHY_OPTIONS(tmp) \
        ((tmp) & 0x03)

#define GP_WB_WRITE_SUBEV_DSC_TX_PHY(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_CHECK_OFFSET_SUBEV_DSC(offset); \
          GP_WB_MWRITE_U8((offset) + 0x002, 0x03, (val)); \
        } while (0)

#define GP_WB_SET_SUBEV_DSC_TX_PHY_TO_PHY_OPTIONS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x3C; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Rx phy mode to use for the subevent (no coding specified) */
#define GP_WB_READ_SUBEV_DSC_RX_PHY(offset) \
        ((GP_WB_READ_U8((offset) + 0x002) >> 2) & 0x03)

#define GP_WB_GET_SUBEV_DSC_RX_PHY_FROM_PHY_OPTIONS(tmp) \
        (((tmp) >> 2) & 0x03)

#define GP_WB_WRITE_SUBEV_DSC_RX_PHY(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_CHECK_OFFSET_SUBEV_DSC(offset); \
          GP_WB_MWRITE_U8((offset) + 0x002, 0x0C, (val) << 2); \
        } while (0)

#define GP_WB_SET_SUBEV_DSC_RX_PHY_TO_PHY_OPTIONS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x33; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Overrule, when set and rx PHY was coded, use the same coding for TX. */
#define GP_WB_READ_SUBEV_DSC_CODING_FOLLOW_REMOTE(offset) \
        GP_WB_READ_U1((offset) + 0x002, 4)

#define GP_WB_GET_SUBEV_DSC_CODING_FOLLOW_REMOTE_FROM_PHY_OPTIONS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_SUBEV_DSC_CODING_FOLLOW_REMOTE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SUBEV_DSC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x002, 4, (val)); \
        } while (0)

#define GP_WB_SET_SUBEV_DSC_CODING_FOLLOW_REMOTE_TO_PHY_OPTIONS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/* indicates if multistandard listening is allowed for this subevent. */
#define GP_WB_READ_SUBEV_DSC_MS_ALLOWED(offset) \
        GP_WB_READ_U1((offset) + 0x002, 5)

#define GP_WB_GET_SUBEV_DSC_MS_ALLOWED_FROM_PHY_OPTIONS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_SUBEV_DSC_MS_ALLOWED(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SUBEV_DSC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x002, 5, (val)); \
        } while (0)

#define GP_WB_SET_SUBEV_DSC_MS_ALLOWED_TO_PHY_OPTIONS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* Execution time (1us base) */
#define GP_WB_READ_SUBEV_DSC_EXECUTION_TIME(offset) \
        GP_WB_READ_U32((offset) + 0x004)

#define GP_WB_WRITE_SUBEV_DSC_EXECUTION_TIME(offset, val) do { \
          GP_WB_CHECK_OFFSET_SUBEV_DSC(offset); \
          GP_WB_WRITE_U32((offset) + 0x004, (val)); \
        } while (0)


/* RX SEDs only: receive window size. */
#define GP_WB_READ_SUBEV_DSC_RX_WD_SIZE(offset) \
        GP_WB_READ_U32((offset) + 0x008)

#define GP_WB_WRITE_SUBEV_DSC_RX_WD_SIZE(offset, val) do { \
          GP_WB_CHECK_OFFSET_SUBEV_DSC(offset); \
          GP_WB_WRITE_U32((offset) + 0x008, (val)); \
        } while (0)

/* TX SEDs only: aux pointer */
#define GP_WB_READ_SUBEV_DSC_TX_AUX_PTR(offset) \
        GP_WB_READ_U24((offset) + 0x008)

#define GP_WB_WRITE_SUBEV_DSC_TX_AUX_PTR(offset, val) do { \
          GP_WB_CHECK_OFFSET_SUBEV_DSC(offset); \
          GP_WB_WRITE_U24((offset) + 0x008, (val)); \
        } while (0)

/* TX SEDs only: PBM number */
#define GP_WB_READ_SUBEV_DSC_TX_PBM_NR(offset) \
        GP_WB_READ_U8((offset) + 0x00b)

#define GP_WB_WRITE_SUBEV_DSC_TX_PBM_NR(offset, val) do { \
          GP_WB_CHECK_OFFSET_SUBEV_DSC(offset); \
          GP_WB_WRITE_U8((offset) + 0x00b, (val)); \
        } while (0)


/* event count */
#define GP_WB_READ_SUBEV_DSC_EVENT_COUNT(offset) \
        GP_WB_READ_U16((offset) + 0x00c)

#define GP_WB_WRITE_SUBEV_DSC_EVENT_COUNT(offset, val) do { \
          GP_WB_CHECK_OFFSET_SUBEV_DSC(offset); \
          GP_WB_WRITE_U16((offset) + 0x00c, (val)); \
        } while (0)


/* time (1us base) */
#define GP_WB_READ_SUBEV_DSC_DURATION(offset) \
        GP_WB_READ_U16((offset) + 0x010)

#define GP_WB_WRITE_SUBEV_DSC_DURATION(offset, val) do { \
          GP_WB_CHECK_OFFSET_SUBEV_DSC(offset); \
          GP_WB_WRITE_U16((offset) + 0x010, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SUBEV_DSC_FLAGS(offset) \
        GP_WB_READ_U16((offset) + 0x012)

#define GP_WB_WRITE_SUBEV_DSC_FLAGS(offset, val) \
      GP_WB_WRITE_U16((offset) + 0x012, (val))

#define GP_WB_READ_SUBEV_DSC_CURRENT_ANTENNA(offset) \
        GP_WB_READ_U1((offset) + 0x012, 0)

#define GP_WB_GET_SUBEV_DSC_CURRENT_ANTENNA_FROM_FLAGS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_SUBEV_DSC_CURRENT_ANTENNA(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SUBEV_DSC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x012, 0, (val)); \
        } while (0)

#define GP_WB_SET_SUBEV_DSC_CURRENT_ANTENNA_TO_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FE; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

#define GP_WB_READ_SUBEV_DSC_EVENT_VALID(offset) \
        GP_WB_READ_U1((offset) + 0x012, 1)

#define GP_WB_GET_SUBEV_DSC_EVENT_VALID_FROM_FLAGS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_SUBEV_DSC_EVENT_VALID(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SUBEV_DSC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x012, 1, (val)); \
        } while (0)

#define GP_WB_SET_SUBEV_DSC_EVENT_VALID_TO_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FD; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

#define GP_WB_READ_SUBEV_DSC_EVENT_DONE(offset) \
        GP_WB_READ_U1((offset) + 0x012, 2)

#define GP_WB_GET_SUBEV_DSC_EVENT_DONE_FROM_FLAGS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_SUBEV_DSC_EVENT_DONE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SUBEV_DSC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x012, 2, (val)); \
        } while (0)

#define GP_WB_SET_SUBEV_DSC_EVENT_DONE_TO_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07FB; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

#define GP_WB_READ_SUBEV_DSC_EVENT_DROPPED(offset) \
        GP_WB_READ_U1((offset) + 0x012, 3)

#define GP_WB_GET_SUBEV_DSC_EVENT_DROPPED_FROM_FLAGS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_SUBEV_DSC_EVENT_DROPPED(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SUBEV_DSC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x012, 3, (val)); \
        } while (0)

#define GP_WB_SET_SUBEV_DSC_EVENT_DROPPED_TO_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07F7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

#define GP_WB_READ_SUBEV_DSC_SCAN_REQUESTED(offset) \
        GP_WB_READ_U1((offset) + 0x012, 4)

#define GP_WB_GET_SUBEV_DSC_SCAN_REQUESTED_FROM_FLAGS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_SUBEV_DSC_SCAN_REQUESTED(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SUBEV_DSC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x012, 4, (val)); \
        } while (0)

#define GP_WB_SET_SUBEV_DSC_SCAN_REQUESTED_TO_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07EF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

#define GP_WB_READ_SUBEV_DSC_CONNECTION_REQUESTED(offset) \
        GP_WB_READ_U1((offset) + 0x012, 5)

#define GP_WB_GET_SUBEV_DSC_CONNECTION_REQUESTED_FROM_FLAGS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_SUBEV_DSC_CONNECTION_REQUESTED(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SUBEV_DSC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x012, 5, (val)); \
        } while (0)

#define GP_WB_SET_SUBEV_DSC_CONNECTION_REQUESTED_TO_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07DF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

#define GP_WB_READ_SUBEV_DSC_EXEC_CONDITIONAL(offset) \
        GP_WB_READ_U1((offset) + 0x012, 6)

#define GP_WB_GET_SUBEV_DSC_EXEC_CONDITIONAL_FROM_FLAGS(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_SUBEV_DSC_EXEC_CONDITIONAL(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SUBEV_DSC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x012, 6, (val)); \
        } while (0)

#define GP_WB_SET_SUBEV_DSC_EXEC_CONDITIONAL_TO_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07BF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

#define GP_WB_READ_SUBEV_DSC_UNKNOWN_ADVA(offset) \
        GP_WB_READ_U1((offset) + 0x012, 7)

#define GP_WB_GET_SUBEV_DSC_UNKNOWN_ADVA_FROM_FLAGS(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_SUBEV_DSC_UNKNOWN_ADVA(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SUBEV_DSC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x012, 7, (val)); \
        } while (0)

#define GP_WB_SET_SUBEV_DSC_UNKNOWN_ADVA_TO_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x077F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_SUBEV_DSC_UPDATE_AUX_PTR(offset) \
        GP_WB_READ_U1((offset) + 0x013, 0)

#define GP_WB_GET_SUBEV_DSC_UPDATE_AUX_PTR_FROM_FLAGS(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_SUBEV_DSC_UPDATE_AUX_PTR(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SUBEV_DSC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x013, 0, (val)); \
        } while (0)

#define GP_WB_SET_SUBEV_DSC_UPDATE_AUX_PTR_TO_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

#define GP_WB_READ_SUBEV_DSC_NOTHING_RECEIVED(offset) \
        GP_WB_READ_U1((offset) + 0x013, 1)

#define GP_WB_GET_SUBEV_DSC_NOTHING_RECEIVED_FROM_FLAGS(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_SUBEV_DSC_NOTHING_RECEIVED(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SUBEV_DSC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x013, 1, (val)); \
        } while (0)

#define GP_WB_SET_SUBEV_DSC_NOTHING_RECEIVED_TO_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05FF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)

#define GP_WB_READ_SUBEV_DSC_PRIMARY_PHY_WAS_CODED(offset) \
        GP_WB_READ_U1((offset) + 0x013, 2)

#define GP_WB_GET_SUBEV_DSC_PRIMARY_PHY_WAS_CODED_FROM_FLAGS(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_SUBEV_DSC_PRIMARY_PHY_WAS_CODED(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SUBEV_DSC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x013, 2, (val)); \
        } while (0)

#define GP_WB_SET_SUBEV_DSC_PRIMARY_PHY_WAS_CODED_TO_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03FF; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)


#define GP_WB_READ_SUBEV_DSC_DROP_REASON(offset) \
        GP_WB_READ_U8((offset) + 0x014)

#define GP_WB_WRITE_SUBEV_DSC_DROP_REASON(offset, val) do { \
          GP_WB_CHECK_OFFSET_SUBEV_DSC(offset); \
          GP_WB_WRITE_U8((offset) + 0x014, (val)); \
        } while (0)


/* for TX ADV_ASC for RX SCAN_ASC */
#define GP_WB_READ_SUBEV_DSC_CONTEXT_IDX(offset) \
        GP_WB_READ_U8((offset) + 0x015)

#define GP_WB_WRITE_SUBEV_DSC_CONTEXT_IDX(offset, val) do { \
          GP_WB_CHECK_OFFSET_SUBEV_DSC(offset); \
          GP_WB_WRITE_U8((offset) + 0x015, (val)); \
        } while (0)


/* pointer to a CM style list of rx_list_entry elements that get written after the RX mode is set and before the receiver is started */
#define GP_WB_READ_SUBEV_DSC_RX_LIST_PTR(offset) \
        GP_WB_READ_U16((offset) + 0x016)

#define GP_WB_WRITE_SUBEV_DSC_RX_LIST_PTR(offset, val) do { \
          GP_WB_CHECK_OFFSET_SUBEV_DSC(offset); \
          GP_WB_WRITE_U16((offset) + 0x016, (val)); \
        } while (0)

/***************************
 * layout: pdl_entry
 ***************************/

#define GP_WB_READ_PDL_ENTRY_SUBEV_DSC_IDX(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_PDL_ENTRY_SUBEV_DSC_IDX(offset, val) do { \
          GP_WB_CHECK_OFFSET_PDL_ENTRY(offset); \
          GP_WB_WRITE_U8((offset) + 0x000, (val)); \
        } while (0)


/* PDL index of the next available PDL entry - 0xFF is the invalid index */
#define GP_WB_READ_PDL_ENTRY_NEXT_FREE_IDX(offset) \
        GP_WB_READ_U8((offset) + 0x001)

#define GP_WB_WRITE_PDL_ENTRY_NEXT_FREE_IDX(offset, val) do { \
          GP_WB_CHECK_OFFSET_PDL_ENTRY(offset); \
          GP_WB_WRITE_U8((offset) + 0x001, (val)); \
        } while (0)


/* PDL index of the next prescheduled entry - 0xFF is the invalid index */
#define GP_WB_READ_PDL_ENTRY_FORWARD_IDX(offset) \
        GP_WB_READ_U8((offset) + 0x002)

#define GP_WB_WRITE_PDL_ENTRY_FORWARD_IDX(offset, val) do { \
          GP_WB_CHECK_OFFSET_PDL_ENTRY(offset); \
          GP_WB_WRITE_U8((offset) + 0x002, (val)); \
        } while (0)

/***************************
 * layout: adv_asc
 ***************************/

/* priority of the event, (0= lowest priority; 255 is highest priority) */
#define GP_WB_READ_ADV_ASC_PRIORITY(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_ADV_ASC_PRIORITY(offset, val) do { \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_WRITE_U8((offset) + 0x000, (val)); \
        } while (0)


/* when enabled, the event will not do any radio activity and the event will be skipped. The event state will still be updated though. */
#define GP_WB_READ_ADV_ASC_SUSPEND_EVENT(offset) \
        GP_WB_READ_U1((offset) + 0x001, 0)

#define GP_WB_WRITE_ADV_ASC_SUSPEND_EVENT(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 0, (val)); \
        } while (0)

/* when 1, the round robin mechanism will also take into account the nr_consec_skipped_events for this event */
#define GP_WB_READ_ADV_ASC_EXTENDED_PRIO_EN(offset) \
        GP_WB_READ_U1((offset) + 0x001, 1)

#define GP_WB_WRITE_ADV_ASC_EXTENDED_PRIO_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 1, (val)); \
        } while (0)


/* Indicates the number of events that are skipped in a row */
#define GP_WB_READ_ADV_ASC_NR_CONSEC_SKIPPED_EVENTS(offset) \
        GP_WB_READ_U16((offset) + 0x002)

#define GP_WB_WRITE_ADV_ASC_NR_CONSEC_SKIPPED_EVENTS(offset, val) do { \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_WRITE_U16((offset) + 0x002, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADV_ASC_CHANNEL_MAP(offset) \
        GP_WB_READ_U40((offset) + 0x004)

#define GP_WB_WRITE_ADV_ASC_CHANNEL_MAP(offset, val) \
      GP_WB_WRITE_U40((offset) + 0x004, (val))

#define GP_WB_READ_ADV_ASC_CHANNEL_MAP0(offset) \
        GP_WB_READ_U8((offset) + 0x004)

#define GP_WB_GET_ADV_ASC_CHANNEL_MAP0_FROM_CHANNEL_MAP(tmp) \
        ((tmp) & 0xFF)

#define GP_WB_WRITE_ADV_ASC_CHANNEL_MAP0(offset, val) do { \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_WRITE_U8((offset) + 0x004, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_CHANNEL_MAP0_TO_CHANNEL_MAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFFFF00; \
          (tmp) |= ((UInt64)(val)); \
        } while (0)

#define GP_WB_READ_ADV_ASC_CHANNEL_MAP1(offset) \
        GP_WB_READ_U8((offset) + 0x005)

#define GP_WB_GET_ADV_ASC_CHANNEL_MAP1_FROM_CHANNEL_MAP(tmp) \
        (((tmp) >> 8) & 0xFF)

#define GP_WB_WRITE_ADV_ASC_CHANNEL_MAP1(offset, val) do { \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_WRITE_U8((offset) + 0x005, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_CHANNEL_MAP1_TO_CHANNEL_MAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFF00FF; \
          (tmp) |= (((UInt64)(val)) << 8); \
        } while (0)

#define GP_WB_READ_ADV_ASC_CHANNEL_MAP2(offset) \
        GP_WB_READ_U8((offset) + 0x006)

#define GP_WB_GET_ADV_ASC_CHANNEL_MAP2_FROM_CHANNEL_MAP(tmp) \
        (((tmp) >> 16) & 0xFF)

#define GP_WB_WRITE_ADV_ASC_CHANNEL_MAP2(offset, val) do { \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_WRITE_U8((offset) + 0x006, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_CHANNEL_MAP2_TO_CHANNEL_MAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFF00FFFF; \
          (tmp) |= (((UInt64)(val)) << 16); \
        } while (0)

#define GP_WB_READ_ADV_ASC_CHANNEL_MAP3(offset) \
        GP_WB_READ_U8((offset) + 0x007)

#define GP_WB_GET_ADV_ASC_CHANNEL_MAP3_FROM_CHANNEL_MAP(tmp) \
        (((tmp) >> 24) & 0xFF)

#define GP_WB_WRITE_ADV_ASC_CHANNEL_MAP3(offset, val) do { \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_WRITE_U8((offset) + 0x007, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_CHANNEL_MAP3_TO_CHANNEL_MAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFF00FFFFFF; \
          (tmp) |= (((UInt64)(val)) << 24); \
        } while (0)

#define GP_WB_READ_ADV_ASC_CHANNEL_MAP4(offset) \
        GP_WB_READ_U8((offset) + 0x008)

#define GP_WB_GET_ADV_ASC_CHANNEL_MAP4_FROM_CHANNEL_MAP(tmp) \
        (((tmp) >> 32) & 0xFF)

#define GP_WB_WRITE_ADV_ASC_CHANNEL_MAP4(offset, val) do { \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_WRITE_U8((offset) + 0x008, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_CHANNEL_MAP4_TO_CHANNEL_MAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0x00FFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 32); \
        } while (0)


/* number of valid channel in the channel map */
#define GP_WB_READ_ADV_ASC_CHANNEL_MAP_SIZE(offset) \
        GP_WB_READ_U8((offset) + 0x009)

#define GP_WB_WRITE_ADV_ASC_CHANNEL_MAP_SIZE(offset, val) do { \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_WRITE_U8((offset) + 0x009, (val)); \
        } while (0)


/* AdvA When own address is RPA, then prand consists of 3 MSBs */
#define GP_WB_READ_ADV_ASC_OWN_ADDRESS(offset) \
        GP_WB_READ_U48((offset) + 0x00c)

#define GP_WB_WRITE_ADV_ASC_OWN_ADDRESS(offset, val) do { \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_WRITE_U48((offset) + 0x00c, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADV_ASC_OWN_ADDRESS_FLAGS(offset) \
        GP_WB_READ_U8((offset) + 0x012)

#define GP_WB_WRITE_ADV_ASC_OWN_ADDRESS_FLAGS(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x012, (val))

/* 0 = public 1 = random address stored in own_address */
#define GP_WB_READ_ADV_ASC_OWN_ADDRESS_TYPE(offset) \
        GP_WB_READ_U1((offset) + 0x012, 0)

#define GP_WB_GET_ADV_ASC_OWN_ADDRESS_TYPE_FROM_OWN_ADDRESS_FLAGS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_ADV_ASC_OWN_ADDRESS_TYPE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x012, 0, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_OWN_ADDRESS_TYPE_TO_OWN_ADDRESS_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_ADV_ASC_GENERATE_RPA_SOURCEADDR(offset) \
        GP_WB_READ_U1((offset) + 0x012, 1)

#define GP_WB_GET_ADV_ASC_GENERATE_RPA_SOURCEADDR_FROM_OWN_ADDRESS_FLAGS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_ADV_ASC_GENERATE_RPA_SOURCEADDR(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x012, 1, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_GENERATE_RPA_SOURCEADDR_TO_OWN_ADDRESS_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* AdvA When own address is RPA, then prand consists of 3 MSBs */
#define GP_WB_READ_ADV_ASC_PEER_ADDRESS(offset) \
        GP_WB_READ_U48((offset) + 0x014)

#define GP_WB_WRITE_ADV_ASC_PEER_ADDRESS(offset, val) do { \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_WRITE_U48((offset) + 0x014, (val)); \
        } while (0)


/* 0 = public 1 = random address */
#define GP_WB_READ_ADV_ASC_PEER_ADDRESS_TYPE(offset) \
        GP_WB_READ_U1((offset) + 0x01a, 0)

#define GP_WB_WRITE_ADV_ASC_PEER_ADDRESS_TYPE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_WRITE_U8((offset) + 0x01a, (val)); \
        } while (0)


/* pbm to transmit for the AUX_ADV_IND PDU (without AuxPtr) to be transmitted as the first packet in a TxEASecScan or TxEASecConn. */
#define GP_WB_READ_ADV_ASC_PBM(offset) \
        GP_WB_READ_U8((offset) + 0x01b)

#define GP_WB_WRITE_ADV_ASC_PBM(offset, val) do { \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_WRITE_U8((offset) + 0x01b, (val)); \
        } while (0)


/* indicates the position of the AuxPtr in the pbm */
#define GP_WB_READ_ADV_ASC_AUX_PTR_OFFSET(offset) \
        GP_WB_READ_U16((offset) + 0x01c)

#define GP_WB_WRITE_ADV_ASC_AUX_PTR_OFFSET(offset, val) do { \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_WRITE_U16((offset) + 0x01c, (val)); \
        } while (0)


/* used by NRT to identify the advertising set */
#define GP_WB_READ_ADV_ASC_ADVERTISING_HANDLE(offset) \
        GP_WB_READ_U8((offset) + 0x01e)

#define GP_WB_WRITE_ADV_ASC_ADVERTISING_HANDLE(offset, val) do { \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_WRITE_U8((offset) + 0x01e, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADV_ASC_FRAME_TYPE_ACCEPT_MASK(offset) \
        GP_WB_READ_U16((offset) + 0x020)

#define GP_WB_WRITE_ADV_ASC_FRAME_TYPE_ACCEPT_MASK(offset, val) \
      GP_WB_WRITE_U16((offset) + 0x020, (val))

#define GP_WB_READ_ADV_ASC_ACCEPT_FT_ADV_IND(offset) \
        GP_WB_READ_U1((offset) + 0x020, 0)

#define GP_WB_GET_ADV_ASC_ACCEPT_FT_ADV_IND_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_ADV_ASC_ACCEPT_FT_ADV_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x020, 0, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_ACCEPT_FT_ADV_IND_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFE; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

#define GP_WB_READ_ADV_ASC_ACCEPT_FT_ADV_DIRECT_IND(offset) \
        GP_WB_READ_U1((offset) + 0x020, 1)

#define GP_WB_GET_ADV_ASC_ACCEPT_FT_ADV_DIRECT_IND_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_ADV_ASC_ACCEPT_FT_ADV_DIRECT_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x020, 1, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_ACCEPT_FT_ADV_DIRECT_IND_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFD; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

#define GP_WB_READ_ADV_ASC_ACCEPT_FT_ADV_NONCONN_IND(offset) \
        GP_WB_READ_U1((offset) + 0x020, 2)

#define GP_WB_GET_ADV_ASC_ACCEPT_FT_ADV_NONCONN_IND_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_ADV_ASC_ACCEPT_FT_ADV_NONCONN_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x020, 2, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_ACCEPT_FT_ADV_NONCONN_IND_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFB; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

#define GP_WB_READ_ADV_ASC_ACCEPT_FT_SCAN_REQ(offset) \
        GP_WB_READ_U1((offset) + 0x020, 3)

#define GP_WB_GET_ADV_ASC_ACCEPT_FT_SCAN_REQ_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_ADV_ASC_ACCEPT_FT_SCAN_REQ(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x020, 3, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_ACCEPT_FT_SCAN_REQ_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFF7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

#define GP_WB_READ_ADV_ASC_ACCEPT_FT_AUX_SCAN_REQ(offset) \
        GP_WB_READ_U1((offset) + 0x020, 3)

#define GP_WB_GET_ADV_ASC_ACCEPT_FT_AUX_SCAN_REQ_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_ADV_ASC_ACCEPT_FT_AUX_SCAN_REQ(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x020, 3, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_ACCEPT_FT_AUX_SCAN_REQ_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFF7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

#define GP_WB_READ_ADV_ASC_ACCEPT_FT_SCAN_RSP(offset) \
        GP_WB_READ_U1((offset) + 0x020, 4)

#define GP_WB_GET_ADV_ASC_ACCEPT_FT_SCAN_RSP_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_ADV_ASC_ACCEPT_FT_SCAN_RSP(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x020, 4, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_ACCEPT_FT_SCAN_RSP_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFEF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

#define GP_WB_READ_ADV_ASC_ACCEPT_FT_CONNECT_REQ(offset) \
        GP_WB_READ_U1((offset) + 0x020, 5)

#define GP_WB_GET_ADV_ASC_ACCEPT_FT_CONNECT_REQ_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_ADV_ASC_ACCEPT_FT_CONNECT_REQ(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x020, 5, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_ACCEPT_FT_CONNECT_REQ_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFDF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

#define GP_WB_READ_ADV_ASC_ACCEPT_FT_AUX_CONNECT_REQ(offset) \
        GP_WB_READ_U1((offset) + 0x020, 5)

#define GP_WB_GET_ADV_ASC_ACCEPT_FT_AUX_CONNECT_REQ_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_ADV_ASC_ACCEPT_FT_AUX_CONNECT_REQ(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x020, 5, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_ACCEPT_FT_AUX_CONNECT_REQ_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFDF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

#define GP_WB_READ_ADV_ASC_ACCEPT_FT_ADV_SCAN_IND(offset) \
        GP_WB_READ_U1((offset) + 0x020, 6)

#define GP_WB_GET_ADV_ASC_ACCEPT_FT_ADV_SCAN_IND_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_ADV_ASC_ACCEPT_FT_ADV_SCAN_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x020, 6, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_ACCEPT_FT_ADV_SCAN_IND_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFBF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

#define GP_WB_READ_ADV_ASC_ACCEPT_FT_ADV_EXT_IND(offset) \
        GP_WB_READ_U1((offset) + 0x020, 7)

#define GP_WB_GET_ADV_ASC_ACCEPT_FT_ADV_EXT_IND_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADV_ASC_ACCEPT_FT_ADV_EXT_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x020, 7, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_ACCEPT_FT_ADV_EXT_IND_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_ADV_ASC_ACCEPT_FT_AUX_ADV_IND(offset) \
        GP_WB_READ_U1((offset) + 0x020, 7)

#define GP_WB_GET_ADV_ASC_ACCEPT_FT_AUX_ADV_IND_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADV_ASC_ACCEPT_FT_AUX_ADV_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x020, 7, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_ACCEPT_FT_AUX_ADV_IND_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_ADV_ASC_ACCEPT_FT_AUX_SCAN_RSP(offset) \
        GP_WB_READ_U1((offset) + 0x020, 7)

#define GP_WB_GET_ADV_ASC_ACCEPT_FT_AUX_SCAN_RSP_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADV_ASC_ACCEPT_FT_AUX_SCAN_RSP(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x020, 7, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_ACCEPT_FT_AUX_SCAN_RSP_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_ADV_ASC_ACCEPT_FT_AUX_SYNC_IND(offset) \
        GP_WB_READ_U1((offset) + 0x020, 7)

#define GP_WB_GET_ADV_ASC_ACCEPT_FT_AUX_SYNC_IND_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADV_ASC_ACCEPT_FT_AUX_SYNC_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x020, 7, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_ACCEPT_FT_AUX_SYNC_IND_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_ADV_ASC_ACCEPT_FT_AUX_CHAIN_IND(offset) \
        GP_WB_READ_U1((offset) + 0x020, 7)

#define GP_WB_GET_ADV_ASC_ACCEPT_FT_AUX_CHAIN_IND_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADV_ASC_ACCEPT_FT_AUX_CHAIN_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x020, 7, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_ACCEPT_FT_AUX_CHAIN_IND_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_ADV_ASC_ACCEPT_FT_AUX_CONNECT_RSP(offset) \
        GP_WB_READ_U1((offset) + 0x021, 0)

#define GP_WB_GET_ADV_ASC_ACCEPT_FT_AUX_CONNECT_RSP_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_ADV_ASC_ACCEPT_FT_AUX_CONNECT_RSP(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x021, 0, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_ACCEPT_FT_AUX_CONNECT_RSP_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFEFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

#define GP_WB_READ_ADV_ASC_ACCEPT_FT_RESERVED_9(offset) \
        GP_WB_READ_U1((offset) + 0x021, 1)

#define GP_WB_GET_ADV_ASC_ACCEPT_FT_RESERVED_9_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_ADV_ASC_ACCEPT_FT_RESERVED_9(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x021, 1, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_ACCEPT_FT_RESERVED_9_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFDFF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)

#define GP_WB_READ_ADV_ASC_ACCEPT_FT_RESERVED_10(offset) \
        GP_WB_READ_U1((offset) + 0x021, 2)

#define GP_WB_GET_ADV_ASC_ACCEPT_FT_RESERVED_10_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_ADV_ASC_ACCEPT_FT_RESERVED_10(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x021, 2, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_ACCEPT_FT_RESERVED_10_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFBFF; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)

#define GP_WB_READ_ADV_ASC_ACCEPT_FT_RESERVED_11(offset) \
        GP_WB_READ_U1((offset) + 0x021, 3)

#define GP_WB_GET_ADV_ASC_ACCEPT_FT_RESERVED_11_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_ADV_ASC_ACCEPT_FT_RESERVED_11(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x021, 3, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_ACCEPT_FT_RESERVED_11_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7FF; \
          (tmp) |= (((UInt16)(val)) << 11); \
        } while (0)

#define GP_WB_READ_ADV_ASC_ACCEPT_FT_RESERVED_12(offset) \
        GP_WB_READ_U1((offset) + 0x021, 4)

#define GP_WB_GET_ADV_ASC_ACCEPT_FT_RESERVED_12_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_ADV_ASC_ACCEPT_FT_RESERVED_12(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x021, 4, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_ACCEPT_FT_RESERVED_12_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEFFF; \
          (tmp) |= (((UInt16)(val)) << 12); \
        } while (0)

#define GP_WB_READ_ADV_ASC_ACCEPT_FT_RESERVED_13(offset) \
        GP_WB_READ_U1((offset) + 0x021, 5)

#define GP_WB_GET_ADV_ASC_ACCEPT_FT_RESERVED_13_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_ADV_ASC_ACCEPT_FT_RESERVED_13(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x021, 5, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_ACCEPT_FT_RESERVED_13_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDFFF; \
          (tmp) |= (((UInt16)(val)) << 13); \
        } while (0)

#define GP_WB_READ_ADV_ASC_ACCEPT_FT_RESERVED_14(offset) \
        GP_WB_READ_U1((offset) + 0x021, 6)

#define GP_WB_GET_ADV_ASC_ACCEPT_FT_RESERVED_14_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_ADV_ASC_ACCEPT_FT_RESERVED_14(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x021, 6, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_ACCEPT_FT_RESERVED_14_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBFFF; \
          (tmp) |= (((UInt16)(val)) << 14); \
        } while (0)

#define GP_WB_READ_ADV_ASC_ACCEPT_FT_RESERVED_15(offset) \
        GP_WB_READ_U1((offset) + 0x021, 7)

#define GP_WB_GET_ADV_ASC_ACCEPT_FT_RESERVED_15_FROM_FRAME_TYPE_ACCEPT_MASK(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_ADV_ASC_ACCEPT_FT_RESERVED_15(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x021, 7, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_ACCEPT_FT_RESERVED_15_TO_FRAME_TYPE_ACCEPT_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7FFF; \
          (tmp) |= (((UInt16)(val)) << 15); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADV_ASC_WHITELIST_ENABLE_MASK(offset) \
        GP_WB_READ_U16((offset) + 0x022)

#define GP_WB_WRITE_ADV_ASC_WHITELIST_ENABLE_MASK(offset, val) \
      GP_WB_WRITE_U16((offset) + 0x022, (val))

#define GP_WB_READ_ADV_ASC_WL_EN_ADV_IND(offset) \
        GP_WB_READ_U1((offset) + 0x022, 0)

#define GP_WB_GET_ADV_ASC_WL_EN_ADV_IND_FROM_WHITELIST_ENABLE_MASK(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_ADV_ASC_WL_EN_ADV_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x022, 0, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_WL_EN_ADV_IND_TO_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFE; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

#define GP_WB_READ_ADV_ASC_WL_EN_ADV_DIRECT_IND(offset) \
        GP_WB_READ_U1((offset) + 0x022, 1)

#define GP_WB_GET_ADV_ASC_WL_EN_ADV_DIRECT_IND_FROM_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_ADV_ASC_WL_EN_ADV_DIRECT_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x022, 1, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_WL_EN_ADV_DIRECT_IND_TO_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFD; \
          (tmp) |= (((UInt16)(val)) << 1); \
        } while (0)

#define GP_WB_READ_ADV_ASC_WL_EN_ADV_NONCONN_IND(offset) \
        GP_WB_READ_U1((offset) + 0x022, 2)

#define GP_WB_GET_ADV_ASC_WL_EN_ADV_NONCONN_IND_FROM_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_ADV_ASC_WL_EN_ADV_NONCONN_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x022, 2, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_WL_EN_ADV_NONCONN_IND_TO_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFFB; \
          (tmp) |= (((UInt16)(val)) << 2); \
        } while (0)

#define GP_WB_READ_ADV_ASC_WL_EN_SCAN_REQ(offset) \
        GP_WB_READ_U1((offset) + 0x022, 3)

#define GP_WB_GET_ADV_ASC_WL_EN_SCAN_REQ_FROM_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_ADV_ASC_WL_EN_SCAN_REQ(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x022, 3, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_WL_EN_SCAN_REQ_TO_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFF7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

#define GP_WB_READ_ADV_ASC_WL_EN_AUX_SCAN_REQ(offset) \
        GP_WB_READ_U1((offset) + 0x022, 3)

#define GP_WB_GET_ADV_ASC_WL_EN_AUX_SCAN_REQ_FROM_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_ADV_ASC_WL_EN_AUX_SCAN_REQ(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x022, 3, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_WL_EN_AUX_SCAN_REQ_TO_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFF7; \
          (tmp) |= (((UInt16)(val)) << 3); \
        } while (0)

#define GP_WB_READ_ADV_ASC_WL_EN_SCAN_RSP(offset) \
        GP_WB_READ_U1((offset) + 0x022, 4)

#define GP_WB_GET_ADV_ASC_WL_EN_SCAN_RSP_FROM_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_ADV_ASC_WL_EN_SCAN_RSP(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x022, 4, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_WL_EN_SCAN_RSP_TO_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFEF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

#define GP_WB_READ_ADV_ASC_WL_EN_CONNECT_REQ(offset) \
        GP_WB_READ_U1((offset) + 0x022, 5)

#define GP_WB_GET_ADV_ASC_WL_EN_CONNECT_REQ_FROM_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_ADV_ASC_WL_EN_CONNECT_REQ(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x022, 5, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_WL_EN_CONNECT_REQ_TO_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFDF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

#define GP_WB_READ_ADV_ASC_WL_EN_AUX_CONNECT_REQ(offset) \
        GP_WB_READ_U1((offset) + 0x022, 5)

#define GP_WB_GET_ADV_ASC_WL_EN_AUX_CONNECT_REQ_FROM_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_ADV_ASC_WL_EN_AUX_CONNECT_REQ(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x022, 5, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_WL_EN_AUX_CONNECT_REQ_TO_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFDF; \
          (tmp) |= (((UInt16)(val)) << 5); \
        } while (0)

#define GP_WB_READ_ADV_ASC_WL_EN_ADV_SCAN_IND(offset) \
        GP_WB_READ_U1((offset) + 0x022, 6)

#define GP_WB_GET_ADV_ASC_WL_EN_ADV_SCAN_IND_FROM_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_ADV_ASC_WL_EN_ADV_SCAN_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x022, 6, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_WL_EN_ADV_SCAN_IND_TO_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFFBF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

#define GP_WB_READ_ADV_ASC_WL_EN_ADV_EXT_IND(offset) \
        GP_WB_READ_U1((offset) + 0x022, 7)

#define GP_WB_GET_ADV_ASC_WL_EN_ADV_EXT_IND_FROM_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADV_ASC_WL_EN_ADV_EXT_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x022, 7, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_WL_EN_ADV_EXT_IND_TO_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_ADV_ASC_WL_EN_AUX_ADV_IND(offset) \
        GP_WB_READ_U1((offset) + 0x022, 7)

#define GP_WB_GET_ADV_ASC_WL_EN_AUX_ADV_IND_FROM_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADV_ASC_WL_EN_AUX_ADV_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x022, 7, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_WL_EN_AUX_ADV_IND_TO_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_ADV_ASC_WL_EN_AUX_SCAN_RSP(offset) \
        GP_WB_READ_U1((offset) + 0x022, 7)

#define GP_WB_GET_ADV_ASC_WL_EN_AUX_SCAN_RSP_FROM_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADV_ASC_WL_EN_AUX_SCAN_RSP(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x022, 7, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_WL_EN_AUX_SCAN_RSP_TO_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_ADV_ASC_WL_EN_AUX_SYNC_IND(offset) \
        GP_WB_READ_U1((offset) + 0x022, 7)

#define GP_WB_GET_ADV_ASC_WL_EN_AUX_SYNC_IND_FROM_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADV_ASC_WL_EN_AUX_SYNC_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x022, 7, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_WL_EN_AUX_SYNC_IND_TO_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_ADV_ASC_WL_EN_AUX_CHAIN_IND(offset) \
        GP_WB_READ_U1((offset) + 0x022, 7)

#define GP_WB_GET_ADV_ASC_WL_EN_AUX_CHAIN_IND_FROM_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_ADV_ASC_WL_EN_AUX_CHAIN_IND(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x022, 7, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_WL_EN_AUX_CHAIN_IND_TO_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFF7F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

#define GP_WB_READ_ADV_ASC_WL_EN_AUX_CONNECT_RSP(offset) \
        GP_WB_READ_U1((offset) + 0x023, 0)

#define GP_WB_GET_ADV_ASC_WL_EN_AUX_CONNECT_RSP_FROM_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_ADV_ASC_WL_EN_AUX_CONNECT_RSP(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x023, 0, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_WL_EN_AUX_CONNECT_RSP_TO_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFEFF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

#define GP_WB_READ_ADV_ASC_WL_EN_RESERVED_9(offset) \
        GP_WB_READ_U1((offset) + 0x023, 1)

#define GP_WB_GET_ADV_ASC_WL_EN_RESERVED_9_FROM_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_ADV_ASC_WL_EN_RESERVED_9(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x023, 1, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_WL_EN_RESERVED_9_TO_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFDFF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)

#define GP_WB_READ_ADV_ASC_WL_EN_RESERVED_10(offset) \
        GP_WB_READ_U1((offset) + 0x023, 2)

#define GP_WB_GET_ADV_ASC_WL_EN_RESERVED_10_FROM_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 10) & 0x01)

#define GP_WB_WRITE_ADV_ASC_WL_EN_RESERVED_10(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x023, 2, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_WL_EN_RESERVED_10_TO_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xFBFF; \
          (tmp) |= (((UInt16)(val)) << 10); \
        } while (0)

#define GP_WB_READ_ADV_ASC_WL_EN_RESERVED_11(offset) \
        GP_WB_READ_U1((offset) + 0x023, 3)

#define GP_WB_GET_ADV_ASC_WL_EN_RESERVED_11_FROM_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_ADV_ASC_WL_EN_RESERVED_11(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x023, 3, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_WL_EN_RESERVED_11_TO_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xF7FF; \
          (tmp) |= (((UInt16)(val)) << 11); \
        } while (0)

#define GP_WB_READ_ADV_ASC_WL_EN_RESERVED_12(offset) \
        GP_WB_READ_U1((offset) + 0x023, 4)

#define GP_WB_GET_ADV_ASC_WL_EN_RESERVED_12_FROM_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_ADV_ASC_WL_EN_RESERVED_12(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x023, 4, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_WL_EN_RESERVED_12_TO_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xEFFF; \
          (tmp) |= (((UInt16)(val)) << 12); \
        } while (0)

#define GP_WB_READ_ADV_ASC_WL_EN_RESERVED_13(offset) \
        GP_WB_READ_U1((offset) + 0x023, 5)

#define GP_WB_GET_ADV_ASC_WL_EN_RESERVED_13_FROM_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 13) & 0x01)

#define GP_WB_WRITE_ADV_ASC_WL_EN_RESERVED_13(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x023, 5, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_WL_EN_RESERVED_13_TO_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xDFFF; \
          (tmp) |= (((UInt16)(val)) << 13); \
        } while (0)

#define GP_WB_READ_ADV_ASC_WL_EN_RESERVED_14(offset) \
        GP_WB_READ_U1((offset) + 0x023, 6)

#define GP_WB_GET_ADV_ASC_WL_EN_RESERVED_14_FROM_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_ADV_ASC_WL_EN_RESERVED_14(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x023, 6, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_WL_EN_RESERVED_14_TO_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xBFFF; \
          (tmp) |= (((UInt16)(val)) << 14); \
        } while (0)

#define GP_WB_READ_ADV_ASC_WL_EN_RESERVED_15(offset) \
        GP_WB_READ_U1((offset) + 0x023, 7)

#define GP_WB_GET_ADV_ASC_WL_EN_RESERVED_15_FROM_WHITELIST_ENABLE_MASK(tmp) \
        (((tmp) >> 15) & 0x01)

#define GP_WB_WRITE_ADV_ASC_WL_EN_RESERVED_15(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x023, 7, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_WL_EN_RESERVED_15_TO_WHITELIST_ENABLE_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x7FFF; \
          (tmp) |= (((UInt16)(val)) << 15); \
        } while (0)


/* The time in microseconds between 2 consecutive advertising packets in a single (primary) advertising event. Should not exceed 10ms. */
#define GP_WB_READ_ADV_ASC_INTRA_EVT_TX_SPACING(offset) \
        GP_WB_READ_U16((offset) + 0x024)

#define GP_WB_WRITE_ADV_ASC_INTRA_EVT_TX_SPACING(offset, val) do { \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_WRITE_U16((offset) + 0x024, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ADV_ASC_CONTEXT_FLAGS(offset) \
        GP_WB_READ_U8((offset) + 0x026)

#define GP_WB_WRITE_ADV_ASC_CONTEXT_FLAGS(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x026, (val))

/* queue AUX_SCAN_REQs */
#define GP_WB_READ_ADV_ASC_QUEUE_SCAN_REQS(offset) \
        GP_WB_READ_U1((offset) + 0x026, 0)

#define GP_WB_GET_ADV_ASC_QUEUE_SCAN_REQS_FROM_CONTEXT_FLAGS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_ADV_ASC_QUEUE_SCAN_REQS(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x026, 0, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_QUEUE_SCAN_REQS_TO_CONTEXT_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_ADV_ASC_DIRECTED_ADV(offset) \
        GP_WB_READ_U1((offset) + 0x026, 1)

#define GP_WB_GET_ADV_ASC_DIRECTED_ADV_FROM_CONTEXT_FLAGS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_ADV_ASC_DIRECTED_ADV(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x026, 1, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_DIRECTED_ADV_TO_CONTEXT_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Cleared by NRT when starting scannable advertising. Set by RT upon receiving a scan request */
#define GP_WB_READ_ADV_ASC_SCAN_REQ(offset) \
        GP_WB_READ_U1((offset) + 0x026, 2)

#define GP_WB_GET_ADV_ASC_SCAN_REQ_FROM_CONTEXT_FLAGS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_ADV_ASC_SCAN_REQ(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x026, 2, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_SCAN_REQ_TO_CONTEXT_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* Cleared by NRT when starting connectable advertising. Set by RT upon receiving an AUX_CONNECT_REQ. Never cleared by RT */
#define GP_WB_READ_ADV_ASC_CONN_REQ(offset) \
        GP_WB_READ_U1((offset) + 0x026, 3)

#define GP_WB_GET_ADV_ASC_CONN_REQ_FROM_CONTEXT_FLAGS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_ADV_ASC_CONN_REQ(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x026, 3, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_CONN_REQ_TO_CONTEXT_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

/* RT does not randomize the Channel Map; 1 = RT does randomize the order of channels in the Channel Map */
#define GP_WB_READ_ADV_ASC_RAND_ORDER_IN_CHANNEL_MAP(offset) \
        GP_WB_READ_U1((offset) + 0x026, 4)

#define GP_WB_GET_ADV_ASC_RAND_ORDER_IN_CHANNEL_MAP_FROM_CONTEXT_FLAGS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_ADV_ASC_RAND_ORDER_IN_CHANNEL_MAP(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_ADV_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x026, 4, (val)); \
        } while (0)

#define GP_WB_SET_ADV_ASC_RAND_ORDER_IN_CHANNEL_MAP_TO_CONTEXT_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

/***************************
 * layout: bgsc_ev_info
 ***************************/

/* priority of the event, (0= lowest priority; 255 is highest priority) */
#define GP_WB_READ_BGSC_EV_INFO_PRIORITY(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_BGSC_EV_INFO_PRIORITY(offset, val) do { \
          GP_WB_CHECK_OFFSET_BGSC_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x000, (val)); \
        } while (0)


/* when enabled, the event will not do any radio activity and the event will be skipped. The event state will still be updated though. */
#define GP_WB_READ_BGSC_EV_INFO_SUSPEND_EVENT(offset) \
        GP_WB_READ_U1((offset) + 0x001, 0)

#define GP_WB_WRITE_BGSC_EV_INFO_SUSPEND_EVENT(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BGSC_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 0, (val)); \
        } while (0)

/* when 1, the round robin mechanism will also take into account the nr_consec_skipped_events for this event */
#define GP_WB_READ_BGSC_EV_INFO_EXTENDED_PRIO_EN(offset) \
        GP_WB_READ_U1((offset) + 0x001, 1)

#define GP_WB_WRITE_BGSC_EV_INFO_EXTENDED_PRIO_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BGSC_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 1, (val)); \
        } while (0)


/* Indicates the number of events that are skipped in a row */
#define GP_WB_READ_BGSC_EV_INFO_NR_CONSEC_SKIPPED_EVENTS(offset) \
        GP_WB_READ_U16((offset) + 0x002)

#define GP_WB_WRITE_BGSC_EV_INFO_NR_CONSEC_SKIPPED_EVENTS(offset, val) do { \
          GP_WB_CHECK_OFFSET_BGSC_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x002, (val)); \
        } while (0)


/* Time an event needs to be soft aborted before next event trigger of the same event (in us), should be minumum the event_processing delay */
#define GP_WB_READ_BGSC_EV_INFO_GUARD_TIME(offset) \
        GP_WB_READ_U24((offset) + 0x004)

#define GP_WB_WRITE_BGSC_EV_INFO_GUARD_TIME(offset, val) do { \
          GP_WB_CHECK_OFFSET_BGSC_EV_INFO(offset); \
          GP_WB_WRITE_U24((offset) + 0x004, (val)); \
        } while (0)


/* The time between two events (in us) */
#define GP_WB_READ_BGSC_EV_INFO_INTERVAL(offset) \
        GP_WB_READ_U24((offset) + 0x008)

#define GP_WB_WRITE_BGSC_EV_INFO_INTERVAL(offset, val) do { \
          GP_WB_CHECK_OFFSET_BGSC_EV_INFO(offset); \
          GP_WB_WRITE_U24((offset) + 0x008, (val)); \
        } while (0)


/* the duration of the RX window. Resolution 16 us */
#define GP_WB_READ_BGSC_EV_INFO_WINDOW_DURATION(offset) \
        GP_WB_READ_U24((offset) + 0x00c)

#define GP_WB_WRITE_BGSC_EV_INFO_WINDOW_DURATION(offset, val) do { \
          GP_WB_CHECK_OFFSET_BGSC_EV_INFO(offset); \
          GP_WB_WRITE_U24((offset) + 0x00c, (val)); \
        } while (0)


/* current index within the channel map */
#define GP_WB_READ_BGSC_EV_INFO_CURRENT_CH_MAP_IDX(offset) \
        GP_WB_READ_U8((offset) + 0x00f)

#define GP_WB_WRITE_BGSC_EV_INFO_CURRENT_CH_MAP_IDX(offset, val) do { \
          GP_WB_CHECK_OFFSET_BGSC_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x00f, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BGSC_EV_INFO_SCAN_CH_MAP(offset) \
        GP_WB_READ_U40((offset) + 0x010)

#define GP_WB_WRITE_BGSC_EV_INFO_SCAN_CH_MAP(offset, val) \
      GP_WB_WRITE_U40((offset) + 0x010, (val))

/* channel for first  scan RX window. Always used */
#define GP_WB_READ_BGSC_EV_INFO_SCAN_CH0(offset) \
        GP_WB_READ_U8((offset) + 0x010)

#define GP_WB_GET_BGSC_EV_INFO_SCAN_CH0_FROM_SCAN_CH_MAP(tmp) \
        ((tmp) & 0xFF)

#define GP_WB_WRITE_BGSC_EV_INFO_SCAN_CH0(offset, val) do { \
          GP_WB_CHECK_OFFSET_BGSC_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x010, (val)); \
        } while (0)

#define GP_WB_SET_BGSC_EV_INFO_SCAN_CH0_TO_SCAN_CH_MAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFFFF00; \
          (tmp) |= ((UInt64)(val)); \
        } while (0)

/* channel for second scan RX window. if 255, channel is skipped */
#define GP_WB_READ_BGSC_EV_INFO_SCAN_CH1(offset) \
        GP_WB_READ_U8((offset) + 0x011)

#define GP_WB_GET_BGSC_EV_INFO_SCAN_CH1_FROM_SCAN_CH_MAP(tmp) \
        (((tmp) >> 8) & 0xFF)

#define GP_WB_WRITE_BGSC_EV_INFO_SCAN_CH1(offset, val) do { \
          GP_WB_CHECK_OFFSET_BGSC_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x011, (val)); \
        } while (0)

#define GP_WB_SET_BGSC_EV_INFO_SCAN_CH1_TO_SCAN_CH_MAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFF00FF; \
          (tmp) |= (((UInt64)(val)) << 8); \
        } while (0)

/* channel for third  scan RX window. if 255, channel is skipped */
#define GP_WB_READ_BGSC_EV_INFO_SCAN_CH2(offset) \
        GP_WB_READ_U8((offset) + 0x012)

#define GP_WB_GET_BGSC_EV_INFO_SCAN_CH2_FROM_SCAN_CH_MAP(tmp) \
        (((tmp) >> 16) & 0xFF)

#define GP_WB_WRITE_BGSC_EV_INFO_SCAN_CH2(offset, val) do { \
          GP_WB_CHECK_OFFSET_BGSC_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x012, (val)); \
        } while (0)

#define GP_WB_SET_BGSC_EV_INFO_SCAN_CH2_TO_SCAN_CH_MAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFF00FFFF; \
          (tmp) |= (((UInt64)(val)) << 16); \
        } while (0)

/* channel for fourth scan RX window. if 255, channel is skipped */
#define GP_WB_READ_BGSC_EV_INFO_SCAN_CH3(offset) \
        GP_WB_READ_U8((offset) + 0x013)

#define GP_WB_GET_BGSC_EV_INFO_SCAN_CH3_FROM_SCAN_CH_MAP(tmp) \
        (((tmp) >> 24) & 0xFF)

#define GP_WB_WRITE_BGSC_EV_INFO_SCAN_CH3(offset, val) do { \
          GP_WB_CHECK_OFFSET_BGSC_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x013, (val)); \
        } while (0)

#define GP_WB_SET_BGSC_EV_INFO_SCAN_CH3_TO_SCAN_CH_MAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFF00FFFFFF; \
          (tmp) |= (((UInt64)(val)) << 24); \
        } while (0)

/* channel for fifth  scan RX window. if 255, channel is skipped */
#define GP_WB_READ_BGSC_EV_INFO_SCAN_CH4(offset) \
        GP_WB_READ_U8((offset) + 0x014)

#define GP_WB_GET_BGSC_EV_INFO_SCAN_CH4_FROM_SCAN_CH_MAP(tmp) \
        (((tmp) >> 32) & 0xFF)

#define GP_WB_WRITE_BGSC_EV_INFO_SCAN_CH4(offset, val) do { \
          GP_WB_CHECK_OFFSET_BGSC_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x014, (val)); \
        } while (0)

#define GP_WB_SET_BGSC_EV_INFO_SCAN_CH4_TO_SCAN_CH_MAP(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0x00FFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 32); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BGSC_EV_INFO_PHY_MASK(offset) \
        GP_WB_READ_U8((offset) + 0x015)

#define GP_WB_WRITE_BGSC_EV_INFO_PHY_MASK(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x015, (val))

/* 1Mbit */
#define GP_WB_READ_BGSC_EV_INFO_ONE(offset) \
        GP_WB_READ_U1((offset) + 0x015, 0)

#define GP_WB_GET_BGSC_EV_INFO_ONE_FROM_PHY_MASK(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_BGSC_EV_INFO_ONE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BGSC_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x015, 0, (val)); \
        } while (0)

#define GP_WB_SET_BGSC_EV_INFO_ONE_TO_PHY_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* reserved for future use */
#define GP_WB_READ_BGSC_EV_INFO_RESERVED_1(offset) \
        GP_WB_READ_U1((offset) + 0x015, 1)

#define GP_WB_GET_BGSC_EV_INFO_RESERVED_1_FROM_PHY_MASK(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_BGSC_EV_INFO_RESERVED_1(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BGSC_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x015, 1, (val)); \
        } while (0)

#define GP_WB_SET_BGSC_EV_INFO_RESERVED_1_TO_PHY_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* long range */
#define GP_WB_READ_BGSC_EV_INFO_LR(offset) \
        GP_WB_READ_U1((offset) + 0x015, 2)

#define GP_WB_GET_BGSC_EV_INFO_LR_FROM_PHY_MASK(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_BGSC_EV_INFO_LR(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BGSC_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x015, 2, (val)); \
        } while (0)

#define GP_WB_SET_BGSC_EV_INFO_LR_TO_PHY_MASK(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_BGSC_EV_INFO_SCAN_FLAGS(offset) \
        GP_WB_READ_U8((offset) + 0x016)

#define GP_WB_WRITE_BGSC_EV_INFO_SCAN_FLAGS(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x016, (val))

/* enable legacy and extended scanning */
#define GP_WB_READ_BGSC_EV_INFO_ENABLE_SCAN(offset) \
        GP_WB_READ_U1((offset) + 0x016, 0)

#define GP_WB_GET_BGSC_EV_INFO_ENABLE_SCAN_FROM_SCAN_FLAGS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_BGSC_EV_INFO_ENABLE_SCAN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BGSC_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x016, 0, (val)); \
        } while (0)

#define GP_WB_SET_BGSC_EV_INFO_ENABLE_SCAN_TO_SCAN_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* enable legacy and extended initiating */
#define GP_WB_READ_BGSC_EV_INFO_ENABLE_INIT(offset) \
        GP_WB_READ_U1((offset) + 0x016, 1)

#define GP_WB_GET_BGSC_EV_INFO_ENABLE_INIT_FROM_SCAN_FLAGS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_BGSC_EV_INFO_ENABLE_INIT(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BGSC_EV_INFO(offset); \
          GP_WB_MWRITE_U1((offset) + 0x016, 1, (val)); \
        } while (0)

#define GP_WB_SET_BGSC_EV_INFO_ENABLE_INIT_TO_SCAN_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* pointer to (legacy) scan_even_info event structure */
#define GP_WB_READ_BGSC_EV_INFO_SCAN_EV_INFO_PTR(offset) \
        GP_WB_READ_U16((offset) + 0x018)

#define GP_WB_WRITE_BGSC_EV_INFO_SCAN_EV_INFO_PTR(offset, val) do { \
          GP_WB_CHECK_OFFSET_BGSC_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x018, (val)); \
        } while (0)


/* pointer to (legacy) init_even_info event structure */
#define GP_WB_READ_BGSC_EV_INFO_INIT_EV_INFO_PTR(offset) \
        GP_WB_READ_U16((offset) + 0x01a)

#define GP_WB_WRITE_BGSC_EV_INFO_INIT_EV_INFO_PTR(offset, val) do { \
          GP_WB_CHECK_OFFSET_BGSC_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x01a, (val)); \
        } while (0)


/* Indicates whether the antenna switching feature should be enabled */
#define GP_WB_READ_BGSC_EV_INFO_EN_ANT_SWITCHING(offset) \
        GP_WB_READ_U8((offset) + 0x01c)

#define GP_WB_WRITE_BGSC_EV_INFO_EN_ANT_SWITCHING(offset, val) do { \
          GP_WB_CHECK_OFFSET_BGSC_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x01c, (val)); \
        } while (0)


/* Indicates the antenna currently being used (or next to be used when not during the event) */
#define GP_WB_READ_BGSC_EV_INFO_CURR_ANTENNA(offset) \
        GP_WB_READ_U8((offset) + 0x01d)

#define GP_WB_WRITE_BGSC_EV_INFO_CURR_ANTENNA(offset, val) do { \
          GP_WB_CHECK_OFFSET_BGSC_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x01d, (val)); \
        } while (0)


/* pointer to a CM style list of rx_list_entry elements that get written after the RX mode is set and before the receiver is started */
#define GP_WB_READ_BGSC_EV_INFO_RX_LIST_PTR(offset) \
        GP_WB_READ_U16((offset) + 0x01e)

#define GP_WB_WRITE_BGSC_EV_INFO_RX_LIST_PTR(offset, val) do { \
          GP_WB_CHECK_OFFSET_BGSC_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x01e, (val)); \
        } while (0)


/* indicates if multistandard listening is allowed for this subevent. */
#define GP_WB_READ_BGSC_EV_INFO_MS_ALLOWED(offset) \
        GP_WB_READ_U1((offset) + 0x020, 0)

#define GP_WB_WRITE_BGSC_EV_INFO_MS_ALLOWED(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_BGSC_EV_INFO(offset); \
          GP_WB_WRITE_U8((offset) + 0x020, (val)); \
        } while (0)


/* Internal state of the RT. Indicates the elapsed scan time (in us) during the current event (= effective RX on time). */
#define GP_WB_READ_BGSC_EV_INFO_ELAPSED_SCAN_TIME(offset) \
        GP_WB_READ_U24((offset) + 0x024)

#define GP_WB_WRITE_BGSC_EV_INFO_ELAPSED_SCAN_TIME(offset, val) do { \
          GP_WB_CHECK_OFFSET_BGSC_EV_INFO(offset); \
          GP_WB_WRITE_U24((offset) + 0x024, (val)); \
        } while (0)


/* Internal state of the RT. Indicates the timestamp when the last scan started. */
#define GP_WB_READ_BGSC_EV_INFO_LAST_SCAN_START_TIME(offset) \
        GP_WB_READ_U32((offset) + 0x028)

#define GP_WB_WRITE_BGSC_EV_INFO_LAST_SCAN_START_TIME(offset, val) do { \
          GP_WB_CHECK_OFFSET_BGSC_EV_INFO(offset); \
          GP_WB_WRITE_U32((offset) + 0x028, (val)); \
        } while (0)


/* DEPRECATED! Must stay for background compability reasons. Linear ram offset for the init_common_ext_info structure. */
#define GP_WB_READ_BGSC_EV_INFO_INIT_COMMON_EXT_INFO_BASE_PTR_DEPR(offset) \
        GP_WB_READ_U16((offset) + 0x02c)

#define GP_WB_WRITE_BGSC_EV_INFO_INIT_COMMON_EXT_INFO_BASE_PTR_DEPR(offset, val) do { \
          GP_WB_CHECK_OFFSET_BGSC_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x02c, (val)); \
        } while (0)


/* DEPRECATED! Must stay for background compability reasons. Linear ram offset for the scan_common_ext_info structure. */
#define GP_WB_READ_BGSC_EV_INFO_SCAN_COMMON_EXT_INFO_BASE_PTR_DEPR(offset) \
        GP_WB_READ_U16((offset) + 0x02e)

#define GP_WB_WRITE_BGSC_EV_INFO_SCAN_COMMON_EXT_INFO_BASE_PTR_DEPR(offset, val) do { \
          GP_WB_CHECK_OFFSET_BGSC_EV_INFO(offset); \
          GP_WB_WRITE_U16((offset) + 0x02e, (val)); \
        } while (0)

/***************************
 * layout: scan_asc
 ***************************/

/* priority of the event, (0= lowest priority; 255 is highest priority) */
#define GP_WB_READ_SCAN_ASC_PRIORITY(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_SCAN_ASC_PRIORITY(offset, val) do { \
          GP_WB_CHECK_OFFSET_SCAN_ASC(offset); \
          GP_WB_WRITE_U8((offset) + 0x000, (val)); \
        } while (0)


/* when enabled, the event will not do any radio activity and the event will be skipped. The event state will still be updated though. */
#define GP_WB_READ_SCAN_ASC_SUSPEND_EVENT(offset) \
        GP_WB_READ_U1((offset) + 0x001, 0)

#define GP_WB_WRITE_SCAN_ASC_SUSPEND_EVENT(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 0, (val)); \
        } while (0)

/* when 1, the round robin mechanism will also take into account the nr_consec_skipped_events for this event */
#define GP_WB_READ_SCAN_ASC_EXTENDED_PRIO_EN(offset) \
        GP_WB_READ_U1((offset) + 0x001, 1)

#define GP_WB_WRITE_SCAN_ASC_EXTENDED_PRIO_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 1, (val)); \
        } while (0)


/* Indicates the number of events that are skipped in a row */
#define GP_WB_READ_SCAN_ASC_NR_CONSEC_SKIPPED_EVENTS(offset) \
        GP_WB_READ_U16((offset) + 0x002)

#define GP_WB_WRITE_SCAN_ASC_NR_CONSEC_SKIPPED_EVENTS(offset, val) do { \
          GP_WB_CHECK_OFFSET_SCAN_ASC(offset); \
          GP_WB_WRITE_U16((offset) + 0x002, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SCAN_ASC_FLAGS(offset) \
        GP_WB_READ_U8((offset) + 0x004)

#define GP_WB_WRITE_SCAN_ASC_FLAGS(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x004, (val))

/* free or not , set by RT when claimed, cleared by NRT when released */
#define GP_WB_READ_SCAN_ASC_IN_USE(offset) \
        GP_WB_READ_U1((offset) + 0x004, 0)

#define GP_WB_GET_SCAN_ASC_IN_USE_FROM_FLAGS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_SCAN_ASC_IN_USE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x004, 0, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_ASC_IN_USE_TO_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* by NRT, this flag is cleared by RT and set by NRT */
#define GP_WB_READ_SCAN_ASC_HALTED(offset) \
        GP_WB_READ_U1((offset) + 0x004, 1)

#define GP_WB_GET_SCAN_ASC_HALTED_FROM_FLAGS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_SCAN_ASC_HALTED(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x004, 1, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_ASC_HALTED_TO_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* by RT, this flag is used by RT only - ADI valid for comparrison */
#define GP_WB_READ_SCAN_ASC_VALID_ADI(offset) \
        GP_WB_READ_U1((offset) + 0x004, 2)

#define GP_WB_GET_SCAN_ASC_VALID_ADI_FROM_FLAGS(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_SCAN_ASC_VALID_ADI(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x004, 2, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_ASC_VALID_ADI_TO_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/* set/read by RT: indicates that primary phy is an active scan phy */
#define GP_WB_READ_SCAN_ASC_PRIM_PHY_ACTIVE_SCAN(offset) \
        GP_WB_READ_U1((offset) + 0x004, 3)

#define GP_WB_GET_SCAN_ASC_PRIM_PHY_ACTIVE_SCAN_FROM_FLAGS(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_SCAN_ASC_PRIM_PHY_ACTIVE_SCAN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SCAN_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x004, 3, (val)); \
        } while (0)

#define GP_WB_SET_SCAN_ASC_PRIM_PHY_ACTIVE_SCAN_TO_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)


/* when a peer address is resolved write the found index in the scan context for later use (use case: AdvA and TargetA not in the same pdu) */
#define GP_WB_READ_SCAN_ASC_IRK_IDX(offset) \
        GP_WB_READ_U8((offset) + 0x005)

#define GP_WB_WRITE_SCAN_ASC_IRK_IDX(offset, val) do { \
          GP_WB_CHECK_OFFSET_SCAN_ASC(offset); \
          GP_WB_WRITE_U8((offset) + 0x005, (val)); \
        } while (0)


/* ADI as received in ADV_EXT_IND or AUX_ADV_IND */
#define GP_WB_READ_SCAN_ASC_ADI(offset) \
        GP_WB_READ_U16((offset) + 0x006)

#define GP_WB_WRITE_SCAN_ASC_ADI(offset, val) do { \
          GP_WB_CHECK_OFFSET_SCAN_ASC(offset); \
          GP_WB_WRITE_U16((offset) + 0x006, (val)); \
        } while (0)

/***************************
 * layout: per_asc
 ***************************/

/* priority of the event, (0= lowest priority; 255 is highest priority) */
#define GP_WB_READ_PER_ASC_PRIORITY(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_PER_ASC_PRIORITY(offset, val) do { \
          GP_WB_CHECK_OFFSET_PER_ASC(offset); \
          GP_WB_WRITE_U8((offset) + 0x000, (val)); \
        } while (0)


/* when enabled, the event will not do any radio activity and the event will be skipped. The event state will still be updated though. */
#define GP_WB_READ_PER_ASC_SUSPEND_EVENT(offset) \
        GP_WB_READ_U1((offset) + 0x001, 0)

#define GP_WB_WRITE_PER_ASC_SUSPEND_EVENT(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PER_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 0, (val)); \
        } while (0)

/* when 1, the round robin mechanism will also take into account the nr_consec_skipped_events for this event */
#define GP_WB_READ_PER_ASC_EXTENDED_PRIO_EN(offset) \
        GP_WB_READ_U1((offset) + 0x001, 1)

#define GP_WB_WRITE_PER_ASC_EXTENDED_PRIO_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_PER_ASC(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 1, (val)); \
        } while (0)


/* Indicates the number of events that are skipped in a row */
#define GP_WB_READ_PER_ASC_NR_CONSEC_SKIPPED_EVENTS(offset) \
        GP_WB_READ_U16((offset) + 0x002)

#define GP_WB_WRITE_PER_ASC_NR_CONSEC_SKIPPED_EVENTS(offset, val) do { \
          GP_WB_CHECK_OFFSET_PER_ASC(offset); \
          GP_WB_WRITE_U16((offset) + 0x002, (val)); \
        } while (0)


/* The access address for periodic advertising packets. */
#define GP_WB_READ_PER_ASC_ADV_ACCESS_ADDRESS(offset) \
        GP_WB_READ_U32((offset) + 0x004)

#define GP_WB_WRITE_PER_ASC_ADV_ACCESS_ADDRESS(offset, val) do { \
          GP_WB_CHECK_OFFSET_PER_ASC(offset); \
          GP_WB_WRITE_U32((offset) + 0x004, (val)); \
        } while (0)


/* The crc init for the periodic advertising channels */
#define GP_WB_READ_PER_ASC_ADV_CRC_INIT(offset) \
        GP_WB_READ_U24((offset) + 0x008)

#define GP_WB_WRITE_PER_ASC_ADV_CRC_INIT(offset, val) do { \
          GP_WB_CHECK_OFFSET_PER_ASC(offset); \
          GP_WB_WRITE_U24((offset) + 0x008, (val)); \
        } while (0)


/* index to the channelmap and remap table */
#define GP_WB_READ_PER_ASC_CH_MAP_IDX(offset) \
        GP_WB_READ_U8((offset) + 0x00b)

#define GP_WB_WRITE_PER_ASC_CH_MAP_IDX(offset, val) do { \
          GP_WB_CHECK_OFFSET_PER_ASC(offset); \
          GP_WB_WRITE_U8((offset) + 0x00b, (val)); \
        } while (0)

/***************************
 * layout: sync_c
 ***************************/

/* priority of the event, (0= lowest priority; 255 is highest priority) */
#define GP_WB_READ_SYNC_C_PRIORITY(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_SYNC_C_PRIORITY(offset, val) do { \
          GP_WB_CHECK_OFFSET_SYNC_C(offset); \
          GP_WB_WRITE_U8((offset) + 0x000, (val)); \
        } while (0)


/* when enabled, the event will not do any radio activity and the event will be skipped. The event state will still be updated though. */
#define GP_WB_READ_SYNC_C_SUSPEND_EVENT(offset) \
        GP_WB_READ_U1((offset) + 0x001, 0)

#define GP_WB_WRITE_SYNC_C_SUSPEND_EVENT(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SYNC_C(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 0, (val)); \
        } while (0)

/* when 1, the round robin mechanism will also take into account the nr_consec_skipped_events for this event */
#define GP_WB_READ_SYNC_C_EXTENDED_PRIO_EN(offset) \
        GP_WB_READ_U1((offset) + 0x001, 1)

#define GP_WB_WRITE_SYNC_C_EXTENDED_PRIO_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SYNC_C(offset); \
          GP_WB_MWRITE_U1((offset) + 0x001, 1, (val)); \
        } while (0)


/* Indicates the number of events that are skipped in a row */
#define GP_WB_READ_SYNC_C_NR_CONSEC_SKIPPED_EVENTS(offset) \
        GP_WB_READ_U16((offset) + 0x002)

#define GP_WB_WRITE_SYNC_C_NR_CONSEC_SKIPPED_EVENTS(offset, val) do { \
          GP_WB_CHECK_OFFSET_SYNC_C(offset); \
          GP_WB_WRITE_U16((offset) + 0x002, (val)); \
        } while (0)


/* Index to the channel map and remap table. */
#define GP_WB_READ_SYNC_C_CH_MAP_IDX(offset) \
        GP_WB_READ_U8((offset) + 0x004)

#define GP_WB_WRITE_SYNC_C_CH_MAP_IDX(offset, val) do { \
          GP_WB_CHECK_OFFSET_SYNC_C(offset); \
          GP_WB_WRITE_U8((offset) + 0x004, (val)); \
        } while (0)


/* Access address for periodic advertising packets. */
#define GP_WB_READ_SYNC_C_ADV_ACCESS_ADDRESS(offset) \
        GP_WB_READ_U32((offset) + 0x008)

#define GP_WB_WRITE_SYNC_C_ADV_ACCESS_ADDRESS(offset, val) do { \
          GP_WB_CHECK_OFFSET_SYNC_C(offset); \
          GP_WB_WRITE_U32((offset) + 0x008, (val)); \
        } while (0)


/* CRC init value for the periodic advertising channels. */
#define GP_WB_READ_SYNC_C_ADV_CRC_INIT(offset) \
        GP_WB_READ_U24((offset) + 0x00c)

#define GP_WB_WRITE_SYNC_C_ADV_CRC_INIT(offset, val) do { \
          GP_WB_CHECK_OFFSET_SYNC_C(offset); \
          GP_WB_WRITE_U24((offset) + 0x00c, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SYNC_C_FLAGS(offset) \
        GP_WB_READ_U8((offset) + 0x00f)

#define GP_WB_WRITE_SYNC_C_FLAGS(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x00f, (val))

/* The halted_by_nrt flag. */
#define GP_WB_READ_SYNC_C_HALTED(offset) \
        GP_WB_READ_U1((offset) + 0x00f, 0)

#define GP_WB_GET_SYNC_C_HALTED_FROM_FLAGS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_SYNC_C_HALTED(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SYNC_C(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00f, 0, (val)); \
        } while (0)

#define GP_WB_SET_SYNC_C_HALTED_TO_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Indicates if bt fake preable is present. */
#define GP_WB_READ_SYNC_C_RX_BT_FAKE_PREAMBLE_PRESENT(offset) \
        GP_WB_READ_U1((offset) + 0x00f, 1)

#define GP_WB_GET_SYNC_C_RX_BT_FAKE_PREAMBLE_PRESENT_FROM_FLAGS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_SYNC_C_RX_BT_FAKE_PREAMBLE_PRESENT(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_SYNC_C(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00f, 1, (val)); \
        } while (0)

#define GP_WB_SET_SYNC_C_RX_BT_FAKE_PREAMBLE_PRESENT_TO_FLAGS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* Threshold for BLE preamble validation. */
#define GP_WB_READ_SYNC_C_RX_BT_VALIDATION_THRESH(offset) \
        GP_WB_READ_U16((offset) + 0x010)

#define GP_WB_WRITE_SYNC_C_RX_BT_VALIDATION_THRESH(offset, val) do { \
          GP_WB_CHECK_OFFSET_SYNC_C(offset); \
          GP_WB_WRITE_U16((offset) + 0x010, (val)); \
        } while (0)


/* Amount of symbols inside the access code the validation is going to start. */
#define GP_WB_READ_SYNC_C_RX_BT_VALIDATION_N(offset) \
        GP_WB_READ_U8((offset) + 0x012)

#define GP_WB_WRITE_SYNC_C_RX_BT_VALIDATION_N(offset, val) do { \
          GP_WB_CHECK_OFFSET_SYNC_C(offset); \
          GP_WB_WRITE_U8((offset) + 0x012, (val)); \
        } while (0)


/* Index inside the access code where a fake preamble starts. */
#define GP_WB_READ_SYNC_C_RX_BT_FAKE_PREAMBLE_N(offset) \
        GP_WB_READ_U8((offset) + 0x013)

#define GP_WB_WRITE_SYNC_C_RX_BT_FAKE_PREAMBLE_N(offset, val) do { \
          GP_WB_CHECK_OFFSET_SYNC_C(offset); \
          GP_WB_WRITE_U8((offset) + 0x013, (val)); \
        } while (0)

/***************************
 * layout: tx_power_config
 ***************************/

/* pointer to the global PA power table (offset from start of RAM) */
#define GP_WB_READ_TX_POWER_CONFIG_PA_POWER_SETTING_TABLE_PTR(offset) \
        GP_WB_READ_U16((offset) + 0x000)

#define GP_WB_WRITE_TX_POWER_CONFIG_PA_POWER_SETTING_TABLE_PTR(offset, val) do { \
          GP_WB_CHECK_OFFSET_TX_POWER_CONFIG(offset); \
          GP_WB_WRITE_U16((offset) + 0x000, (val)); \
        } while (0)


/* pointer to the Tx power limitation table (offset from start of RAM) */
#define GP_WB_READ_TX_POWER_CONFIG_POWER_LIMITATION_TABLE_PTR(offset) \
        GP_WB_READ_U16((offset) + 0x002)

#define GP_WB_WRITE_TX_POWER_CONFIG_POWER_LIMITATION_TABLE_PTR(offset, val) do { \
          GP_WB_CHECK_OFFSET_TX_POWER_CONFIG(offset); \
          GP_WB_WRITE_U16((offset) + 0x002, (val)); \
        } while (0)


/* Number of entries in power_limitation_table_ptr */
#define GP_WB_READ_TX_POWER_CONFIG_POWER_LIMITATION_TABLE_SIZE(offset) \
        GP_WB_READ_U8((offset) + 0x004)

#define GP_WB_WRITE_TX_POWER_CONFIG_POWER_LIMITATION_TABLE_SIZE(offset, val) do { \
          GP_WB_CHECK_OFFSET_TX_POWER_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x004, (val)); \
        } while (0)


/* Whether or not closed loop measurements are enabled. This isi nternal state for RT, can only be set to 0 by NRT before RT is initialized. */
#define GP_WB_READ_TX_POWER_CONFIG_CLOSED_LOOP_ENABLED(offset) \
        GP_WB_READ_U1((offset) + 0x005, 0)

#define GP_WB_WRITE_TX_POWER_CONFIG_CLOSED_LOOP_ENABLED(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_TX_POWER_CONFIG(offset); \
          GP_WB_MWRITE_U1((offset) + 0x005, 0, (val)); \
        } while (0)

/* ADC buffer RT can use (exclusively) for closed loop purposes. Can be 0 (buffer A), 1 (buffer B), 2 (buffer C) or 3 (no buffer specified) */
#define GP_WB_READ_TX_POWER_CONFIG_ADC_BUFFER(offset) \
        ((GP_WB_READ_U8((offset) + 0x005) >> 1) & 0x03)

#define GP_WB_WRITE_TX_POWER_CONFIG_ADC_BUFFER(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_CHECK_OFFSET_TX_POWER_CONFIG(offset); \
          GP_WB_MWRITE_U8((offset) + 0x005, 0x06, (val) << 1); \
        } while (0)


/* pointer to the location where we need to write the results of the tx power measurements (offset from start of RAM) */
#define GP_WB_READ_TX_POWER_CONFIG_MEASUREMENT_DONE_MEM_PTR(offset) \
        GP_WB_READ_U16((offset) + 0x006)

#define GP_WB_WRITE_TX_POWER_CONFIG_MEASUREMENT_DONE_MEM_PTR(offset, val) do { \
          GP_WB_CHECK_OFFSET_TX_POWER_CONFIG(offset); \
          GP_WB_WRITE_U16((offset) + 0x006, (val)); \
        } while (0)


/* bitfield of fll channels that require closed loop measurements. Setting a bit to 1 enables measurements on that channel */
#define GP_WB_READ_TX_POWER_CONFIG_CHANNELS_TO_MEASURE(offset) \
        GP_WB_READ_U64((offset) + 0x008)

#define GP_WB_WRITE_TX_POWER_CONFIG_CHANNELS_TO_MEASURE(offset, val) do { \
          GP_WB_CHECK_OFFSET_TX_POWER_CONFIG(offset); \
          GP_WB_WRITE_U64((offset) + 0x008, (val)); \
        } while (0)

/***************************
 * layout: tx_power_limit
 ***************************/

/* Fll channel that needs a Tx power limitation */
#define GP_WB_READ_TX_POWER_LIMIT_FLL_CHANNEL(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_TX_POWER_LIMIT_FLL_CHANNEL(offset, val) do { \
          GP_WB_CHECK_OFFSET_TX_POWER_LIMIT(offset); \
          GP_WB_WRITE_U8((offset) + 0x000, (val)); \
        } while (0)

/* Index to entry in global PA table (used to identify the tx power setting that need to be used) */
#define GP_WB_READ_TX_POWER_LIMIT_PA_POWER_TABLE_INDEX(offset) \
        GP_WB_READ_U8((offset) + 0x001)

#define GP_WB_WRITE_TX_POWER_LIMIT_PA_POWER_TABLE_INDEX(offset, val) do { \
          GP_WB_CHECK_OFFSET_TX_POWER_LIMIT(offset); \
          GP_WB_WRITE_U8((offset) + 0x001, (val)); \
        } while (0)

/***************************
 * layout: tx_power_measurement_done
 ***************************/

/* Index to entry in global PA table (used to identify the original tx power setting that was used) */
#define GP_WB_READ_TX_POWER_MEASUREMENT_DONE_PA_POWER_TABLE_INDEX(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_TX_POWER_MEASUREMENT_DONE_PA_POWER_TABLE_INDEX(offset, val) do { \
          GP_WB_CHECK_OFFSET_TX_POWER_MEASUREMENT_DONE(offset); \
          GP_WB_WRITE_U8((offset) + 0x000, (val)); \
        } while (0)

/* The hardware power setting that was used for the last transmit */
#define GP_WB_READ_TX_POWER_MEASUREMENT_DONE_USED_TX_POWER_SETTING(offset) \
        GP_WB_READ_U8((offset) + 0x001)

#define GP_WB_WRITE_TX_POWER_MEASUREMENT_DONE_USED_TX_POWER_SETTING(offset, val) do { \
          GP_WB_CHECK_OFFSET_TX_POWER_MEASUREMENT_DONE(offset); \
          GP_WB_WRITE_U8((offset) + 0x001, (val)); \
        } while (0)

/* Voltage measured by ADC */
#define GP_WB_READ_TX_POWER_MEASUREMENT_DONE_DETECTED_VOLTAGE(offset) \
        GP_WB_READ_U16((offset) + 0x002)

#define GP_WB_WRITE_TX_POWER_MEASUREMENT_DONE_DETECTED_VOLTAGE(offset, val) do { \
          GP_WB_CHECK_OFFSET_TX_POWER_MEASUREMENT_DONE(offset); \
          GP_WB_WRITE_U16((offset) + 0x002, (val)); \
        } while (0)

/***************************
 * layout: rx_list_entry
 ***************************/

/* address to be written */
#define GP_WB_READ_RX_LIST_ENTRY_ADDRESS(offset) \
        GP_WB_READ_U16((offset) + 0x000)

#define GP_WB_WRITE_RX_LIST_ENTRY_ADDRESS(offset, val) do { \
          GP_WB_CHECK_OFFSET_RX_LIST_ENTRY(offset); \
          GP_WB_WRITE_U16((offset) + 0x000, (val)); \
        } while (0)


/* value to write */
#define GP_WB_READ_RX_LIST_ENTRY_VALUE(offset) \
        GP_WB_READ_U8((offset) + 0x002)

#define GP_WB_WRITE_RX_LIST_ENTRY_VALUE(offset, val) do { \
          GP_WB_CHECK_OFFSET_RX_LIST_ENTRY(offset); \
          GP_WB_WRITE_U8((offset) + 0x002, (val)); \
        } while (0)

/* mask to use for the write, if 0xff a normal write is done, otherwise a read-modify-write is done */
#define GP_WB_READ_RX_LIST_ENTRY_MASK(offset) \
        GP_WB_READ_U8((offset) + 0x003)

#define GP_WB_WRITE_RX_LIST_ENTRY_MASK(offset, val) do { \
          GP_WB_CHECK_OFFSET_RX_LIST_ENTRY(offset); \
          GP_WB_WRITE_U8((offset) + 0x003, (val)); \
        } while (0)

/***************************
 * layout: ant_switch_config
 ***************************/

/* The length of the switch sequence (max = 74) */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SEQUENCE_LENGTH(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SEQUENCE_LENGTH(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x000, (val)); \
        } while (0)

/* The slot duration */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOT_DURATION(offset) \
        GP_WB_READ_U8((offset) + 0x001)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOT_DURATION(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x001, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_ANT_SWITCH_CONFIG_ANT_SWITCH_SLOTS(offset) \
        GP_WB_READ_U64((offset) + 0x004)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_ANT_SWITCH_SLOTS(offset, val) \
      GP_WB_WRITE_U64((offset) + 0x004, (val))

/* The first 2 antenna id (2 antenna ids per byte, 4 lsbs = slot 0) */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_0(offset) \
        GP_WB_READ_U8((offset) + 0x004)

#define GP_WB_GET_ANT_SWITCH_CONFIG_SLOTS_0_FROM_ANT_SWITCH_SLOTS(tmp) \
        ((tmp) & 0xFF)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_0(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x004, (val)); \
        } while (0)

#define GP_WB_SET_ANT_SWITCH_CONFIG_SLOTS_0_TO_ANT_SWITCH_SLOTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFFFFFFFFFF00; \
          (tmp) |= ((UInt64)(val)); \
        } while (0)

/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_1(offset) \
        GP_WB_READ_U8((offset) + 0x005)

#define GP_WB_GET_ANT_SWITCH_CONFIG_SLOTS_1_FROM_ANT_SWITCH_SLOTS(tmp) \
        (((tmp) >> 8) & 0xFF)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_1(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x005, (val)); \
        } while (0)

#define GP_WB_SET_ANT_SWITCH_CONFIG_SLOTS_1_TO_ANT_SWITCH_SLOTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFFFFFFFF00FF; \
          (tmp) |= (((UInt64)(val)) << 8); \
        } while (0)

/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_2(offset) \
        GP_WB_READ_U8((offset) + 0x006)

#define GP_WB_GET_ANT_SWITCH_CONFIG_SLOTS_2_FROM_ANT_SWITCH_SLOTS(tmp) \
        (((tmp) >> 16) & 0xFF)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_2(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x006, (val)); \
        } while (0)

#define GP_WB_SET_ANT_SWITCH_CONFIG_SLOTS_2_TO_ANT_SWITCH_SLOTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFFFFFF00FFFF; \
          (tmp) |= (((UInt64)(val)) << 16); \
        } while (0)

/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_3(offset) \
        GP_WB_READ_U8((offset) + 0x007)

#define GP_WB_GET_ANT_SWITCH_CONFIG_SLOTS_3_FROM_ANT_SWITCH_SLOTS(tmp) \
        (((tmp) >> 24) & 0xFF)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_3(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x007, (val)); \
        } while (0)

#define GP_WB_SET_ANT_SWITCH_CONFIG_SLOTS_3_TO_ANT_SWITCH_SLOTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFFFF00FFFFFF; \
          (tmp) |= (((UInt64)(val)) << 24); \
        } while (0)

/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_4(offset) \
        GP_WB_READ_U8((offset) + 0x008)

#define GP_WB_GET_ANT_SWITCH_CONFIG_SLOTS_4_FROM_ANT_SWITCH_SLOTS(tmp) \
        (((tmp) >> 32) & 0xFF)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_4(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x008, (val)); \
        } while (0)

#define GP_WB_SET_ANT_SWITCH_CONFIG_SLOTS_4_TO_ANT_SWITCH_SLOTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFFFF00FFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 32); \
        } while (0)

/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_5(offset) \
        GP_WB_READ_U8((offset) + 0x009)

#define GP_WB_GET_ANT_SWITCH_CONFIG_SLOTS_5_FROM_ANT_SWITCH_SLOTS(tmp) \
        (((tmp) >> 40) & 0xFF)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_5(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x009, (val)); \
        } while (0)

#define GP_WB_SET_ANT_SWITCH_CONFIG_SLOTS_5_TO_ANT_SWITCH_SLOTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFFFF00FFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 40); \
        } while (0)

/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_6(offset) \
        GP_WB_READ_U8((offset) + 0x00a)

#define GP_WB_GET_ANT_SWITCH_CONFIG_SLOTS_6_FROM_ANT_SWITCH_SLOTS(tmp) \
        (((tmp) >> 48) & 0xFF)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_6(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x00a, (val)); \
        } while (0)

#define GP_WB_SET_ANT_SWITCH_CONFIG_SLOTS_6_TO_ANT_SWITCH_SLOTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0xFF00FFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 48); \
        } while (0)

/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_7(offset) \
        GP_WB_READ_U8((offset) + 0x00b)

#define GP_WB_GET_ANT_SWITCH_CONFIG_SLOTS_7_FROM_ANT_SWITCH_SLOTS(tmp) \
        (((tmp) >> 56) & 0xFF)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_7(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x00b, (val)); \
        } while (0)

#define GP_WB_SET_ANT_SWITCH_CONFIG_SLOTS_7_TO_ANT_SWITCH_SLOTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U64(tmp); \
          (tmp) &= 0x00FFFFFFFFFFFFFF; \
          (tmp) |= (((UInt64)(val)) << 56); \
        } while (0)


/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_8(offset) \
        GP_WB_READ_U8((offset) + 0x00c)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_8(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x00c, (val)); \
        } while (0)

/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_9(offset) \
        GP_WB_READ_U8((offset) + 0x00d)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_9(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x00d, (val)); \
        } while (0)

/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_10(offset) \
        GP_WB_READ_U8((offset) + 0x00e)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_10(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x00e, (val)); \
        } while (0)

/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_11(offset) \
        GP_WB_READ_U8((offset) + 0x00f)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_11(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x00f, (val)); \
        } while (0)

/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_12(offset) \
        GP_WB_READ_U8((offset) + 0x010)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_12(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x010, (val)); \
        } while (0)

/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_13(offset) \
        GP_WB_READ_U8((offset) + 0x011)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_13(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x011, (val)); \
        } while (0)

/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_14(offset) \
        GP_WB_READ_U8((offset) + 0x012)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_14(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x012, (val)); \
        } while (0)

/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_15(offset) \
        GP_WB_READ_U8((offset) + 0x013)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_15(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x013, (val)); \
        } while (0)


/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_16(offset) \
        GP_WB_READ_U8((offset) + 0x014)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_16(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x014, (val)); \
        } while (0)

/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_17(offset) \
        GP_WB_READ_U8((offset) + 0x015)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_17(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x015, (val)); \
        } while (0)

/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_18(offset) \
        GP_WB_READ_U8((offset) + 0x016)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_18(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x016, (val)); \
        } while (0)

/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_19(offset) \
        GP_WB_READ_U8((offset) + 0x017)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_19(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x017, (val)); \
        } while (0)

/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_20(offset) \
        GP_WB_READ_U8((offset) + 0x018)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_20(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x018, (val)); \
        } while (0)

/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_21(offset) \
        GP_WB_READ_U8((offset) + 0x019)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_21(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x019, (val)); \
        } while (0)

/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_22(offset) \
        GP_WB_READ_U8((offset) + 0x01a)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_22(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x01a, (val)); \
        } while (0)

/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_23(offset) \
        GP_WB_READ_U8((offset) + 0x01b)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_23(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x01b, (val)); \
        } while (0)


/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_24(offset) \
        GP_WB_READ_U8((offset) + 0x01c)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_24(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x01c, (val)); \
        } while (0)

/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_25(offset) \
        GP_WB_READ_U8((offset) + 0x01d)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_25(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x01d, (val)); \
        } while (0)

/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_26(offset) \
        GP_WB_READ_U8((offset) + 0x01e)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_26(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x01e, (val)); \
        } while (0)

/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_27(offset) \
        GP_WB_READ_U8((offset) + 0x01f)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_27(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x01f, (val)); \
        } while (0)

/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_28(offset) \
        GP_WB_READ_U8((offset) + 0x020)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_28(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x020, (val)); \
        } while (0)

/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_29(offset) \
        GP_WB_READ_U8((offset) + 0x021)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_29(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x021, (val)); \
        } while (0)

/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_30(offset) \
        GP_WB_READ_U8((offset) + 0x022)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_30(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x022, (val)); \
        } while (0)

/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_31(offset) \
        GP_WB_READ_U8((offset) + 0x023)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_31(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x023, (val)); \
        } while (0)


/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_32(offset) \
        GP_WB_READ_U8((offset) + 0x024)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_32(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x024, (val)); \
        } while (0)

/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_33(offset) \
        GP_WB_READ_U8((offset) + 0x025)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_33(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x025, (val)); \
        } while (0)

/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_34(offset) \
        GP_WB_READ_U8((offset) + 0x026)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_34(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x026, (val)); \
        } while (0)

/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_35(offset) \
        GP_WB_READ_U8((offset) + 0x027)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_35(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x027, (val)); \
        } while (0)

/* The next 2 antenna ids */
#define GP_WB_READ_ANT_SWITCH_CONFIG_SLOTS_36(offset) \
        GP_WB_READ_U8((offset) + 0x028)

#define GP_WB_WRITE_ANT_SWITCH_CONFIG_SLOTS_36(offset, val) do { \
          GP_WB_CHECK_OFFSET_ANT_SWITCH_CONFIG(offset); \
          GP_WB_WRITE_U8((offset) + 0x028, (val)); \
        } while (0)

/***************************
 * layout: timer
 ***************************/

/* proberty block access functions for pb.c_name */
#define GP_WB_READ_TIMER_CFG(offset) \
        GP_WB_READ_U8((offset) + 0x000)

#define GP_WB_WRITE_TIMER_CFG(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x000, (val))

/* Prescaler divider selector for tmr, scales down the input clock by a factor of 2**tmr_prescaler_div */
#define GP_WB_READ_TIMER_PRESCALER_DIV(offset) \
        (GP_WB_READ_U8((offset) + 0x000) & 0x0F)

#define GP_WB_GET_TIMER_PRESCALER_DIV_FROM_CFG(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_TIMER_PRESCALER_DIV(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_CHECK_OFFSET_TIMER(offset); \
          GP_WB_MWRITE_U8((offset) + 0x000, 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_TIMER_PRESCALER_DIV_TO_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x70; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* input clock selection for tmr */
#define GP_WB_READ_TIMER_CLK_SEL(offset) \
        ((GP_WB_READ_U8((offset) + 0x000) >> 4) & 0x07)

#define GP_WB_GET_TIMER_CLK_SEL_FROM_CFG(tmp) \
        (((tmp) >> 4) & 0x07)

#define GP_WB_WRITE_TIMER_CLK_SEL(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_WB_CHECK_OFFSET_TIMER(offset); \
          GP_WB_MWRITE_U8((offset) + 0x000, 0x70, (val) << 4); \
        } while (0)

#define GP_WB_SET_TIMER_CLK_SEL_TO_CFG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


/* threshold at which the tmr counter should wrap at */
#define GP_WB_READ_TIMER_THRESHOLD(offset) \
        GP_WB_READ_U16((offset) + 0x002)

#define GP_WB_WRITE_TIMER_THRESHOLD(offset, val) do { \
          GP_WB_CHECK_OFFSET_TIMER(offset); \
          GP_WB_WRITE_U16((offset) + 0x002, (val)); \
        } while (0)


/* current value of the tmr counter */
#define GP_WB_READ_TIMER_VALUE(offset) \
        GP_WB_READ_SER_U16((offset) + 0x004)


/* sets the immediate value of timer  counter to tmr_preset_value */
#define GP_WB_TIMER_PRESET(offset) \
        GP_WB_WRITE_U8((offset) + 0x006, 0x01)


/* interrupt indicating that tmr counter has wrapped (has reached the tmr_threshold) */
#define GP_WB_READ_TIMER_UNMASKED_WRAP_INTERRUPT(offset) \
        GP_WB_READ_U1((offset) + 0x007, 0)


/* clear for the tmr_wrap_interrupt */
#define GP_WB_TIMER_CLR_WRAP_INTERRUPT(offset) \
        GP_WB_WRITE_U8((offset) + 0x008, 0x01)

/***************************
 * layout: uart
 ***************************/

/* TX data FIFO LSB. In case of 8 data bits or less, transmission in triggered by writing this. */
#define GP_WB_WRITE_UART_TX_DATA_0(offset, val) do { \
          GP_WB_CHECK_OFFSET_UART(offset); \
          GP_WB_WRITE_U8((offset) + 0x000, (val)); \
        } while (0)


/* TX data FIFO MSB. In case of 9 data bits, transmission in triggered by writing this. */
#define GP_WB_WRITE_UART_TX_DATA_1(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_UART(offset); \
          GP_WB_WRITE_U8((offset) + 0x001, (val)); \
        } while (0)


/* RX data FIFO LSB. In case of 8 data bits or less, reading this will clear the data from the RX data FIFO. */
#define GP_WB_READ_UART_RX_DATA_0(offset) \
        GP_WB_READ_SER_U8((offset) + 0x002)


/* RX data FIFO MSB. In case of 9 data bits, reading this will clear the data from the RX data FIFO. */
#define GP_WB_READ_UART_RX_DATA_1(offset) \
        GP_WB_READ_SER_U1((offset) + 0x003, 0)


/* Actual baud rate = 16MHz / 8*(baud_rate+1) */
#define GP_WB_READ_UART_BAUD_RATE(offset) \
        GP_WB_READ_U16((offset) + 0x004)

#define GP_WB_WRITE_UART_BAUD_RATE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_WB_CHECK_OFFSET_UART(offset); \
          GP_WB_WRITE_U16((offset) + 0x004, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_UART_CONFIG(offset) \
        GP_WB_READ_U16((offset) + 0x006)

#define GP_WB_WRITE_UART_CONFIG(offset, val) \
      GP_WB_WRITE_U16((offset) + 0x006, (val))

/* Number of data bits in an SPI frame - 1 (0x7 = one byte) */
#define GP_WB_READ_UART_DATA_BITS(offset) \
        (GP_WB_READ_U8((offset) + 0x006) & 0x0F)

#define GP_WB_GET_UART_DATA_BITS_FROM_CONFIG(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_UART_DATA_BITS(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_WB_CHECK_OFFSET_UART(offset); \
          GP_WB_MWRITE_U8((offset) + 0x006, 0x0F, (val)); \
        } while (0)

#define GP_WB_SET_UART_DATA_BITS_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x03F0; \
          (tmp) |= ((UInt16)(val)); \
        } while (0)

/* Parity bit mode. Controls both the generation for TX and the check for RX. */
#define GP_WB_READ_UART_PARITY(offset) \
        ((GP_WB_READ_U8((offset) + 0x006) >> 4) & 0x03)

#define GP_WB_GET_UART_PARITY_FROM_CONFIG(tmp) \
        (((tmp) >> 4) & 0x03)

#define GP_WB_WRITE_UART_PARITY(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x03); \
          GP_WB_CHECK_OFFSET_UART(offset); \
          GP_WB_MWRITE_U8((offset) + 0x006, 0x30, (val) << 4); \
        } while (0)

#define GP_WB_SET_UART_PARITY_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x03); \
          (tmp) &= 0x03CF; \
          (tmp) |= (((UInt16)(val)) << 4); \
        } while (0)

/* Number of stop bits - 1 (0x0 = 1, 0x1 = 2. For RX only the first one is checked) */
#define GP_WB_READ_UART_STOP_BITS(offset) \
        GP_WB_READ_U1((offset) + 0x006, 6)

#define GP_WB_GET_UART_STOP_BITS_FROM_CONFIG(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_UART_STOP_BITS(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_UART(offset); \
          GP_WB_MWRITE_U1((offset) + 0x006, 6, (val)); \
        } while (0)

#define GP_WB_SET_UART_STOP_BITS_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03BF; \
          (tmp) |= (((UInt16)(val)) << 6); \
        } while (0)

/* In case of the HW MSI interface (stream_to_regmap = 0), interpret bit 8 as sync bit to reset internal logic. */
#define GP_WB_READ_UART_USE_SYNC_BIT(offset) \
        GP_WB_READ_U1((offset) + 0x006, 7)

#define GP_WB_GET_UART_USE_SYNC_BIT_FROM_CONFIG(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_UART_USE_SYNC_BIT(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_UART(offset); \
          GP_WB_MWRITE_U1((offset) + 0x006, 7, (val)); \
        } while (0)

#define GP_WB_SET_UART_USE_SYNC_BIT_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x037F; \
          (tmp) |= (((UInt16)(val)) << 7); \
        } while (0)

/* Enable the UART receiver.  (Note the transmitter is automatically enabled when loading data into tx_data) */
#define GP_WB_READ_UART_RX_ENABLE(offset) \
        GP_WB_READ_U1((offset) + 0x007, 0)

#define GP_WB_GET_UART_RX_ENABLE_FROM_CONFIG(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_UART_RX_ENABLE(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_UART(offset); \
          GP_WB_MWRITE_U1((offset) + 0x007, 0, (val)); \
        } while (0)

#define GP_WB_SET_UART_RX_ENABLE_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02FF; \
          (tmp) |= (((UInt16)(val)) << 8); \
        } while (0)

/* In case of the HW MSI interface (stream_to_regmap = 0), bit_reverse the data part of the reply. This feature was added for Lime. */
#define GP_WB_READ_UART_BIT_REVERSE_REPLY(offset) \
        GP_WB_READ_U1((offset) + 0x007, 1)

#define GP_WB_GET_UART_BIT_REVERSE_REPLY_FROM_CONFIG(tmp) \
        (((tmp) >> 9) & 0x01)

#define GP_WB_WRITE_UART_BIT_REVERSE_REPLY(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_UART(offset); \
          GP_WB_MWRITE_U1((offset) + 0x007, 1, (val)); \
        } while (0)

#define GP_WB_SET_UART_BIT_REVERSE_REPLY_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U16(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01FF; \
          (tmp) |= (((UInt16)(val)) << 9); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_UART_STATUS(offset) \
        GP_WB_READ_U8((offset) + 0x008)

/* Status and unmasked interrupt flag for UART TX not busy. The interrupt is cleared implicitly when writing new TX data. Active when no TX transfer ongoing and no data in TX buffer. */
#define GP_WB_READ_UART_UNMASKED_TX_NOT_BUSY_INTERRUPT(offset) \
        GP_WB_READ_U1((offset) + 0x008, 0)

#define GP_WB_GET_UART_UNMASKED_TX_NOT_BUSY_INTERRUPT_FROM_STATUS(tmp) \
        ((tmp) & 0x01)

/* Status and unmasked interrupt flag for TX buffer not full. The interrupt is cleared implicitly when writing new TX data fills the buffer. */
#define GP_WB_READ_UART_UNMASKED_TX_NOT_FULL_INTERRUPT(offset) \
        GP_WB_READ_U1((offset) + 0x008, 1)

#define GP_WB_GET_UART_UNMASKED_TX_NOT_FULL_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

/* Status and unmasked interrupt flag for RX buffer not empty. The interrupt is cleared implicitly when reading the last RX data from the buffer. */
#define GP_WB_READ_UART_UNMASKED_RX_NOT_EMPTY_INTERRUPT(offset) \
        GP_WB_READ_U1((offset) + 0x008, 2)

#define GP_WB_GET_UART_UNMASKED_RX_NOT_EMPTY_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 2) & 0x01)

/* Event and unmasked interrupt flag for the occurrence of a rx data buffer overrun event. Set when the rx data buffer is full and new rx data is available. Cleared explicitly by the SW. */
#define GP_WB_READ_UART_UNMASKED_RX_OVERRUN_INTERRUPT(offset) \
        GP_WB_READ_U1((offset) + 0x008, 3)

#define GP_WB_GET_UART_UNMASKED_RX_OVERRUN_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 3) & 0x01)

/* Event and unmasked interrupt flag for the occurrence of a rx parity error. Set when the parity checking is enabled and the received parity bit does not match with the calculated. Cleared explicitly by the SW. */
#define GP_WB_READ_UART_UNMASKED_RX_PARITY_ERROR_INTERRUPT(offset) \
        GP_WB_READ_U1((offset) + 0x008, 4)

#define GP_WB_GET_UART_UNMASKED_RX_PARITY_ERROR_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 4) & 0x01)

/* Event and unmasked interrupt flag for the occurrence of a rx framing error. Set when the (first) stop bit of a received frame was not 1. Cleared explicitly by the SW. */
#define GP_WB_READ_UART_UNMASKED_RX_FRAMING_ERROR_INTERRUPT(offset) \
        GP_WB_READ_U1((offset) + 0x008, 5)

#define GP_WB_GET_UART_UNMASKED_RX_FRAMING_ERROR_INTERRUPT_FROM_STATUS(tmp) \
        (((tmp) >> 5) & 0x01)

/* Status flag for UART RX not busy. Active when no RX transfer is ongoing. */
#define GP_WB_READ_UART_RX_NOT_BUSY(offset) \
        GP_WB_READ_U1((offset) + 0x008, 6)

#define GP_WB_GET_UART_RX_NOT_BUSY_FROM_STATUS(tmp) \
        (((tmp) >> 6) & 0x01)


#define GP_WB_WRITE_UART_CLR_INTERRUPTS(offset, val) \
      GP_WB_WRITE_U8((offset) + 0x009, (val))

/* Clear the rx_overrun_interrupt. */
#define GP_WB_UART_CLR_RX_OVERRUN_INTERRUPT(offset) \
        GP_WB_WRITE_U8((offset) + 0x009, 0x01)

#define GP_WB_SET_UART_CLR_RX_OVERRUN_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x06; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Clear the rx_parity_error_interrupt. */
#define GP_WB_UART_CLR_RX_PARITY_ERROR_INTERRUPT(offset) \
        GP_WB_WRITE_U8((offset) + 0x009, 0x02)

#define GP_WB_SET_UART_CLR_RX_PARITY_ERROR_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x05; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

/* Clear the rx_framining_error_interrupt. */
#define GP_WB_UART_CLR_RX_FRAMING_ERROR_INTERRUPT(offset) \
        GP_WB_WRITE_U8((offset) + 0x009, 0x04)

#define GP_WB_SET_UART_CLR_RX_FRAMING_ERROR_INTERRUPT_TO_CLR_INTERRUPTS(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x03; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

/***************************
 * layout: dma_sg_descriptor
 ***************************/

/* Address of first data of the block */
#define GP_WB_READ_DMA_SG_DESCRIPTOR_ADDRESS(offset) \
        GP_WB_READ_U32((offset) + 0x000)

#define GP_WB_WRITE_DMA_SG_DESCRIPTOR_ADDRESS(offset, val) do { \
          GP_WB_CHECK_OFFSET_DMA_SG_DESCRIPTOR(offset); \
          GP_WB_WRITE_U32((offset) + 0x000, (val)); \
        } while (0)


/* Flag indicating that this is the last descriptor or that the next descriptor is not ready yet. */
#define GP_WB_READ_DMA_SG_DESCRIPTOR_STOP(offset) \
        GP_WB_READ_U1((offset) + 0x004, 0)

#define GP_WB_WRITE_DMA_SG_DESCRIPTOR_STOP(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_DMA_SG_DESCRIPTOR(offset); \
          GP_WB_MWRITE_U1((offset) + 0x004, 0, (val)); \
        } while (0)

/* Address of next descriptor. Since the address must be aligned on 32-bit, the two LSB are not used. */
#define GP_WB_READ_DMA_SG_DESCRIPTOR_NEXT(offset) \
        ((GP_WB_READ_U32((offset) + 0x004) >> 2) & 0x3FFFFFFF)

#define GP_WB_WRITE_DMA_SG_DESCRIPTOR_NEXT(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x3FFFFFFF); \
          GP_WB_CHECK_OFFSET_DMA_SG_DESCRIPTOR(offset); \
          GP_WB_MWRITE_U32((offset) + 0x004, 0xFFFFFFFC, (UInt32)(val) << 2); \
        } while (0)


/* Number of bytes inside the block */
#define GP_WB_READ_DMA_SG_DESCRIPTOR_LENGTH(offset) \
        (GP_WB_READ_U32((offset) + 0x008) & 0x0FFFFFFF)

#define GP_WB_WRITE_DMA_SG_DESCRIPTOR_LENGTH(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFFFFFF); \
          GP_WB_CHECK_OFFSET_DMA_SG_DESCRIPTOR(offset); \
          GP_WB_MWRITE_U32((offset) + 0x008, 0x0FFFFFFF, (val)); \
        } while (0)

/* When high, data is accessed at Address, without increment (to access a FIFO) */
#define GP_WB_READ_DMA_SG_DESCRIPTOR_CST_ADDRESS(offset) \
        GP_WB_READ_U1((offset) + 0x00b, 4)

#define GP_WB_WRITE_DMA_SG_DESCRIPTOR_CST_ADDRESS(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_DMA_SG_DESCRIPTOR(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00b, 4, (val)); \
        } while (0)

/* When high, block length will be realigned on FIFO width. */
#define GP_WB_READ_DMA_SG_DESCRIPTOR_REALIGN(offset) \
        GP_WB_READ_U1((offset) + 0x00b, 5)

#define GP_WB_WRITE_DMA_SG_DESCRIPTOR_REALIGN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_DMA_SG_DESCRIPTOR(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00b, 5, (val)); \
        } while (0)

/* When high, data is not written to memory (FIFO2AXI only). */
#define GP_WB_READ_DMA_SG_DESCRIPTOR_DISCARD(offset) \
        GP_WB_READ_U1((offset) + 0x00b, 6)

#define GP_WB_WRITE_DMA_SG_DESCRIPTOR_DISCARD(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_DMA_SG_DESCRIPTOR(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00b, 6, (val)); \
        } while (0)

/* Interrupt enable: when high, an interrupt is generated at the end of the block. */
#define GP_WB_READ_DMA_SG_DESCRIPTOR_INT_EN(offset) \
        GP_WB_READ_U1((offset) + 0x00b, 7)

#define GP_WB_WRITE_DMA_SG_DESCRIPTOR_INT_EN(offset, val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_WB_CHECK_OFFSET_DMA_SG_DESCRIPTOR(offset); \
          GP_WB_MWRITE_U1((offset) + 0x00b, 7, (val)); \
        } while (0)


/* User tag (only for AXI2FIFO) */
#define GP_WB_READ_DMA_SG_DESCRIPTOR_TAG(offset) \
        GP_WB_READ_U32((offset) + 0x00c)

#define GP_WB_WRITE_DMA_SG_DESCRIPTOR_TAG(offset, val) do { \
          GP_WB_CHECK_OFFSET_DMA_SG_DESCRIPTOR(offset); \
          GP_WB_WRITE_U32((offset) + 0x00c, (val)); \
        } while (0)

/***************************
 * layout: sec_proc
 ***************************/

#define GP_WB_READ_SEC_PROC_FETCH_ADDR() \
        GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140000))

#define GP_WB_WRITE_SEC_PROC_FETCH_ADDR(val) do { \
          GP_AHB_WRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140000), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SEC_PROC_FETCH_LEN() \
        GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140008))

#define GP_WB_WRITE_SEC_PROC_FETCH_LEN(val) \
      GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140008), (val))

#define GP_WB_READ_SEC_PROC_FETCH_DATA_BLOCK_LENGTH() \
        (GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140008)) & 0x0FFFFFFF)

#define GP_WB_GET_SEC_PROC_FETCH_DATA_BLOCK_LENGTH_FROM_FETCH_LEN(tmp) \
        ((tmp) & 0x0FFFFFFF)

#define GP_WB_WRITE_SEC_PROC_FETCH_DATA_BLOCK_LENGTH(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFFFFFF); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140008), 0x0FFFFFFF, (val)); \
        } while (0)

#define GP_WB_SET_SEC_PROC_FETCH_DATA_BLOCK_LENGTH_TO_FETCH_LEN(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0FFFFFFF); \
          (tmp) &= 0x30000000; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

#define GP_WB_READ_SEC_PROC_FETCH_CONSTANT_ADDRESS() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140008)) >> 28) & 0x01)

#define GP_WB_GET_SEC_PROC_FETCH_CONSTANT_ADDRESS_FROM_FETCH_LEN(tmp) \
        (((tmp) >> 28) & 0x01)

#define GP_WB_WRITE_SEC_PROC_FETCH_CONSTANT_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140008), 0x10000000, (UInt32)(val) << 28); \
        } while (0)

#define GP_WB_SET_SEC_PROC_FETCH_CONSTANT_ADDRESS_TO_FETCH_LEN(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2FFFFFFF; \
          (tmp) |= (((UInt32)(val)) << 28); \
        } while (0)

#define GP_WB_READ_SEC_PROC_FETCH_REALIGN_LENGTH() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140008)) >> 29) & 0x01)

#define GP_WB_GET_SEC_PROC_FETCH_REALIGN_LENGTH_FROM_FETCH_LEN(tmp) \
        (((tmp) >> 29) & 0x01)

#define GP_WB_WRITE_SEC_PROC_FETCH_REALIGN_LENGTH(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140008), 0x20000000, (UInt32)(val) << 29); \
        } while (0)

#define GP_WB_SET_SEC_PROC_FETCH_REALIGN_LENGTH_TO_FETCH_LEN(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1FFFFFFF; \
          (tmp) |= (((UInt32)(val)) << 29); \
        } while (0)


#define GP_WB_READ_SEC_PROC_FETCH_TAG() \
        GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14000c))

#define GP_WB_WRITE_SEC_PROC_FETCH_TAG(val) do { \
          GP_AHB_WRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14000c), (val)); \
        } while (0)


#define GP_WB_READ_SEC_PROC_PUSH_ADDR() \
        GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140010))

#define GP_WB_WRITE_SEC_PROC_PUSH_ADDR(val) do { \
          GP_AHB_WRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140010), (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SEC_PROC_PUSH_LEN() \
        GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140018))

#define GP_WB_WRITE_SEC_PROC_PUSH_LEN(val) \
      GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140018), (val))

#define GP_WB_READ_SEC_PROC_PUSH_DATA_BLOCK_LENGTH() \
        (GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140018)) & 0x0FFFFFFF)

#define GP_WB_GET_SEC_PROC_PUSH_DATA_BLOCK_LENGTH_FROM_PUSH_LEN(tmp) \
        ((tmp) & 0x0FFFFFFF)

#define GP_WB_WRITE_SEC_PROC_PUSH_DATA_BLOCK_LENGTH(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFFFFFF); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140018), 0x0FFFFFFF, (val)); \
        } while (0)

#define GP_WB_SET_SEC_PROC_PUSH_DATA_BLOCK_LENGTH_TO_PUSH_LEN(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0FFFFFFF); \
          (tmp) &= 0x70000000; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

#define GP_WB_READ_SEC_PROC_PUSH_CONSTANT_ADDRESS() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140018)) >> 28) & 0x01)

#define GP_WB_GET_SEC_PROC_PUSH_CONSTANT_ADDRESS_FROM_PUSH_LEN(tmp) \
        (((tmp) >> 28) & 0x01)

#define GP_WB_WRITE_SEC_PROC_PUSH_CONSTANT_ADDRESS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140018), 0x10000000, (UInt32)(val) << 28); \
        } while (0)

#define GP_WB_SET_SEC_PROC_PUSH_CONSTANT_ADDRESS_TO_PUSH_LEN(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x6FFFFFFF; \
          (tmp) |= (((UInt32)(val)) << 28); \
        } while (0)

#define GP_WB_READ_SEC_PROC_PUSH_REALIGN_LENGTH() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140018)) >> 29) & 0x01)

#define GP_WB_GET_SEC_PROC_PUSH_REALIGN_LENGTH_FROM_PUSH_LEN(tmp) \
        (((tmp) >> 29) & 0x01)

#define GP_WB_WRITE_SEC_PROC_PUSH_REALIGN_LENGTH(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140018), 0x20000000, (UInt32)(val) << 29); \
        } while (0)

#define GP_WB_SET_SEC_PROC_PUSH_REALIGN_LENGTH_TO_PUSH_LEN(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x5FFFFFFF; \
          (tmp) |= (((UInt32)(val)) << 29); \
        } while (0)

#define GP_WB_READ_SEC_PROC_PUSH_DISCARD_DATA() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140018)) >> 30) & 0x01)

#define GP_WB_GET_SEC_PROC_PUSH_DISCARD_DATA_FROM_PUSH_LEN(tmp) \
        (((tmp) >> 30) & 0x01)

#define GP_WB_WRITE_SEC_PROC_PUSH_DISCARD_DATA(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140018), 0x40000000, (UInt32)(val) << 30); \
        } while (0)

#define GP_WB_SET_SEC_PROC_PUSH_DISCARD_DATA_TO_PUSH_LEN(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3FFFFFFF; \
          (tmp) |= (((UInt32)(val)) << 30); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SEC_PROC_INT_EN() \
        GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14001c))

#define GP_WB_WRITE_SEC_PROC_INT_EN(val) \
      GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14001c), (val))

#define GP_WB_READ_SEC_PROC_FETCHER_END_OF_BLOCK_INT_EN() \
        (GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14001c)) & 0x01)

#define GP_WB_GET_SEC_PROC_FETCHER_END_OF_BLOCK_INT_EN_FROM_INT_EN(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_SEC_PROC_FETCHER_END_OF_BLOCK_INT_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14001c), 0x00000001, (val)); \
        } while (0)

#define GP_WB_SET_SEC_PROC_FETCHER_END_OF_BLOCK_INT_EN_TO_INT_EN(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_SEC_PROC_FETCHER_STOPPED_INT_EN() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14001c)) >> 1) & 0x01)

#define GP_WB_GET_SEC_PROC_FETCHER_STOPPED_INT_EN_FROM_INT_EN(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_SEC_PROC_FETCHER_STOPPED_INT_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14001c), 0x00000002, (UInt32)(val) << 1); \
        } while (0)

#define GP_WB_SET_SEC_PROC_FETCHER_STOPPED_INT_EN_TO_INT_EN(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_SEC_PROC_FETCHER_ERROR_INT_EN() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14001c)) >> 2) & 0x01)

#define GP_WB_GET_SEC_PROC_FETCHER_ERROR_INT_EN_FROM_INT_EN(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_SEC_PROC_FETCHER_ERROR_INT_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14001c), 0x00000004, (UInt32)(val) << 2); \
        } while (0)

#define GP_WB_SET_SEC_PROC_FETCHER_ERROR_INT_EN_TO_INT_EN(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_SEC_PROC_PUSHER_END_OF_BLOCK_INT_EN() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14001c)) >> 3) & 0x01)

#define GP_WB_GET_SEC_PROC_PUSHER_END_OF_BLOCK_INT_EN_FROM_INT_EN(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_SEC_PROC_PUSHER_END_OF_BLOCK_INT_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14001c), 0x00000008, (UInt32)(val) << 3); \
        } while (0)

#define GP_WB_SET_SEC_PROC_PUSHER_END_OF_BLOCK_INT_EN_TO_INT_EN(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_SEC_PROC_PUSHER_STOPPED_INT_EN() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14001c)) >> 4) & 0x01)

#define GP_WB_GET_SEC_PROC_PUSHER_STOPPED_INT_EN_FROM_INT_EN(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_SEC_PROC_PUSHER_STOPPED_INT_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14001c), 0x00000010, (UInt32)(val) << 4); \
        } while (0)

#define GP_WB_SET_SEC_PROC_PUSHER_STOPPED_INT_EN_TO_INT_EN(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_READ_SEC_PROC_PUSHER_ERROR_INT_EN() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14001c)) >> 5) & 0x01)

#define GP_WB_GET_SEC_PROC_PUSHER_ERROR_INT_EN_FROM_INT_EN(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_SEC_PROC_PUSHER_ERROR_INT_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14001c), 0x00000020, (UInt32)(val) << 5); \
        } while (0)

#define GP_WB_SET_SEC_PROC_PUSHER_ERROR_INT_EN_TO_INT_EN(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


#define GP_WB_WRITE_SEC_PROC_INT_ENSET(val) \
      GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140020), (val))

#define GP_WB_SEC_PROC_FETCHER_END_OF_BLOCK_INT_ENSET() \
        GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140020), 0x00000001)

#define GP_WB_SET_SEC_PROC_FETCHER_END_OF_BLOCK_INT_ENSET_TO_INT_ENSET(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_SEC_PROC_FETCHER_STOPPED_INT_ENSET() \
        GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140020), 0x00000002)

#define GP_WB_SET_SEC_PROC_FETCHER_STOPPED_INT_ENSET_TO_INT_ENSET(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_SEC_PROC_FETCHER_ERROR_INT_ENSET() \
        GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140020), 0x00000004)

#define GP_WB_SET_SEC_PROC_FETCHER_ERROR_INT_ENSET_TO_INT_ENSET(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_SEC_PROC_PUSHER_END_OF_BLOCK_INT_ENSET() \
        GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140020), 0x00000008)

#define GP_WB_SET_SEC_PROC_PUSHER_END_OF_BLOCK_INT_ENSET_TO_INT_ENSET(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_SEC_PROC_PUSHER_STOPPED_INT_ENSET() \
        GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140020), 0x00000010)

#define GP_WB_SET_SEC_PROC_PUSHER_STOPPED_INT_ENSET_TO_INT_ENSET(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_SEC_PROC_PUSHER_ERROR_INT_ENSET() \
        GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140020), 0x00000020)

#define GP_WB_SET_SEC_PROC_PUSHER_ERROR_INT_ENSET_TO_INT_ENSET(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


#define GP_WB_WRITE_SEC_PROC_INT_ENCLR(val) \
      GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140024), (val))

#define GP_WB_SEC_PROC_FETCHER_END_OF_BLOCK_INT_ENCLR() \
        GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140024), 0x00000001)

#define GP_WB_SET_SEC_PROC_FETCHER_END_OF_BLOCK_INT_ENCLR_TO_INT_ENCLR(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_SEC_PROC_FETCHER_STOPPED_INT_ENCLR() \
        GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140024), 0x00000002)

#define GP_WB_SET_SEC_PROC_FETCHER_STOPPED_INT_ENCLR_TO_INT_ENCLR(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_SEC_PROC_FETCHER_ERROR_INT_ENCLR() \
        GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140024), 0x00000004)

#define GP_WB_SET_SEC_PROC_FETCHER_ERROR_INT_ENCLR_TO_INT_ENCLR(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_SEC_PROC_PUSHER_END_OF_BLOCK_INT_ENCLR() \
        GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140024), 0x00000008)

#define GP_WB_SET_SEC_PROC_PUSHER_END_OF_BLOCK_INT_ENCLR_TO_INT_ENCLR(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_SEC_PROC_PUSHER_STOPPED_INT_ENCLR() \
        GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140024), 0x00000010)

#define GP_WB_SET_SEC_PROC_PUSHER_STOPPED_INT_ENCLR_TO_INT_ENCLR(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_SEC_PROC_PUSHER_ERROR_INT_ENCLR() \
        GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140024), 0x00000020)

#define GP_WB_SET_SEC_PROC_PUSHER_ERROR_INT_ENCLR_TO_INT_ENCLR(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SEC_PROC_INT_STATRAW() \
        GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140028))

#define GP_WB_READ_SEC_PROC_FETCHER_END_OF_BLOCK_INT_STATRAW() \
        (GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140028)) & 0x01)

#define GP_WB_GET_SEC_PROC_FETCHER_END_OF_BLOCK_INT_STATRAW_FROM_INT_STATRAW(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_SEC_PROC_FETCHER_STOPPED_INT_STATRAW() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140028)) >> 1) & 0x01)

#define GP_WB_GET_SEC_PROC_FETCHER_STOPPED_INT_STATRAW_FROM_INT_STATRAW(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_SEC_PROC_FETCHER_ERROR_INT_STATRAW() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140028)) >> 2) & 0x01)

#define GP_WB_GET_SEC_PROC_FETCHER_ERROR_INT_STATRAW_FROM_INT_STATRAW(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_SEC_PROC_PUSHER_END_OF_BLOCK_INT_STATRAW() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140028)) >> 3) & 0x01)

#define GP_WB_GET_SEC_PROC_PUSHER_END_OF_BLOCK_INT_STATRAW_FROM_INT_STATRAW(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_READ_SEC_PROC_PUSHER_STOPPED_INT_STATRAW() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140028)) >> 4) & 0x01)

#define GP_WB_GET_SEC_PROC_PUSHER_STOPPED_INT_STATRAW_FROM_INT_STATRAW(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_READ_SEC_PROC_PUSHER_ERROR_INT_STATRAW() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140028)) >> 5) & 0x01)

#define GP_WB_GET_SEC_PROC_PUSHER_ERROR_INT_STATRAW_FROM_INT_STATRAW(tmp) \
        (((tmp) >> 5) & 0x01)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SEC_PROC_INT_STAT() \
        GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14002c))

#define GP_WB_READ_SEC_PROC_FETCHER_END_OF_BLOCK_INT_STAT() \
        (GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14002c)) & 0x01)

#define GP_WB_GET_SEC_PROC_FETCHER_END_OF_BLOCK_INT_STAT_FROM_INT_STAT(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_SEC_PROC_FETCHER_STOPPED_INT_STAT() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14002c)) >> 1) & 0x01)

#define GP_WB_GET_SEC_PROC_FETCHER_STOPPED_INT_STAT_FROM_INT_STAT(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_SEC_PROC_FETCHER_ERROR_INT_STAT() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14002c)) >> 2) & 0x01)

#define GP_WB_GET_SEC_PROC_FETCHER_ERROR_INT_STAT_FROM_INT_STAT(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_READ_SEC_PROC_PUSHER_END_OF_BLOCK_INT_STAT() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14002c)) >> 3) & 0x01)

#define GP_WB_GET_SEC_PROC_PUSHER_END_OF_BLOCK_INT_STAT_FROM_INT_STAT(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_READ_SEC_PROC_PUSHER_STOPPED_INT_STAT() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14002c)) >> 4) & 0x01)

#define GP_WB_GET_SEC_PROC_PUSHER_STOPPED_INT_STAT_FROM_INT_STAT(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_READ_SEC_PROC_PUSHER_ERROR_INT_STAT() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14002c)) >> 5) & 0x01)

#define GP_WB_GET_SEC_PROC_PUSHER_ERROR_INT_STAT_FROM_INT_STAT(tmp) \
        (((tmp) >> 5) & 0x01)


#define GP_WB_WRITE_SEC_PROC_INT_STATCLR(val) \
      GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140030), (val))

#define GP_WB_SEC_PROC_FETCHER_END_OF_BLOCK_INT_STATCLR() \
        GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140030), 0x00000001)

#define GP_WB_SET_SEC_PROC_FETCHER_END_OF_BLOCK_INT_STATCLR_TO_INT_STATCLR(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_SEC_PROC_FETCHER_STOPPED_INT_STATCLR() \
        GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140030), 0x00000002)

#define GP_WB_SET_SEC_PROC_FETCHER_STOPPED_INT_STATCLR_TO_INT_STATCLR(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_SEC_PROC_FETCHER_ERROR_INT_STATCLR() \
        GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140030), 0x00000004)

#define GP_WB_SET_SEC_PROC_FETCHER_ERROR_INT_STATCLR_TO_INT_STATCLR(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x3B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_SEC_PROC_PUSHER_END_OF_BLOCK_INT_STATCLR() \
        GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140030), 0x00000008)

#define GP_WB_SET_SEC_PROC_PUSHER_END_OF_BLOCK_INT_STATCLR_TO_INT_STATCLR(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x37; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_SEC_PROC_PUSHER_STOPPED_INT_STATCLR() \
        GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140030), 0x00000010)

#define GP_WB_SET_SEC_PROC_PUSHER_STOPPED_INT_STATCLR_TO_INT_STATCLR(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x2F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)

#define GP_WB_SEC_PROC_PUSHER_ERROR_INT_STATCLR() \
        GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140030), 0x00000020)

#define GP_WB_SET_SEC_PROC_PUSHER_ERROR_INT_STATCLR_TO_INT_STATCLR(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1F; \
          (tmp) |= (((UInt8)(val)) << 5); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SEC_PROC_CONFIG() \
        GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140034))

#define GP_WB_WRITE_SEC_PROC_CONFIG(val) \
      GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140034), (val))

#define GP_WB_READ_SEC_PROC_FETCHER_SCATHER_GATHER() \
        (GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140034)) & 0x01)

#define GP_WB_GET_SEC_PROC_FETCHER_SCATHER_GATHER_FROM_CONFIG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_SEC_PROC_FETCHER_SCATHER_GATHER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140034), 0x00000001, (val)); \
        } while (0)

#define GP_WB_SET_SEC_PROC_FETCHER_SCATHER_GATHER_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1E; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_READ_SEC_PROC_PUSHER_SCATHER_GATHER() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140034)) >> 1) & 0x01)

#define GP_WB_GET_SEC_PROC_PUSHER_SCATHER_GATHER_FROM_CONFIG(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_SEC_PROC_PUSHER_SCATHER_GATHER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140034), 0x00000002, (UInt32)(val) << 1); \
        } while (0)

#define GP_WB_SET_SEC_PROC_PUSHER_SCATHER_GATHER_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1D; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)

#define GP_WB_READ_SEC_PROC_STOP_FETCHER() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140034)) >> 2) & 0x01)

#define GP_WB_GET_SEC_PROC_STOP_FETCHER_FROM_CONFIG(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_SEC_PROC_STOP_FETCHER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140034), 0x00000004, (UInt32)(val) << 2); \
        } while (0)

#define GP_WB_SET_SEC_PROC_STOP_FETCHER_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x1B; \
          (tmp) |= (((UInt8)(val)) << 2); \
        } while (0)

#define GP_WB_READ_SEC_PROC_STOP_PUSHER() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140034)) >> 3) & 0x01)

#define GP_WB_GET_SEC_PROC_STOP_PUSHER_FROM_CONFIG(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_SEC_PROC_STOP_PUSHER(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140034), 0x00000008, (UInt32)(val) << 3); \
        } while (0)

#define GP_WB_SET_SEC_PROC_STOP_PUSHER_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x17; \
          (tmp) |= (((UInt8)(val)) << 3); \
        } while (0)

#define GP_WB_READ_SEC_PROC_SOFTWARE_RESET() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140034)) >> 4) & 0x01)

#define GP_WB_GET_SEC_PROC_SOFTWARE_RESET_FROM_CONFIG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_SEC_PROC_SOFTWARE_RESET(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140034), 0x00000010, (UInt32)(val) << 4); \
        } while (0)

#define GP_WB_SET_SEC_PROC_SOFTWARE_RESET_TO_CONFIG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0F; \
          (tmp) |= (((UInt8)(val)) << 4); \
        } while (0)


#define GP_WB_WRITE_SEC_PROC_START(val) \
      GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140038), (val))

#define GP_WB_SEC_PROC_START_FETCH() \
        GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140038), 0x00000001)

#define GP_WB_SET_SEC_PROC_START_FETCH_TO_START(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

#define GP_WB_SEC_PROC_START_PUSH() \
        GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x140038), 0x00000002)

#define GP_WB_SET_SEC_PROC_START_PUSH_TO_START(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SEC_PROC_STATUS() \
        GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14003c))

#define GP_WB_READ_SEC_PROC_FETCHER_BUSY() \
        (GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14003c)) & 0x01)

#define GP_WB_GET_SEC_PROC_FETCHER_BUSY_FROM_STATUS(tmp) \
        ((tmp) & 0x01)

#define GP_WB_READ_SEC_PROC_PUSHER_BUSY() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14003c)) >> 1) & 0x01)

#define GP_WB_GET_SEC_PROC_PUSHER_BUSY_FROM_STATUS(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_READ_SEC_PROC_NOT_EMPTY() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14003c)) >> 4) & 0x01)

#define GP_WB_GET_SEC_PROC_NOT_EMPTY_FROM_STATUS(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_READ_SEC_PROC_PUSHER_WAITING_FIFO() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14003c)) >> 5) & 0x01)

#define GP_WB_GET_SEC_PROC_PUSHER_WAITING_FIFO_FROM_STATUS(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_READ_SEC_PROC_SOFT_RST_BUSY() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14003c)) >> 6) & 0x01)

#define GP_WB_GET_SEC_PROC_SOFT_RST_BUSY_FROM_STATUS(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_READ_SEC_PROC_RESERVED() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14003c)) >> 8) & 0x01)

#define GP_WB_GET_SEC_PROC_RESERVED_FROM_STATUS(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_READ_SEC_PROC_NR_OF_DATA() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14003c)) >> 16) & 0xFFFF)

#define GP_WB_GET_SEC_PROC_NR_OF_DATA_FROM_STATUS(tmp) \
        (((tmp) >> 16) & 0xFFFF)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SEC_PROC_RNG_CONTROL_REG() \
        GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141000))

#define GP_WB_WRITE_SEC_PROC_RNG_CONTROL_REG(val) \
      GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141000), (val))

/* Enable the NDRNG. */
#define GP_WB_READ_SEC_PROC_ENABLE() \
        (GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141000)) & 0x01)

#define GP_WB_GET_SEC_PROC_ENABLE_FROM_RNG_CONTROL_REG(tmp) \
        ((tmp) & 0x01)

#define GP_WB_WRITE_SEC_PROC_ENABLE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141000), 0x00000001, (val)); \
        } while (0)

#define GP_WB_SET_SEC_PROC_ENABLE_TO_RNG_CONTROL_REG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0759FE; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* Select between the NDRNG with asynchronous free running oscillators (when '0') and the Pseudo-Random generator with synchronous oscillators for simulation purpose (when '1') */
#define GP_WB_READ_SEC_PROC_LFSR_EN() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141000)) >> 1) & 0x01)

#define GP_WB_GET_SEC_PROC_LFSR_EN_FROM_RNG_CONTROL_REG(tmp) \
        (((tmp) >> 1) & 0x01)

#define GP_WB_WRITE_SEC_PROC_LFSR_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141000), 0x00000002, (UInt32)(val) << 1); \
        } while (0)

#define GP_WB_SET_SEC_PROC_LFSR_EN_TO_RNG_CONTROL_REG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0759FD; \
          (tmp) |= (((UInt32)(val)) << 1); \
        } while (0)

/* Select input for conditioning function and continuous tests: 0: Noise source (normal mode); 1: Test data register (test mode) */
#define GP_WB_READ_SEC_PROC_TEST_EN() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141000)) >> 2) & 0x01)

#define GP_WB_GET_SEC_PROC_TEST_EN_FROM_RNG_CONTROL_REG(tmp) \
        (((tmp) >> 2) & 0x01)

#define GP_WB_WRITE_SEC_PROC_TEST_EN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141000), 0x00000004, (UInt32)(val) << 2); \
        } while (0)

#define GP_WB_SET_SEC_PROC_TEST_EN_TO_RNG_CONTROL_REG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0759FB; \
          (tmp) |= (((UInt32)(val)) << 2); \
        } while (0)

/* 0: the conditioning function is used (normal mode). 1: the conditioning function is bypassed (to observe entropy source directly) */
#define GP_WB_READ_SEC_PROC_COND_BYPASS() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141000)) >> 3) & 0x01)

#define GP_WB_GET_SEC_PROC_COND_BYPASS_FROM_RNG_CONTROL_REG(tmp) \
        (((tmp) >> 3) & 0x01)

#define GP_WB_WRITE_SEC_PROC_COND_BYPASS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141000), 0x00000008, (UInt32)(val) << 3); \
        } while (0)

#define GP_WB_SET_SEC_PROC_COND_BYPASS_TO_RNG_CONTROL_REG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0759F7; \
          (tmp) |= (((UInt32)(val)) << 3); \
        } while (0)

/* Interrupt enable for Repetition Count Test failure */
#define GP_WB_READ_SEC_PROC_INT_EN_REP() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141000)) >> 4) & 0x01)

#define GP_WB_GET_SEC_PROC_INT_EN_REP_FROM_RNG_CONTROL_REG(tmp) \
        (((tmp) >> 4) & 0x01)

#define GP_WB_WRITE_SEC_PROC_INT_EN_REP(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141000), 0x00000010, (UInt32)(val) << 4); \
        } while (0)

#define GP_WB_SET_SEC_PROC_INT_EN_REP_TO_RNG_CONTROL_REG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0759EF; \
          (tmp) |= (((UInt32)(val)) << 4); \
        } while (0)

/* Interrupt enable for Adaptive Proportion Test failure (64-sample window) */
#define GP_WB_READ_SEC_PROC_INT_EN_PROP1() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141000)) >> 5) & 0x01)

#define GP_WB_GET_SEC_PROC_INT_EN_PROP1_FROM_RNG_CONTROL_REG(tmp) \
        (((tmp) >> 5) & 0x01)

#define GP_WB_WRITE_SEC_PROC_INT_EN_PROP1(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141000), 0x00000020, (UInt32)(val) << 5); \
        } while (0)

#define GP_WB_SET_SEC_PROC_INT_EN_PROP1_TO_RNG_CONTROL_REG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0759DF; \
          (tmp) |= (((UInt32)(val)) << 5); \
        } while (0)

/* Interrupt enable for Adaptive Proportion Test failure (4096-sample window) */
#define GP_WB_READ_SEC_PROC_INT_EN_PROP2() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141000)) >> 6) & 0x01)

#define GP_WB_GET_SEC_PROC_INT_EN_PROP2_FROM_RNG_CONTROL_REG(tmp) \
        (((tmp) >> 6) & 0x01)

#define GP_WB_WRITE_SEC_PROC_INT_EN_PROP2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141000), 0x00000040, (UInt32)(val) << 6); \
        } while (0)

#define GP_WB_SET_SEC_PROC_INT_EN_PROP2_TO_RNG_CONTROL_REG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0759BF; \
          (tmp) |= (((UInt32)(val)) << 6); \
        } while (0)

/* Interrupt enable for FIFO full */
#define GP_WB_READ_SEC_PROC_INT_EN_FULL() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141000)) >> 7) & 0x01)

#define GP_WB_GET_SEC_PROC_INT_EN_FULL_FROM_RNG_CONTROL_REG(tmp) \
        (((tmp) >> 7) & 0x01)

#define GP_WB_WRITE_SEC_PROC_INT_EN_FULL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141000), 0x00000080, (UInt32)(val) << 7); \
        } while (0)

#define GP_WB_SET_SEC_PROC_INT_EN_FULL_TO_RNG_CONTROL_REG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x07597F; \
          (tmp) |= (((UInt32)(val)) << 7); \
        } while (0)

/* Software reset. 0: Normal mode. 1: The continuous test, the conditioning function and the FIFO are reset. This bit is not cleared automatically. */
#define GP_WB_READ_SEC_PROC_SOFT_RESET() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141000)) >> 8) & 0x01)

#define GP_WB_GET_SEC_PROC_SOFT_RESET_FROM_RNG_CONTROL_REG(tmp) \
        (((tmp) >> 8) & 0x01)

#define GP_WB_WRITE_SEC_PROC_SOFT_RESET(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141000), 0x00000100, (UInt32)(val) << 8); \
        } while (0)

#define GP_WB_SET_SEC_PROC_SOFT_RESET_TO_RNG_CONTROL_REG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0758FF; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* Force oscillators to run when FIFO is full */
#define GP_WB_READ_SEC_PROC_FORCE_RUN() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141000)) >> 11) & 0x01)

#define GP_WB_GET_SEC_PROC_FORCE_RUN_FROM_RNG_CONTROL_REG(tmp) \
        (((tmp) >> 11) & 0x01)

#define GP_WB_WRITE_SEC_PROC_FORCE_RUN(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141000), 0x00000800, (UInt32)(val) << 11); \
        } while (0)

#define GP_WB_SET_SEC_PROC_FORCE_RUN_TO_RNG_CONTROL_REG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0751FF; \
          (tmp) |= (((UInt32)(val)) << 11); \
        } while (0)

/* Bypass NIST tests such that the results of the start-up and online test do not affect the FSM state */
#define GP_WB_READ_SEC_PROC_HEALTH_TEST_BYPASS() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141000)) >> 12) & 0x01)

#define GP_WB_GET_SEC_PROC_HEALTH_TEST_BYPASS_FROM_RNG_CONTROL_REG(tmp) \
        (((tmp) >> 12) & 0x01)

#define GP_WB_WRITE_SEC_PROC_HEALTH_TEST_BYPASS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141000), 0x00001000, (UInt32)(val) << 12); \
        } while (0)

#define GP_WB_SET_SEC_PROC_HEALTH_TEST_BYPASS_TO_RNG_CONTROL_REG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0749FF; \
          (tmp) |= (((UInt32)(val)) << 12); \
        } while (0)

/* Select input to health test module. 0: Before conditioning. 1: After conditioning */
#define GP_WB_READ_SEC_PROC_HEALTH_TEST_SEL() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141000)) >> 14) & 0x01)

#define GP_WB_GET_SEC_PROC_HEALTH_TEST_SEL_FROM_RNG_CONTROL_REG(tmp) \
        (((tmp) >> 14) & 0x01)

#define GP_WB_WRITE_SEC_PROC_HEALTH_TEST_SEL(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141000), 0x00004000, (UInt32)(val) << 14); \
        } while (0)

#define GP_WB_SET_SEC_PROC_HEALTH_TEST_SEL_TO_RNG_CONTROL_REG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x0719FF; \
          (tmp) |= (((UInt32)(val)) << 14); \
        } while (0)

/* Number of 128 bit blocks used in AES-CBCMAC post-processing. This value cannot be zero. */
#define GP_WB_READ_SEC_PROC_NB_128_BIT_BLOCKS() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141000)) >> 16) & 0x07)

#define GP_WB_GET_SEC_PROC_NB_128_BIT_BLOCKS_FROM_RNG_CONTROL_REG(tmp) \
        (((tmp) >> 16) & 0x07)

#define GP_WB_WRITE_SEC_PROC_NB_128_BIT_BLOCKS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141000), 0x00070000, (UInt32)(val) << 16); \
        } while (0)

#define GP_WB_SET_SEC_PROC_NB_128_BIT_BLOCKS_TO_RNG_CONTROL_REG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0x0059FF; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)


/* Number of 32 bits words of random available in the FIFO. Writing to this register clears the FIFO full interrupt. */
#define GP_WB_READ_SEC_PROC_FIFO_LEVEL() \
        GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141004))

#define GP_WB_WRITE_SEC_PROC_FIFO_LEVEL(val) do { \
          GP_AHB_WRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141004), (val)); \
        } while (0)


/* FIFO level at which the rings are restarted when in the FIFOFull_Off state, expressed in number of 128bit blocks. */
#define GP_WB_READ_SEC_PROC_FIFO_THRESH() \
        (GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141008)) & 0x01)

#define GP_WB_WRITE_SEC_PROC_FIFO_THRESH(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141008), 0x00000001, (val)); \
        } while (0)


/* Maximum number of 32 bits words that can be stored in the FIFO: 2^g_fifodepth. */
#define GP_WB_READ_SEC_PROC_FIFO_DEPTH() \
        GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14100c))


/* The set of registers bits constituted by key_0, key_1, key_2 and key_3 form the 128-bit AES key used for conditioning function. The first byte (MSB of 128-bit word) is at address 0x1010, the second byte at address 0x1011... */
#define GP_WB_READ_SEC_PROC_KEY_0() \
        GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141010))

#define GP_WB_WRITE_SEC_PROC_KEY_0(val) do { \
          GP_AHB_WRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141010), (val)); \
        } while (0)


/* The set of registers bits constituted by key_0, key_1, key_2 and key_3 form the 128-bit AES key used for conditioning function. The first byte (MSB of 128-bit word) is at address 0x1010, the second byte at address 0x1011... */
#define GP_WB_READ_SEC_PROC_KEY_1() \
        GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141014))

#define GP_WB_WRITE_SEC_PROC_KEY_1(val) do { \
          GP_AHB_WRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141014), (val)); \
        } while (0)


/* The set of registers bits constituted by key_0, key_1, key_2 and key_3 form the 128-bit AES key used for conditioning function. The first byte (MSB of 128-bit word) is at address 0x1010, the second byte at address 0x1011... */
#define GP_WB_READ_SEC_PROC_KEY_2() \
        GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141018))

#define GP_WB_WRITE_SEC_PROC_KEY_2(val) do { \
          GP_AHB_WRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141018), (val)); \
        } while (0)


/* The set of registers bits constituted by key_0, key_1, key_2 and key_3 form the 128-bit AES key used for conditioning function. The first byte (MSB of 128-bit word) is at address 0x1010, the second byte at address 0x1011... */
#define GP_WB_READ_SEC_PROC_KEY_3() \
        GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14101c))

#define GP_WB_WRITE_SEC_PROC_KEY_3(val) do { \
          GP_AHB_WRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14101c), (val)); \
        } while (0)


/* This register is used to feed known data to the conditioning function or to the continuous tests. When one data is written into this register, the 32-bit are sent to those modules. Since some time is needed for processing, there is one busy flag (test_data_busy in rng_status register) going high as soon as one data is written, and going low when the next data can be written. Write access to this register is ignored when test_en bit in rng_control register is low. Test data written through this interface are expected to be a multiple of 128 bits. */
#define GP_WB_WRITE_SEC_PROC_TEST_DATA(val) do { \
          GP_AHB_WRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141020), (val)); \
        } while (0)


/* Repetition Test Count Cut-Off value */
#define GP_WB_READ_SEC_PROC_REP_THRESHOLD() \
        (GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141024)) & 0x3F)

#define GP_WB_WRITE_SEC_PROC_REP_THRESHOLD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141024), 0x0000003F, (val)); \
        } while (0)


/* Adaptive Proportion Test (64-sample window) Cut-Off value */
#define GP_WB_READ_SEC_PROC_PROP1_THRESHOLD() \
        (GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141028)) & 0x3F)

#define GP_WB_WRITE_SEC_PROC_PROP1_THRESHOLD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x3F); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141028), 0x0000003F, (val)); \
        } while (0)


/* Adaptive Proportion Test (4096-sample window) Cut-Off value */
#define GP_WB_READ_SEC_PROC_PROP2_THRESHOLD() \
        (GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14102c)) & 0x0FFF)

#define GP_WB_WRITE_SEC_PROC_PROP2_THRESHOLD(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0FFF); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14102c), 0x00000FFF, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SEC_PROC_RNG_STATUS_REG() \
        GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141030))

/* High when data written to test_data_reg register is being processed */
#define GP_WB_READ_SEC_PROC_TEST_DATA_BUSY() \
        (GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141030)) & 0x01)

#define GP_WB_GET_SEC_PROC_TEST_DATA_BUSY_FROM_RNG_STATUS_REG(tmp) \
        ((tmp) & 0x01)

/* State of the control FSM. 000: Reset, 001: StartUp, 010: FifoFullOn, 011: FifoFullOff, 100: Running, 101: Error, 110: Unused, 111: Unused */
#define GP_WB_READ_SEC_PROC_STATE() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141030)) >> 1) & 0x07)

#define GP_WB_GET_SEC_PROC_STATE_FROM_RNG_STATUS_REG(tmp) \
        (((tmp) >> 1) & 0x07)

/* NIST-800-90B repetition Count Test interrupt status */
#define GP_WB_READ_SEC_PROC_REP_FAIL() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141030)) >> 4) & 0x01)

#define GP_WB_GET_SEC_PROC_REP_FAIL_FROM_RNG_STATUS_REG(tmp) \
        (((tmp) >> 4) & 0x01)

/* NIST-800-90B adaptive Proportion Test (64-sample window) interrupt status */
#define GP_WB_READ_SEC_PROC_PROP1_FAIL() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141030)) >> 5) & 0x01)

#define GP_WB_GET_SEC_PROC_PROP1_FAIL_FROM_RNG_STATUS_REG(tmp) \
        (((tmp) >> 5) & 0x01)

/* NIST-800-90B adaptive Proportion Test (4096-sample window) interrupt status */
#define GP_WB_READ_SEC_PROC_PROP2_FAIL() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141030)) >> 6) & 0x01)

#define GP_WB_GET_SEC_PROC_PROP2_FAIL_FROM_RNG_STATUS_REG(tmp) \
        (((tmp) >> 6) & 0x01)

/* FIFO full status */
#define GP_WB_READ_SEC_PROC_FULL_INT() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141030)) >> 7) & 0x01)

#define GP_WB_GET_SEC_PROC_FULL_INT_FROM_RNG_STATUS_REG(tmp) \
        (((tmp) >> 7) & 0x01)

/* Start-up test failure */
#define GP_WB_READ_SEC_PROC_START_UP_FAIL() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141030)) >> 10) & 0x01)

#define GP_WB_GET_SEC_PROC_START_UP_FAIL_FROM_RNG_STATUS_REG(tmp) \
        (((tmp) >> 10) & 0x01)


/* Number of clock cycles to wait before sampling data from the noise source. All those bits are reset high, the reset value is 2^g_WaitCounterSize-1. */
#define GP_WB_READ_SEC_PROC_INIT_WAIT_VAL() \
        (GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141034)) & 0xFFFF)

#define GP_WB_WRITE_SEC_PROC_INIT_WAIT_VAL(val) do { \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141034), 0x0000FFFF, (val)); \
        } while (0)


/* Disable oscillator rings #0 to #24 */
#define GP_WB_WRITE_SEC_PROC_DISABLE_OSC_0(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01FFFFFF); \
          GP_AHB_WRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141038), (val)); \
        } while (0)


/* Number of clk cycles to wait before stopping the rings after the FIFO is full. */
#define GP_WB_READ_SEC_PROC_SW_OFF_TMR_VAL() \
        (GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141040)) & 0xFFFF)

#define GP_WB_WRITE_SEC_PROC_SW_OFF_TMR_VAL(val) do { \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141040), 0x0000FFFF, (val)); \
        } while (0)


/* Sample clock divider. The frequency at which the outputs of the rings are sampled is given by Fs = Fpclk/(ClkDiv + 1). */
#define GP_WB_READ_SEC_PROC_CLK_DIV() \
        (GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141044)) & 0xFF)

#define GP_WB_WRITE_SEC_PROC_CLK_DIV(val) do { \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x141044), 0x000000FF, (val)); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SEC_PROC_PK_POINTER_REG() \
        GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142000))

#define GP_WB_WRITE_SEC_PROC_PK_POINTER_REG(val) \
      GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142000), (val))

/* When executing primitive arithmetic operations, this Pointer defines where operand A is located in memory (location 0 to 0xF). */
#define GP_WB_READ_SEC_PROC_OP_PTR_A() \
        (GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142000)) & 0x0F)

#define GP_WB_GET_SEC_PROC_OP_PTR_A_FROM_PK_POINTER_REG(tmp) \
        ((tmp) & 0x0F)

#define GP_WB_WRITE_SEC_PROC_OP_PTR_A(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142000), 0x0000000F, (val)); \
        } while (0)

#define GP_WB_SET_SEC_PROC_OP_PTR_A_TO_PK_POINTER_REG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x0F0F0F00; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* When executing primitive arithmetic operations, this Pointer defines where operand B is located in memory (location 0 to 0xF). */
#define GP_WB_READ_SEC_PROC_OP_PTR_B() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142000)) >> 8) & 0x0F)

#define GP_WB_GET_SEC_PROC_OP_PTR_B_FROM_PK_POINTER_REG(tmp) \
        (((tmp) >> 8) & 0x0F)

#define GP_WB_WRITE_SEC_PROC_OP_PTR_B(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142000), 0x00000F00, (UInt32)(val) << 8); \
        } while (0)

#define GP_WB_SET_SEC_PROC_OP_PTR_B_TO_PK_POINTER_REG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x0F0F000F; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* When executing primitive arithmetic operations, this pointer defines the location (0 to 0xF) where the result will be stored in memory. */
#define GP_WB_READ_SEC_PROC_OP_PTR_C() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142000)) >> 16) & 0x0F)

#define GP_WB_GET_SEC_PROC_OP_PTR_C_FROM_PK_POINTER_REG(tmp) \
        (((tmp) >> 16) & 0x0F)

#define GP_WB_WRITE_SEC_PROC_OP_PTR_C(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142000), 0x000F0000, (UInt32)(val) << 16); \
        } while (0)

#define GP_WB_SET_SEC_PROC_OP_PTR_C_TO_PK_POINTER_REG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x0F000F0F; \
          (tmp) |= (((UInt32)(val)) << 16); \
        } while (0)

/* When executing primitive arithmetic operations, this pointer defines the location where the modulus is located in memory (location 0 or 0xF). */
#define GP_WB_READ_SEC_PROC_OP_PTR_N() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142000)) >> 24) & 0x0F)

#define GP_WB_GET_SEC_PROC_OP_PTR_N_FROM_PK_POINTER_REG(tmp) \
        (((tmp) >> 24) & 0x0F)

#define GP_WB_WRITE_SEC_PROC_OP_PTR_N(val) do { \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142000), 0x0F000000, (UInt32)(val) << 24); \
        } while (0)

#define GP_WB_SET_SEC_PROC_OP_PTR_N_TO_PK_POINTER_REG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x0F); \
          (tmp) &= 0x000F0F0F; \
          (tmp) |= (((UInt32)(val)) << 24); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SEC_PROC_PK_COMMAND_REG() \
        GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142004))

#define GP_WB_WRITE_SEC_PROC_PK_COMMAND_REG(val) \
      GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142004), (val))

/* defines the operation to be performed */
#define GP_WB_READ_SEC_PROC_TYPE_OF_OPERATION() \
        (GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142004)) & 0x7F)

#define GP_WB_GET_SEC_PROC_TYPE_OF_OPERATION_FROM_PK_COMMAND_REG(tmp) \
        ((tmp) & 0x7F)

#define GP_WB_WRITE_SEC_PROC_TYPE_OF_OPERATION(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142004), 0x0000007F, (val)); \
        } while (0)

#define GP_WB_SET_SEC_PROC_TYPE_OF_OPERATION_TO_PK_COMMAND_REG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          (tmp) &= 0xF0707F00; \
          (tmp) |= ((UInt32)(val)); \
        } while (0)

/* This field defines the size (= number of bytes minus one) of the operands for the current operation. Possible values are limited by the maximum supported operand size. */
#define GP_WB_READ_SEC_PROC_SIZE_OF_OPERANDS() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142004)) >> 8) & 0x7F)

#define GP_WB_GET_SEC_PROC_SIZE_OF_OPERANDS_FROM_PK_COMMAND_REG(tmp) \
        (((tmp) >> 8) & 0x7F)

#define GP_WB_WRITE_SEC_PROC_SIZE_OF_OPERANDS(val) do { \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142004), 0x00007F00, (UInt32)(val) << 8); \
        } while (0)

#define GP_WB_SET_SEC_PROC_SIZE_OF_OPERANDS_TO_PK_COMMAND_REG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x7F); \
          (tmp) &= 0xF070007F; \
          (tmp) |= (((UInt32)(val)) << 8); \
        } while (0)

/* Enable accelerator for specific curve modulus: 0x0: No acceleration (default), 0x1: P256, 0x2: P384, 0x3: P521/E-521, 0x4: P192, 0x5: Curve25519/Ed25519. This field has no effect when the optional acceleration hardware is not included. */
#define GP_WB_READ_SEC_PROC_SEL_CURVE() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142004)) >> 20) & 0x07)

#define GP_WB_GET_SEC_PROC_SEL_CURVE_FROM_PK_COMMAND_REG(tmp) \
        (((tmp) >> 20) & 0x07)

#define GP_WB_WRITE_SEC_PROC_SEL_CURVE(val) do { \
          GP_WB_RANGE_CHECK(val, 0x07); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142004), 0x00700000, (UInt32)(val) << 20); \
        } while (0)

#define GP_WB_SET_SEC_PROC_SEL_CURVE_TO_PK_COMMAND_REG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x07); \
          (tmp) &= 0xF0007F7F; \
          (tmp) |= (((UInt32)(val)) << 20); \
        } while (0)

/* Swap the bytes on AHB interface: '0': Native format (little endian), '1': Byte swapped (big endian). This bit must be programmed before writing/reading any data in data memory. */
#define GP_WB_READ_SEC_PROC_SWAP_BYTES() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142004)) >> 28) & 0x01)

#define GP_WB_GET_SEC_PROC_SWAP_BYTES_FROM_PK_COMMAND_REG(tmp) \
        (((tmp) >> 28) & 0x01)

#define GP_WB_WRITE_SEC_PROC_SWAP_BYTES(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142004), 0x10000000, (UInt32)(val) << 28); \
        } while (0)

#define GP_WB_SET_SEC_PROC_SWAP_BYTES_TO_PK_COMMAND_REG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xE0707F7F; \
          (tmp) |= (((UInt32)(val)) << 28); \
        } while (0)

#define GP_WB_READ_SEC_PROC_FLAG_A() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142004)) >> 29) & 0x01)

#define GP_WB_GET_SEC_PROC_FLAG_A_FROM_PK_COMMAND_REG(tmp) \
        (((tmp) >> 29) & 0x01)

#define GP_WB_WRITE_SEC_PROC_FLAG_A(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142004), 0x20000000, (UInt32)(val) << 29); \
        } while (0)

#define GP_WB_SET_SEC_PROC_FLAG_A_TO_PK_COMMAND_REG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xD0707F7F; \
          (tmp) |= (((UInt32)(val)) << 29); \
        } while (0)

#define GP_WB_READ_SEC_PROC_FLAG_B() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142004)) >> 30) & 0x01)

#define GP_WB_GET_SEC_PROC_FLAG_B_FROM_PK_COMMAND_REG(tmp) \
        (((tmp) >> 30) & 0x01)

#define GP_WB_WRITE_SEC_PROC_FLAG_B(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142004), 0x40000000, (UInt32)(val) << 30); \
        } while (0)

#define GP_WB_SET_SEC_PROC_FLAG_B_TO_PK_COMMAND_REG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0xB0707F7F; \
          (tmp) |= (((UInt32)(val)) << 30); \
        } while (0)

/* This bit indicates if the IP has to calculate R^2 mod N for the next operation. This bit must be set to '1' when a new prime number has been programmed. This bit is used for primitive operations and ignored for the other operations.'0': don't recalculate R^2 mod N', '1': re-calculate R^2 mod N */
#define GP_WB_READ_SEC_PROC_CALC_R2() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142004)) >> 31) & 0x01)

#define GP_WB_GET_SEC_PROC_CALC_R2_FROM_PK_COMMAND_REG(tmp) \
        (((tmp) >> 31) & 0x01)

#define GP_WB_WRITE_SEC_PROC_CALC_R2(val) do { \
          GP_WB_RANGE_CHECK(val, 0x01); \
          GP_AHB_MWRITE_U32 (GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142004), 0x80000000, (UInt32)(val) << 31); \
        } while (0)

#define GP_WB_SET_SEC_PROC_CALC_R2_TO_PK_COMMAND_REG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U32(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x70707F7F; \
          (tmp) |= (((UInt32)(val)) << 31); \
        } while (0)


#define GP_WB_WRITE_SEC_PROC_PK_CONTROL_REG(val) \
      GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142008), (val))

/* Writing a '1' starts the processing */
#define GP_WB_SEC_PROC_PK_START() \
        GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142008), 0x00000001)

#define GP_WB_SET_SEC_PROC_PK_START_TO_PK_CONTROL_REG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x02; \
          (tmp) |= ((UInt8)(val)); \
        } while (0)

/* Writing a '1' clears the IRQ output */
#define GP_WB_SEC_PROC_CLEAR_IRQ() \
        GP_AHB_WRITE_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142008), 0x00000002)

#define GP_WB_SET_SEC_PROC_CLEAR_IRQ_TO_PK_CONTROL_REG(tmp, val) do { \
          GP_WB_SIZE_CHECK_U8(tmp); \
          GP_WB_RANGE_CHECK(val, 0x01); \
          (tmp) &= 0x01; \
          (tmp) |= (((UInt8)(val)) << 1); \
        } while (0)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SEC_PROC_PK_STATUS_REG() \
        GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14200c))

/* These bits indicate which data location generated the error flag. They are not available for all error flags. */
#define GP_WB_READ_SEC_PROC_FAIL_ADDRESS() \
        (GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14200c)) & 0x0F)

#define GP_WB_GET_SEC_PROC_FAIL_ADDRESS_FROM_PK_STATUS_REG(tmp) \
        ((tmp) & 0x0F)

/* Status signal set to 1 when Point Px is not on the defined EC. This flag is updated after execution of the command Check_Point_OnCurve. */
#define GP_WB_READ_SEC_PROC_POINT_PX_NOT_ON_CURVE() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14200c)) >> 4) & 0x01)

#define GP_WB_GET_SEC_PROC_POINT_PX_NOT_ON_CURVE_FROM_PK_STATUS_REG(tmp) \
        (((tmp) >> 4) & 0x01)

/* Status signal set to 1 when Point Px is at the infinity. This flag is updated after execution of an ECC operation. */
#define GP_WB_READ_SEC_PROC_POINT_PX_AT_INFINITY() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14200c)) >> 5) & 0x01)

#define GP_WB_GET_SEC_PROC_POINT_PX_AT_INFINITY_FROM_PK_STATUS_REG(tmp) \
        (((tmp) >> 5) & 0x01)

/* Status signal set to 1 when couple x, y is not valid (i.e. not smaller than the prime). This flag is updated after execution of the command Check_Couple_Less_Prime. */
#define GP_WB_READ_SEC_PROC_COUPLE_NOT_VALID() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14200c)) >> 6) & 0x01)

#define GP_WB_GET_SEC_PROC_COUPLE_NOT_VALID_FROM_PK_STATUS_REG(tmp) \
        (((tmp) >> 6) & 0x01)

/* Status signal set to 1 when Parameter n is not valid. This flag is updated after execution of the command Check_n. */
#define GP_WB_READ_SEC_PROC_PARAM_N_NOT_VALID() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14200c)) >> 7) & 0x01)

#define GP_WB_GET_SEC_PROC_PARAM_N_NOT_VALID_FROM_PK_STATUS_REG(tmp) \
        (((tmp) >> 7) & 0x01)

/* This flag is set to '1' when the Type of operation programmed in the command register is not supported. */
#define GP_WB_READ_SEC_PROC_NOT_IMPLEMENTED() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14200c)) >> 8) & 0x01)

#define GP_WB_GET_SEC_PROC_NOT_IMPLEMENTED_FROM_PK_STATUS_REG(tmp) \
        (((tmp) >> 8) & 0x01)

/* This flag indicates if the signature can be accepted or must be rejected. This flag is set to 1 when the signature is not valid and is updated after execution of the command ECDSA_Generation, ECDSA_Verification, DSA_Generation, DSA_Verification, Ed25519_CheckValid. */
#define GP_WB_READ_SEC_PROC_SIGNATURE_NOT_VALID() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14200c)) >> 9) & 0x01)

#define GP_WB_GET_SEC_PROC_SIGNATURE_NOT_VALID_FROM_PK_STATUS_REG(tmp) \
        (((tmp) >> 9) & 0x01)

/* Status signal set to 1 when parameters A and B are not valid, i.e 4A^3+ 27B^2 = 0. This flag is updated after execution of the command Check_AB. */
#define GP_WB_READ_SEC_PROC_PARAM_AB_NOT_VALID() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14200c)) >> 10) & 0x01)

#define GP_WB_GET_SEC_PROC_PARAM_AB_NOT_VALID_FROM_PK_STATUS_REG(tmp) \
        (((tmp) >> 10) & 0x01)

/* This flag is set to '1' when executing a modular inversion (pk_command_Reg[3:0] = 0x6 or 0x9) if the operand is not invertible. */
#define GP_WB_READ_SEC_PROC_NOT_INVERTIBLE() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14200c)) >> 11) & 0x01)

#define GP_WB_GET_SEC_PROC_NOT_INVERTIBLE_FROM_PK_STATUS_REG(tmp) \
        (((tmp) >> 11) & 0x01)

/* After the Rabin-Miller Primality test, this flag is: cleared to '0' when the random number under test is probably prime; set to '1' when the random number under test is composite */
#define GP_WB_READ_SEC_PROC_COMPOSITE() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14200c)) >> 12) & 0x01)

#define GP_WB_GET_SEC_PROC_COMPOSITE_FROM_PK_STATUS_REG(tmp) \
        (((tmp) >> 12) & 0x01)

/* This flag is set to '1' when executing a modular square root if the operand is not a quadratic residue. */
#define GP_WB_READ_SEC_PROC_NOT_QUADRATIC_RESIDUE() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14200c)) >> 13) & 0x01)

#define GP_WB_GET_SEC_PROC_NOT_QUADRATIC_RESIDUE_FROM_PK_STATUS_REG(tmp) \
        (((tmp) >> 13) & 0x01)

/* This bit reflects the BUSY output value. It is set to '1' when the operation starts and it is cleared when the operation is finished. */
#define GP_WB_READ_SEC_PROC_PK_BUSY() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14200c)) >> 16) & 0x01)

#define GP_WB_GET_SEC_PROC_PK_BUSY_FROM_PK_STATUS_REG(tmp) \
        (((tmp) >> 16) & 0x01)

/* This bit reflects the IRQ output value. It is set to '1' when the operation is finished. It is cleared when the CPU writes the bit 1 of pk_control_reg Register. */
#define GP_WB_READ_SEC_PROC_INTERRUPT_STATUS() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x14200c)) >> 17) & 0x01)

#define GP_WB_GET_SEC_PROC_INTERRUPT_STATUS_FROM_PK_STATUS_REG(tmp) \
        (((tmp) >> 17) & 0x01)


/* Number of core clock cycles used during previous operation */
#define GP_WB_READ_SEC_PROC_TIMER() \
        GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142014))


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_SEC_PROC_PK_HW_CONFIG_REG() \
        GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142018))

/* Maximum operand size (number of bytes) */
#define GP_WB_READ_SEC_PROC_MAX_OP_SIZE() \
        (GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142018)) & 0x0FFF)

#define GP_WB_GET_SEC_PROC_MAX_OP_SIZE_FROM_PK_HW_CONFIG_REG(tmp) \
        ((tmp) & 0x0FFF)

/* Number of multipliers: 0x0: 1 multiplier, 0x1: 4 multipliers, 0x2: 16 multipliers, 0x4: 64 multipliers, 0x8: 256 multipliers */
#define GP_WB_READ_SEC_PROC_NB_MULT() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142018)) >> 12) & 0x0F)

#define GP_WB_GET_SEC_PROC_NB_MULT_FROM_PK_HW_CONFIG_REG(tmp) \
        (((tmp) >> 12) & 0x0F)

/* Support prime field */
#define GP_WB_READ_SEC_PROC_PRIME_FIELD() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142018)) >> 16) & 0x01)

#define GP_WB_GET_SEC_PROC_PRIME_FIELD_FROM_PK_HW_CONFIG_REG(tmp) \
        (((tmp) >> 16) & 0x01)

/* Support binary field */
#define GP_WB_READ_SEC_PROC_BINARY_FIELD() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142018)) >> 17) & 0x01)

#define GP_WB_GET_SEC_PROC_BINARY_FIELD_FROM_PK_HW_CONFIG_REG(tmp) \
        (((tmp) >> 17) & 0x01)

/* Support ECC P256 acceleration */
#define GP_WB_READ_SEC_PROC_P256() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142018)) >> 20) & 0x01)

#define GP_WB_GET_SEC_PROC_P256_FROM_PK_HW_CONFIG_REG(tmp) \
        (((tmp) >> 20) & 0x01)

/* Support ECC P384 acceleration */
#define GP_WB_READ_SEC_PROC_P384() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142018)) >> 21) & 0x01)

#define GP_WB_GET_SEC_PROC_P384_FROM_PK_HW_CONFIG_REG(tmp) \
        (((tmp) >> 21) & 0x01)

/* Support ECC P521 acceleration */
#define GP_WB_READ_SEC_PROC_P521() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142018)) >> 22) & 0x01)

#define GP_WB_GET_SEC_PROC_P521_FROM_PK_HW_CONFIG_REG(tmp) \
        (((tmp) >> 22) & 0x01)

/* Support ECC P192 acceleration */
#define GP_WB_READ_SEC_PROC_P192() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142018)) >> 23) & 0x01)

#define GP_WB_GET_SEC_PROC_P192_FROM_PK_HW_CONFIG_REG(tmp) \
        (((tmp) >> 23) & 0x01)

/* Support Curve25519/Ed25519 acceleration */
#define GP_WB_READ_SEC_PROC_CURVE_ED_25519() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142018)) >> 24) & 0x01)

#define GP_WB_GET_SEC_PROC_CURVE_ED_25519_FROM_PK_HW_CONFIG_REG(tmp) \
        (((tmp) >> 24) & 0x01)

/* State of DisableCM input (high when counter-measures are disabled) */
#define GP_WB_READ_SEC_PROC_DISABLE_CM() \
        ((GP_AHB_READ_U32(GP_MM_AHB_ADDR_FROM_COMPRESSED(0x142018)) >> 31) & 0x01)

#define GP_WB_GET_SEC_PROC_DISABLE_CM_FROM_PK_HW_CONFIG_REG(tmp) \
        (((tmp) >> 31) & 0x01)

/***************************
 * layout: userlic
 ***************************/

/* When anything other then 0 will overrule the Vendor BLE device address. Little endian format */
#define GP_WB_READ_USERLIC_VENDOR_BLE_ADDRESS() \
        GP_WB_READ_U48(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200000))


/* Programmer can write the 8-byte 802.15.4 MAC Address here */
#define GP_WB_READ_USERLIC_VENDOR_ID_MAC() \
        GP_WB_READ_U64(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200008))

/* 4 byte Greenpower start source-id. This field defines the lowest source-id of the device. Other source-ids (if existing) will be consecutive.  Little endian format */
#define GP_WB_READ_USERLIC_GREENPOWER_START_SOURCE_ID() \
        GP_WB_READ_U32(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200008))

/* Programmer can write the number of source-ids to this device, starting with the start source id. */
#define GP_WB_READ_USERLIC_NUMBER_OF_SOURCE_IDS() \
        GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x20000c))

/* If zero, indicates that the value is a Vendor Greenpower source ID else the data is a 802.15.4 Address */
#define GP_WB_READ_USERLIC_ZERO_PATTERN() \
        GP_WB_READ_U24(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x20000d))


/* Optionally specified CRC in the programming XML file. The Programmer verifies it against the actual image and, if correct, stores it in the User License. The user bootloader can use this to validate the user program. */
#define GP_WB_READ_USERLIC_CRC_VALUE() \
        GP_WB_READ_U32(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200010))

/* Start address for section to generate CRC over. Address shall be 4-byte aligned */
#define GP_WB_READ_USERLIC_START_ADDRESS() \
        GP_WB_READ_U24(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200014))

/* The CRC-TYPE specifies the type of CRC algorithm: 0: CRC not available, 1:CRC-32 (polynomial 0xEDB88320). */
#define GP_WB_READ_USERLIC_CRC_TYPE() \
        GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200017))


/* Size of the section to generate CRC over in 4-byte increments */
#define GP_WB_READ_USERLIC_SIZE() \
        GP_WB_READ_U24(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200018))


/* Vector pointer in the same format as CORTEXM4_VECTOR_TABLE_OFFSET: 256-byte "word address", i.e. byte address / 256 */
#define GP_WB_READ_USERLIC_VECTOR_POINTER() \
        GP_WB_READ_U24(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x20001c))


#define GP_WB_READ_USERLIC_USER_KEYS_WRITE_LOCK() \
        GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x20001f))

/* User key 0 is write locked if set */
#define GP_WB_READ_USERLIC_USER_KEY_0_WRITE_LOCK() \
        (GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x20001f)) & 0x01)

/* User key 1 is write locked if set */
#define GP_WB_READ_USERLIC_USER_KEY_1_WRITE_LOCK() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x20001f)) >> 1) & 0x01)

/* User key 2 is write locked if set */
#define GP_WB_READ_USERLIC_USER_KEY_2_WRITE_LOCK() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x20001f)) >> 2) & 0x01)

/* User key 3 is write locked if set */
#define GP_WB_READ_USERLIC_USER_KEY_3_WRITE_LOCK() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x20001f)) >> 3) & 0x01)

/* User key 4 is write locked if set */
#define GP_WB_READ_USERLIC_USER_KEY_4_WRITE_LOCK() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x20001f)) >> 4) & 0x01)

/* User key 5 is write locked if set */
#define GP_WB_READ_USERLIC_USER_KEY_5_WRITE_LOCK() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x20001f)) >> 5) & 0x01)

/* User key 6 is write locked if set */
#define GP_WB_READ_USERLIC_USER_KEY_6_WRITE_LOCK() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x20001f)) >> 6) & 0x01)

/* User key 7 is write locked if set */
#define GP_WB_READ_USERLIC_USER_KEY_7_WRITE_LOCK() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x20001f)) >> 7) & 0x01)


/* Program at vector_pointer is to be loaded (i.e. image is valid) when magic word equals 0x693A5C81 (LSB first, so *0x20=0x81), for any other value, HW will not boot the program and stay in bootloader. */
#define GP_WB_READ_USERLIC_MW_PROGRAM_LOAD() \
        GP_WB_READ_U32(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200020))


/* Only applies to Debug Mode: Debug mode is locked and cannot be used to program the chip when magic word equals 0xDBE4080F (LSB first, so *0x24=0x0F). JTAG and SWD debug interfaces will be disable by the ROM bootloader if this bit is set. */
#define GP_WB_READ_USERLIC_MW_DEBUG_LOCK() \
        GP_WB_READ_U32(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200024))


/* Only applies to Programmer Mode: Flash cannot be erased in bulk when magic word equals 0xA2693A5C (LSB first, so *0x28=0x5C) */
#define GP_WB_READ_USERLIC_MW_BULK_ERASE_LOCK() \
        GP_WB_READ_U32(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200028))


/* Sector Read lock bitmap applies to Programmer Mode only! */
#define GP_WB_READ_USERLIC_SECTOR_READ_LOCK_FINE() \
        GP_WB_READ_U64(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200030))

/* read lock bits for the 16 consecutive 2kB sectors (lsb = first 2kB sector, msb = 16th/last 2kB sector), starting at offset 0x0, locked if set. */
#define GP_WB_READ_USERLIC_SECTOR_READ_LOCK_FINE_0() \
        GP_WB_READ_U16(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200030))

/* read lock bits for the 16 consecutive 2kB sectors (lsb = first 2kB sector, msb = 16th/last 2kB sector), starting at offset 0x40000 = 256 kByte, locked if set. */
#define GP_WB_READ_USERLIC_SECTOR_READ_LOCK_FINE_1() \
        GP_WB_READ_U16(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200032))

/* read lock bits for the 16 consecutive 2kB sectors (lsb = first 2kB sector, msb = 16th/last 2kB sector), starting at offset 0x80000 = 512 kByte, locked if set. */
#define GP_WB_READ_USERLIC_SECTOR_READ_LOCK_FINE_2() \
        GP_WB_READ_U16(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200034))

/* read lock bits for the 16 consecutive 2kB sectors (lsb = first 2kB sector, msb = 16th/last 2kB sector), starting at offset 0xC0000 = 768 kByte, locked if set. */
#define GP_WB_READ_USERLIC_SECTOR_READ_LOCK_FINE_3() \
        GP_WB_READ_U16(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200036))


/* Sector read lock bitmap applies to Programmer Mode only! */
#define GP_WB_READ_USERLIC_SECTOR_READ_LOCKS_COARSE() \
        (GP_WB_READ_U16(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200038)) & 0x0FFF)

/* read lock bit for the  32kB sector, starting at offset  0x8000 =  32 kBytes, locked if set */
#define GP_WB_READ_USERLIC_SECTOR_READ_LOCK_COARSE_LOW_0() \
        (GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200038)) & 0x01)

/* read lock bit for the  64kB sector, starting at offset 0x10000 =  64 kBytes, locked if set */
#define GP_WB_READ_USERLIC_SECTOR_READ_LOCK_COARSE_MID_0() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200038)) >> 1) & 0x01)

/* read lock bit for the 128kB sector, starting at offset 0x20000 = 128 kBytes, locked if set */
#define GP_WB_READ_USERLIC_SECTOR_READ_LOCK_COARSE_HIGH_0() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200038)) >> 2) & 0x01)

/* read lock bit for the  32kB sector, starting at offset 0x48000 = 288 kBytes, locked if set */
#define GP_WB_READ_USERLIC_SECTOR_READ_LOCK_COARSE_LOW_1() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200038)) >> 3) & 0x01)

/* read lock bit for the  64kB sector, starting at offset 0x50000 = 320 kBytes, locked if set */
#define GP_WB_READ_USERLIC_SECTOR_READ_LOCK_COARSE_MID_1() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200038)) >> 4) & 0x01)

/* read lock bit for the 128kB sector, starting at offset 0x60000 = 384 kBytes, locked if set */
#define GP_WB_READ_USERLIC_SECTOR_READ_LOCK_COARSE_HIGH_1() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200038)) >> 5) & 0x01)

/* read lock bit for the  32kB sector, starting at offset 0x88000 = 544 kBytes, locked if set */
#define GP_WB_READ_USERLIC_SECTOR_READ_LOCK_COARSE_LOW_2() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200038)) >> 6) & 0x01)

/* read lock bit for the  64kB sector, starting at offset 0x90000 = 576 kBytes, locked if set */
#define GP_WB_READ_USERLIC_SECTOR_READ_LOCK_COARSE_MID_2() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200038)) >> 7) & 0x01)

/* read lock bit for the 128kB sector, starting at offset 0xA0000 = 640 kBytes, locked if set */
#define GP_WB_READ_USERLIC_SECTOR_READ_LOCK_COARSE_HIGH_2() \
        (GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200039)) & 0x01)

/* read lock bit for the  32kB sector, starting at offset 0xC8000 = 800 kBytes, locked if set */
#define GP_WB_READ_USERLIC_SECTOR_READ_LOCK_COARSE_LOW_3() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200039)) >> 1) & 0x01)

/* read lock bit for the  64kB sector, starting at offset 0xD0000 = 832 kBytes, locked if set */
#define GP_WB_READ_USERLIC_SECTOR_READ_LOCK_COARSE_MID_3() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200039)) >> 2) & 0x01)

/* read lock bit for the 128kB sector, starting at offset 0xE0000 = 896 kBytes, locked if set */
#define GP_WB_READ_USERLIC_SECTOR_READ_LOCK_COARSE_HIGH_3() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200039)) >> 3) & 0x01)


/* Sector Write lock bitmap applies to Programmer Mode only! */
#define GP_WB_READ_USERLIC_SECTOR_WRITE_LOCK_FINE() \
        GP_WB_READ_U64(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200040))

/* Write lock bits for the 16 consecutive 2kB sectors (lsb = first 2kB sector, msb = 16th/last 2kB sector), starting at offset 0x0, locked if set. */
#define GP_WB_READ_USERLIC_SECTOR_WRITE_LOCK_FINE_0() \
        GP_WB_READ_U16(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200040))

/* Write lock bits for the 16 consecutive 2kB sectors (lsb = first 2kB sector, msb = 16th/last 2kB sector), starting at offset 0x40000 = 256 kByte, locked if set. */
#define GP_WB_READ_USERLIC_SECTOR_WRITE_LOCK_FINE_1() \
        GP_WB_READ_U16(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200042))

/* Write lock bits for the 16 consecutive 2kB sectors (lsb = first 2kB sector, msb = 16th/last 2kB sector), starting at offset 0x80000 = 512 kByte, locked if set. */
#define GP_WB_READ_USERLIC_SECTOR_WRITE_LOCK_FINE_2() \
        GP_WB_READ_U16(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200044))

/* Write lock bits for the 16 consecutive 2kB sectors (lsb = first 2kB sector, msb = 16th/last 2kB sector), starting at offset 0xC0000 = 768 kByte, locked if set. */
#define GP_WB_READ_USERLIC_SECTOR_WRITE_LOCK_FINE_3() \
        GP_WB_READ_U16(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200046))


/* Sector Write lock bitmap applies to Programmer Mode only! */
#define GP_WB_READ_USERLIC_SECTOR_WRITE_LOCKS_COARSE() \
        (GP_WB_READ_U16(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200048)) & 0x0FFF)

/* write lock bit for the  32kB sector, starting at offset  0x8000 =  32 kBytes, locked if set */
#define GP_WB_READ_USERLIC_SECTOR_WRITE_LOCK_COARSE_LOW_0() \
        (GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200048)) & 0x01)

/* write lock bit for the  64kB sector, starting at offset 0x10000 =  64 kBytes, locked if set */
#define GP_WB_READ_USERLIC_SECTOR_WRITE_LOCK_COARSE_MID_0() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200048)) >> 1) & 0x01)

/* write lock bit for the 128kB sector, starting at offset 0x20000 = 128 kBytes, locked if set */
#define GP_WB_READ_USERLIC_SECTOR_WRITE_LOCK_COARSE_HIGH_0() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200048)) >> 2) & 0x01)

/* write lock bit for the  32kB sector, starting at offset 0x48000 = 288 kBytes, locked if set */
#define GP_WB_READ_USERLIC_SECTOR_WRITE_LOCK_COARSE_LOW_1() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200048)) >> 3) & 0x01)

/* write lock bit for the  64kB sector, starting at offset 0x50000 = 320 kBytes, locked if set */
#define GP_WB_READ_USERLIC_SECTOR_WRITE_LOCK_COARSE_MID_1() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200048)) >> 4) & 0x01)

/* write lock bit for the 128kB sector, starting at offset 0x60000 = 384 kBytes, locked if set */
#define GP_WB_READ_USERLIC_SECTOR_WRITE_LOCK_COARSE_HIGH_1() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200048)) >> 5) & 0x01)

/* write lock bit for the  32kB sector, starting at offset 0x88000 = 544 kBytes, locked if set */
#define GP_WB_READ_USERLIC_SECTOR_WRITE_LOCK_COARSE_LOW_2() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200048)) >> 6) & 0x01)

/* write lock bit for the  64kB sector, starting at offset 0x90000 = 576 kBytes, locked if set */
#define GP_WB_READ_USERLIC_SECTOR_WRITE_LOCK_COARSE_MID_2() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200048)) >> 7) & 0x01)

/* write lock bit for the 128kB sector, starting at offset 0xA0000 = 640 kBytes, locked if set */
#define GP_WB_READ_USERLIC_SECTOR_WRITE_LOCK_COARSE_HIGH_2() \
        (GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200049)) & 0x01)

/* write lock bit for the  32kB sector, starting at offset 0xC8000 = 800 kBytes, locked if set */
#define GP_WB_READ_USERLIC_SECTOR_WRITE_LOCK_COARSE_LOW_3() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200049)) >> 1) & 0x01)

/* write lock bit for the  64kB sector, starting at offset 0xD0000 = 832 kBytes, locked if set */
#define GP_WB_READ_USERLIC_SECTOR_WRITE_LOCK_COARSE_MID_3() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200049)) >> 2) & 0x01)

/* write lock bit for the 128kB sector, starting at offset 0xE0000 = 896 kBytes, locked if set */
#define GP_WB_READ_USERLIC_SECTOR_WRITE_LOCK_COARSE_HIGH_3() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200049)) >> 3) & 0x01)


#define GP_WB_READ_USERLIC_APP_VERSION() \
        GP_WB_READ_U32(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200050))

/* Major version number that can be optionally used by the application */
#define GP_WB_READ_USERLIC_APP_VERSION_MAJOR() \
        GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200050))

/* Minor version number that can be optionally used by the application */
#define GP_WB_READ_USERLIC_APP_VERSION_MINOR() \
        GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200051))

/* Revison version number that can be optionally used by the application */
#define GP_WB_READ_USERLIC_APP_VERSION_REVISION() \
        GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200052))

/* Patch version number that can be optionally used by the application */
#define GP_WB_READ_USERLIC_APP_VERSION_PATCH() \
        GP_WB_READ_U8(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200053))


/* Reserved */
#define GP_WB_READ_USERLIC_APP_DESCRIPTOR() \
        GP_WB_READ_U32(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200054))


/* Written by SW. LSB is 0x00 and unused. Remaining 3 bytes contain changelist version (LSB first). */
#define GP_WB_READ_USERLIC_APP_CHANGELIST_SPEC() \
        GP_WB_READ_U32(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200058))


/* Reserved */
#define GP_WB_READ_USERLIC_APP_SPECIFIC_VERSION_0() \
        GP_WB_READ_U32(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200060))


/* Reserved */
#define GP_WB_READ_USERLIC_APP_SPECIFIC_VERSION_1() \
        GP_WB_READ_U32(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200064))


/* Reserved */
#define GP_WB_READ_USERLIC_APP_SPECIFIC_VERSION_2() \
        GP_WB_READ_U32(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x200068))


/* Reserved */
#define GP_WB_READ_USERLIC_DFT_VERSION() \
        GP_WB_READ_U32(GP_MM_FLASH_ADDR_FROM_COMPRESSED(0x20006c))

/***************************
 * layout: nvr
 ***************************/

/* Magic Word to indicate that Tracking Info fields are initialized. Magic word is 0x35774B0C. */
#define GP_WB_READ_NVR_TRACKING_MW() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380000))


/* 8-byte field used for product tracking purposes. An unused tracking entry is specified as an all-one pattern. We check what entry needs to be written next by finding the next 'all-one' pattern. */
#define GP_WB_READ_NVR_TRACKING_INFO_0() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380008))


/* 8-byte field used for product tracking purposes. An unused tracking entry is specified as an all-one pattern. We check what entry needs to be written next by finding the next 'all-one' pattern. */
#define GP_WB_READ_NVR_TRACKING_INFO_1() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380010))


/* 8-byte field used for product tracking purposes. An unused tracking entry is specified as an all-one pattern. We check what entry needs to be written next by finding the next 'all-one' pattern. */
#define GP_WB_READ_NVR_TRACKING_INFO_2() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380018))


/* 8-byte field used for product tracking purposes. An unused tracking entry is specified as an all-one pattern. We check what entry needs to be written next by finding the next 'all-one' pattern. */
#define GP_WB_READ_NVR_TRACKING_INFO_3() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380020))


/* 8-byte field used for product tracking purposes. An unused tracking entry is specified as an all-one pattern. We check what entry needs to be written next by finding the next 'all-one' pattern. */
#define GP_WB_READ_NVR_TRACKING_INFO_4() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380028))


/* 8-byte field used for product tracking purposes. An unused tracking entry is specified as an all-one pattern. We check what entry needs to be written next by finding the next 'all-one' pattern. */
#define GP_WB_READ_NVR_TRACKING_INFO_5() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380030))


/* 8-byte field used for product tracking purposes. An unused tracking entry is specified as an all-one pattern. We check what entry needs to be written next by finding the next 'all-one' pattern. */
#define GP_WB_READ_NVR_TRACKING_INFO_6() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380038))


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_NVR_ADC_RAW_CAL_0() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380040))

#define GP_WB_READ_NVR_RSSI_ADC_VREF() \
        GP_WB_READ_U16(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380040))

#define GP_WB_GET_NVR_RSSI_ADC_VREF_FROM_ADC_RAW_CAL_0(tmp) \
        ((tmp) & 0xFFFF)

/* no use for it yest */
#define GP_WB_READ_NVR_RSSI_RESERVED() \
        GP_WB_READ_U16(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380042))

#define GP_WB_GET_NVR_RSSI_RESERVED_FROM_ADC_RAW_CAL_0(tmp) \
        (((tmp) >> 16) & 0xFFFF)

/* SQ8_8 value temperature offset in Kelvin/Celcius, encoded as a sixteen bit value with 8 bit before and 8 bit behind the comma (overkill I know). Will be added by the SW to the derived temperature. */
#define GP_WB_READ_NVR_TEMP_OFFSET() \
        (GP_WB_S16(GP_WB_READ_U16(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380044)), 16))

#define GP_WB_GET_NVR_TEMP_OFFSET_FROM_ADC_RAW_CAL_0(tmp) \
        (GP_WB_S16((((tmp) >> 32) & 0xFFFF), 16))

#define GP_WB_READ_NVR_TEMP_SLOPE() \
        GP_WB_READ_U16(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380046))

#define GP_WB_GET_NVR_TEMP_SLOPE_FROM_ADC_RAW_CAL_0(tmp) \
        (((tmp) >> 48) & 0xFFFF)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_NVR_ADC_RAW_CAL_1() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380048))

#define GP_WB_READ_NVR_GP_ADC_VREF_SINGLE_ENDED() \
        GP_WB_READ_U16(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380048))

#define GP_WB_GET_NVR_GP_ADC_VREF_SINGLE_ENDED_FROM_ADC_RAW_CAL_1(tmp) \
        ((tmp) & 0xFFFF)

#define GP_WB_READ_NVR_GP_ADC_OFFSET_SINGLE_ENDED() \
        (GP_WB_S16(GP_WB_READ_U16(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x38004a)), 16))

#define GP_WB_GET_NVR_GP_ADC_OFFSET_SINGLE_ENDED_FROM_ADC_RAW_CAL_1(tmp) \
        (GP_WB_S16((((tmp) >> 16) & 0xFFFF), 16))

#define GP_WB_READ_NVR_GP_ADC_VREF_DIFFERENTIAL() \
        GP_WB_READ_U16(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x38004c))

#define GP_WB_GET_NVR_GP_ADC_VREF_DIFFERENTIAL_FROM_ADC_RAW_CAL_1(tmp) \
        (((tmp) >> 32) & 0xFFFF)

#define GP_WB_READ_NVR_GP_ADC_OFFSET_DIFFERENTIAL() \
        (GP_WB_S16(GP_WB_READ_U16(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x38004e)), 16))

#define GP_WB_GET_NVR_GP_ADC_OFFSET_DIFFERENTIAL_FROM_ADC_RAW_CAL_1(tmp) \
        (GP_WB_S16((((tmp) >> 48) & 0xFFFF), 16))


/* RAM block remap configuration - 0x50: lower 32KB (ignored), 0x51 upper 32KB ('UCRAM') */
#define GP_WB_READ_NVR_RAM_REMAP() \
        GP_WB_READ_U16(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380050))


/* Flash block remap configuration */
#define GP_WB_READ_NVR_FLASH_BLOCK_REMAP() \
        GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380052))


/* Indicates the sector to remap to redundant sector 0. Value is a 10-bit [9..0] physical address indicating sector index eg. ((address) - 0x04000000) >> 11. Valid entries MUST have bit[15] set to 1 to indicate validity. */
#define GP_WB_READ_NVR_FLASH_SECTOR_REMAP_ENTRY_0() \
        GP_WB_READ_U16(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380054))


/* Indicates the sector to remap to redundant sector 1. Value is a 10-bit [9..0] physical address indicating sector index eg. ((address) - 0x04000000) >> 11. Valid entries MUST have bit[15] set to 1 to indicate validity. */
#define GP_WB_READ_NVR_FLASH_SECTOR_REMAP_ENTRY_1() \
        GP_WB_READ_U16(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380056))


/* Indicates the sector to remap to redundant sector 2. Value is a 10-bit [9..0] physical address indicating sector index eg. ((address) - 0x04000000) >> 11. Valid entries MUST have bit[15] set to 1 to indicate validity. */
#define GP_WB_READ_NVR_FLASH_SECTOR_REMAP_ENTRY_2() \
        GP_WB_READ_U16(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380058))


/* Indicates the sector to remap to redundant sector 3. Value is a 10-bit [9..0] physical address indicating sector index eg. ((address) - 0x04000000) >> 11. Valid entries MUST have bit[15] set to 1 to indicate validity. */
#define GP_WB_READ_NVR_FLASH_SECTOR_REMAP_ENTRY_3() \
        GP_WB_READ_U16(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x38005a))


/* Number of ticks to be used during each measurement, a non zero value indicates that RC_SLEEP_CLOCK_BENCHMARK_NO_OF_LP_TICKS, RC_SLEEP_CLOCK_BENCHMARK_QUEUE_DEPTH and RC_SLEEP_CLOCK_BENCHMARK_ENABLE_MULTIPLE_MEASUREMENTS are valid and the default values in the SW should be overruled with the values stored here */
#define GP_WB_READ_NVR_RC_SLEEP_CLOCK_BENCHMARK_NO_OF_LP_TICKS() \
        GP_WB_READ_U16(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380060))

/* Amount of measurements to be averaged */
#define GP_WB_READ_NVR_RC_SLEEP_CLOCK_BENCHMARK_QUEUE_DEPTH() \
        GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380062))

/* Boolean to indicate if multiple measurement should be taken during one awake cycle */
#define GP_WB_READ_NVR_RC_SLEEP_CLOCK_BENCHMARK_ENABLE_MULTIPLE_MEASUREMENTS() \
        GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380063))


/* VDD RAM sel. This shall be copied to PMUD_VDDRAM_SEL property. */
#define GP_WB_READ_NVR_VDD_RAM_SEL() \
        GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380064))


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_NVR_XO_RINGOSC_CONTROL() \
        GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380065))

/* Course calibration value for ringoscillator and clock synthesiser */
#define GP_WB_READ_NVR_XO_RING29M_COURSE_BANK() \
        (GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380065)) & 0x0F)

#define GP_WB_GET_NVR_XO_RING29M_COURSE_BANK_FROM_XO_RINGOSC_CONTROL(tmp) \
        ((tmp) & 0x0F)

/* Course calibration value for ringoscillator and clock synthesiser */
#define GP_WB_READ_NVR_XO_RING29M_FINE_BANK() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380065)) >> 4) & 0x0F)

#define GP_WB_GET_NVR_XO_RING29M_FINE_BANK_FROM_XO_RINGOSC_CONTROL(tmp) \
        (((tmp) >> 4) & 0x0F)


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_NVR_GLOBAL_LDO_SETTINGS() \
        GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380066))

/* Default value to be used for global LDO refbits when DCDC is not used (copy to PMUD_PU_GLOBAL_LDO_REFBITS field) */
#define GP_WB_READ_NVR_GLDO_REFBITS_DEFAULT() \
        (GP_WB_S8((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380066)) & 0x07), 3))

#define GP_WB_GET_NVR_GLDO_REFBITS_DEFAULT_FROM_GLOBAL_LDO_SETTINGS(tmp) \
        (GP_WB_S8(((tmp) & 0x07), 3))

/* Default value to be used for global LDO refbits when DCDC is not used (copy to PMUD_PU_GLOBAL_LDO_REFBITS field) */
#define GP_WB_READ_NVR_GLDO_REFBITS_DEFAULT_VALID() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380066)) >> 3) & 0x01)

#define GP_WB_GET_NVR_GLDO_REFBITS_DEFAULT_VALID_FROM_GLOBAL_LDO_SETTINGS(tmp) \
        (((tmp) >> 3) & 0x01)

/* Default value to be used for global LDO refbits when DCDC is sed (copy to PMUD_PU_GLOBAL_LDO_REFBITS field) */
#define GP_WB_READ_NVR_GLDO_REFBITS_IN_DCDC_MODE() \
        (GP_WB_S8(((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380066)) >> 4) & 0x07), 3))

#define GP_WB_GET_NVR_GLDO_REFBITS_IN_DCDC_MODE_FROM_GLOBAL_LDO_SETTINGS(tmp) \
        (GP_WB_S8((((tmp) >> 4) & 0x07), 3))

/* Default value to be used for global LDO refbits when DCDC is sed (copy to PMUD_PU_GLOBAL_LDO_REFBITS field) */
#define GP_WB_READ_NVR_GLDO_REFBITS_IN_DCDC_MODE_VALID() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380066)) >> 7) & 0x01)

#define GP_WB_GET_NVR_GLDO_REFBITS_IN_DCDC_MODE_VALID_FROM_GLOBAL_LDO_SETTINGS(tmp) \
        (((tmp) >> 7) & 0x01)


/* adc target value to be used in applications with external PA with power detector for creating closed loop power control */
#define GP_WB_READ_NVR_PWR_CONTROL_LOOP_ADC_TARGET() \
        GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380067))


/* tx power value to be used in applications with external PA with power detector for creating closed loop power control */
#define GP_WB_READ_NVR_PWR_CONTROL_LOOP_TX_POWER_SETTING() \
        GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380068))


/* CRC over the first 108 bytes of the page. */
#define GP_WB_READ_NVR_CRC_TRACKING_PAGE() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x38006c))


/* Area in which user can store information like user specific MAC address or user specific BLE address. Not protected by any CRC, so can be written by FTS, without inducing CRC failure. */
#define GP_WB_READ_NVR_USER_AREA_0() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380070))


/* Area in which user can store information like user specific MAC address or user specific BLE address. Not protected by any CRC, so can be written by FTS, without inducing CRC failure. */
#define GP_WB_READ_NVR_USER_AREA_1() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380078))


/* Table that contains 4-byte address/data pairs (LSB of address, MSB of address, 1 byte of data, 1 dummy byte in LSB to MSB order) that is read out by the CM Calibration routine in the Bootloader to calibrate some of the chips registers or to correct initial values. Address == 0x0000 shall be included to act as a gatekeeper for the CM Calibration routine to stop processing the page. */
#define GP_WB_READ_NVR_CM_CAL_DATA_0() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380080))


/* Table that contains 4-byte address/data pairs (LSB of address, MSB of address, 1 byte of data, 1 dummy byte in LSB to MSB order) that is read out by the CM Calibration routine in the Bootloader to calibrate some of the chips registers or to correct initial values. Address == 0x0000 shall be included to act as a gatekeeper for the CM Calibration routine to stop processing the page. */
#define GP_WB_READ_NVR_CM_CAL_DATA_1() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380084))


/* Table that contains 4-byte address/data pairs (LSB of address, MSB of address, 1 byte of data, 1 dummy byte in LSB to MSB order) that is read out by the CM Calibration routine in the Bootloader to calibrate some of the chips registers or to correct initial values. Address == 0x0000 shall be included to act as a gatekeeper for the CM Calibration routine to stop processing the page. */
#define GP_WB_READ_NVR_CM_CAL_DATA_2() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380088))


/* Table that contains 4-byte address/data pairs (LSB of address, MSB of address, 1 byte of data, 1 dummy byte in LSB to MSB order) that is read out by the CM Calibration routine in the Bootloader to calibrate some of the chips registers or to correct initial values. Address == 0x0000 shall be included to act as a gatekeeper for the CM Calibration routine to stop processing the page. */
#define GP_WB_READ_NVR_CM_CAL_DATA_3() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x38008c))


/* Table that contains 4-byte address/data pairs (LSB of address, MSB of address, 1 byte of data, 1 dummy byte in LSB to MSB order) that is read out by the CM Calibration routine in the Bootloader to calibrate some of the chips registers or to correct initial values. Address == 0x0000 shall be included to act as a gatekeeper for the CM Calibration routine to stop processing the page. */
#define GP_WB_READ_NVR_CM_CAL_DATA_4() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380090))


/* Table that contains 4-byte address/data pairs (LSB of address, MSB of address, 1 byte of data, 1 dummy byte in LSB to MSB order) that is read out by the CM Calibration routine in the Bootloader to calibrate some of the chips registers or to correct initial values. Address == 0x0000 shall be included to act as a gatekeeper for the CM Calibration routine to stop processing the page. */
#define GP_WB_READ_NVR_CM_CAL_DATA_5() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380094))


/* Table that contains 4-byte address/data pairs (LSB of address, MSB of address, 1 byte of data, 1 dummy byte in LSB to MSB order) that is read out by the CM Calibration routine in the Bootloader to calibrate some of the chips registers or to correct initial values. Address == 0x0000 shall be included to act as a gatekeeper for the CM Calibration routine to stop processing the page. */
#define GP_WB_READ_NVR_CM_CAL_DATA_6() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380098))


/* Table that contains 4-byte address/data pairs (LSB of address, MSB of address, 1 byte of data, 1 dummy byte in LSB to MSB order) that is read out by the CM Calibration routine in the Bootloader to calibrate some of the chips registers or to correct initial values. Address == 0x0000 shall be included to act as a gatekeeper for the CM Calibration routine to stop processing the page. */
#define GP_WB_READ_NVR_CM_CAL_DATA_7() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x38009c))


/* Table that contains 4-byte address/data pairs (LSB of address, MSB of address, 1 byte of data, 1 dummy byte in LSB to MSB order) that is read out by the CM Calibration routine in the Bootloader to calibrate some of the chips registers or to correct initial values. Address == 0x0000 shall be included to act as a gatekeeper for the CM Calibration routine to stop processing the page. */
#define GP_WB_READ_NVR_CM_CAL_DATA_8() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3800a0))


/* Table that contains 4-byte address/data pairs (LSB of address, MSB of address, 1 byte of data, 1 dummy byte in LSB to MSB order) that is read out by the CM Calibration routine in the Bootloader to calibrate some of the chips registers or to correct initial values. Address == 0x0000 shall be included to act as a gatekeeper for the CM Calibration routine to stop processing the page. */
#define GP_WB_READ_NVR_CM_CAL_DATA_9() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3800a4))


/* Table that contains 4-byte address/data pairs (LSB of address, MSB of address, 1 byte of data, 1 dummy byte in LSB to MSB order) that is read out by the CM Calibration routine in the Bootloader to calibrate some of the chips registers or to correct initial values. Address == 0x0000 shall be included to act as a gatekeeper for the CM Calibration routine to stop processing the page. */
#define GP_WB_READ_NVR_CM_CAL_DATA_10() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3800a8))


/* Table that contains 4-byte address/data pairs (LSB of address, MSB of address, 1 byte of data, 1 dummy byte in LSB to MSB order) that is read out by the CM Calibration routine in the Bootloader to calibrate some of the chips registers or to correct initial values. Address == 0x0000 shall be included to act as a gatekeeper for the CM Calibration routine to stop processing the page. */
#define GP_WB_READ_NVR_CM_CAL_DATA_11() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3800ac))


/* Table that contains 4-byte address/data pairs (LSB of address, MSB of address, 1 byte of data, 1 dummy byte in LSB to MSB order) that is read out by the CM Calibration routine in the Bootloader to calibrate some of the chips registers or to correct initial values. Address == 0x0000 shall be included to act as a gatekeeper for the CM Calibration routine to stop processing the page. */
#define GP_WB_READ_NVR_CM_CAL_DATA_12() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3800b0))


/* Table that contains 4-byte address/data pairs (LSB of address, MSB of address, 1 byte of data, 1 dummy byte in LSB to MSB order) that is read out by the CM Calibration routine in the Bootloader to calibrate some of the chips registers or to correct initial values. Address == 0x0000 shall be included to act as a gatekeeper for the CM Calibration routine to stop processing the page. */
#define GP_WB_READ_NVR_CM_CAL_DATA_13() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3800b4))


/* Table that contains 4-byte address/data pairs (LSB of address, MSB of address, 1 byte of data, 1 dummy byte in LSB to MSB order) that is read out by the CM Calibration routine in the Bootloader to calibrate some of the chips registers or to correct initial values. Address == 0x0000 shall be included to act as a gatekeeper for the CM Calibration routine to stop processing the page. */
#define GP_WB_READ_NVR_CM_CAL_DATA_14() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3800b8))


/* Table that contains 4-byte address/data pairs (LSB of address, MSB of address, 1 byte of data, 1 dummy byte in LSB to MSB order) that is read out by the CM Calibration routine in the Bootloader to calibrate some of the chips registers or to correct initial values. Address == 0x0000 shall be included to act as a gatekeeper for the CM Calibration routine to stop processing the page. */
#define GP_WB_READ_NVR_CM_CAL_DATA_15() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3800bc))


/* Table that contains 4-byte address/data pairs (LSB of address, MSB of address, 1 byte of data, 1 dummy byte in LSB to MSB order) that is read out by the CM Calibration routine in the Bootloader to calibrate some of the chips registers or to correct initial values. Address == 0x0000 shall be included to act as a gatekeeper for the CM Calibration routine to stop processing the page. */
#define GP_WB_READ_NVR_CM_CAL_DATA_16() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3800c0))


/* Table that contains 4-byte address/data pairs (LSB of address, MSB of address, 1 byte of data, 1 dummy byte in LSB to MSB order) that is read out by the CM Calibration routine in the Bootloader to calibrate some of the chips registers or to correct initial values. Address == 0x0000 shall be included to act as a gatekeeper for the CM Calibration routine to stop processing the page. */
#define GP_WB_READ_NVR_CM_CAL_DATA_17() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3800c4))


/* Table that contains 4-byte address/data pairs (LSB of address, MSB of address, 1 byte of data, 1 dummy byte in LSB to MSB order) that is read out by the CM Calibration routine in the Bootloader to calibrate some of the chips registers or to correct initial values. Address == 0x0000 shall be included to act as a gatekeeper for the CM Calibration routine to stop processing the page. */
#define GP_WB_READ_NVR_CM_CAL_DATA_18() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3800c8))


/* Table that contains 4-byte address/data pairs (LSB of address, MSB of address, 1 byte of data, 1 dummy byte in LSB to MSB order) that is read out by the CM Calibration routine in the Bootloader to calibrate some of the chips registers or to correct initial values. Address == 0x0000 shall be included to act as a gatekeeper for the CM Calibration routine to stop processing the page. */
#define GP_WB_READ_NVR_CM_CAL_DATA_19() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3800cc))


/* Table that contains 4-byte address/data pairs (LSB of address, MSB of address, 1 byte of data, 1 dummy byte in LSB to MSB order) that is read out by the CM Calibration routine in the Bootloader to calibrate some of the chips registers or to correct initial values. Address == 0x0000 shall be included to act as a gatekeeper for the CM Calibration routine to stop processing the page. */
#define GP_WB_READ_NVR_CM_CAL_DATA_20() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3800d0))


/* Table that contains 4-byte address/data pairs (LSB of address, MSB of address, 1 byte of data, 1 dummy byte in LSB to MSB order) that is read out by the CM Calibration routine in the Bootloader to calibrate some of the chips registers or to correct initial values. Address == 0x0000 shall be included to act as a gatekeeper for the CM Calibration routine to stop processing the page. */
#define GP_WB_READ_NVR_CM_CAL_DATA_21() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3800d4))


/* Table that contains 4-byte address/data pairs (LSB of address, MSB of address, 1 byte of data, 1 dummy byte in LSB to MSB order) that is read out by the CM Calibration routine in the Bootloader to calibrate some of the chips registers or to correct initial values. Address == 0x0000 shall be included to act as a gatekeeper for the CM Calibration routine to stop processing the page. */
#define GP_WB_READ_NVR_CM_CAL_DATA_22() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3800d8))


/* Table that contains 4-byte address/data pairs (LSB of address, MSB of address, 1 byte of data, 1 dummy byte in LSB to MSB order) that is read out by the CM Calibration routine in the Bootloader to calibrate some of the chips registers or to correct initial values. Address == 0x0000 shall be included to act as a gatekeeper for the CM Calibration routine to stop processing the page. */
#define GP_WB_READ_NVR_CM_CAL_DATA_23() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3800dc))


/* Table that contains 4-byte address/data pairs (LSB of address, MSB of address, 1 byte of data, 1 dummy byte in LSB to MSB order) that is read out by the CM Calibration routine in the Bootloader to calibrate some of the chips registers or to correct initial values. Address == 0x0000 shall be included to act as a gatekeeper for the CM Calibration routine to stop processing the page. */
#define GP_WB_READ_NVR_CM_CAL_DATA_24() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3800e0))


/* Table that contains 4-byte address/data pairs (LSB of address, MSB of address, 1 byte of data, 1 dummy byte in LSB to MSB order) that is read out by the CM Calibration routine in the Bootloader to calibrate some of the chips registers or to correct initial values. Address == 0x0000 shall be included to act as a gatekeeper for the CM Calibration routine to stop processing the page. */
#define GP_WB_READ_NVR_CM_CAL_DATA_25() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3800e4))


/* Table that contains 4-byte address/data pairs (LSB of address, MSB of address, 1 byte of data, 1 dummy byte in LSB to MSB order) that is read out by the CM Calibration routine in the Bootloader to calibrate some of the chips registers or to correct initial values. Address == 0x0000 shall be included to act as a gatekeeper for the CM Calibration routine to stop processing the page. */
#define GP_WB_READ_NVR_CM_CAL_DATA_26() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3800e8))


/* Table that contains 4-byte address/data pairs (LSB of address, MSB of address, 1 byte of data, 1 dummy byte in LSB to MSB order) that is read out by the CM Calibration routine in the Bootloader to calibrate some of the chips registers or to correct initial values. Address == 0x0000 shall be included to act as a gatekeeper for the CM Calibration routine to stop processing the page. */
#define GP_WB_READ_NVR_CM_CAL_DATA_27() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3800ec))


/* Table that contains 4-byte address/data pairs (LSB of address, MSB of address, 1 byte of data, 1 dummy byte in LSB to MSB order) that is read out by the CM Calibration routine in the Bootloader to calibrate some of the chips registers or to correct initial values. Address == 0x0000 shall be included to act as a gatekeeper for the CM Calibration routine to stop processing the page. */
#define GP_WB_READ_NVR_CM_CAL_DATA_28() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3800f0))


/* Table that contains 4-byte address/data pairs (LSB of address, MSB of address, 1 byte of data, 1 dummy byte in LSB to MSB order) that is read out by the CM Calibration routine in the Bootloader to calibrate some of the chips registers or to correct initial values. Address == 0x0000 shall be included to act as a gatekeeper for the CM Calibration routine to stop processing the page. */
#define GP_WB_READ_NVR_CM_CAL_DATA_29() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3800f4))


/* Table that contains 4-byte address/data pairs (LSB of address, MSB of address, 1 byte of data, 1 dummy byte in LSB to MSB order) that is read out by the CM Calibration routine in the Bootloader to calibrate some of the chips registers or to correct initial values. Address == 0x0000 shall be included to act as a gatekeeper for the CM Calibration routine to stop processing the page. */
#define GP_WB_READ_NVR_CM_CAL_DATA_30() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3800f8))


/* CRC over the first 124 bytes of the page. */
#define GP_WB_READ_NVR_CRC_CAL_PAGE() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3800fc))


/* Product ID encoded as ASCII characters (i.e. 10 characters max).  The first character of the Product ID will be stored in the lowest address. */
#define GP_WB_READ_NVR_PRODUCT_ID_0() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380100))


/* Product ID encoded as ASCII characters (i.e. 10 characters max).  The first character of the Product ID will be stored in the lowest address. */
#define GP_WB_READ_NVR_PRODUCT_ID_1() \
        GP_WB_READ_U16(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380108))


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_NVR_PRODUCT_CUSTOM_MARKER() \
        GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x38010a))

/* Module Revision (revision of the module and its components) */
#define GP_WB_READ_NVR_MODREV() \
        (GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x38010a)) & 0x0F)

#define GP_WB_GET_NVR_MODREV_FROM_PRODUCT_CUSTOM_MARKER(tmp) \
        ((tmp) & 0x0F)

/* Module (integrated PA) */
#define GP_WB_READ_NVR_MOD() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x38010a)) >> 7) & 0x01)

#define GP_WB_GET_NVR_MOD_FROM_PRODUCT_CUSTOM_MARKER(tmp) \
        (((tmp) >> 7) & 0x01)


/* The 'UnknownChipVersionHandling' informs older SW about its compatibility of the current chip. Indeed, when the chip version (as read from the silicon) of the current chip is unknown to the SW, the SW will behave as if the current chip had 'UnknownChipVersionHanlding' as chip version */
#define GP_WB_READ_NVR_UNKNOWN_CHIP_VERSION_HANDLING() \
        GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x38010b))


/* Reserved for Product Version Number. */
#define GP_WB_READ_NVR_PRODUCT_VERSION() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x38010c))


/* IEEE802.15.4 MAC address. */
#define GP_WB_READ_NVR_MAC_ADDRESSS() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380110))


/* BLE Device Address */
#define GP_WB_READ_NVR_BLE_DEVICE_ADDRESS() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380118))


/* Reserved for 4-byte Start-Source-ID. */
#define GP_WB_READ_NVR_GREENPOWER_SRC_ID_START() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380120))


/* Reserved for number of Source Ids assigned to this device, starting with Start-Source-ID. */
#define GP_WB_READ_NVR_GREENPOWER_SRC_ID_LEN() \
        GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380124))


/* If bit(7)=0, the default Prgram mode pin is gpio3. If bit(7)=1 the program mode pin shall be allocated to gpiox, with x = bits(4:0) (valid range 0 to 17) */
#define GP_WB_READ_NVR_BL_PROG_PIN() \
        GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380128))


/* Period between each of the 50 samples taken before switching to program load. A value of 0 shall be interpreted as 10us. Any other value shall imply a time period of the value*1us. */
#define GP_WB_READ_NVR_BL_PROG_PIN_DELAY() \
        GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380129))


/* Time out used in Program and Debug mode before forced switch to User/Bare Access Mode. Bit(3:0) specifies Program Mode Timeout. Bit(7:4) specifies Debug Mode Time out.Following encoding is used for the 4-bit-value If the value = 0, time out = 4s. otherwise, time out =125ms * 2^value. */
#define GP_WB_READ_NVR_BL_TIMEOUTS() \
        GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x38012a))


/* Bit(2:0) specifies the Package ID (for configuring pull up/down on unused pins) 0 = Unknown, do nothing (i.e. use HW defaults) 1 = QFN32 2 = QFN40 3 = QFN48 4 = QFN56 */
#define GP_WB_READ_NVR_BL_PACKAGE_CONFIG() \
        GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x38012b))


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_NVR_BL_MODE_CTRL() \
        GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x38012c))

/* Use Schmitt trigger on SPI port in Program Mode */
#define GP_WB_READ_NVR_BL_MODE_CTRL_SCHMITT_ON_SPI() \
        (GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x38012c)) & 0x01)

#define GP_WB_GET_NVR_BL_MODE_CTRL_SCHMITT_ON_SPI_FROM_BL_MODE_CTRL(tmp) \
        ((tmp) & 0x01)

/* Use Schmitt trigger on UART port in Program Mode. */
#define GP_WB_READ_NVR_BL_MODE_CTRL_SCHMITT_ON_UART() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x38012c)) >> 1) & 0x01)

#define GP_WB_GET_NVR_BL_MODE_CTRL_SCHMITT_ON_UART_FROM_BL_MODE_CTRL(tmp) \
        (((tmp) >> 1) & 0x01)

/* Enable Internal PU/PD for JTAG/SWD in Debug Mode, only valid/used in default mode, ie. when bl_jtag_mapping == 0. */
#define GP_WB_READ_NVR_BL_MODE_CTRL_JTAG_PULLUPS() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x38012c)) >> 2) & 0x01)

#define GP_WB_GET_NVR_BL_MODE_CTRL_JTAG_PULLUPS_FROM_BL_MODE_CTRL(tmp) \
        (((tmp) >> 2) & 0x01)


/* JTAG mapping to use for Debug Mode. */
#define GP_WB_READ_NVR_BL_JTAG_MAPPING() \
        GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x38012d))


/* Bootloader Configuration, depending on package and SIP-configuration. See seperate tab. */
#define GP_WB_READ_NVR_BL_CONFIG() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380130))


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_NVR_ROM_PUF_CONFIG() \
        GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380134))

/* Security functions supported */
#define GP_WB_READ_NVR_ROM_PUF_SUPPORT() \
        (GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380134)) & 0x01)

#define GP_WB_GET_NVR_ROM_PUF_SUPPORT_FROM_ROM_PUF_CONFIG(tmp) \
        ((tmp) & 0x01)

/* Allow random number to be generated at start-up */
#define GP_WB_READ_NVR_ROM_PUF_ALLOW_RANDOM_NUMBER() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380134)) >> 1) & 0x01)

#define GP_WB_GET_NVR_ROM_PUF_ALLOW_RANDOM_NUMBER_FROM_ROM_PUF_CONFIG(tmp) \
        (((tmp) >> 1) & 0x01)

/* Allow random number to be generated at start-up */
#define GP_WB_READ_NVR_ROM_PUF_ALLOW_PRIVATE_KEY() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380134)) >> 2) & 0x01)

#define GP_WB_GET_NVR_ROM_PUF_ALLOW_PRIVATE_KEY_FROM_ROM_PUF_CONFIG(tmp) \
        (((tmp) >> 2) & 0x01)

/* Allow CUSTOMER INFO region to be used for security information */
#define GP_WB_READ_NVR_ROM_PUF_ALLOW_CUSTOMER_INFO() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380134)) >> 3) & 0x01)

#define GP_WB_GET_NVR_ROM_PUF_ALLOW_CUSTOMER_INFO_FROM_ROM_PUF_CONFIG(tmp) \
        (((tmp) >> 3) & 0x01)

/* Do not use hardware for public key generations */
#define GP_WB_READ_NVR_ROM_PUF_SW_PUBLIC_KEY() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380134)) >> 6) & 0x01)

#define GP_WB_GET_NVR_ROM_PUF_SW_PUBLIC_KEY_FROM_ROM_PUF_CONFIG(tmp) \
        (((tmp) >> 6) & 0x01)

/* Do not retry upon insufficient entropy */
#define GP_WB_READ_NVR_ROM_PUF_INHIBIT_RETRIES() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380134)) >> 7) & 0x01)

#define GP_WB_GET_NVR_ROM_PUF_INHIBIT_RETRIES_FROM_ROM_PUF_CONFIG(tmp) \
        (((tmp) >> 7) & 0x01)


/* Mass Erase Challenge */
#define GP_WB_READ_NVR_MASS_ERASE_CHALLENGE() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380138))


/* 2-byte TestProgram Version. LSB is minor, MSB is major. */
#define GP_WB_READ_NVR_TEST_PROGRAM_VERSION() \
        GP_WB_READ_U16(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x38013c))


/* 2-byte InfoLayout Version. LSB is minor, MSB is major. Shall be set to 0x13E = 0, 0x13F = 1 => v1.0 */
#define GP_WB_READ_NVR_INFO_LAYOUT_VERSION() \
        GP_WB_READ_U16(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x38013e))


/* When set to a specific pattern, it indicates that the BL is valid. This field is used by the ROM bootloader. See Flash Magic Word Tab for more information. */
#define GP_WB_READ_NVR_BL_MAGIC_WORD() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380140))


/* proberty block access functions for pb.c_name */
#define GP_WB_READ_NVR_LICENSE_BLOCK_MAP() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380144))

/* sets the nvm size (use type for encoding) */
#define GP_WB_READ_NVR_NVM_SIZE() \
        (GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380144)) & 0x07)

#define GP_WB_GET_NVR_NVM_SIZE_FROM_LICENSE_BLOCK_MAP(tmp) \
        ((tmp) & 0x07)

/* Protect read access to lower part (first 128 bytes) of Security Section ROM (last 256 bytes) => Bootloader will apply this in User, Bare Access and Debug Mode, such that keys are only accessible in ROM Sec Boot */
#define GP_WB_READ_NVR_READ_PROTECT_ROM_SECURITY_LOWER() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380144)) >> 3) & 0x01)

#define GP_WB_GET_NVR_READ_PROTECT_ROM_SECURITY_LOWER_FROM_LICENSE_BLOCK_MAP(tmp) \
        (((tmp) >> 3) & 0x01)

/* Write lock info page 0 (Qorvo Area) in user, bare access and debug mode (NVR sector 0) */
#define GP_WB_READ_NVR_WRITE_LOCK_INF_PAGE_0() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380144)) >> 4) & 0x01)

#define GP_WB_GET_NVR_WRITE_LOCK_INF_PAGE_0_FROM_LICENSE_BLOCK_MAP(tmp) \
        (((tmp) >> 4) & 0x01)

/* Write lock info page 1 (Customer Area) in user, bare access and debug mode (NVR sector 0) */
#define GP_WB_READ_NVR_WRITE_LOCK_INF_PAGE_1() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380144)) >> 5) & 0x01)

#define GP_WB_GET_NVR_WRITE_LOCK_INF_PAGE_1_FROM_LICENSE_BLOCK_MAP(tmp) \
        (((tmp) >> 5) & 0x01)

/* Write lock info page 2 (Device Attestation A) in user, bare access and debug mode (NVR sector 1) */
#define GP_WB_READ_NVR_WRITE_LOCK_INF_PAGE_2() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380144)) >> 6) & 0x01)

#define GP_WB_GET_NVR_WRITE_LOCK_INF_PAGE_2_FROM_LICENSE_BLOCK_MAP(tmp) \
        (((tmp) >> 6) & 0x01)

/* Write lock info page 3 (Device Attestation B)  in user, bare access and debug mode (NVR sector 1) */
#define GP_WB_READ_NVR_WRITE_LOCK_INF_PAGE_3() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380144)) >> 7) & 0x01)

#define GP_WB_GET_NVR_WRITE_LOCK_INF_PAGE_3_FROM_LICENSE_BLOCK_MAP(tmp) \
        (((tmp) >> 7) & 0x01)

/* Disables the spi slave interface */
#define GP_WB_READ_NVR_DISABLE_SPI() \
        (GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380145)) & 0x01)

#define GP_WB_GET_NVR_DISABLE_SPI_FROM_LICENSE_BLOCK_MAP(tmp) \
        (((tmp) >> 8) & 0x01)

/* Disables the i2c slave interface */
#define GP_WB_READ_NVR_DISABLE_I2C() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380145)) >> 1) & 0x01)

#define GP_WB_GET_NVR_DISABLE_I2C_FROM_LICENSE_BLOCK_MAP(tmp) \
        (((tmp) >> 9) & 0x01)

/* Disables the spi master interface */
#define GP_WB_READ_NVR_DISABLE_SPI_M() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380145)) >> 2) & 0x01)

#define GP_WB_GET_NVR_DISABLE_SPI_M_FROM_LICENSE_BLOCK_MAP(tmp) \
        (((tmp) >> 10) & 0x01)

/* Disables the i2c master interface */
#define GP_WB_READ_NVR_DISABLE_I2C_M() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380145)) >> 3) & 0x01)

#define GP_WB_GET_NVR_DISABLE_I2C_M_FROM_LICENSE_BLOCK_MAP(tmp) \
        (((tmp) >> 11) & 0x01)

/* Disables the ir block */
#define GP_WB_READ_NVR_DISABLE_IR() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380145)) >> 4) & 0x01)

#define GP_WB_GET_NVR_DISABLE_IR_FROM_LICENSE_BLOCK_MAP(tmp) \
        (((tmp) >> 12) & 0x01)

/* Disables the keyscan block */
#define GP_WB_READ_NVR_DISABLE_KEYSCAN() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380145)) >> 5) & 0x01)

#define GP_WB_GET_NVR_DISABLE_KEYSCAN_FROM_LICENSE_BLOCK_MAP(tmp) \
        (((tmp) >> 13) & 0x01)

/* Disables the adc block */
#define GP_WB_READ_NVR_DISABLE_ADC() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380145)) >> 6) & 0x01)

#define GP_WB_GET_NVR_DISABLE_ADC_FROM_LICENSE_BLOCK_MAP(tmp) \
        (((tmp) >> 14) & 0x01)

/* Protect read access to upper part (last 128 bytes) of Security Section ROM (last 256 bytes) => Bootloader will apply this in User, Bare Access and Debug Mode, such that keys are only accessible in ROM Sec Boot */
#define GP_WB_READ_NVR_READ_PROTECT_ROM_SECURITY_UPPER() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380145)) >> 7) & 0x01)

#define GP_WB_GET_NVR_READ_PROTECT_ROM_SECURITY_UPPER_FROM_LICENSE_BLOCK_MAP(tmp) \
        (((tmp) >> 15) & 0x01)

/* Disables the i2s master interface */
#define GP_WB_READ_NVR_DISABLE_I2S_M() \
        (GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380146)) & 0x01)

#define GP_WB_GET_NVR_DISABLE_I2S_M_FROM_LICENSE_BLOCK_MAP(tmp) \
        (((tmp) >> 16) & 0x01)

/* Disables the PWM block */
#define GP_WB_READ_NVR_DISABLE_PWM() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380146)) >> 1) & 0x01)

#define GP_WB_GET_NVR_DISABLE_PWM_FROM_LICENSE_BLOCK_MAP(tmp) \
        (((tmp) >> 17) & 0x01)

/* Disables the asp block */
#define GP_WB_READ_NVR_DISABLE_ASP() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380146)) >> 2) & 0x01)

#define GP_WB_GET_NVR_DISABLE_ASP_FROM_LICENSE_BLOCK_MAP(tmp) \
        (((tmp) >> 18) & 0x01)

/* Disables the direct security processor interface */
#define GP_WB_READ_NVR_DISABLE_SECPROC_MRI() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380146)) >> 3) & 0x01)

#define GP_WB_GET_NVR_DISABLE_SECPROC_MRI_FROM_LICENSE_BLOCK_MAP(tmp) \
        (((tmp) >> 19) & 0x01)

/* Disables the concurrent listening feature */
#define GP_WB_READ_NVR_DISABLE_CONCURRENT() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380146)) >> 4) & 0x01)

#define GP_WB_GET_NVR_DISABLE_CONCURRENT_FROM_LICENSE_BLOCK_MAP(tmp) \
        (((tmp) >> 20) & 0x01)

/* Disables the BLE high data rate */
#define GP_WB_READ_NVR_DISABLE_BLE_HDR() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380146)) >> 5) & 0x01)

#define GP_WB_GET_NVR_DISABLE_BLE_HDR_FROM_LICENSE_BLOCK_MAP(tmp) \
        (((tmp) >> 21) & 0x01)

/* Disables the 802.15.4 functionality */
#define GP_WB_READ_NVR_DISABLE_802154() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380146)) >> 6) & 0x01)

#define GP_WB_GET_NVR_DISABLE_802154_FROM_LICENSE_BLOCK_MAP(tmp) \
        (((tmp) >> 22) & 0x01)

/* Disables the BLE functionality */
#define GP_WB_READ_NVR_DISABLE_BLE() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380146)) >> 7) & 0x01)

#define GP_WB_GET_NVR_DISABLE_BLE_FROM_LICENSE_BLOCK_MAP(tmp) \
        (((tmp) >> 23) & 0x01)

/* Disables listening to multiple channels. But keeps attenuator diversity through slot hopping alive */
#define GP_WB_READ_NVR_DISABLE_MULTI_CHANNEL() \
        (GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380147)) & 0x01)

#define GP_WB_GET_NVR_DISABLE_MULTI_CHANNEL_FROM_LICENSE_BLOCK_MAP(tmp) \
        (((tmp) >> 24) & 0x01)

/* Disables the attenuator diversity feature */
#define GP_WB_READ_NVR_DISABLE_ATTENUATOR_DIV() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380147)) >> 1) & 0x01)

#define GP_WB_GET_NVR_DISABLE_ATTENUATOR_DIV_FROM_LICENSE_BLOCK_MAP(tmp) \
        (((tmp) >> 25) & 0x01)

/* Locks the number of supported pans to what is set by the cm restore */
#define GP_WB_READ_NVR_LOCK_MULTI_PAN() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380147)) >> 2) & 0x01)

#define GP_WB_GET_NVR_LOCK_MULTI_PAN_FROM_LICENSE_BLOCK_MAP(tmp) \
        (((tmp) >> 26) & 0x01)

/* Protect read access to upper part of NVR page 0 (0x140 and above) => Bootloader will apply this in User, Bare Access and Debug Mode (e.g. for symmetric keys that do not need to be accessible to MCU, but are used directly by AES engine) */
#define GP_WB_READ_NVR_READ_PROTECT_INF_PAGE_0_UPPER() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380147)) >> 3) & 0x01)

#define GP_WB_GET_NVR_READ_PROTECT_INF_PAGE_0_UPPER_FROM_LICENSE_BLOCK_MAP(tmp) \
        (((tmp) >> 27) & 0x01)

/* Protect read access to upper part of NVR page 0 (0x200 to 0x27F) => Bootloader will apply this in Bare Access and Debug Mode, NOT IN USER MODE (for private keys that need to be accessible to MCU) */
#define GP_WB_READ_NVR_READ_PROTECT_INF_PAGE_1_LOWER() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380147)) >> 4) & 0x01)

#define GP_WB_GET_NVR_READ_PROTECT_INF_PAGE_1_LOWER_FROM_LICENSE_BLOCK_MAP(tmp) \
        (((tmp) >> 28) & 0x01)

/* Blocks all write access to nvr_cfg by forcing flash lck_cfg bit */
#define GP_WB_READ_NVR_LOCK_NVR_CFG() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380147)) >> 5) & 0x01)

#define GP_WB_GET_NVR_LOCK_NVR_CFG_FROM_LICENSE_BLOCK_MAP(tmp) \
        (((tmp) >> 29) & 0x01)

/* Blocks all access to flash testmodes */
#define GP_WB_READ_NVR_LOCK_FLASH_TM() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380147)) >> 6) & 0x01)

#define GP_WB_GET_NVR_LOCK_FLASH_TM_FROM_LICENSE_BLOCK_MAP(tmp) \
        (((tmp) >> 30) & 0x01)

/* locks the interface to the license (when triggered, no more license updates can happen) */
#define GP_WB_READ_NVR_LOCK_LICENSE_ITF() \
        ((GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380147)) >> 7) & 0x01)

#define GP_WB_GET_NVR_LOCK_LICENSE_ITF_FROM_LICENSE_BLOCK_MAP(tmp) \
        (((tmp) >> 31) & 0x01)


/* Read Unlock Response */
#define GP_WB_READ_NVR_READ_UNLOCK_RESPONSE() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380148))


/* Product specific key x */
#define GP_WB_READ_NVR_PRODUCT_KEY_0_LSB() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380150))


/* Product specific key x */
#define GP_WB_READ_NVR_PRODUCT_KEY_0_MSB() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380158))


/* Product specific key x */
#define GP_WB_READ_NVR_PRODUCT_KEY_1_LSB() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380160))


/* Product specific key x */
#define GP_WB_READ_NVR_PRODUCT_KEY_1_MSB() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380168))


/* Mass Erase Response - lower 64-bits */
#define GP_WB_READ_NVR_MASS_ERASE_RESPONSE_LSB() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380170))


/* Mass Erase Response - upper 32-bits */
#define GP_WB_READ_NVR_MASS_ERASE_RESPONSE_MSB() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380178))


/* CRC over the first 124 bytes of the page. Note this CRC value can only be used by the bootloader as the last part of this page cannot be read back. */
#define GP_WB_READ_NVR_CRC_FIXED_PAGE() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x38017c))


/* User can store up to 8 keys. No CRC is available over this page as existing keys can not be read back. User has to verify correct operation by performing an AES encryption and checking cypher text for expected value. */
#define GP_WB_READ_NVR_USER_KEY_0_LSB() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380180))


/* User can store up to 8 keys. No CRC is available over this page as existing keys can not be read back. User has to verify correct operation by performing an AES encryption and checking cypher text for expected value. */
#define GP_WB_READ_NVR_USER_KEY_0_MSB() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380188))


/* User can store up to 8 keys. No CRC is available over this page as existing keys can not be read back. User has to verify correct operation by performing an AES encryption and checking cypher text for expected value. */
#define GP_WB_READ_NVR_USER_KEY_1_LSB() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380190))


/* User can store up to 8 keys. No CRC is available over this page as existing keys can not be read back. User has to verify correct operation by performing an AES encryption and checking cypher text for expected value. */
#define GP_WB_READ_NVR_USER_KEY_1_MSB() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x380198))


/* User can store up to 8 keys. No CRC is available over this page as existing keys can not be read back. User has to verify correct operation by performing an AES encryption and checking cypher text for expected value. */
#define GP_WB_READ_NVR_USER_KEY_2_LSB() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3801a0))


/* User can store up to 8 keys. No CRC is available over this page as existing keys can not be read back. User has to verify correct operation by performing an AES encryption and checking cypher text for expected value. */
#define GP_WB_READ_NVR_USER_KEY_2_MSB() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3801a8))


/* User can store up to 8 keys. No CRC is available over this page as existing keys can not be read back. User has to verify correct operation by performing an AES encryption and checking cypher text for expected value. */
#define GP_WB_READ_NVR_USER_KEY_3_LSB() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3801b0))


/* User can store up to 8 keys. No CRC is available over this page as existing keys can not be read back. User has to verify correct operation by performing an AES encryption and checking cypher text for expected value. */
#define GP_WB_READ_NVR_USER_KEY_3_MSB() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3801b8))


/* User can store up to 8 keys. No CRC is available over this page as existing keys can not be read back. User has to verify correct operation by performing an AES encryption and checking cypher text for expected value. */
#define GP_WB_READ_NVR_USER_KEY_4_LSB() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3801c0))


/* User can store up to 8 keys. No CRC is available over this page as existing keys can not be read back. User has to verify correct operation by performing an AES encryption and checking cypher text for expected value. */
#define GP_WB_READ_NVR_USER_KEY_4_MSB() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3801c8))


/* User can store up to 8 keys. No CRC is available over this page as existing keys can not be read back. User has to verify correct operation by performing an AES encryption and checking cypher text for expected value. */
#define GP_WB_READ_NVR_USER_KEY_5_LSB() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3801d0))


/* User can store up to 8 keys. No CRC is available over this page as existing keys can not be read back. User has to verify correct operation by performing an AES encryption and checking cypher text for expected value. */
#define GP_WB_READ_NVR_USER_KEY_5_MSB() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3801d8))


/* User can store up to 8 keys. No CRC is available over this page as existing keys can not be read back. User has to verify correct operation by performing an AES encryption and checking cypher text for expected value. */
#define GP_WB_READ_NVR_USER_KEY_6_LSB() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3801e0))


/* User can store up to 8 keys. No CRC is available over this page as existing keys can not be read back. User has to verify correct operation by performing an AES encryption and checking cypher text for expected value. */
#define GP_WB_READ_NVR_USER_KEY_6_MSB() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3801e8))


/* User can store up to 8 keys. No CRC is available over this page as existing keys can not be read back. User has to verify correct operation by performing an AES encryption and checking cypher text for expected value. */
#define GP_WB_READ_NVR_USER_KEY_7_LSB() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3801f0))


/* User can store up to 8 keys. No CRC is available over this page as existing keys can not be read back. User has to verify correct operation by performing an AES encryption and checking cypher text for expected value. */
#define GP_WB_READ_NVR_USER_KEY_7_MSB() \
        GP_WB_READ_U64(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3801f8))

/***************************
 * layout: nvr_cfg
 ***************************/

/* Magic word to indicate the Flash Vref Cal field is written and shall be applied. MW = 0x2a0f2b57 */
#define GP_WB_READ_NVR_CFG_FLASH_VREF_MW() \
        GP_WB_READ_U32(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3c0000))


/* Calibrated PMUD_ANALOG_TUNING register contents. */
#define GP_WB_READ_NVR_CFG_FLASH_VREF_CAL_0() \
        GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3c0004))

/* Calibrated 8-bits (!) PMUD_FLASH_REFBITS register. */
#define GP_WB_READ_NVR_CFG_FLASH_VREF_CAL_1() \
        GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3c0005))

/* Calibrated 8-bits (!) PMUD_PU_DIG_LDO_REFBITS register. */
#define GP_WB_READ_NVR_CFG_FLASH_VREF_CAL_2() \
        GP_WB_READ_U8(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3c0006))


/* Flash Configuration Register. Always used even if MW is not valid. */
#define GP_WB_READ_NVR_CFG_FLASH_CONF_0() \
        GP_WB_READ_U16(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3c0180))


/* Flash Configuration Register. Always used even if MW is not valid. */
#define GP_WB_READ_NVR_CFG_FLASH_CONF_1() \
        GP_WB_READ_U16(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3c0190))


/* Flash Configuration Register. Always used even if MW is not valid. */
#define GP_WB_READ_NVR_CFG_FLASH_CONF_2() \
        GP_WB_READ_U16(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3c01a0))


/* Flash Configuration Register. Always used even if MW is not valid. */
#define GP_WB_READ_NVR_CFG_FLASH_CONF_3() \
        GP_WB_READ_U16(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3c01b0))


/* Flash Configuration Register. Always used even if MW is not valid. */
#define GP_WB_READ_NVR_CFG_FLASH_CONF_4() \
        GP_WB_READ_U16(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3c01c0))


/* Flash Configuration Register. Always used even if MW is not valid. */
#define GP_WB_READ_NVR_CFG_FLASH_CONF_5() \
        GP_WB_READ_U16(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3c01d0))


/* Flash Configuration Register. Always used even if MW is not valid. */
#define GP_WB_READ_NVR_CFG_FLASH_CONF_6() \
        GP_WB_READ_U16(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3c01e0))


/* Flash Configuration Register. Always used even if MW is not valid. */
#define GP_WB_READ_NVR_CFG_FLASH_CONF_7() \
        GP_WB_READ_U16(GP_MM_FLASH_ALT_ADDR_FROM_COMPRESSED(0x3c01f0))

#endif //GP_WB_PROP_H

